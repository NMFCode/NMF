//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Cmof
{
    
    
    /// <summary>
    /// The public interface for Property
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Property))]
    [XmlDefaultImplementationTypeAttribute(typeof(Property))]
    [ModelRepresentationClassAttribute("http://www.omg.org/spec/MOF/20131001/cmof.xmi#//Property")]
    public interface IProperty : IModelElement, IStructuralFeature
    {
        
        /// <summary>
        /// Specifies the kind of aggregation that applies to the Property.
        /// </summary>
        [DefaultValueAttribute(AggregationKind.None)]
        [DisplayNameAttribute("aggregation")]
        [DescriptionAttribute("Specifies the kind of aggregation that applies to the Property.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("aggregation")]
        [XmlAttributeAttribute(true)]
        AggregationKind Aggregation
        {
            get;
            set;
        }
        
        /// <summary>
        /// If isDerived is true, the value of the attribute is derived from information elsewhere.
        ///Specifies whether the Property is derived, i.e., whether its value or values can be computed from other information.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerived")]
        [DescriptionAttribute("If isDerived is true, the value of the attribute is derived from information else" +
            "where.\nSpecifies whether the Property is derived, i.e., whether its value or val" +
            "ues can be computed from other information.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerived")]
        [XmlAttributeAttribute(true)]
        bool IsDerived
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies whether the property is derived as the union of all of the properties that are constrained to subset it.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerivedUnion")]
        [DescriptionAttribute("Specifies whether the property is derived as the union of all of the properties t" +
            "hat are constrained to subset it.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerivedUnion")]
        [XmlAttributeAttribute(true)]
        bool IsDerivedUnion
        {
            get;
            set;
        }
        
        /// <summary>
        /// True indicates this property can be used to uniquely identify an instance of the containing Class.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isID")]
        [DescriptionAttribute("True indicates this property can be used to uniquely identify an instance of the " +
            "containing Class.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isID")]
        [XmlAttributeAttribute(true)]
        bool IsID
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the Class that owns the Property.
        ///References the Class that owns the Property.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("class")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedAttribute")]
        NMF.Interop.Cmof.IClass Class
        {
            get;
            set;
        }
        
        /// <summary>
        /// The DataType that owns this Property.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("datatype")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedAttribute")]
        NMF.Interop.Cmof.IDataType Datatype
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the owning association of this property, if any.
        /// </summary>
        [DisplayNameAttribute("owningAssociation")]
        [DescriptionAttribute("References the owning association of this property, if any.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("owningAssociation")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedEnd")]
        IAssociation OwningAssociation
        {
            get;
            set;
        }
        
        /// <summary>
        /// A ValueSpecification that is evaluated to give a default value for the Property when an object of the owning Classifier is instantiated.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("defaultValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification DefaultValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the properties that are redefined by this property.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedProperty")]
        [DescriptionAttribute("References the properties that are redefined by this property.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("redefinedProperty")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IProperty> RedefinedProperty
        {
            get;
        }
        
        /// <summary>
        /// References the properties of which this property is constrained to be a subset.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("subsettedProperty")]
        [DescriptionAttribute("References the properties of which this property is constrained to be a subset.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("subsettedProperty")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IProperty> SubsettedProperty
        {
            get;
        }
        
        /// <summary>
        /// References the association of which this property is a member, if any.
        /// </summary>
        [DisplayNameAttribute("association")]
        [DescriptionAttribute("References the association of which this property is a member, if any.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("association")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("memberEnd")]
        IAssociation Association
        {
            get;
            set;
        }
        
        /// <summary>
        /// A multiplicity of a composite aggregation must not have an upper bound greater than 1.
        ///A multiplicity on an aggregate end of a composite aggregation must not have an upper bound greater than 1.
        ///isComposite implies (upperBound()-&gt;isEmpty() or upperBound() &lt;= 1)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Multiplicity_of_composite(object diagnostics, object context);
        
        /// <summary>
        /// Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.
        ///self.subsettedProperty-&gt;notEmpty() implies
        ///  (self.subsettingContext()-&gt;notEmpty() and self.subsettingContext()-&gt;forAll (sc |
        ///    self.subsettedProperty-&gt;forAll(sp |
        ///      sp.subsettingContext()-&gt;exists(c | sc.conformsTo(c)))))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetting_context_conforms(object diagnostics, object context);
        
        /// <summary>
        /// A derived union is read only.
        ///isDerivedUnion implies isReadOnly
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Derived_union_is_read_only(object diagnostics, object context);
        
        /// <summary>
        /// A redefined property must be inherited from a more general classifier containing the redefining property.
        ///if (redefinedProperty-&gt;notEmpty()) then
        ///  (redefinitionContext-&gt;notEmpty() and
        ///      redefinedProperty-&gt;forAll(rp|
        ///        ((redefinitionContext-&gt;collect(fc|
        ///          fc.allParents()))-&gt;asSet())-&gt;collect(c| c.allFeatures())-&gt;asSet()-&gt;includes(rp))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Redefined_property_inherited(object diagnostics, object context);
        
        /// <summary>
        /// A property may not subset a property with the same name.
        ///true
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetted_property_names(object diagnostics, object context);
        
        /// <summary>
        /// A derived union is derived.
        ///isDerivedUnion implies isDerived
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Derived_union_is_derived(object diagnostics, object context);
        
        /// <summary>
        /// A subsetting property may strengthen the type of the subsetted property, and its upper bound may be less.
        ///self.subsettedProperty-&gt;forAll(sp |
        ///  self.type.conformsTo(sp.type) and
        ///    ((self.upperBound()-&gt;notEmpty() and sp.upperBound()-&gt;notEmpty()) implies
        ///      self.upperBound()&lt;=sp.upperBound() ))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetting_rules(object diagnostics, object context);
        
        /// <summary>
        /// The query isAttribute() is true if the Property is defined as an attribute of some classifier.
        ///result = Classifier.allInstances-&gt;exists(c | c.attribute-&gt;includes(p))
        /// </summary>
        /// <param name="p"></param>
        bool IsAttribute(IProperty p);
        
        /// <summary>
        /// The query isNavigable() indicates whether it is possible to navigate across the property.
        ///result = not classifier-&gt;isEmpty() or association.owningAssociation.navigableOwnedEnd-&gt;includes(self)
        /// </summary>
        bool IsNavigable();
        
        /// <summary>
        /// The query subsettingContext() gives the context for subsetting a property. It consists, in the case of an attribute, of the corresponding classifier, and in the case of an association end, all of the classifiers at the other ends.
        ///result = if association-&gt;notEmpty()
        ///then association.endType-type
        ///else if classifier-&gt;notEmpty() then Set{classifier} else Set{} endif
        ///endif
        /// </summary>
        ISetExpression<NMF.Interop.Cmof.IType> SubsettingContext();
    }
}
