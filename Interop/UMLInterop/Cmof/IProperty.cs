//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Cmof
{
    
    
    /// <summary>
    /// The public interface for Property
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Property))]
    [XmlDefaultImplementationTypeAttribute(typeof(Property))]
    [ModelRepresentationClassAttribute("http://www.omg.org/spec/MOF/20131001/cmof.xmi#//Property")]
    public interface IProperty : IModelElement, IStructuralFeature
    {
        
        /// <summary>
        /// Specifies the kind of aggregation that applies to the Property.
        /// </summary>
        [DefaultValueAttribute(AggregationKind.None)]
        [DisplayNameAttribute("aggregation")]
        [DescriptionAttribute("Specifies the kind of aggregation that applies to the Property.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("aggregation")]
        [XmlAttributeAttribute(true)]
        AggregationKind Aggregation
        {
            get;
            set;
        }
        
        /// <summary>
        /// If isDerived is true, the value of the attribute is derived from information elsewhere.
        ///Specifies whether the Property is derived, i.e., whether its value or values can be computed from other information.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerived")]
        [DescriptionAttribute("If isDerived is true, the value of the attribute is derived from information else" +
            "where.\nSpecifies whether the Property is derived, i.e., whether its value or val" +
            "ues can be computed from other information.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerived")]
        [XmlAttributeAttribute(true)]
        bool IsDerived
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies whether the property is derived as the union of all of the properties that are constrained to subset it.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerivedUnion")]
        [DescriptionAttribute("Specifies whether the property is derived as the union of all of the properties t" +
            "hat are constrained to subset it.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerivedUnion")]
        [XmlAttributeAttribute(true)]
        bool IsDerivedUnion
        {
            get;
            set;
        }
        
        /// <summary>
        /// True indicates this property can be used to uniquely identify an instance of the containing Class.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isID")]
        [DescriptionAttribute("True indicates this property can be used to uniquely identify an instance of the " +
            "containing Class.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isID")]
        [XmlAttributeAttribute(true)]
        bool IsID
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the Class that owns the Property.
        ///References the Class that owns the Property.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("class")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedAttribute")]
        NMF.Interop.Cmof.IClass Class
        {
            get;
            set;
        }
        
        /// <summary>
        /// The DataType that owns this Property.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("datatype")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedAttribute")]
        NMF.Interop.Cmof.IDataType Datatype
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the association of which this property is a member, if any.
        /// </summary>
        [DisplayNameAttribute("association")]
        [DescriptionAttribute("References the association of which this property is a member, if any.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("association")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("memberEnd")]
        IAssociation Association
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the owning association of this property, if any.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("owningAssociation")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedEnd")]
        IAssociation OwningAssociation
        {
            get;
            set;
        }
        
        /// <summary>
        /// A ValueSpecification that is evaluated to give a default value for the Property when an object of the owning Classifier is instantiated.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("defaultValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification DefaultValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the properties that are redefined by this property.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedProperty")]
        [DescriptionAttribute("References the properties that are redefined by this property.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("redefinedProperty")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IProperty> RedefinedProperty
        {
            get;
        }
        
        /// <summary>
        /// References the properties of which this property is constrained to be a subset.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("subsettedProperty")]
        [DescriptionAttribute("References the properties of which this property is constrained to be a subset.")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("subsettedProperty")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IProperty> SubsettedProperty
        {
            get;
        }
        
        /// <summary>
        /// A multiplicity of a composite aggregation must not have an upper bound greater than 1.
        ///A multiplicity on an aggregate end of a composite aggregation must not have an upper bound greater than 1.
        ///isComposite implies (upperBound()->isEmpty() or upperBound() <= 1)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Multiplicity_of_composite(object diagnostics, object context);
        
        /// <summary>
        /// Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.
        ///self.subsettedProperty->notEmpty() implies
        ///  (self.subsettingContext()->notEmpty() and self.subsettingContext()->forAll (sc |
        ///    self.subsettedProperty->forAll(sp |
        ///      sp.subsettingContext()->exists(c | sc.conformsTo(c)))))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetting_context_conforms(object diagnostics, object context);
        
        /// <summary>
        /// A derived union is read only.
        ///isDerivedUnion implies isReadOnly
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Derived_union_is_read_only(object diagnostics, object context);
        
        /// <summary>
        /// A redefined property must be inherited from a more general classifier containing the redefining property.
        ///if (redefinedProperty->notEmpty()) then
        ///  (redefinitionContext->notEmpty() and
        ///      redefinedProperty->forAll(rp|
        ///        ((redefinitionContext->collect(fc|
        ///          fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Redefined_property_inherited(object diagnostics, object context);
        
        /// <summary>
        /// A property may not subset a property with the same name.
        ///true
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetted_property_names(object diagnostics, object context);
        
        /// <summary>
        /// A derived union is derived.
        ///isDerivedUnion implies isDerived
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Derived_union_is_derived(object diagnostics, object context);
        
        /// <summary>
        /// A subsetting property may strengthen the type of the subsetted property, and its upper bound may be less.
        ///self.subsettedProperty->forAll(sp |
        ///  self.type.conformsTo(sp.type) and
        ///    ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies
        ///      self.upperBound()<=sp.upperBound() ))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetting_rules(object diagnostics, object context);
        
        /// <summary>
        /// Missing derivation for Property::/default : String
        ///true
        /// </summary>
        string Default();
        
        /// <summary>
        /// The query isAttribute() is true if the Property is defined as an attribute of some classifier.
        ///result = Classifier.allInstances->exists(c | c.attribute->includes(p))
        /// </summary>
        /// <param name="p"></param>
        bool IsAttribute(IProperty p);
        
        /// <summary>
        /// The value of isComposite is true only if aggregation is composite.
        ///result = (self.aggregation = #composite)
        /// </summary>
        bool IsComposite();
        
        /// <summary>
        /// The query isNavigable() indicates whether it is possible to navigate across the property.
        ///result = not classifier->isEmpty() or association.owningAssociation.navigableOwnedEnd->includes(self)
        /// </summary>
        bool IsNavigable();
        
        /// <summary>
        /// If this property is owned by a class, associated with a binary association, and the other end of the association is also owned by a class, then opposite gives the other end.
        ///result = if owningAssociation->isEmpty() and association.memberEnd->size() = 2
        ///  then
        ///    let otherEnd = (association.memberEnd - self)->any() in
        ///      if otherEnd.owningAssociation->isEmpty() then otherEnd else Set{} endif
        ///    else Set {}
        ///    endif
        /// </summary>
        IProperty Opposite();
        
        /// <summary>
        /// The query subsettingContext() gives the context for subsetting a property. It consists, in the case of an attribute, of the corresponding classifier, and in the case of an association end, all of the classifiers at the other ends.
        ///result = if association->notEmpty()
        ///then association.endType-type
        ///else if classifier->notEmpty() then Set{classifier} else Set{} endif
        ///endif
        /// </summary>
        ISetExpression<NMF.Interop.Cmof.IType> SubsettingContext();
    }
}

