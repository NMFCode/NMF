//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Cmof
{
    
    
    /// <summary>
    /// The public interface for MultiplicityElement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(MultiplicityElement))]
    [XmlDefaultImplementationTypeAttribute(typeof(MultiplicityElement))]
    [ModelRepresentationClassAttribute("http://www.omg.org/spec/MOF/20131001/cmof.xmi#//MultiplicityElement")]
    public interface IMultiplicityElement : IModelElement, IElement
    {
        
        /// <summary>
        /// For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this element are sequentially ordered.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isOrdered")]
        [DescriptionAttribute("For a multivalued multiplicity, this attribute specifies whether the values in an" +
            " instantiation of this element are sequentially ordered.")]
        [CategoryAttribute("MultiplicityElement")]
        [XmlElementNameAttribute("isOrdered")]
        [XmlAttributeAttribute(true)]
        bool IsOrdered
        {
            get;
            set;
        }
        
        /// <summary>
        /// For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of this element are unique.
        /// </summary>
        [DefaultValueAttribute(true)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isUnique")]
        [DescriptionAttribute("For a multivalued multiplicity, this attributes specifies whether the values in a" +
            "n instantiation of this element are unique.")]
        [CategoryAttribute("MultiplicityElement")]
        [XmlElementNameAttribute("isUnique")]
        [XmlAttributeAttribute(true)]
        bool IsUnique
        {
            get;
            set;
        }
        
        /// <summary>
        /// The specification of the lower bound for this multiplicity.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("lowerValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification LowerValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// The specification of the upper bound for this multiplicity.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("upperValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification UpperValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// The lower bound must be a non-negative integer literal.
        ///lowerBound()->notEmpty() implies lowerBound() >= 0
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Lower_ge_0(object diagnostics, object context);
        
        /// <summary>
        /// If a non-literal ValueSpecification is used for the lower or upper bound, then evaluating that specification must not have side effects.
        ///true
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Value_specification_no_side_effects(object diagnostics, object context);
        
        /// <summary>
        /// The upper bound must be greater than or equal to the lower bound.
        ///(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Upper_ge_lower(object diagnostics, object context);
        
        /// <summary>
        /// If a non-literal ValueSpecification is used for the lower or upper bound, then that specification must be a constant expression.
        ///true
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Value_specification_constant(object diagnostics, object context);
        
        /// <summary>
        /// The query includesCardinality() checks whether the specified cardinality is valid for this multiplicity.
        ///result = (lowerBound() <= C) and (upperBound() >= C)
        ///upperBound()->notEmpty() and lowerBound()->notEmpty()
        /// </summary>
        /// <param name="c"></param>
        bool IncludesCardinality(int c);
        
        /// <summary>
        /// The query includesMultiplicity() checks whether this multiplicity includes all the cardinalities allowed by the specified multiplicity.
        ///result = (self.lowerBound() <= M.lowerBound()) and (self.upperBound() >= M.upperBound())
        ///self.upperBound()->notEmpty() and self.lowerBound()->notEmpty() and M.upperBound()->notEmpty() and M.lowerBound()->notEmpty()
        /// </summary>
        /// <param name="m"></param>
        bool IncludesMultiplicity(IMultiplicityElement m);
        
        /// <summary>
        /// The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
        ///upperBound()->notEmpty()
        ///result = upperBound() > 1
        /// </summary>
        bool IsMultivalued();
        
        /// <summary>
        /// The derived lower attribute must equal the lowerBound.
        ///result = lowerBound()
        /// </summary>
        int Lower();
        
        /// <summary>
        /// The query lowerBound() returns the lower bound of the multiplicity as an integer.
        ///result = if lowerValue->isEmpty() then 1 else lowerValue.integerValue() endif
        /// </summary>
        int LowerBound();
        
        /// <summary>
        /// The derived upper attribute must equal the upperBound.
        ///result = upperBound()
        /// </summary>
        void Upper();
        
        /// <summary>
        /// The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited natural.
        ///result = if upperValue->isEmpty() then 1 else upperValue.unlimitedValue() endif
        /// </summary>
        void UpperBound();
    }
}

