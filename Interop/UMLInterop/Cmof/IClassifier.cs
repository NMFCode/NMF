//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Cmof
{
    
    
    /// <summary>
    /// The public interface for Classifier
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Classifier))]
    [XmlDefaultImplementationTypeAttribute(typeof(Classifier))]
    [ModelRepresentationClassAttribute("http://www.omg.org/spec/MOF/20131001/cmof.xmi#//Classifier")]
    public interface IClassifier : IModelElement, NMF.Interop.Cmof.IType, IRedefinableElement, NMF.Interop.Cmof.INamespace
    {
        
        /// <summary>
        /// If true, the Classifier does not provide a complete declaration and can typically not be instantiated. An abstract classifier is intended to be used by other classifiers e.g. as the target of general metarelationships or generalization relationships.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isAbstract")]
        [DescriptionAttribute("If true, the Classifier does not provide a complete declaration and can typically" +
            " not be instantiated. An abstract classifier is intended to be used by other cla" +
            "ssifiers e.g. as the target of general metarelationships or generalization relat" +
            "ionships.")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isAbstract")]
        [XmlAttributeAttribute(true)]
        bool IsAbstract
        {
            get;
            set;
        }
        
        /// <summary>
        /// If true, the Classifier cannot be specialized by generalization. Note that this property is preserved through package merge operations; that is, the capability to specialize a Classifier (i.e., isFinalSpecialization =false) must be preserved in the resulting Classifier of a package merge operation where a Classifier with isFinalSpecialization =false is merged with a matching Classifier with isFinalSpecialization =true: the resulting Classifier will have isFinalSpecialization =false.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isFinalSpecialization")]
        [DescriptionAttribute(@"If true, the Classifier cannot be specialized by generalization. Note that this property is preserved through package merge operations; that is, the capability to specialize a Classifier (i.e., isFinalSpecialization =false) must be preserved in the resulting Classifier of a package merge operation where a Classifier with isFinalSpecialization =false is merged with a matching Classifier with isFinalSpecialization =true: the resulting Classifier will have isFinalSpecialization =false.")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isFinalSpecialization")]
        [XmlAttributeAttribute(true)]
        bool IsFinalSpecialization
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies the Generalization relationships for this Classifier. These Generalizations navigaten to more general classifiers in the generalization hierarchy.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("generalization")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("specific")]
        [ConstantAttribute()]
        IOrderedSetExpression<IGeneralization> Generalization
        {
            get;
        }
        
        /// <summary>
        /// References the Classifiers that are redefined by this Classifier.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedClassifier")]
        [DescriptionAttribute("References the Classifiers that are redefined by this Classifier.")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("redefinedClassifier")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IClassifier> RedefinedClassifier
        {
            get;
        }
        
        /// <summary>
        /// The parents of a classifier must be non-final.
        ///self.parents()-&gt;forAll(not isFinalSpecialization)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Non_final_parents(object diagnostics, object context);
        
        /// <summary>
        /// A classifier may only specialize classifiers of a valid type.
        ///self.parents()-&gt;forAll(c | self.maySpecializeType(c))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Specialize_type(object diagnostics, object context);
        
        /// <summary>
        /// Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transitively specific classifier of the same classifier.
        ///not self.allParents()-&gt;includes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool No_cycles_in_generalization(object diagnostics, object context);
        
        /// <summary>
        /// The query allFeatures() gives all of the features in the namespace of the classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.
        ///result = member-&gt;select(oclIsKindOf(Feature))
        /// </summary>
        ISetExpression<IFeature> AllFeatures();
        
        /// <summary>
        /// The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
        ///result = self.parents()-&gt;union(self.parents()-&gt;collect(p | p.allParents())
        /// </summary>
        ISetExpression<IClassifier> AllParents();
        
        /// <summary>
        /// The query hasVisibilityOf() determines whether a named element is visible in the classifier. By default all are visible. It is only called when the argument is something owned by a parent.
        ///result = (n.visibility &lt;&gt; VisibilityKind::private)
        ///self.allParents()-&gt;including(self)-&gt;collect(c | c.member)-&gt;includes(n)
        /// </summary>
        /// <param name="n"></param>
        bool HasVisibilityOf(INamedElement n);
        
        /// <summary>
        /// The inherit operation is overridden to exclude redefined properties.
        ///The query inherit() defines how to inherit a set of elements. Here the operation is defined to inherit them all. It is intended to be redefined in circumstances where inheritance is affected by redefinition.
        ///result = inhs
        /// </summary>
        /// <param name="inhs"></param>
        ISetExpression<INamedElement> Inherit(IEnumerable<INamedElement> inhs);
        
        /// <summary>
        /// The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.
        ///c.allParents()-&gt;includes(self)
        ///result = member-&gt;select(m | c.hasVisibilityOf(m))
        /// </summary>
        /// <param name="c"></param>
        ISetExpression<INamedElement> InheritableMembers(IClassifier c);
        
        /// <summary>
        /// The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.
        ///result = self.oclIsKindOf(c.oclType)
        /// </summary>
        /// <param name="c"></param>
        bool MaySpecializeType(IClassifier c);
        
        /// <summary>
        /// The query parents() gives all of the immediate ancestors of a generalized Classifier.
        ///result = generalization.general
        /// </summary>
        ISetExpression<IClassifier> Parents();
    }
}
