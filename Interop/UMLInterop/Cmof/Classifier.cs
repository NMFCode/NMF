//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Cmof
{
    
    
    /// <summary>
    /// A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.
    /// </summary>
    [XmlNamespaceAttribute("http://www.omg.org/spec/MOF/20131001/cmof.xmi")]
    [XmlNamespacePrefixAttribute("cmof")]
    [ModelRepresentationClassAttribute("http://www.omg.org/spec/MOF/20131001/cmof.xmi#//Classifier")]
    [DebuggerDisplayAttribute("Classifier {Name}")]
    public abstract partial class Classifier : Namespace, IClassifier, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _non_final_parentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNon_final_parentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _specialize_typeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSpecialize_typeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _no_cycles_in_generalizationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNo_cycles_in_generalizationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allFeaturesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllFeaturesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allParentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllParentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _hasVisibilityOfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveHasVisibilityOfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inheritOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInheritOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inheritableMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInheritableMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _maySpecializeTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMaySpecializeTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParentsOperation);
        
        /// <summary>
        /// The backing field for the IsAbstract property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isAbstract = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isAbstractAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsAbstractAttribute);
        
        /// <summary>
        /// The backing field for the IsFinalSpecialization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isFinalSpecialization = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isFinalSpecializationAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsFinalSpecializationAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _generalizationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveGeneralizationReference);
        
        /// <summary>
        /// The backing field for the Generalization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierGeneralizationCollection _generalization;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedClassifierReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedClassifierReference);
        
        /// <summary>
        /// The backing field for the RedefinedClassifier property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IClassifier> _redefinedClassifier;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_consistentOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_consistentOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _non_leaf_redefinitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNon_leaf_redefinitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_context_validOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_context_validOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isConsistentWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsConsistentWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isRedefinitionContextValidOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsRedefinitionContextValidOperation);
        
        /// <summary>
        /// The backing field for the IsLeaf property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isLeaf = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isLeafAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsLeafAttribute);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _conformsToOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveConformsToOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isInstanceOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsInstanceOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageReference);
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Classifier()
        {
            this._generalization = new ClassifierGeneralizationCollection(this);
            this._generalization.CollectionChanging += this.GeneralizationCollectionChanging;
            this._generalization.CollectionChanged += this.GeneralizationCollectionChanged;
            this._redefinedClassifier = new ObservableAssociationSet<IClassifier>();
            this._redefinedClassifier.CollectionChanging += this.RedefinedClassifierCollectionChanging;
            this._redefinedClassifier.CollectionChanged += this.RedefinedClassifierCollectionChanged;
        }
        
        /// <summary>
        /// If true, the Classifier does not provide a complete declaration and can typically not be instantiated. An abstract classifier is intended to be used by other classifiers e.g. as the target of general metarelationships or generalization relationships.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isAbstract")]
        [DescriptionAttribute("If true, the Classifier does not provide a complete declaration and can typically" +
            " not be instantiated. An abstract classifier is intended to be used by other cla" +
            "ssifiers e.g. as the target of general metarelationships or generalization relat" +
            "ionships.")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isAbstract")]
        [XmlAttributeAttribute(true)]
        public bool IsAbstract
        {
            get
            {
                return this._isAbstract;
            }
            set
            {
                if ((this._isAbstract != value))
                {
                    bool old = this._isAbstract;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsAbstract", e, _isAbstractAttribute);
                    this._isAbstract = value;
                    this.OnPropertyChanged("IsAbstract", e, _isAbstractAttribute);
                }
            }
        }
        
        /// <summary>
        /// If true, the Classifier cannot be specialized by generalization. Note that this property is preserved through package merge operations; that is, the capability to specialize a Classifier (i.e., isFinalSpecialization =false) must be preserved in the resulting Classifier of a package merge operation where a Classifier with isFinalSpecialization =false is merged with a matching Classifier with isFinalSpecialization =true: the resulting Classifier will have isFinalSpecialization =false.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isFinalSpecialization")]
        [DescriptionAttribute(@"If true, the Classifier cannot be specialized by generalization. Note that this property is preserved through package merge operations; that is, the capability to specialize a Classifier (i.e., isFinalSpecialization =false) must be preserved in the resulting Classifier of a package merge operation where a Classifier with isFinalSpecialization =false is merged with a matching Classifier with isFinalSpecialization =true: the resulting Classifier will have isFinalSpecialization =false.")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isFinalSpecialization")]
        [XmlAttributeAttribute(true)]
        public bool IsFinalSpecialization
        {
            get
            {
                return this._isFinalSpecialization;
            }
            set
            {
                if ((this._isFinalSpecialization != value))
                {
                    bool old = this._isFinalSpecialization;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsFinalSpecialization", e, _isFinalSpecializationAttribute);
                    this._isFinalSpecialization = value;
                    this.OnPropertyChanged("IsFinalSpecialization", e, _isFinalSpecializationAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies the Generalization relationships for this Classifier. These Generalizations navigaten to more general classifiers in the generalization hierarchy.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("generalization")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("specific")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IGeneralization> Generalization
        {
            get
            {
                return this._generalization;
            }
        }
        
        /// <summary>
        /// References the Classifiers that are redefined by this Classifier.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedClassifier")]
        [DescriptionAttribute("References the Classifiers that are redefined by this Classifier.")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("redefinedClassifier")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IClassifier> RedefinedClassifier
        {
            get
            {
                return this._redefinedClassifier;
            }
        }
        
        /// <summary>
        /// Indicates whether it is possible to further redefine a RedefinableElement. If the value is true, then it is not possible to further redefine the RedefinableElement. Note that this property is preserved through package merge operations; that is, the capability to redefine a RedefinableElement (i.e., isLeaf=false) must be preserved in the resulting RedefinableElement of a package merge operation where a RedefinableElement with isLeaf=false is merged with a matching RedefinableElement with isLeaf=true: the resulting RedefinableElement will have isLeaf=false. Default value is false.
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isLeaf")]
        [DescriptionAttribute(@"Indicates whether it is possible to further redefine a RedefinableElement. If the value is true, then it is not possible to further redefine the RedefinableElement. Note that this property is preserved through package merge operations; that is, the capability to redefine a RedefinableElement (i.e., isLeaf=false) must be preserved in the resulting RedefinableElement of a package merge operation where a RedefinableElement with isLeaf=false is merged with a matching RedefinableElement with isLeaf=true: the resulting RedefinableElement will have isLeaf=false. Default value is false.")]
        [CategoryAttribute("RedefinableElement")]
        [XmlElementNameAttribute("isLeaf")]
        [XmlAttributeAttribute(true)]
        public bool IsLeaf
        {
            get
            {
                return this._isLeaf;
            }
            set
            {
                if ((this._isLeaf != value))
                {
                    bool old = this._isLeaf;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsLeaf", e, _isLeafAttribute);
                    this._isLeaf = value;
                    this.OnPropertyChanged("IsLeaf", e, _isLeafAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies the owning package of this classifier, if any.
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("package")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedType")]
        public IPackage Package
        {
            get
            {
                return ModelHelper.CastAs<IPackage>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ClassifierChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ClassifierReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.omg.org/spec/MOF/20131001/cmof.xmi#//Classifier")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// The parents of a classifier must be non-final.
        ///self.parents()-&gt;forAll(not isFinalSpecialization)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Non_final_parents(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_non_final_parentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method non_final_parents registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _non_final_parentsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _non_final_parentsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _non_final_parentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNon_final_parentsOperation()
        {
            return ClassInstance.LookupOperation("non_final_parents");
        }
        
        /// <summary>
        /// A classifier may only specialize classifiers of a valid type.
        ///self.parents()-&gt;forAll(c | self.maySpecializeType(c))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Specialize_type(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_specialize_typeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method specialize_type registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _specialize_typeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _specialize_typeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _specialize_typeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSpecialize_typeOperation()
        {
            return ClassInstance.LookupOperation("specialize_type");
        }
        
        /// <summary>
        /// Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transitively specific classifier of the same classifier.
        ///not self.allParents()-&gt;includes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool No_cycles_in_generalization(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_no_cycles_in_generalizationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method no_cycles_in_generalization registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _no_cycles_in_generalizationOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _no_cycles_in_generalizationOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _no_cycles_in_generalizationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNo_cycles_in_generalizationOperation()
        {
            return ClassInstance.LookupOperation("no_cycles_in_generalization");
        }
        
        /// <summary>
        /// The query allFeatures() gives all of the features in the namespace of the classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.
        ///result = member-&gt;select(oclIsKindOf(Feature))
        /// </summary>
        public ISetExpression<IFeature> AllFeatures()
        {
            System.Func<IClassifier, ISetExpression<IFeature>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IFeature>>>(_allFeaturesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allFeatures registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allFeaturesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allFeaturesOperation.Value, e));
            ISetExpression<IFeature> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allFeaturesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllFeaturesOperation()
        {
            return ClassInstance.LookupOperation("allFeatures");
        }
        
        /// <summary>
        /// The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
        ///result = self.parents()-&gt;union(self.parents()-&gt;collect(p | p.allParents())
        /// </summary>
        public ISetExpression<IClassifier> AllParents()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_allParentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allParents registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allParentsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allParentsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allParentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllParentsOperation()
        {
            return ClassInstance.LookupOperation("allParents");
        }
        
        /// <summary>
        /// The query hasVisibilityOf() determines whether a named element is visible in the classifier. By default all are visible. It is only called when the argument is something owned by a parent.
        ///result = (n.visibility &lt;&gt; VisibilityKind::private)
        ///self.allParents()-&gt;including(self)-&gt;collect(c | c.member)-&gt;includes(n)
        /// </summary>
        /// <param name="n"></param>
        public bool HasVisibilityOf(INamedElement n)
        {
            System.Func<IClassifier, INamedElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, INamedElement, bool>>(_hasVisibilityOfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method hasVisibilityOf registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _hasVisibilityOfOperation.Value, n);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _hasVisibilityOfOperation.Value, e));
            bool result = handler.Invoke(this, n);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _hasVisibilityOfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveHasVisibilityOfOperation()
        {
            return ClassInstance.LookupOperation("hasVisibilityOf");
        }
        
        /// <summary>
        /// The inherit operation is overridden to exclude redefined properties.
        ///The query inherit() defines how to inherit a set of elements. Here the operation is defined to inherit them all. It is intended to be redefined in circumstances where inheritance is affected by redefinition.
        ///result = inhs
        /// </summary>
        /// <param name="inhs"></param>
        public ISetExpression<INamedElement> Inherit(IEnumerable<INamedElement> inhs)
        {
            System.Func<IClassifier, IEnumerable<INamedElement>, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IEnumerable<INamedElement>, ISetExpression<INamedElement>>>(_inheritOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inherit registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inheritOperation.Value, inhs);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inheritOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this, inhs);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inheritOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInheritOperation()
        {
            return ClassInstance.LookupOperation("inherit");
        }
        
        /// <summary>
        /// The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.
        ///c.allParents()-&gt;includes(self)
        ///result = member-&gt;select(m | c.hasVisibilityOf(m))
        /// </summary>
        /// <param name="c"></param>
        public ISetExpression<INamedElement> InheritableMembers(IClassifier c)
        {
            System.Func<IClassifier, IClassifier, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, ISetExpression<INamedElement>>>(_inheritableMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inheritableMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inheritableMembersOperation.Value, c);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inheritableMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this, c);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inheritableMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInheritableMembersOperation()
        {
            return ClassInstance.LookupOperation("inheritableMembers");
        }
        
        /// <summary>
        /// The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.
        ///result = self.oclIsKindOf(c.oclType)
        /// </summary>
        /// <param name="c"></param>
        public bool MaySpecializeType(IClassifier c)
        {
            System.Func<IClassifier, IClassifier, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, bool>>(_maySpecializeTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method maySpecializeType registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _maySpecializeTypeOperation.Value, c);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _maySpecializeTypeOperation.Value, e));
            bool result = handler.Invoke(this, c);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _maySpecializeTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMaySpecializeTypeOperation()
        {
            return ClassInstance.LookupOperation("maySpecializeType");
        }
        
        /// <summary>
        /// The query parents() gives all of the immediate ancestors of a generalized Classifier.
        ///result = generalization.general
        /// </summary>
        public ISetExpression<IClassifier> Parents()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_parentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parents registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parentsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parentsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParentsOperation()
        {
            return ClassInstance.LookupOperation("parents");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsAbstractAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Cmof.Classifier.ClassInstance)).Resolve("isAbstract")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsFinalSpecializationAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Cmof.Classifier.ClassInstance)).Resolve("isFinalSpecialization")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveGeneralizationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Cmof.Classifier.ClassInstance)).Resolve("generalization")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Generalization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void GeneralizationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Generalization", e, _generalizationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Generalization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void GeneralizationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Generalization", e, _generalizationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedClassifierReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Cmof.Classifier.ClassInstance)).Resolve("redefinedClassifier")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedClassifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedClassifierCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedClassifier", e, _redefinedClassifierReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedClassifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedClassifierCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedClassifier", e, _redefinedClassifierReference);
        }
        
        /// <summary>
        /// A redefining element must be consistent with each redefined element.
        ///self.redefinedElement-&gt;forAll(re | re.isConsistentWith(self))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_consistent(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_consistentOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_consistent registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_consistentOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_consistentOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_consistentOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_consistentOperation()
        {
            return ClassInstance.LookupOperation("redefinition_consistent");
        }
        
        /// <summary>
        /// A redefinable element can only redefine non-leaf redefinable elements
        ///self.redefinedElement-&gt;forAll(not isLeaf)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Non_leaf_redefinition(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_non_leaf_redefinitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method non_leaf_redefinition registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _non_leaf_redefinitionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _non_leaf_redefinitionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _non_leaf_redefinitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNon_leaf_redefinitionOperation()
        {
            return ClassInstance.LookupOperation("non_leaf_redefinition");
        }
        
        /// <summary>
        /// At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.
        ///self.redefinedElement-&gt;forAll(e | self.isRedefinitionContextValid(e))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_context_valid(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_context_validOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_context_valid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_context_validOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_context_validOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_context_validOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_context_validOperation()
        {
            return ClassInstance.LookupOperation("redefinition_context_valid");
        }
        
        /// <summary>
        /// The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for subclasses of RedefinableElement to define the consistency conditions.
        ///redefinee.isRedefinitionContextValid(self)
        ///result = false
        /// </summary>
        /// <param name="redefinee"></param>
        public bool IsConsistentWith(IRedefinableElement redefinee)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isConsistentWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isConsistentWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isConsistentWithOperation.Value, redefinee);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isConsistentWithOperation.Value, e));
            bool result = handler.Invoke(this, redefinee);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isConsistentWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsConsistentWithOperation()
        {
            return ClassInstance.LookupOperation("isConsistentWith");
        }
        
        /// <summary>
        /// The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinition contexts of the specified element.
        ///result = redefinitionContext-&gt;exists(c | c.allParents()-&gt;includes(redefined.redefinitionContext)))
        /// </summary>
        /// <param name="redefined"></param>
        public bool IsRedefinitionContextValid(IRedefinableElement redefined)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isRedefinitionContextValidOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isRedefinitionContextValid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isRedefinitionContextValidOperation.Value, redefined);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isRedefinitionContextValidOperation.Value, e));
            bool result = handler.Invoke(this, redefined);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isRedefinitionContextValidOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsRedefinitionContextValidOperation()
        {
            return ClassInstance.LookupOperation("isRedefinitionContextValid");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsLeafAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Cmof.RedefinableElement.ClassInstance)).Resolve("isLeaf")));
        }
        
        /// <summary>
        /// The query conformsTo() gives true for a type that conforms to another. By default, two types do not conform to each other. This query is intended to be redefined for specific conformance situations.
        ///result = false
        /// </summary>
        /// <param name="other"></param>
        public bool ConformsTo(NMF.Interop.Cmof.IType other)
        {
            System.Func<NMF.Interop.Cmof.IType, NMF.Interop.Cmof.IType, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Cmof.IType, NMF.Interop.Cmof.IType, bool>>(_conformsToOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method conformsTo registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _conformsToOperation.Value, other);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _conformsToOperation.Value, e));
            bool result = handler.Invoke(this, other);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _conformsToOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveConformsToOperation()
        {
            return ClassInstance.LookupOperation("conformsTo");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="object"></param>
        public bool IsInstance(IObject @object)
        {
            System.Func<NMF.Interop.Cmof.IType, IObject, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Cmof.IType, IObject, bool>>(_isInstanceOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isInstance registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isInstanceOperation.Value, @object);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isInstanceOperation.Value, e));
            bool result = handler.Invoke(this, @object);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isInstanceOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsInstanceOperation()
        {
            return ClassInstance.LookupOperation("isInstance");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Cmof.Type.ClassInstance)).Resolve("package")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newPackage = ModelHelper.CastAs<IPackage>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldPackage, newPackage);
            this.OnPropertyChanging("Package", e, _packageReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newPackage = ModelHelper.CastAs<IPackage>(newParent);
            if ((oldPackage != null))
            {
                oldPackage.OwnedType.Remove(this);
            }
            if ((newPackage != null))
            {
                newPackage.OwnedType.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldPackage, newPackage);
            this.OnPropertyChanged("Package", e, _packageReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int generalizationIndex = ModelHelper.IndexOfReference(this.Generalization, element);
            if ((generalizationIndex != -1))
            {
                return ModelHelper.CreatePath("generalization", generalizationIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "GENERALIZATION"))
            {
                if ((index < this.Generalization.Count))
                {
                    return this.Generalization[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGE"))
            {
                return this.Package;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISABSTRACT"))
            {
                return this.IsAbstract;
            }
            if ((attribute == "ISFINALSPECIALIZATION"))
            {
                return this.IsFinalSpecialization;
            }
            if ((attribute == "ISLEAF"))
            {
                return this.IsLeaf;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "GENERALIZATION"))
            {
                return this._generalization;
            }
            if ((feature == "REDEFINEDCLASSIFIER"))
            {
                return this._redefinedClassifier;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "PACKAGE"))
            {
                this.Package = ((IPackage)(value));
                return;
            }
            if ((feature == "ISABSTRACT"))
            {
                this.IsAbstract = ((bool)(value));
                return;
            }
            if ((feature == "ISFINALSPECIALIZATION"))
            {
                this.IsFinalSpecialization = ((bool)(value));
                return;
            }
            if ((feature == "ISLEAF"))
            {
                this.IsLeaf = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISABSTRACT"))
            {
                return Observable.Box(new IsAbstractProxy(this));
            }
            if ((attribute == "ISFINALSPECIALIZATION"))
            {
                return Observable.Box(new IsFinalSpecializationProxy(this));
            }
            if ((attribute == "ISLEAF"))
            {
                return Observable.Box(new IsLeafProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "PACKAGE"))
            {
                return new PackageProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._generalization))
            {
                return "generalization";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.omg.org/spec/MOF/20131001/cmof.xmi#//Classifier")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Classifier class
        /// </summary>
        public class ClassifierChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Classifier _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ClassifierChildrenCollection(Classifier parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Generalization.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Generalization.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Generalization.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IGeneralization generalizationCasted = item.As<IGeneralization>();
                if ((generalizationCasted != null))
                {
                    this._parent.Generalization.Add(generalizationCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Generalization.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Generalization.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> generalizationEnumerator = this._parent.Generalization.GetEnumerator();
                try
                {
                    for (
                    ; generalizationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = generalizationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    generalizationEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IGeneralization generalizationItem = item.As<IGeneralization>();
                if (((generalizationItem != null) 
                            && this._parent.Generalization.Remove(generalizationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Generalization).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Classifier class
        /// </summary>
        public class ClassifierReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Classifier _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ClassifierReferencedElementsCollection(Classifier parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Generalization.Count);
                    count = (count + this._parent.RedefinedClassifier.Count);
                    if ((this._parent.Package != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Generalization.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.RedefinedClassifier.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Generalization.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.RedefinedClassifier.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IGeneralization generalizationCasted = item.As<IGeneralization>();
                if ((generalizationCasted != null))
                {
                    this._parent.Generalization.Add(generalizationCasted);
                }
                IClassifier redefinedClassifierCasted = item.As<IClassifier>();
                if ((redefinedClassifierCasted != null))
                {
                    this._parent.RedefinedClassifier.Add(redefinedClassifierCasted);
                }
                if ((this._parent.Package == null))
                {
                    IPackage packageCasted = item.As<IPackage>();
                    if ((packageCasted != null))
                    {
                        this._parent.Package = packageCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Generalization.Clear();
                this._parent.RedefinedClassifier.Clear();
                this._parent.Package = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Generalization.Contains(item))
                {
                    return true;
                }
                if (this._parent.RedefinedClassifier.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Package))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> generalizationEnumerator = this._parent.Generalization.GetEnumerator();
                try
                {
                    for (
                    ; generalizationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = generalizationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    generalizationEnumerator.Dispose();
                }
                IEnumerator<IModelElement> redefinedClassifierEnumerator = this._parent.RedefinedClassifier.GetEnumerator();
                try
                {
                    for (
                    ; redefinedClassifierEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = redefinedClassifierEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    redefinedClassifierEnumerator.Dispose();
                }
                if ((this._parent.Package != null))
                {
                    array[arrayIndex] = this._parent.Package;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IGeneralization generalizationItem = item.As<IGeneralization>();
                if (((generalizationItem != null) 
                            && this._parent.Generalization.Remove(generalizationItem)))
                {
                    return true;
                }
                IClassifier classifierItem = item.As<IClassifier>();
                if (((classifierItem != null) 
                            && this._parent.RedefinedClassifier.Remove(classifierItem)))
                {
                    return true;
                }
                if ((this._parent.Package == item))
                {
                    this._parent.Package = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Generalization).Concat(this._parent.RedefinedClassifier).Concat(this._parent.Package).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isAbstract property
        /// </summary>
        private sealed class IsAbstractProxy : ModelPropertyChange<IClassifier, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsAbstractProxy(IClassifier modelElement) : 
                    base(modelElement, "isAbstract")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsAbstract;
                }
                set
                {
                    this.ModelElement.IsAbstract = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isFinalSpecialization property
        /// </summary>
        private sealed class IsFinalSpecializationProxy : ModelPropertyChange<IClassifier, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsFinalSpecializationProxy(IClassifier modelElement) : 
                    base(modelElement, "isFinalSpecialization")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsFinalSpecialization;
                }
                set
                {
                    this.ModelElement.IsFinalSpecialization = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isLeaf property
        /// </summary>
        private sealed class IsLeafProxy : ModelPropertyChange<IRedefinableElement, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsLeafProxy(IRedefinableElement modelElement) : 
                    base(modelElement, "isLeaf")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsLeaf;
                }
                set
                {
                    this.ModelElement.IsLeaf = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the package property
        /// </summary>
        private sealed class PackageProxy : ModelPropertyChange<NMF.Interop.Cmof.IType, IPackage>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public PackageProxy(NMF.Interop.Cmof.IType modelElement) : 
                    base(modelElement, "package")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IPackage Value
            {
                get
                {
                    return this.ModelElement.Package;
                }
                set
                {
                    this.ModelElement.Package = value;
                }
            }
        }
    }
}
