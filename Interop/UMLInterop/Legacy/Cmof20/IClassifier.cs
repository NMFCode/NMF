//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NMF.Interop.Legacy.Cmof
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Linq;
    using NMF.Expressions;
    using NMF.Expressions.Linq;
    using NMF.Models;
    using NMF.Models.Meta;
    using NMF.Models.Collections;
    using NMF.Models.Expressions;
    using NMF.Collections.Generic;
    using NMF.Collections.ObjectModel;
    using NMF.Serialization;
    using NMF.Utilities;
    using System.Collections.Specialized;
    using NMF.Models.Repository;
    using System.Globalization;
    
    
    /// <summary>
    /// The public interface for Classifier
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Classifier))]
    [XmlDefaultImplementationTypeAttribute(typeof(Classifier))]
    [ModelRepresentationClassAttribute("http://schema.omg.org/spec/MOF/2.0/cmof.xml#//Classifier")]
    public interface IClassifier : IModelElement, NMF.Interop.Legacy.Cmof.IType, NMF.Interop.Legacy.Cmof.INamespace
    {
        
        /// <summary>
        /// References the general classifier in the Generalization relationship. Subsets DirectedRelationship::target.
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("general")]
        [DescriptionAttribute("References the general classifier in the Generalization relationship. Subsets Dir" +
            "ectedRelationship::target.")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("general")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IClassifier> General
        {
            get;
        }
        
        /// <summary>
        /// Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transitively specific classifier of the same classifier.
        ///not self.allParents()->includes(self)
        /// </summary>
        /// <param name="diagnostics"></param>
        /// <param name="context"></param>
        bool No_cycles_in_generalization(object diagnostics, object context);
        
        /// <summary>
        /// A classifier may only specialize classifiers of a valid type.
        ///self.parents()->forAll(c | self.maySpecializeType(c))
        /// </summary>
        /// <param name="diagnostics"></param>
        /// <param name="context"></param>
        bool Specialize_type(object diagnostics, object context);
        
        /// <summary>
        /// The query conformsTo() gives true for a classifier that defines a type that conforms to another. This is used, for example, in the specification of signature conformance for operations.
        ///result = (self=other) or (self.allParents()->includes(other))
        /// </summary>
        /// <param name="other"></param>
        bool ConformsTo(IClassifier other);
        
        /// <summary>
        /// The query allFeatures() gives all of the features in the namespace of the classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.
        ///result = member->select(oclIsKindOf(Feature))
        /// </summary>
        ISetExpression<IFeature> AllFeatures();
        
        /// <summary>
        /// The general classifiers are the classifiers referenced by the generalization relationships.
        ///result = self.parents()
        /// </summary>
        ISetExpression<IClassifier> GetGenerals();
        
        /// <summary>
        /// The query parents() gives all of the immediate ancestors of a generalized Classifier.
        ///result = generalization.general
        /// </summary>
        ISetExpression<IClassifier> Parents();
        
        /// <summary>
        /// The inheritedMember association is derived by inheriting the inheritable members of the parents.
        ///result = self.inherit(self.parents()->collect(p | p.inheritableMembers(self))
        /// </summary>
        ISetExpression<INamedElement> GetInheritedMembers();
        
        /// <summary>
        /// The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
        ///result = self.parents()->union(self.parents()->collect(p | p.allParents())
        /// </summary>
        ISetExpression<IClassifier> AllParents();
        
        /// <summary>
        /// The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.
        ///c.allParents()->includes(self)
        ///result = member->select(m | c.hasVisibilityOf(m))
        /// </summary>
        /// <param name="c"></param>
        ISetExpression<INamedElement> InheritableMembers(IClassifier c);
        
        /// <summary>
        /// The query hasVisibilityOf() determines whether a named element is visible in the classifier. By default all are visible. It is only called when the argument is something owned by a parent.
        ///self.allParents()->collect(c | c.member)->includes(n)
        ///result = if (self.inheritedMember->includes(n)) then (n.visibility <> #private) else true
        /// </summary>
        /// <param name="n"></param>
        bool HasVisibilityOf(INamedElement n);
        
        /// <summary>
        /// The inherit operation is overridden to exclude redefined properties.
        ///result = inhs
        /// </summary>
        /// <param name="inhs"></param>
        ISetExpression<INamedElement> Inherit(IEnumerable<INamedElement> inhs);
        
        /// <summary>
        /// The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.
        ///result = self.oclIsKindOf(c.oclType)
        /// </summary>
        /// <param name="c"></param>
        bool MaySpecializeType(IClassifier c);
    }
}
