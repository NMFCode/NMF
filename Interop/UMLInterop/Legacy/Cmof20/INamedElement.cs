//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Legacy.Cmof
{
    
    
    /// <summary>
    /// The public interface for NamedElement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(NamedElement))]
    [XmlDefaultImplementationTypeAttribute(typeof(NamedElement))]
    [ModelRepresentationClassAttribute("http://schema.omg.org/spec/MOF/2.0/cmof.xml#//NamedElement")]
    public interface INamedElement : IModelElement, IElement
    {
        
        /// <summary>
        /// Determines the visibility of the NamedElement within different Namespaces within the overall model.
        /// </summary>
        [DisplayNameAttribute("visibility")]
        [DescriptionAttribute("Determines the visibility of the NamedElement within different Namespaces within " +
            "the overall model.")]
        [CategoryAttribute("NamedElement")]
        [XmlElementNameAttribute("visibility")]
        [XmlAttributeAttribute(true)]
        Nullable<VisibilityKind> Visibility
        {
            get;
            set;
        }
        
        /// <summary>
        /// The name of the NamedElement.
        /// </summary>
        [DisplayNameAttribute("name")]
        [DescriptionAttribute("The name of the NamedElement.")]
        [CategoryAttribute("NamedElement")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// Gets fired before the operation no_name gets called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> No_nameCalling;
        
        /// <summary>
        /// Gets fired after the operation no_name got called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> No_nameCalled;
        
        /// <summary>
        /// Gets fired before the operation qualified_name gets called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> Qualified_nameCalling;
        
        /// <summary>
        /// Gets fired after the operation qualified_name got called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> Qualified_nameCalled;
        
        /// <summary>
        /// Gets fired before the operation visibility_needs_ownership gets called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> Visibility_needs_ownershipCalling;
        
        /// <summary>
        /// Gets fired after the operation visibility_needs_ownership got called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> Visibility_needs_ownershipCalled;
        
        /// <summary>
        /// Gets fired before the operation allNamespaces gets called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> AllNamespacesCalling;
        
        /// <summary>
        /// Gets fired after the operation allNamespaces got called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> AllNamespacesCalled;
        
        /// <summary>
        /// Gets fired before the operation isDistinguishableFrom gets called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> IsDistinguishableFromCalling;
        
        /// <summary>
        /// Gets fired after the operation isDistinguishableFrom got called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> IsDistinguishableFromCalled;
        
        /// <summary>
        /// Gets fired before the operation separator gets called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> SeparatorCalling;
        
        /// <summary>
        /// Gets fired after the operation separator got called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> SeparatorCalled;
        
        /// <summary>
        /// Gets fired before the operation qualifiedName gets called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> QualifiedNameCalling;
        
        /// <summary>
        /// Gets fired after the operation qualifiedName got called
        /// </summary>
        event System.EventHandler<OperationCallEventArgs> QualifiedNameCalled;
        
        /// <summary>
        /// Gets fired when the Visibility property changed its value
        /// </summary>
        event System.EventHandler<ValueChangedEventArgs> VisibilityChanged;
        
        /// <summary>
        /// Gets fired before the Visibility property changes its value
        /// </summary>
        event System.EventHandler<ValueChangedEventArgs> VisibilityChanging;
        
        /// <summary>
        /// Gets fired when the Name property changed its value
        /// </summary>
        event System.EventHandler<ValueChangedEventArgs> NameChanged;
        
        /// <summary>
        /// Gets fired before the Name property changes its value
        /// </summary>
        event System.EventHandler<ValueChangedEventArgs> NameChanging;
        
        /// <summary>
        /// If there is no name, or one of the containing namespaces has no name, there is no qualified name.
        ///(self.name->isEmpty() or self.allNamespaces()->select(ns | ns.name->isEmpty())->notEmpty())
        ///
        ///  implies self.qualifiedName->isEmpty()
        /// </summary>
        /// <param name="diagnostics"></param>
        /// <param name="context"></param>
        bool No_name(object diagnostics, object context);
        
        /// <summary>
        /// When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.
        ///(self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()) implies
        ///  self.qualifiedName = self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))
        /// </summary>
        /// <param name="diagnostics"></param>
        /// <param name="context"></param>
        bool Qualified_name(object diagnostics, object context);
        
        /// <summary>
        /// If a NamedElement is not owned by a Namespace, it does not have a visibility.
        ///namespace->isEmpty() implies visibility->isEmpty()
        /// </summary>
        /// <param name="diagnostics"></param>
        /// <param name="context"></param>
        bool Visibility_needs_ownership(object diagnostics, object context);
        
        /// <summary>
        /// The query allNamespaces() gives the sequence of namespaces in which the NamedElement is nested, working outwards.
        ///result = if self.namespace->isEmpty()
        ///then Sequence{}
        ///else self.namespace.allNamespaces()->prepend(self.namespace)
        ///endif
        /// </summary>
        IOrderedSetExpression<NMF.Interop.Legacy.Cmof.INamespace> AllNamespaces();
        
        /// <summary>
        /// The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a Namespace. By default, two named elements are distinguishable if (a) they have unrelated types or (b) they have related types but different names.
        ///result = if self.oclIsKindOf(n.oclType) or n.oclIsKindOf(self.oclType)
        ///then ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()
        ///else true
        ///endif
        /// </summary>
        /// <param name="n"></param>
        /// <param name="ns"></param>
        bool IsDistinguishableFrom(INamedElement n, NMF.Interop.Legacy.Cmof.INamespace ns);
        
        /// <summary>
        /// The query separator() gives the string that is used to separate names when constructing a qualified name.
        ///result = '::'
        /// </summary>
        string Separator();
        
        /// <summary>
        /// When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.
        ///result = if self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()
        ///then 
        ///    self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))
        ///else
        ///    Set{}
        ///endif
        /// </summary>
        string QualifiedName();
    }
}

