//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for LoopNode
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(LoopNode))]
    [XmlDefaultImplementationTypeAttribute(typeof(LoopNode))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//LoopNode")]
    public interface ILoopNode : IModelElement, IStructuredActivityNode
    {
        
        /// <summary>
        /// If true, the test is performed before the first execution of the bodyPart. If false, the bodyPart is executed once before the test is performed.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isTestedFirst")]
        [DescriptionAttribute("If true, the test is performed before the first execution of the bodyPart. If fal" +
            "se, the bodyPart is executed once before the test is performed.\n<p>From package " +
            "UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("isTestedFirst")]
        [XmlAttributeAttribute(true)]
        bool IsTestedFirst
        {
            get;
            set;
        }
        
        /// <summary>
        /// The OutputPins on Actions within the bodyPart, the values of which are moved to the loopVariable OutputPins after the completion of each execution of the bodyPart, before the next iteration of the loop begins or before the loop exits.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("bodyOutput")]
        [DescriptionAttribute(@"The OutputPins on Actions within the bodyPart, the values of which are moved to the loopVariable OutputPins after the completion of each execution of the bodyPart, before the next iteration of the loop begins or before the loop exits.
<p>From package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("bodyOutput")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        IOrderedSetExpression<IOutputPin> BodyOutput
        {
            get;
        }
        
        /// <summary>
        /// The set of ExecutableNodes that perform the repetitive computations of the loop. The bodyPart is executed as long as the test section produces a true value.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("bodyPart")]
        [DescriptionAttribute("The set of ExecutableNodes that perform the repetitive computations of the loop. " +
            "The bodyPart is executed as long as the test section produces a true value.\n<p>F" +
            "rom package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("bodyPart")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IExecutableNode> BodyPart
        {
            get;
        }
        
        /// <summary>
        /// An OutputPin on an Action in the test section whose Boolean value determines whether to continue executing the loop bodyPart.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DisplayNameAttribute("decider")]
        [DescriptionAttribute("An OutputPin on an Action in the test section whose Boolean value determines whet" +
            "her to continue executing the loop bodyPart.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("decider")]
        [XmlAttributeAttribute(true)]
        IOutputPin Decider
        {
            get;
            set;
        }
        
        /// <summary>
        /// A list of OutputPins that hold the values of the loop variables during an execution of the loop. When the test fails, the values are moved to the result OutputPins of the loop.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("loopVariable")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IOutputPin> LoopVariable
        {
            get;
        }
        
        /// <summary>
        /// A list of InputPins whose values are moved into the loopVariable Pins before the first iteration of the loop.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("loopVariableInput")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IInputPin> LoopVariableInput
        {
            get;
        }
        
        /// <summary>
        /// A list of OutputPins that receive the loopVariable values after the last iteration of the loop and constitute the output of the LoopNode.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("result")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IOutputPin> Result
        {
            get;
        }
        
        /// <summary>
        /// The set of ExecutableNodes executed before the first iteration of the loop, in order to initialize values or perform other setup computations.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("setupPart")]
        [DescriptionAttribute("The set of ExecutableNodes executed before the first iteration of the loop, in or" +
            "der to initialize values or perform other setup computations.\n<p>From package UM" +
            "L::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("setupPart")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IExecutableNode> SetupPart
        {
            get;
        }
        
        /// <summary>
        /// The set of ExecutableNodes executed in order to provide the test result for the loop.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("test")]
        [DescriptionAttribute("The set of ExecutableNodes executed in order to provide the test result for the l" +
            "oop.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("test")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IExecutableNode> Test
        {
            get;
        }
        
        /// <summary>
        /// The result OutputPins have no incoming edges.
        ///result.incoming->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Result_no_incoming(object diagnostics, object context);
        
        /// <summary>
        /// The loopVariableInputs must not have outgoing edges.
        ///loopVariableInput.outgoing->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Input_edges(object diagnostics, object context);
        
        /// <summary>
        /// The union of the ExecutableNodes in the setupPart, test and bodyPart of a LoopNode must be the same as the subset of nodes contained in the LoopNode (considered as a StructuredActivityNode) that are ExecutableNodes.
        ///setupPart->union(test)->union(bodyPart)=node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->asSet()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Executable_nodes(object diagnostics, object context);
        
        /// <summary>
        /// The bodyOutput pins are OutputPins on Actions in the body of the LoopNode.
        ///bodyPart.oclAsType(Action).allActions().output->includesAll(bodyOutput)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Body_output_pins(object diagnostics, object context);
        
        /// <summary>
        /// The test and body parts of a ConditionalNode must be disjoint with each other.
        ///setupPart->intersection(test)->isEmpty() and
        ///setupPart->intersection(bodyPart)->isEmpty() and
        ///test->intersection(bodyPart)->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Setup_test_and_body(object diagnostics, object context);
        
        /// <summary>
        /// A LoopNode must have the same number of bodyOutput Pins as loopVariables, and each bodyOutput Pin must be compatible with the corresponding loopVariable (by positional order) in type, multiplicity, ordering and uniqueness.
        ///bodyOutput->size()=loopVariable->size() and
        ///Sequence{1..loopVariable->size()}->forAll(i |
        ///	bodyOutput->at(i).type.conformsTo(loopVariable->at(i).type) and
        ///	bodyOutput->at(i).isOrdered = loopVariable->at(i).isOrdered and
        ///	bodyOutput->at(i).isUnique = loopVariable->at(i).isUnique and
        ///	loopVariable->at(i).includesMultiplicity(bodyOutput->at(i)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Matching_output_pins(object diagnostics, object context);
        
        /// <summary>
        /// A LoopNode must have the same number of loopVariableInputs and loopVariables, and they must match in type, uniqueness and multiplicity.
        ///loopVariableInput->size()=loopVariable->size() and
        ///loopVariableInput.type=loopVariable.type and
        ///loopVariableInput.isUnique=loopVariable.isUnique and
        ///loopVariableInput.lower=loopVariable.lower and
        ///loopVariableInput.upper=loopVariable.upper
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Matching_loop_variables(object diagnostics, object context);
        
        /// <summary>
        /// A LoopNode must have the same number of result OutputPins and loopVariables, and they must match in type, uniqueness and multiplicity.
        ///result->size()=loopVariable->size() and
        ///result.type=loopVariable.type and
        ///result.isUnique=loopVariable.isUnique and
        ///result.lower=loopVariable.lower and
        ///result.upper=loopVariable.upper
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Matching_result_pins(object diagnostics, object context);
        
        /// <summary>
        /// All ActivityEdges outgoing from loopVariable OutputPins must have targets within the LoopNode.
        ///allOwnedNodes()->includesAll(loopVariable.outgoing.target)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Loop_variable_outgoing(object diagnostics, object context);
    }
}

