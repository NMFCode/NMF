//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Classifier represents a classification of instances according to their Features.
    ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Classifier")]
    [DebuggerDisplayAttribute("Classifier {Name}")]
    public abstract partial class Classifier : Namespace, IClassifier, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _specialize_typeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSpecialize_typeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _maps_to_generalization_setOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMaps_to_generalization_setOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _non_final_parentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNon_final_parentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _no_cycles_in_generalizationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNo_cycles_in_generalizationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllAttributesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllAttributesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllOperationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllOperationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOperationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOperationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOperationOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOperationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOperationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOperationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allFeaturesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllFeaturesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allParentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllParentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getGeneralsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetGeneralsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _hasVisibilityOfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveHasVisibilityOfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inheritOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInheritOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inheritableMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInheritableMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getInheritedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetInheritedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _maySpecializeTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMaySpecializeTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _directlyRealizedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDirectlyRealizedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _directlyUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDirectlyUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allRealizedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllRealizedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isSubstitutableForOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsSubstitutableForOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allAttributesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllAttributesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allSlottableFeaturesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllSlottableFeaturesOperation);
        
        /// <summary>
        /// The backing field for the IsAbstract property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isAbstract = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isAbstractAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsAbstractAttribute);
        
        /// <summary>
        /// The backing field for the IsFinalSpecialization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isFinalSpecialization = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isFinalSpecializationAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsFinalSpecializationAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _generalizationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveGeneralizationReference);
        
        /// <summary>
        /// The backing field for the Generalization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierGeneralizationCollection _generalization;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _powertypeExtentReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePowertypeExtentReference);
        
        /// <summary>
        /// The backing field for the PowertypeExtent property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierPowertypeExtentCollection _powertypeExtent;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedUseCaseReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedUseCaseReference);
        
        /// <summary>
        /// The backing field for the OwnedUseCase property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IUseCase> _ownedUseCase;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _useCaseReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveUseCaseReference);
        
        /// <summary>
        /// The backing field for the UseCase property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierUseCaseCollection _useCase;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedClassifierReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedClassifierReference);
        
        /// <summary>
        /// The backing field for the RedefinedClassifier property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationList<IClassifier> _redefinedClassifier;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _representationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRepresentationReference);
        
        /// <summary>
        /// The backing field for the Representation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ICollaborationUse _representation;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _substitutionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSubstitutionReference);
        
        /// <summary>
        /// The backing field for the Substitution property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierSubstitutionCollection _substitution;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_consistentOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_consistentOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _non_leaf_redefinitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNon_leaf_redefinitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_context_validOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_context_validOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isConsistentWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsConsistentWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isRedefinitionContextValidOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsRedefinitionContextValidOperation);
        
        /// <summary>
        /// The backing field for the IsLeaf property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isLeaf = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isLeafAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsLeafAttribute);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createAssociationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateAssociationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAssociationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAssociationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _conformsToOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveConformsToOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageReference);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _namespace_needs_visibilityOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNamespace_needs_visibilityOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompatibleWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompatibleWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateParameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateParameterOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningTemplateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the OwningTemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _owningTemplateParameter;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the TemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _templateParameter;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameterableElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameterableElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateBindingReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateBindingReference);
        
        /// <summary>
        /// The backing field for the TemplateBinding property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TemplateableElementTemplateBindingCollection _templateBinding;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTemplateSignatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTemplateSignatureReference);
        
        /// <summary>
        /// The backing field for the OwnedTemplateSignature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateSignature _ownedTemplateSignature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Classifier()
        {
            this._generalization = new ClassifierGeneralizationCollection(this);
            this._generalization.CollectionChanging += this.GeneralizationCollectionChanging;
            this._generalization.CollectionChanged += this.GeneralizationCollectionChanged;
            this._powertypeExtent = new ClassifierPowertypeExtentCollection(this);
            this._powertypeExtent.CollectionChanging += this.PowertypeExtentCollectionChanging;
            this._powertypeExtent.CollectionChanged += this.PowertypeExtentCollectionChanged;
            this._ownedUseCase = new ObservableCompositionOrderedSet<IUseCase>(this);
            this._ownedUseCase.CollectionChanging += this.OwnedUseCaseCollectionChanging;
            this._ownedUseCase.CollectionChanged += this.OwnedUseCaseCollectionChanged;
            this._useCase = new ClassifierUseCaseCollection(this);
            this._useCase.CollectionChanging += this.UseCaseCollectionChanging;
            this._useCase.CollectionChanged += this.UseCaseCollectionChanged;
            this._redefinedClassifier = new ObservableAssociationList<IClassifier>();
            this._redefinedClassifier.CollectionChanging += this.RedefinedClassifierCollectionChanging;
            this._redefinedClassifier.CollectionChanged += this.RedefinedClassifierCollectionChanged;
            this._substitution = new ClassifierSubstitutionCollection(this);
            this._substitution.CollectionChanging += this.SubstitutionCollectionChanging;
            this._substitution.CollectionChanged += this.SubstitutionCollectionChanged;
            this._templateBinding = new TemplateableElementTemplateBindingCollection(this);
            this._templateBinding.CollectionChanging += this.TemplateBindingCollectionChanging;
            this._templateBinding.CollectionChanged += this.TemplateBindingCollectionChanged;
        }
        
        /// <summary>
        /// If true, the Classifier can only be instantiated by instantiating one of its specializations. An abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations or Generalizations.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isAbstract")]
        [DescriptionAttribute(@"If true, the Classifier can only be instantiated by instantiating one of its specializations. An abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations or Generalizations.
<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isAbstract")]
        [XmlAttributeAttribute(true)]
        public bool IsAbstract
        {
            get
            {
                return this._isAbstract;
            }
            set
            {
                if ((this._isAbstract != value))
                {
                    bool old = this._isAbstract;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsAbstract", e, _isAbstractAttribute);
                    this._isAbstract = value;
                    this.OnPropertyChanged("IsAbstract", e, _isAbstractAttribute);
                }
            }
        }
        
        /// <summary>
        /// If true, the Classifier cannot be specialized.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isFinalSpecialization")]
        [DescriptionAttribute("If true, the Classifier cannot be specialized.\n<p>From package UML::Classificatio" +
            "n.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isFinalSpecialization")]
        [XmlAttributeAttribute(true)]
        public bool IsFinalSpecialization
        {
            get
            {
                return this._isFinalSpecialization;
            }
            set
            {
                if ((this._isFinalSpecialization != value))
                {
                    bool old = this._isFinalSpecialization;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsFinalSpecialization", e, _isFinalSpecializationAttribute);
                    this._isFinalSpecialization = value;
                    this.OnPropertyChanged("IsFinalSpecialization", e, _isFinalSpecializationAttribute);
                }
            }
        }
        
        /// <summary>
        /// The Generalization relationships for this Classifier. These Generalizations navigate to more general Classifiers in the generalization hierarchy.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("generalization")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("specific")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IGeneralization> Generalization
        {
            get
            {
                return this._generalization;
            }
        }
        
        /// <summary>
        /// The GeneralizationSet of which this Classifier is a power type.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("powertypeExtent")]
        [DescriptionAttribute("The GeneralizationSet of which this Classifier is a power type.\n<p>From package U" +
            "ML::Classification.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("powertypeExtent")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("powertype")]
        [ConstantAttribute()]
        public ISetExpression<IGeneralizationSet> PowertypeExtent
        {
            get
            {
                return this._powertypeExtent;
            }
        }
        
        /// <summary>
        /// The UseCases owned by this classifier.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedUseCase")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IUseCase> OwnedUseCase
        {
            get
            {
                return this._ownedUseCase;
            }
        }
        
        /// <summary>
        /// The set of UseCases for which this Classifier is the subject.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("useCase")]
        [DescriptionAttribute("The set of UseCases for which this Classifier is the subject.\n<p>From package UML" +
            "::Classification.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("useCase")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("subject")]
        [ConstantAttribute()]
        public ISetExpression<IUseCase> UseCase
        {
            get
            {
                return this._useCase;
            }
        }
        
        /// <summary>
        /// The Classifiers redefined by this Classifier.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedClassifier")]
        [DescriptionAttribute("The Classifiers redefined by this Classifier.\n<p>From package UML::Classification" +
            ".</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("redefinedClassifier")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<IClassifier> RedefinedClassifier
        {
            get
            {
                return this._redefinedClassifier;
            }
        }
        
        /// <summary>
        /// A CollaborationUse which indicates the Collaboration that represents this Classifier.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("representation")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ICollaborationUse Representation
        {
            get
            {
                return this._representation;
            }
            set
            {
                if ((this._representation != value))
                {
                    ICollaborationUse old = this._representation;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Representation", e, _representationReference);
                    this._representation = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetRepresentation;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetRepresentation;
                    }
                    this.OnPropertyChanged("Representation", e, _representationReference);
                }
            }
        }
        
        /// <summary>
        /// The Substitutions owned by this Classifier.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("substitution")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("substitutingClassifier")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ISubstitution> Substitution
        {
            get
            {
                return this._substitution;
            }
        }
        
        IListExpression<ICollaborationUse> IClassifier.CollaborationUse
        {
            get
            {
                return new ClassifierCollaborationUseCollection(this);
            }
        }
        
        /// <summary>
        /// Indicates whether it is possible to further redefine a RedefinableElement. If the value is true, then it is not possible to further redefine the RedefinableElement.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isLeaf")]
        [DescriptionAttribute("Indicates whether it is possible to further redefine a RedefinableElement. If the" +
            " value is true, then it is not possible to further redefine the RedefinableEleme" +
            "nt.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("RedefinableElement")]
        [XmlElementNameAttribute("isLeaf")]
        [XmlAttributeAttribute(true)]
        public bool IsLeaf
        {
            get
            {
                return this._isLeaf;
            }
            set
            {
                if ((this._isLeaf != value))
                {
                    bool old = this._isLeaf;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsLeaf", e, _isLeafAttribute);
                    this._isLeaf = value;
                    this.OnPropertyChanged("IsLeaf", e, _isLeafAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies the owning Package of this Type, if any.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("package")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedType")]
        public IPackage Package
        {
            get
            {
                return ModelHelper.CastAs<IPackage>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// The formal TemplateParameter that owns this ParameterableElement.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("owningTemplateParameter")]
        [DescriptionAttribute("The formal TemplateParameter that owns this ParameterableElement.\n<p>From package" +
            " UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("owningTemplateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedParameteredElement")]
        public ITemplateParameter OwningTemplateParameter
        {
            get
            {
                return this._owningTemplateParameter;
            }
            set
            {
                if ((this._owningTemplateParameter != value))
                {
                    ITemplateParameter old = this._owningTemplateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwningTemplateParameter", e, _owningTemplateParameterReference);
                    this._owningTemplateParameter = value;
                    if ((old != null))
                    {
                        old.OwnedParameteredElement = null;
                        old.Deleted -= this.OnResetOwningTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.OwnedParameteredElement = this;
                        value.Deleted += this.OnResetOwningTemplateParameter;
                    }
                    this.OnPropertyChanged("OwningTemplateParameter", e, _owningTemplateParameterReference);
                }
            }
        }
        
        /// <summary>
        /// The TemplateParameter that exposes this ParameterableElement as a formal parameter.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("templateParameter")]
        [DescriptionAttribute("The TemplateParameter that exposes this ParameterableElement as a formal paramete" +
            "r.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("templateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("parameteredElement")]
        public ITemplateParameter TemplateParameter
        {
            get
            {
                return this._templateParameter;
            }
            set
            {
                if ((this._templateParameter != value))
                {
                    ITemplateParameter old = this._templateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TemplateParameter", e, _templateParameterReference);
                    this._templateParameter = value;
                    if ((old != null))
                    {
                        old.ParameteredElement = null;
                        old.Deleted -= this.OnResetTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.ParameteredElement = this;
                        value.Deleted += this.OnResetTemplateParameter;
                    }
                    this.OnPropertyChanged("TemplateParameter", e, _templateParameterReference);
                }
            }
        }
        
        ITemplateParameter IParameterableElement.TemplateParameter
        {
            get
            {
                IParameterableElement _this = this;
                return _this.OwningTemplateParameter;
            }
            set
            {
                IParameterableElement _this = this;
                _this.OwningTemplateParameter = value;
            }
        }
        
        /// <summary>
        /// The optional TemplateBindings from this TemplateableElement to one or more templates.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("templateBinding")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("boundElement")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITemplateBinding> TemplateBinding
        {
            get
            {
                return this._templateBinding;
            }
        }
        
        /// <summary>
        /// The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a TemplateableElement has a TemplateSignature, then it is a template.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedTemplateSignature")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("template")]
        public ITemplateSignature OwnedTemplateSignature
        {
            get
            {
                return this._ownedTemplateSignature;
            }
            set
            {
                if ((this._ownedTemplateSignature != value))
                {
                    ITemplateSignature old = this._ownedTemplateSignature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                    this._ownedTemplateSignature = value;
                    if ((old != null))
                    {
                        old.Template = null;
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetOwnedTemplateSignature;
                    }
                    if ((value != null))
                    {
                        value.Template = this;
                        value.Parent = this;
                        value.ParentChanged += this.OnResetOwnedTemplateSignature;
                    }
                    this.OnPropertyChanged("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ClassifierChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ClassifierReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Classifier")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// A Classifier may only specialize Classifiers of a valid type.
        ///parents()-&gt;forAll(c | self.maySpecializeType(c))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Specialize_type(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_specialize_typeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method specialize_type registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _specialize_typeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _specialize_typeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _specialize_typeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSpecialize_typeOperation()
        {
            return ClassInstance.LookupOperation("specialize_type");
        }
        
        /// <summary>
        /// The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances also be its subclasses.
        ///powertypeExtent-&gt;forAll( gs | 
        ///  gs.generalization-&gt;forAll( gen | 
        ///    not (gen.general = self) and not gen.general.allParents()-&gt;includes(self) and not (gen.specific = self) and not self.allParents()-&gt;includes(gen.specific) 
        ///  ))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Maps_to_generalization_set(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_maps_to_generalization_setOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method maps_to_generalization_set registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _maps_to_generalization_setOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _maps_to_generalization_setOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _maps_to_generalization_setOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMaps_to_generalization_setOperation()
        {
            return ClassInstance.LookupOperation("maps_to_generalization_set");
        }
        
        /// <summary>
        /// The parents of a Classifier must be non-final.
        ///parents()-&gt;forAll(not isFinalSpecialization)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Non_final_parents(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_non_final_parentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method non_final_parents registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _non_final_parentsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _non_final_parentsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _non_final_parentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNon_final_parentsOperation()
        {
            return ClassInstance.LookupOperation("non_final_parents");
        }
        
        /// <summary>
        /// Generalization hierarchies must be directed and acyclical. A Classifier can not be both a transitively general and transitively specific Classifier of the same Classifier.
        ///not allParents()-&gt;includes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool No_cycles_in_generalization(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_no_cycles_in_generalizationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method no_cycles_in_generalization registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _no_cycles_in_generalizationOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _no_cycles_in_generalizationOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _no_cycles_in_generalizationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNo_cycles_in_generalizationOperation()
        {
            return ClassInstance.LookupOperation("no_cycles_in_generalization");
        }
        
        /// <summary>
        /// Retrieves all the attributes of this classifier, including those inherited from its parents.
        /// </summary>
        public ISetExpression<IProperty> GetAllAttributes()
        {
            System.Func<IClassifier, ISetExpression<IProperty>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IProperty>>>(_getAllAttributesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllAttributes registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllAttributesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllAttributesOperation.Value, e));
            ISetExpression<IProperty> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllAttributesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllAttributesOperation()
        {
            return ClassInstance.LookupOperation("getAllAttributes");
        }
        
        /// <summary>
        /// Retrieves all the operations of this classifier, including those inherited from its parents.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IOperation> GetAllOperations()
        {
            System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>>>(_getAllOperationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllOperations registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllOperationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllOperationsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IOperation> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllOperationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllOperationsOperation()
        {
            return ClassInstance.LookupOperation("getAllOperations");
        }
        
        /// <summary>
        /// Retrieves all the interfaces on which this classifier or any of its parents has a usage dependency.
        /// </summary>
        public ISetExpression<IInterface> GetAllUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_getAllUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllUsedInterfaces registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("getAllUsedInterfaces");
        }
        
        /// <summary>
        /// Retrieves the first operation with the specified name, parameter names, and parameter types from this classifier.
        /// </summary>
        /// <param name="name">The name of the operation to retrieve, or null.</param>
        /// <param name="parameterNames">The parameter names of the operation to retrieve, or null.</param>
        /// <param name="parameterTypes">The parameter types of the operation to retrieve, or null.</param>
        public NMF.Interop.Uml.IOperation GetOperation(string name, IEnumerable<string> parameterNames, IEnumerable<NMF.Interop.Uml.IType> parameterTypes)
        {
            System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, NMF.Interop.Uml.IOperation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, NMF.Interop.Uml.IOperation>>(_getOperationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOperation registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOperationOperation.Value, name, parameterNames, parameterTypes);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOperationOperation.Value, e));
            NMF.Interop.Uml.IOperation result = handler.Invoke(this, name, parameterNames, parameterTypes);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOperationOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves the first operation with the specified name, parameter names, and parameter types from this classifier, ignoring case if indicated.
        /// </summary>
        /// <param name="name">The name of the operation to retrieve, or null.</param>
        /// <param name="parameterNames">The parameter names of the operation to retrieve, or null.</param>
        /// <param name="parameterTypes">The parameter types of the operation to retrieve, or null.</param>
        /// <param name="ignoreCase">Whether to ignore case in String comparisons.</param>
        public NMF.Interop.Uml.IOperation GetOperation(string name, IEnumerable<string> parameterNames, IEnumerable<NMF.Interop.Uml.IType> parameterTypes, bool ignoreCase)
        {
            System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, bool, NMF.Interop.Uml.IOperation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, bool, NMF.Interop.Uml.IOperation>>(_getOperationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOperation registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOperationOperation.Value, name, parameterNames, parameterTypes, ignoreCase);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOperationOperation.Value, e));
            NMF.Interop.Uml.IOperation result = handler.Invoke(this, name, parameterNames, parameterTypes, ignoreCase);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOperationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOperationOperation()
        {
            return ClassInstance.LookupOperation("getOperation");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOperationOperation_()
        {
            return ClassInstance.LookupOperation("getOperation");
        }
        
        /// <summary>
        /// Retrieves the operations of this classifier.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IOperation> GetOperations()
        {
            System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>>>(_getOperationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOperations registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOperationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOperationsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IOperation> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOperationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOperationsOperation()
        {
            return ClassInstance.LookupOperation("getOperations");
        }
        
        /// <summary>
        /// Retrieves the interfaces on which this classifier has a usage dependency.
        /// </summary>
        public ISetExpression<IInterface> GetUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_getUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getUsedInterfaces registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("getUsedInterfaces");
        }
        
        /// <summary>
        /// The query allFeatures() gives all of the Features in the namespace of the Classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.
        ///result = (member-&gt;select(oclIsKindOf(Feature))-&gt;collect(oclAsType(Feature))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IFeature> AllFeatures()
        {
            System.Func<IClassifier, ISetExpression<IFeature>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IFeature>>>(_allFeaturesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allFeatures registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allFeaturesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allFeaturesOperation.Value, e));
            ISetExpression<IFeature> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allFeaturesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllFeaturesOperation()
        {
            return ClassInstance.LookupOperation("allFeatures");
        }
        
        /// <summary>
        /// The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
        ///result = (parents()-&gt;union(parents()-&gt;collect(allParents())-&gt;asSet()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IClassifier> AllParents()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_allParentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allParents registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allParentsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allParentsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allParentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllParentsOperation()
        {
            return ClassInstance.LookupOperation("allParents");
        }
        
        /// <summary>
        /// The general Classifiers are the ones referenced by the Generalization relationships.
        ///result = (parents())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IClassifier> GetGenerals()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_getGeneralsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getGenerals registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getGeneralsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getGeneralsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getGeneralsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetGeneralsOperation()
        {
            return ClassInstance.LookupOperation("getGenerals");
        }
        
        /// <summary>
        /// The query hasVisibilityOf() determines whether a NamedElement is visible in the classifier. Non-private members are visible. It is only called when the argument is something owned by a parent.
        ///allParents()-&gt;including(self)-&gt;collect(member)-&gt;includes(n)
        ///result = (n.visibility &lt;&gt; VisibilityKind::private)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="n"></param>
        public bool HasVisibilityOf(INamedElement n)
        {
            System.Func<IClassifier, INamedElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, INamedElement, bool>>(_hasVisibilityOfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method hasVisibilityOf registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _hasVisibilityOfOperation.Value, n);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _hasVisibilityOfOperation.Value, e));
            bool result = handler.Invoke(this, n);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _hasVisibilityOfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveHasVisibilityOfOperation()
        {
            return ClassInstance.LookupOperation("hasVisibilityOf");
        }
        
        /// <summary>
        /// The query inherit() defines how to inherit a set of elements passed as its argument.  It excludes redefined elements from the result.
        ///result = (inhs-&gt;reject(inh |
        ///  inh.oclIsKindOf(RedefinableElement) and
        ///  ownedMember-&gt;select(oclIsKindOf(RedefinableElement))-&gt;
        ///    select(redefinedElement-&gt;includes(inh.oclAsType(RedefinableElement)))
        ///       -&gt;notEmpty()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="inhs"></param>
        public ISetExpression<INamedElement> Inherit(IEnumerable<INamedElement> inhs)
        {
            System.Func<IClassifier, IEnumerable<INamedElement>, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IEnumerable<INamedElement>, ISetExpression<INamedElement>>>(_inheritOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inherit registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inheritOperation.Value, inhs);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inheritOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this, inhs);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inheritOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInheritOperation()
        {
            return ClassInstance.LookupOperation("inherit");
        }
        
        /// <summary>
        /// The query inheritableMembers() gives all of the members of a Classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.
        ///c.allParents()-&gt;includes(self)
        ///result = (member-&gt;select(m | c.hasVisibilityOf(m)))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="c"></param>
        public ISetExpression<INamedElement> InheritableMembers(IClassifier c)
        {
            System.Func<IClassifier, IClassifier, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, ISetExpression<INamedElement>>>(_inheritableMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inheritableMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inheritableMembersOperation.Value, c);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inheritableMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this, c);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inheritableMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInheritableMembersOperation()
        {
            return ClassInstance.LookupOperation("inheritableMembers");
        }
        
        /// <summary>
        /// The inheritedMember association is derived by inheriting the inheritable members of the parents.
        ///result = (inherit(parents()-&gt;collect(inheritableMembers(self))-&gt;asSet()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<INamedElement> GetInheritedMembers()
        {
            System.Func<IClassifier, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<INamedElement>>>(_getInheritedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getInheritedMembers registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getInheritedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getInheritedMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getInheritedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetInheritedMembersOperation()
        {
            return ClassInstance.LookupOperation("getInheritedMembers");
        }
        
        /// <summary>
        /// The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.
        ///result = (self.oclIsKindOf(c.oclType()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="c"></param>
        public bool MaySpecializeType(IClassifier c)
        {
            System.Func<IClassifier, IClassifier, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, bool>>(_maySpecializeTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method maySpecializeType registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _maySpecializeTypeOperation.Value, c);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _maySpecializeTypeOperation.Value, e));
            bool result = handler.Invoke(this, c);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _maySpecializeTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMaySpecializeTypeOperation()
        {
            return ClassInstance.LookupOperation("maySpecializeType");
        }
        
        /// <summary>
        /// The query parents() gives all of the immediate ancestors of a generalized Classifier.
        ///result = (generalization.general-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IClassifier> Parents()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_parentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parents registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parentsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parentsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParentsOperation()
        {
            return ClassInstance.LookupOperation("parents");
        }
        
        /// <summary>
        /// The Interfaces directly realized by this Classifier
        ///result = ((clientDependency-&gt;
        ///  select(oclIsKindOf(Realization) and supplier-&gt;forAll(oclIsKindOf(Interface))))-&gt;
        ///      collect(supplier.oclAsType(Interface))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> DirectlyRealizedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_directlyRealizedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method directlyRealizedInterfaces registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _directlyRealizedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _directlyRealizedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _directlyRealizedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDirectlyRealizedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("directlyRealizedInterfaces");
        }
        
        /// <summary>
        /// The Interfaces directly used by this Classifier
        ///result = ((supplierDependency-&gt;
        ///  select(oclIsKindOf(Usage) and client-&gt;forAll(oclIsKindOf(Interface))))-&gt;
        ///    collect(client.oclAsType(Interface))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> DirectlyUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_directlyUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method directlyUsedInterfaces registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _directlyUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _directlyUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _directlyUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDirectlyUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("directlyUsedInterfaces");
        }
        
        /// <summary>
        /// The Interfaces realized by this Classifier and all of its generalizations
        ///result = (directlyRealizedInterfaces()-&gt;union(self.allParents()-&gt;collect(directlyRealizedInterfaces()))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> AllRealizedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_allRealizedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allRealizedInterfaces registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allRealizedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allRealizedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allRealizedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllRealizedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("allRealizedInterfaces");
        }
        
        /// <summary>
        /// The Interfaces used by this Classifier and all of its generalizations
        ///result = (directlyUsedInterfaces()-&gt;union(self.allParents()-&gt;collect(directlyUsedInterfaces()))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> AllUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_allUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allUsedInterfaces registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("allUsedInterfaces");
        }
        
        /// <summary>
        /// result = (substitution.contract-&gt;includes(contract))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="contract"></param>
        public bool IsSubstitutableFor(IClassifier contract)
        {
            System.Func<IClassifier, IClassifier, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, bool>>(_isSubstitutableForOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isSubstitutableFor registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isSubstitutableForOperation.Value, contract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isSubstitutableForOperation.Value, e));
            bool result = handler.Invoke(this, contract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isSubstitutableForOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsSubstitutableForOperation()
        {
            return ClassInstance.LookupOperation("isSubstitutableFor");
        }
        
        /// <summary>
        /// The query allAttributes gives an ordered set of all owned and inherited attributes of the Classifier. All owned attributes appear before any inherited attributes, and the attributes inherited from any more specific parent Classifier appear before those of any more general parent Classifier. However, if the Classifier has multiple immediate parents, then the relative ordering of the sets of attributes from those parents is not defined.
        ///result = (attribute-&gt;asSequence()-&gt;union(parents()-&gt;asSequence().allAttributes())-&gt;select(p | member-&gt;includes(p))-&gt;asOrderedSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public IOrderedSetExpression<IProperty> AllAttributes()
        {
            System.Func<IClassifier, IOrderedSetExpression<IProperty>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IOrderedSetExpression<IProperty>>>(_allAttributesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allAttributes registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allAttributesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allAttributesOperation.Value, e));
            IOrderedSetExpression<IProperty> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allAttributesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllAttributesOperation()
        {
            return ClassInstance.LookupOperation("allAttributes");
        }
        
        /// <summary>
        /// All StructuralFeatures related to the Classifier that may have Slots, including direct attributes, inherited attributes, private attributes in generalizations, and memberEnds of Associations, but excluding redefined StructuralFeatures.
        ///result = (member-&gt;select(oclIsKindOf(StructuralFeature))-&gt;
        ///  collect(oclAsType(StructuralFeature))-&gt;
        ///   union(self.inherit(self.allParents()-&gt;collect(p | p.attribute)-&gt;asSet())-&gt;
        ///     collect(oclAsType(StructuralFeature)))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IStructuralFeature> AllSlottableFeatures()
        {
            System.Func<IClassifier, ISetExpression<IStructuralFeature>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IStructuralFeature>>>(_allSlottableFeaturesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allSlottableFeatures registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allSlottableFeaturesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allSlottableFeaturesOperation.Value, e));
            ISetExpression<IStructuralFeature> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allSlottableFeaturesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllSlottableFeaturesOperation()
        {
            return ClassInstance.LookupOperation("allSlottableFeatures");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsAbstractAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("isAbstract")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsFinalSpecializationAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("isFinalSpecialization")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveGeneralizationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("generalization")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Generalization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void GeneralizationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Generalization", e, _generalizationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Generalization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void GeneralizationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Generalization", e, _generalizationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePowertypeExtentReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("powertypeExtent")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PowertypeExtent property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PowertypeExtentCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PowertypeExtent", e, _powertypeExtentReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PowertypeExtent property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PowertypeExtentCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PowertypeExtent", e, _powertypeExtentReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedUseCaseReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("ownedUseCase")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedUseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedUseCaseCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedUseCase", e, _ownedUseCaseReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedUseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedUseCaseCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedUseCase", e, _ownedUseCaseReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveUseCaseReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("useCase")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the UseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void UseCaseCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("UseCase", e, _useCaseReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the UseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void UseCaseCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("UseCase", e, _useCaseReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedClassifierReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("redefinedClassifier")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedClassifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedClassifierCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedClassifier", e, _redefinedClassifierReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedClassifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedClassifierCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedClassifier", e, _redefinedClassifierReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRepresentationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("representation")));
        }
        
        /// <summary>
        /// Handles the event that the Representation property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRepresentation(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Representation))
            {
                this.Representation = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSubstitutionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("substitution")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Substitution property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SubstitutionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Substitution", e, _substitutionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Substitution property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SubstitutionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Substitution", e, _substitutionReference);
        }
        
        /// <summary>
        /// A redefining element must be consistent with each redefined element.
        ///redefinedElement-&gt;forAll(re | re.isConsistentWith(self))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_consistent(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_consistentOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_consistent registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_consistentOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_consistentOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_consistentOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_consistentOperation()
        {
            return ClassInstance.LookupOperation("redefinition_consistent");
        }
        
        /// <summary>
        /// A RedefinableElement can only redefine non-leaf RedefinableElements.
        ///redefinedElement-&gt;forAll(re | not re.isLeaf)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Non_leaf_redefinition(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_non_leaf_redefinitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method non_leaf_redefinition registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _non_leaf_redefinitionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _non_leaf_redefinitionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _non_leaf_redefinitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNon_leaf_redefinitionOperation()
        {
            return ClassInstance.LookupOperation("non_leaf_redefinition");
        }
        
        /// <summary>
        /// At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.
        ///redefinedElement-&gt;forAll(re | self.isRedefinitionContextValid(re))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_context_valid(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_context_validOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_context_valid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_context_validOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_context_validOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_context_validOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_context_validOperation()
        {
            return ClassInstance.LookupOperation("redefinition_context_valid");
        }
        
        /// <summary>
        /// The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for subclasses of RedefinableElement to define the consistency conditions.
        ///redefiningElement.isRedefinitionContextValid(self)
        ///result = (false)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="redefiningElement"></param>
        public bool IsConsistentWith(IRedefinableElement redefiningElement)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isConsistentWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isConsistentWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isConsistentWithOperation.Value, redefiningElement);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isConsistentWithOperation.Value, e));
            bool result = handler.Invoke(this, redefiningElement);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isConsistentWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsConsistentWithOperation()
        {
            return ClassInstance.LookupOperation("isConsistentWith");
        }
        
        /// <summary>
        /// The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinition contexts of the specified element.
        ///result = (redefinitionContext-&gt;exists(c | c.allParents()-&gt;includesAll(redefinedElement.redefinitionContext)))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="redefinedElement"></param>
        public bool IsRedefinitionContextValid(IRedefinableElement redefinedElement)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isRedefinitionContextValidOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isRedefinitionContextValid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isRedefinitionContextValidOperation.Value, redefinedElement);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isRedefinitionContextValidOperation.Value, e));
            bool result = handler.Invoke(this, redefinedElement);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isRedefinitionContextValidOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsRedefinitionContextValidOperation()
        {
            return ClassInstance.LookupOperation("isRedefinitionContextValid");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsLeafAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.RedefinableElement.ClassInstance)).Resolve("isLeaf")));
        }
        
        /// <summary>
        /// Creates a(n) (binary) association between this type and the specified other type, with the specified navigabilities, aggregations, names, lower bounds, and upper bounds, and owned by this type&apos;s nearest package.
        /// </summary>
        /// <param name="end1IsNavigable">The navigability for the first end of the new association.</param>
        /// <param name="end1Aggregation">The aggregation for the first end of the new association.</param>
        /// <param name="end1Name">The name for the first end of the new association.</param>
        /// <param name="end1Lower">The lower bound for the first end of the new association.</param>
        /// <param name="end1Upper">The upper bound for the first end of the new association.</param>
        /// <param name="end1Type">The type for the first end of the new association.</param>
        /// <param name="end2IsNavigable">The navigability for the second end of the new association.</param>
        /// <param name="end2Aggregation">The aggregation for the second end of the new association.</param>
        /// <param name="end2Name">The name for the second end of the new association.</param>
        /// <param name="end2Lower">The lower bound for the second end of the new association.</param>
        /// <param name="end2Upper">The upper bound for the second end of the new association.</param>
        public IAssociation CreateAssociation(bool end1IsNavigable, AggregationKind end1Aggregation, string end1Name, int end1Lower, object end1Upper, NMF.Interop.Uml.IType end1Type, bool end2IsNavigable, AggregationKind end2Aggregation, string end2Name, int end2Lower, object end2Upper)
        {
            System.Func<NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, IAssociation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, IAssociation>>(_createAssociationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createAssociation registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createAssociationOperation.Value, end1IsNavigable, end1Aggregation, end1Name, end1Lower, end1Upper, end1Type, end2IsNavigable, end2Aggregation, end2Name, end2Lower, end2Upper);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createAssociationOperation.Value, e));
            IAssociation result = handler.Invoke(this, end1IsNavigable, end1Aggregation, end1Name, end1Lower, end1Upper, end1Type, end2IsNavigable, end2Aggregation, end2Name, end2Lower, end2Upper);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createAssociationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateAssociationOperation()
        {
            return ClassInstance.LookupOperation("createAssociation");
        }
        
        /// <summary>
        /// Retrieves the associations in which this type is involved.
        /// </summary>
        public ISetExpression<IAssociation> GetAssociations()
        {
            System.Func<NMF.Interop.Uml.IType, ISetExpression<IAssociation>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IType, ISetExpression<IAssociation>>>(_getAssociationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAssociations registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAssociationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAssociationsOperation.Value, e));
            ISetExpression<IAssociation> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAssociationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAssociationsOperation()
        {
            return ClassInstance.LookupOperation("getAssociations");
        }
        
        /// <summary>
        /// The query conformsTo() gives true for a Type that conforms to another. By default, two Types do not conform to each other. This query is intended to be redefined for specific conformance situations.
        ///result = (false)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="other"></param>
        public bool ConformsTo(NMF.Interop.Uml.IType other)
        {
            System.Func<NMF.Interop.Uml.IType, NMF.Interop.Uml.IType, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IType, NMF.Interop.Uml.IType, bool>>(_conformsToOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method conformsTo registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _conformsToOperation.Value, other);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _conformsToOperation.Value, e));
            bool result = handler.Invoke(this, other);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _conformsToOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveConformsToOperation()
        {
            return ClassInstance.LookupOperation("conformsTo");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Type.ClassInstance)).Resolve("package")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newPackage = ModelHelper.CastAs<IPackage>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldPackage, newPackage);
            this.OnPropertyChanging("Package", e, _packageReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newPackage = ModelHelper.CastAs<IPackage>(newParent);
            if ((oldPackage != null))
            {
                oldPackage.OwnedType.Remove(this);
            }
            if ((newPackage != null))
            {
                newPackage.OwnedType.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldPackage, newPackage);
            this.OnPropertyChanged("Package", e, _packageReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// A PackageableElement owned by a Namespace must have a visibility.
        ///visibility = null implies namespace = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Namespace_needs_visibility(object diagnostics, object context)
        {
            System.Func<IPackageableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackageableElement, object, object, bool>>(_namespace_needs_visibilityOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method namespace_needs_visibility registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _namespace_needs_visibilityOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _namespace_needs_visibilityOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _namespace_needs_visibilityOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNamespace_needs_visibilityOperation()
        {
            return ClassInstance.LookupOperation("namespace_needs_visibility");
        }
        
        /// <summary>
        /// The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified ParameterableElement. By default, this ParameterableElement is compatible with another ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. Subclasses of ParameterableElement should override this operation to specify different compatibility constraints.
        ///result = (self.oclIsKindOf(p.oclType()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="p"></param>
        public bool IsCompatibleWith(IParameterableElement p)
        {
            System.Func<IParameterableElement, IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, IParameterableElement, bool>>(_isCompatibleWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isCompatibleWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompatibleWithOperation.Value, p);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompatibleWithOperation.Value, e));
            bool result = handler.Invoke(this, p);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompatibleWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompatibleWithOperation()
        {
            return ClassInstance.LookupOperation("isCompatibleWith");
        }
        
        /// <summary>
        /// The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal TemplateParameter.
        ///result = (templateParameter-&gt;notEmpty())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplateParameter()
        {
            System.Func<IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, bool>>(_isTemplateParameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplateParameter registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateParameterOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateParameterOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateParameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateParameterOperation()
        {
            return ClassInstance.LookupOperation("isTemplateParameter");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("owningTemplateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the OwningTemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwningTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwningTemplateParameter))
            {
                this.OwningTemplateParameter = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("templateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the TemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.TemplateParameter))
            {
                this.TemplateParameter = null;
            }
        }
        
        /// <summary>
        /// The query isTemplate() returns whether this TemplateableElement is actually a template.
        ///result = (ownedTemplateSignature &lt;&gt; null)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplate()
        {
            System.Func<ITemplateableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, bool>>(_isTemplateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplate registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateOperation()
        {
            return ClassInstance.LookupOperation("isTemplate");
        }
        
        /// <summary>
        /// The query parameterableElements() returns the set of ParameterableElements that may be used as the parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all the ownedElements. Subclasses may override this operation if they choose to restrict the set of ParameterableElements.
        ///result = (self.allOwnedElements()-&gt;select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)-&gt;asSet())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IParameterableElement> ParameterableElements()
        {
            System.Func<ITemplateableElement, ISetExpression<IParameterableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, ISetExpression<IParameterableElement>>>(_parameterableElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameterableElements registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameterableElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameterableElementsOperation.Value, e));
            ISetExpression<IParameterableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameterableElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameterableElementsOperation()
        {
            return ClassInstance.LookupOperation("parameterableElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateBindingReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("templateBinding")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TemplateBinding", e, _templateBindingReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TemplateBinding", e, _templateBindingReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTemplateSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("ownedTemplateSignature")));
        }
        
        /// <summary>
        /// Handles the event that the OwnedTemplateSignature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwnedTemplateSignature(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwnedTemplateSignature))
            {
                this.OwnedTemplateSignature = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int generalizationIndex = ModelHelper.IndexOfReference(this.Generalization, element);
            if ((generalizationIndex != -1))
            {
                return ModelHelper.CreatePath("generalization", generalizationIndex);
            }
            int ownedUseCaseIndex = ModelHelper.IndexOfReference(this.OwnedUseCase, element);
            if ((ownedUseCaseIndex != -1))
            {
                return ModelHelper.CreatePath("ownedUseCase", ownedUseCaseIndex);
            }
            if ((element == this.Representation))
            {
                return ModelHelper.CreatePath("representation");
            }
            int substitutionIndex = ModelHelper.IndexOfReference(this.Substitution, element);
            if ((substitutionIndex != -1))
            {
                return ModelHelper.CreatePath("substitution", substitutionIndex);
            }
            int templateBindingIndex = ModelHelper.IndexOfReference(this.TemplateBinding, element);
            if ((templateBindingIndex != -1))
            {
                return ModelHelper.CreatePath("templateBinding", templateBindingIndex);
            }
            if ((element == this.OwnedTemplateSignature))
            {
                return ModelHelper.CreatePath("ownedTemplateSignature");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "GENERALIZATION"))
            {
                if ((index < this.Generalization.Count))
                {
                    return this.Generalization[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDUSECASE"))
            {
                if ((index < this.OwnedUseCase.Count))
                {
                    return this.OwnedUseCase[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "REPRESENTATION"))
            {
                return this.Representation;
            }
            if ((reference == "SUBSTITUTION"))
            {
                if ((index < this.Substitution.Count))
                {
                    return this.Substitution[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGE"))
            {
                return this.Package;
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return this.OwningTemplateParameter;
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return this.TemplateParameter;
            }
            if ((reference == "TEMPLATEBINDING"))
            {
                if ((index < this.TemplateBinding.Count))
                {
                    return this.TemplateBinding[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return this.OwnedTemplateSignature;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISABSTRACT"))
            {
                return this.IsAbstract;
            }
            if ((attribute == "ISFINALSPECIALIZATION"))
            {
                return this.IsFinalSpecialization;
            }
            if ((attribute == "ISLEAF"))
            {
                return this.IsLeaf;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "GENERALIZATION"))
            {
                return this._generalization;
            }
            if ((feature == "POWERTYPEEXTENT"))
            {
                return this._powertypeExtent;
            }
            if ((feature == "OWNEDUSECASE"))
            {
                return this._ownedUseCase;
            }
            if ((feature == "USECASE"))
            {
                return this._useCase;
            }
            if ((feature == "REDEFINEDCLASSIFIER"))
            {
                return this._redefinedClassifier;
            }
            if ((feature == "SUBSTITUTION"))
            {
                return this._substitution;
            }
            if ((feature == "TEMPLATEBINDING"))
            {
                return this._templateBinding;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "REPRESENTATION"))
            {
                this.Representation = ((ICollaborationUse)(value));
                return;
            }
            if ((feature == "PACKAGE"))
            {
                this.Package = ((IPackage)(value));
                return;
            }
            if ((feature == "OWNINGTEMPLATEPARAMETER"))
            {
                this.OwningTemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "TEMPLATEPARAMETER"))
            {
                this.TemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "OWNEDTEMPLATESIGNATURE"))
            {
                this.OwnedTemplateSignature = ((ITemplateSignature)(value));
                return;
            }
            if ((feature == "ISABSTRACT"))
            {
                this.IsAbstract = ((bool)(value));
                return;
            }
            if ((feature == "ISFINALSPECIALIZATION"))
            {
                this.IsFinalSpecialization = ((bool)(value));
                return;
            }
            if ((feature == "ISLEAF"))
            {
                this.IsLeaf = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISABSTRACT"))
            {
                return Observable.Box(new IsAbstractProxy(this));
            }
            if ((attribute == "ISFINALSPECIALIZATION"))
            {
                return Observable.Box(new IsFinalSpecializationProxy(this));
            }
            if ((attribute == "ISLEAF"))
            {
                return Observable.Box(new IsLeafProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "REPRESENTATION"))
            {
                return new RepresentationProxy(this);
            }
            if ((reference == "PACKAGE"))
            {
                return new PackageProxy(this);
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return new OwningTemplateParameterProxy(this);
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return new TemplateParameterProxy(this);
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return new OwnedTemplateSignatureProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._generalization))
            {
                return "generalization";
            }
            if ((container == this._ownedUseCase))
            {
                return "ownedUseCase";
            }
            if ((container == this._substitution))
            {
                return "substitution";
            }
            if ((container == this._templateBinding))
            {
                return "templateBinding";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Classifier")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Classifier class
        /// </summary>
        public class ClassifierChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Classifier _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ClassifierChildrenCollection(Classifier parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Classifier class
        /// </summary>
        public class ClassifierReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Classifier _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ClassifierReferencedElementsCollection(Classifier parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isAbstract property
        /// </summary>
        private sealed class IsAbstractProxy : ModelPropertyChange<IClassifier, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsAbstractProxy(IClassifier modelElement) : 
                    base(modelElement, "isAbstract")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsAbstract;
                }
                set
                {
                    this.ModelElement.IsAbstract = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isFinalSpecialization property
        /// </summary>
        private sealed class IsFinalSpecializationProxy : ModelPropertyChange<IClassifier, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsFinalSpecializationProxy(IClassifier modelElement) : 
                    base(modelElement, "isFinalSpecialization")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsFinalSpecialization;
                }
                set
                {
                    this.ModelElement.IsFinalSpecialization = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the representation property
        /// </summary>
        private sealed class RepresentationProxy : ModelPropertyChange<IClassifier, ICollaborationUse>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RepresentationProxy(IClassifier modelElement) : 
                    base(modelElement, "representation")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ICollaborationUse Value
            {
                get
                {
                    return this.ModelElement.Representation;
                }
                set
                {
                    this.ModelElement.Representation = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isLeaf property
        /// </summary>
        private sealed class IsLeafProxy : ModelPropertyChange<IRedefinableElement, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsLeafProxy(IRedefinableElement modelElement) : 
                    base(modelElement, "isLeaf")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsLeaf;
                }
                set
                {
                    this.ModelElement.IsLeaf = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the package property
        /// </summary>
        private sealed class PackageProxy : ModelPropertyChange<NMF.Interop.Uml.IType, IPackage>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public PackageProxy(NMF.Interop.Uml.IType modelElement) : 
                    base(modelElement, "package")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IPackage Value
            {
                get
                {
                    return this.ModelElement.Package;
                }
                set
                {
                    this.ModelElement.Package = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningTemplateParameter property
        /// </summary>
        private sealed class OwningTemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningTemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "owningTemplateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.OwningTemplateParameter;
                }
                set
                {
                    this.ModelElement.OwningTemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the templateParameter property
        /// </summary>
        private sealed class TemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "templateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.TemplateParameter;
                }
                set
                {
                    this.ModelElement.TemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the ownedTemplateSignature property
        /// </summary>
        private sealed class OwnedTemplateSignatureProxy : ModelPropertyChange<ITemplateableElement, ITemplateSignature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwnedTemplateSignatureProxy(ITemplateableElement modelElement) : 
                    base(modelElement, "ownedTemplateSignature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateSignature Value
            {
                get
                {
                    return this.ModelElement.OwnedTemplateSignature;
                }
                set
                {
                    this.ModelElement.OwnedTemplateSignature = value;
                }
            }
        }
    }
}
