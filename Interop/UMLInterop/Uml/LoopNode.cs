//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A LoopNode is a StructuredActivityNode that represents an iterative loop with setup, test, and body sections.
    ///<p>From package UML::Actions.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//LoopNode")]
    [DebuggerDisplayAttribute("LoopNode {Name}")]
    public partial class LoopNode : StructuredActivityNode, ILoopNode, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _result_no_incomingOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveResult_no_incomingOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _input_edgesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInput_edgesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _executable_nodesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveExecutable_nodesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _body_output_pinsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBody_output_pinsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setup_test_and_bodyOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetup_test_and_bodyOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _matching_output_pinsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMatching_output_pinsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _matching_loop_variablesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMatching_loop_variablesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _matching_result_pinsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMatching_result_pinsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _loop_variable_outgoingOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveLoop_variable_outgoingOperation);
        
        /// <summary>
        /// The backing field for the IsTestedFirst property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isTestedFirst = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isTestedFirstAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsTestedFirstAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _bodyOutputReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBodyOutputReference);
        
        /// <summary>
        /// The backing field for the BodyOutput property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationOrderedSet<IOutputPin> _bodyOutput;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _bodyPartReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBodyPartReference);
        
        /// <summary>
        /// The backing field for the BodyPart property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IExecutableNode> _bodyPart;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _deciderReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDeciderReference);
        
        /// <summary>
        /// The backing field for the Decider property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IOutputPin _decider;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _loopVariableReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveLoopVariableReference);
        
        /// <summary>
        /// The backing field for the LoopVariable property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IOutputPin> _loopVariable;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _loopVariableInputReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveLoopVariableInputReference);
        
        /// <summary>
        /// The backing field for the LoopVariableInput property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IInputPin> _loopVariableInput;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _resultReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveResultReference);
        
        /// <summary>
        /// The backing field for the Result property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IOutputPin> _result;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _setupPartReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSetupPartReference);
        
        /// <summary>
        /// The backing field for the SetupPart property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IExecutableNode> _setupPart;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _testReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTestReference);
        
        /// <summary>
        /// The backing field for the Test property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IExecutableNode> _test;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public LoopNode()
        {
            this._bodyOutput = new ObservableAssociationOrderedSet<IOutputPin>();
            this._bodyOutput.CollectionChanging += this.BodyOutputCollectionChanging;
            this._bodyOutput.CollectionChanged += this.BodyOutputCollectionChanged;
            this._bodyPart = new ObservableAssociationSet<IExecutableNode>();
            this._bodyPart.CollectionChanging += this.BodyPartCollectionChanging;
            this._bodyPart.CollectionChanged += this.BodyPartCollectionChanged;
            this._loopVariable = new ObservableCompositionOrderedSet<IOutputPin>(this);
            this._loopVariable.CollectionChanging += this.LoopVariableCollectionChanging;
            this._loopVariable.CollectionChanged += this.LoopVariableCollectionChanged;
            this._loopVariableInput = new ObservableCompositionOrderedSet<IInputPin>(this);
            this._loopVariableInput.CollectionChanging += this.LoopVariableInputCollectionChanging;
            this._loopVariableInput.CollectionChanged += this.LoopVariableInputCollectionChanged;
            this._result = new ObservableCompositionOrderedSet<IOutputPin>(this);
            this._result.CollectionChanging += this.ResultCollectionChanging;
            this._result.CollectionChanged += this.ResultCollectionChanged;
            this._setupPart = new ObservableAssociationSet<IExecutableNode>();
            this._setupPart.CollectionChanging += this.SetupPartCollectionChanging;
            this._setupPart.CollectionChanged += this.SetupPartCollectionChanged;
            this._test = new ObservableAssociationSet<IExecutableNode>();
            this._test.CollectionChanging += this.TestCollectionChanging;
            this._test.CollectionChanged += this.TestCollectionChanged;
        }
        
        /// <summary>
        /// If true, the test is performed before the first execution of the bodyPart. If false, the bodyPart is executed once before the test is performed.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isTestedFirst")]
        [DescriptionAttribute("If true, the test is performed before the first execution of the bodyPart. If fal" +
            "se, the bodyPart is executed once before the test is performed.\n<p>From package " +
            "UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("isTestedFirst")]
        [XmlAttributeAttribute(true)]
        public bool IsTestedFirst
        {
            get
            {
                return this._isTestedFirst;
            }
            set
            {
                if ((this._isTestedFirst != value))
                {
                    bool old = this._isTestedFirst;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsTestedFirst", e, _isTestedFirstAttribute);
                    this._isTestedFirst = value;
                    this.OnPropertyChanged("IsTestedFirst", e, _isTestedFirstAttribute);
                }
            }
        }
        
        /// <summary>
        /// The OutputPins on Actions within the bodyPart, the values of which are moved to the loopVariable OutputPins after the completion of each execution of the bodyPart, before the next iteration of the loop begins or before the loop exits.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("bodyOutput")]
        [DescriptionAttribute(@"The OutputPins on Actions within the bodyPart, the values of which are moved to the loopVariable OutputPins after the completion of each execution of the bodyPart, before the next iteration of the loop begins or before the loop exits.
<p>From package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("bodyOutput")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public IOrderedSetExpression<IOutputPin> BodyOutput
        {
            get
            {
                return this._bodyOutput;
            }
        }
        
        /// <summary>
        /// The set of ExecutableNodes that perform the repetitive computations of the loop. The bodyPart is executed as long as the test section produces a true value.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("bodyPart")]
        [DescriptionAttribute("The set of ExecutableNodes that perform the repetitive computations of the loop. " +
            "The bodyPart is executed as long as the test section produces a true value.\n<p>F" +
            "rom package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("bodyPart")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IExecutableNode> BodyPart
        {
            get
            {
                return this._bodyPart;
            }
        }
        
        /// <summary>
        /// An OutputPin on an Action in the test section whose Boolean value determines whether to continue executing the loop bodyPart.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DisplayNameAttribute("decider")]
        [DescriptionAttribute("An OutputPin on an Action in the test section whose Boolean value determines whet" +
            "her to continue executing the loop bodyPart.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("decider")]
        [XmlAttributeAttribute(true)]
        public IOutputPin Decider
        {
            get
            {
                return this._decider;
            }
            set
            {
                if ((this._decider != value))
                {
                    IOutputPin old = this._decider;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Decider", e, _deciderReference);
                    this._decider = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetDecider;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetDecider;
                    }
                    this.OnPropertyChanged("Decider", e, _deciderReference);
                }
            }
        }
        
        /// <summary>
        /// A list of OutputPins that hold the values of the loop variables during an execution of the loop. When the test fails, the values are moved to the result OutputPins of the loop.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("loopVariable")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IOutputPin> LoopVariable
        {
            get
            {
                return this._loopVariable;
            }
        }
        
        /// <summary>
        /// A list of InputPins whose values are moved into the loopVariable Pins before the first iteration of the loop.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("loopVariableInput")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IInputPin> LoopVariableInput
        {
            get
            {
                return this._loopVariableInput;
            }
        }
        
        /// <summary>
        /// A list of OutputPins that receive the loopVariable values after the last iteration of the loop and constitute the output of the LoopNode.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("result")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IOutputPin> Result
        {
            get
            {
                return this._result;
            }
        }
        
        /// <summary>
        /// The set of ExecutableNodes executed before the first iteration of the loop, in order to initialize values or perform other setup computations.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("setupPart")]
        [DescriptionAttribute("The set of ExecutableNodes executed before the first iteration of the loop, in or" +
            "der to initialize values or perform other setup computations.\n<p>From package UM" +
            "L::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("setupPart")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IExecutableNode> SetupPart
        {
            get
            {
                return this._setupPart;
            }
        }
        
        /// <summary>
        /// The set of ExecutableNodes executed in order to provide the test result for the loop.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("test")]
        [DescriptionAttribute("The set of ExecutableNodes executed in order to provide the test result for the l" +
            "oop.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("LoopNode")]
        [XmlElementNameAttribute("test")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IExecutableNode> Test
        {
            get
            {
                return this._test;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new LoopNodeChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new LoopNodeReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//LoopNode")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// The result OutputPins have no incoming edges.
        ///result.incoming->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Result_no_incoming(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_result_no_incomingOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method result_no_incoming registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _result_no_incomingOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _result_no_incomingOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _result_no_incomingOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveResult_no_incomingOperation()
        {
            return ClassInstance.LookupOperation("result_no_incoming");
        }
        
        /// <summary>
        /// The loopVariableInputs must not have outgoing edges.
        ///loopVariableInput.outgoing->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Input_edges(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_input_edgesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method input_edges registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _input_edgesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _input_edgesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _input_edgesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInput_edgesOperation()
        {
            return ClassInstance.LookupOperation("input_edges");
        }
        
        /// <summary>
        /// The union of the ExecutableNodes in the setupPart, test and bodyPart of a LoopNode must be the same as the subset of nodes contained in the LoopNode (considered as a StructuredActivityNode) that are ExecutableNodes.
        ///setupPart->union(test)->union(bodyPart)=node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->asSet()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Executable_nodes(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_executable_nodesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method executable_nodes registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _executable_nodesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _executable_nodesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _executable_nodesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveExecutable_nodesOperation()
        {
            return ClassInstance.LookupOperation("executable_nodes");
        }
        
        /// <summary>
        /// The bodyOutput pins are OutputPins on Actions in the body of the LoopNode.
        ///bodyPart.oclAsType(Action).allActions().output->includesAll(bodyOutput)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Body_output_pins(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_body_output_pinsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method body_output_pins registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _body_output_pinsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _body_output_pinsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _body_output_pinsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBody_output_pinsOperation()
        {
            return ClassInstance.LookupOperation("body_output_pins");
        }
        
        /// <summary>
        /// The test and body parts of a ConditionalNode must be disjoint with each other.
        ///setupPart->intersection(test)->isEmpty() and
        ///setupPart->intersection(bodyPart)->isEmpty() and
        ///test->intersection(bodyPart)->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Setup_test_and_body(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_setup_test_and_bodyOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setup_test_and_body registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setup_test_and_bodyOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setup_test_and_bodyOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setup_test_and_bodyOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetup_test_and_bodyOperation()
        {
            return ClassInstance.LookupOperation("setup_test_and_body");
        }
        
        /// <summary>
        /// A LoopNode must have the same number of bodyOutput Pins as loopVariables, and each bodyOutput Pin must be compatible with the corresponding loopVariable (by positional order) in type, multiplicity, ordering and uniqueness.
        ///bodyOutput->size()=loopVariable->size() and
        ///Sequence{1..loopVariable->size()}->forAll(i |
        ///	bodyOutput->at(i).type.conformsTo(loopVariable->at(i).type) and
        ///	bodyOutput->at(i).isOrdered = loopVariable->at(i).isOrdered and
        ///	bodyOutput->at(i).isUnique = loopVariable->at(i).isUnique and
        ///	loopVariable->at(i).includesMultiplicity(bodyOutput->at(i)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Matching_output_pins(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_matching_output_pinsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method matching_output_pins registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _matching_output_pinsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _matching_output_pinsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _matching_output_pinsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMatching_output_pinsOperation()
        {
            return ClassInstance.LookupOperation("matching_output_pins");
        }
        
        /// <summary>
        /// A LoopNode must have the same number of loopVariableInputs and loopVariables, and they must match in type, uniqueness and multiplicity.
        ///loopVariableInput->size()=loopVariable->size() and
        ///loopVariableInput.type=loopVariable.type and
        ///loopVariableInput.isUnique=loopVariable.isUnique and
        ///loopVariableInput.lower=loopVariable.lower and
        ///loopVariableInput.upper=loopVariable.upper
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Matching_loop_variables(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_matching_loop_variablesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method matching_loop_variables registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _matching_loop_variablesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _matching_loop_variablesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _matching_loop_variablesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMatching_loop_variablesOperation()
        {
            return ClassInstance.LookupOperation("matching_loop_variables");
        }
        
        /// <summary>
        /// A LoopNode must have the same number of result OutputPins and loopVariables, and they must match in type, uniqueness and multiplicity.
        ///result->size()=loopVariable->size() and
        ///result.type=loopVariable.type and
        ///result.isUnique=loopVariable.isUnique and
        ///result.lower=loopVariable.lower and
        ///result.upper=loopVariable.upper
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Matching_result_pins(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_matching_result_pinsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method matching_result_pins registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _matching_result_pinsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _matching_result_pinsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _matching_result_pinsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMatching_result_pinsOperation()
        {
            return ClassInstance.LookupOperation("matching_result_pins");
        }
        
        /// <summary>
        /// All ActivityEdges outgoing from loopVariable OutputPins must have targets within the LoopNode.
        ///allOwnedNodes()->includesAll(loopVariable.outgoing.target)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Loop_variable_outgoing(object diagnostics, object context)
        {
            System.Func<ILoopNode, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ILoopNode, object, object, bool>>(_loop_variable_outgoingOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method loop_variable_outgoing registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _loop_variable_outgoingOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _loop_variable_outgoingOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _loop_variable_outgoingOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveLoop_variable_outgoingOperation()
        {
            return ClassInstance.LookupOperation("loop_variable_outgoing");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsTestedFirstAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("isTestedFirst")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBodyOutputReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("bodyOutput")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the BodyOutput property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyOutputCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("BodyOutput", e, _bodyOutputReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the BodyOutput property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyOutputCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("BodyOutput", e, _bodyOutputReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBodyPartReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("bodyPart")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the BodyPart property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyPartCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("BodyPart", e, _bodyPartReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the BodyPart property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyPartCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("BodyPart", e, _bodyPartReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDeciderReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("decider")));
        }
        
        /// <summary>
        /// Handles the event that the Decider property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDecider(object sender, System.EventArgs eventArgs)
        {
            this.Decider = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveLoopVariableReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("loopVariable")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the LoopVariable property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LoopVariableCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("LoopVariable", e, _loopVariableReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the LoopVariable property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LoopVariableCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("LoopVariable", e, _loopVariableReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveLoopVariableInputReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("loopVariableInput")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the LoopVariableInput property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LoopVariableInputCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("LoopVariableInput", e, _loopVariableInputReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the LoopVariableInput property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LoopVariableInputCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("LoopVariableInput", e, _loopVariableInputReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveResultReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("result")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Result property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ResultCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Result", e, _resultReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Result property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ResultCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Result", e, _resultReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSetupPartReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("setupPart")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the SetupPart property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SetupPartCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("SetupPart", e, _setupPartReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the SetupPart property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SetupPartCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("SetupPart", e, _setupPartReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTestReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.LoopNode.ClassInstance)).Resolve("test")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Test property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TestCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Test", e, _testReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Test property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TestCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Test", e, _testReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int loopVariableIndex = ModelHelper.IndexOfReference(this.LoopVariable, element);
            if ((loopVariableIndex != -1))
            {
                return ModelHelper.CreatePath("loopVariable", loopVariableIndex);
            }
            int loopVariableInputIndex = ModelHelper.IndexOfReference(this.LoopVariableInput, element);
            if ((loopVariableInputIndex != -1))
            {
                return ModelHelper.CreatePath("loopVariableInput", loopVariableInputIndex);
            }
            int resultIndex = ModelHelper.IndexOfReference(this.Result, element);
            if ((resultIndex != -1))
            {
                return ModelHelper.CreatePath("result", resultIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BODYOUTPUT"))
            {
                if ((index < this.BodyOutput.Count))
                {
                    return this.BodyOutput[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "DECIDER"))
            {
                return this.Decider;
            }
            if ((reference == "LOOPVARIABLE"))
            {
                if ((index < this.LoopVariable.Count))
                {
                    return this.LoopVariable[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "LOOPVARIABLEINPUT"))
            {
                if ((index < this.LoopVariableInput.Count))
                {
                    return this.LoopVariableInput[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "RESULT"))
            {
                if ((index < this.Result.Count))
                {
                    return this.Result[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISTESTEDFIRST"))
            {
                return this.IsTestedFirst;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "BODYOUTPUT"))
            {
                return this._bodyOutput;
            }
            if ((feature == "BODYPART"))
            {
                return this._bodyPart;
            }
            if ((feature == "LOOPVARIABLE"))
            {
                return this._loopVariable;
            }
            if ((feature == "LOOPVARIABLEINPUT"))
            {
                return this._loopVariableInput;
            }
            if ((feature == "RESULT"))
            {
                return this._result;
            }
            if ((feature == "SETUPPART"))
            {
                return this._setupPart;
            }
            if ((feature == "TEST"))
            {
                return this._test;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "DECIDER"))
            {
                this.Decider = ((IOutputPin)(value));
                return;
            }
            if ((feature == "ISTESTEDFIRST"))
            {
                this.IsTestedFirst = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISTESTEDFIRST"))
            {
                return Observable.Box(new IsTestedFirstProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "DECIDER"))
            {
                return new DeciderProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._loopVariable))
            {
                return "loopVariable";
            }
            if ((container == this._loopVariableInput))
            {
                return "loopVariableInput";
            }
            if ((container == this._result))
            {
                return "result";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//LoopNode")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the LoopNode class
        /// </summary>
        public class LoopNodeChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private LoopNode _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public LoopNodeChildrenCollection(LoopNode parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.LoopVariable.Count);
                    count = (count + this._parent.LoopVariableInput.Count);
                    count = (count + this._parent.Result.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.LoopVariable.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.LoopVariableInput.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Result.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.LoopVariable.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.LoopVariableInput.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Result.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IOutputPin loopVariableCasted = item.As<IOutputPin>();
                if ((loopVariableCasted != null))
                {
                    this._parent.LoopVariable.Add(loopVariableCasted);
                }
                IInputPin loopVariableInputCasted = item.As<IInputPin>();
                if ((loopVariableInputCasted != null))
                {
                    this._parent.LoopVariableInput.Add(loopVariableInputCasted);
                }
                IOutputPin resultCasted = item.As<IOutputPin>();
                if ((resultCasted != null))
                {
                    this._parent.Result.Add(resultCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.LoopVariable.Clear();
                this._parent.LoopVariableInput.Clear();
                this._parent.Result.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.LoopVariable.Contains(item))
                {
                    return true;
                }
                if (this._parent.LoopVariableInput.Contains(item))
                {
                    return true;
                }
                if (this._parent.Result.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> loopVariableEnumerator = this._parent.LoopVariable.GetEnumerator();
                try
                {
                    for (
                    ; loopVariableEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = loopVariableEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    loopVariableEnumerator.Dispose();
                }
                IEnumerator<IModelElement> loopVariableInputEnumerator = this._parent.LoopVariableInput.GetEnumerator();
                try
                {
                    for (
                    ; loopVariableInputEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = loopVariableInputEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    loopVariableInputEnumerator.Dispose();
                }
                IEnumerator<IModelElement> resultEnumerator = this._parent.Result.GetEnumerator();
                try
                {
                    for (
                    ; resultEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = resultEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    resultEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IOutputPin outputPinItem = item.As<IOutputPin>();
                if (((outputPinItem != null) 
                            && this._parent.LoopVariable.Remove(outputPinItem)))
                {
                    return true;
                }
                IInputPin inputPinItem = item.As<IInputPin>();
                if (((inputPinItem != null) 
                            && this._parent.LoopVariableInput.Remove(inputPinItem)))
                {
                    return true;
                }
                if (((outputPinItem != null) 
                            && this._parent.Result.Remove(outputPinItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.LoopVariable).Concat(this._parent.LoopVariableInput).Concat(this._parent.Result).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the LoopNode class
        /// </summary>
        public class LoopNodeReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private LoopNode _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public LoopNodeReferencedElementsCollection(LoopNode parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.BodyOutput.Count);
                    count = (count + this._parent.BodyPart.Count);
                    if ((this._parent.Decider != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.LoopVariable.Count);
                    count = (count + this._parent.LoopVariableInput.Count);
                    count = (count + this._parent.Result.Count);
                    count = (count + this._parent.SetupPart.Count);
                    count = (count + this._parent.Test.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BodyOutput.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BodyPart.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.LoopVariable.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.LoopVariableInput.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Result.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.SetupPart.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Test.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BodyOutput.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BodyPart.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.LoopVariable.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.LoopVariableInput.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Result.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.SetupPart.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Test.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IOutputPin bodyOutputCasted = item.As<IOutputPin>();
                if ((bodyOutputCasted != null))
                {
                    this._parent.BodyOutput.Add(bodyOutputCasted);
                }
                IExecutableNode bodyPartCasted = item.As<IExecutableNode>();
                if ((bodyPartCasted != null))
                {
                    this._parent.BodyPart.Add(bodyPartCasted);
                }
                if ((this._parent.Decider == null))
                {
                    IOutputPin deciderCasted = item.As<IOutputPin>();
                    if ((deciderCasted != null))
                    {
                        this._parent.Decider = deciderCasted;
                        return;
                    }
                }
                IOutputPin loopVariableCasted = item.As<IOutputPin>();
                if ((loopVariableCasted != null))
                {
                    this._parent.LoopVariable.Add(loopVariableCasted);
                }
                IInputPin loopVariableInputCasted = item.As<IInputPin>();
                if ((loopVariableInputCasted != null))
                {
                    this._parent.LoopVariableInput.Add(loopVariableInputCasted);
                }
                IOutputPin resultCasted = item.As<IOutputPin>();
                if ((resultCasted != null))
                {
                    this._parent.Result.Add(resultCasted);
                }
                IExecutableNode setupPartCasted = item.As<IExecutableNode>();
                if ((setupPartCasted != null))
                {
                    this._parent.SetupPart.Add(setupPartCasted);
                }
                IExecutableNode testCasted = item.As<IExecutableNode>();
                if ((testCasted != null))
                {
                    this._parent.Test.Add(testCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.BodyOutput.Clear();
                this._parent.BodyPart.Clear();
                this._parent.Decider = null;
                this._parent.LoopVariable.Clear();
                this._parent.LoopVariableInput.Clear();
                this._parent.Result.Clear();
                this._parent.SetupPart.Clear();
                this._parent.Test.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.BodyOutput.Contains(item))
                {
                    return true;
                }
                if (this._parent.BodyPart.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Decider))
                {
                    return true;
                }
                if (this._parent.LoopVariable.Contains(item))
                {
                    return true;
                }
                if (this._parent.LoopVariableInput.Contains(item))
                {
                    return true;
                }
                if (this._parent.Result.Contains(item))
                {
                    return true;
                }
                if (this._parent.SetupPart.Contains(item))
                {
                    return true;
                }
                if (this._parent.Test.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> bodyOutputEnumerator = this._parent.BodyOutput.GetEnumerator();
                try
                {
                    for (
                    ; bodyOutputEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = bodyOutputEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    bodyOutputEnumerator.Dispose();
                }
                IEnumerator<IModelElement> bodyPartEnumerator = this._parent.BodyPart.GetEnumerator();
                try
                {
                    for (
                    ; bodyPartEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = bodyPartEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    bodyPartEnumerator.Dispose();
                }
                if ((this._parent.Decider != null))
                {
                    array[arrayIndex] = this._parent.Decider;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> loopVariableEnumerator = this._parent.LoopVariable.GetEnumerator();
                try
                {
                    for (
                    ; loopVariableEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = loopVariableEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    loopVariableEnumerator.Dispose();
                }
                IEnumerator<IModelElement> loopVariableInputEnumerator = this._parent.LoopVariableInput.GetEnumerator();
                try
                {
                    for (
                    ; loopVariableInputEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = loopVariableInputEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    loopVariableInputEnumerator.Dispose();
                }
                IEnumerator<IModelElement> resultEnumerator = this._parent.Result.GetEnumerator();
                try
                {
                    for (
                    ; resultEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = resultEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    resultEnumerator.Dispose();
                }
                IEnumerator<IModelElement> setupPartEnumerator = this._parent.SetupPart.GetEnumerator();
                try
                {
                    for (
                    ; setupPartEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = setupPartEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    setupPartEnumerator.Dispose();
                }
                IEnumerator<IModelElement> testEnumerator = this._parent.Test.GetEnumerator();
                try
                {
                    for (
                    ; testEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = testEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    testEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IOutputPin outputPinItem = item.As<IOutputPin>();
                if (((outputPinItem != null) 
                            && this._parent.BodyOutput.Remove(outputPinItem)))
                {
                    return true;
                }
                IExecutableNode executableNodeItem = item.As<IExecutableNode>();
                if (((executableNodeItem != null) 
                            && this._parent.BodyPart.Remove(executableNodeItem)))
                {
                    return true;
                }
                if ((this._parent.Decider == item))
                {
                    this._parent.Decider = null;
                    return true;
                }
                if (((outputPinItem != null) 
                            && this._parent.LoopVariable.Remove(outputPinItem)))
                {
                    return true;
                }
                IInputPin inputPinItem = item.As<IInputPin>();
                if (((inputPinItem != null) 
                            && this._parent.LoopVariableInput.Remove(inputPinItem)))
                {
                    return true;
                }
                if (((outputPinItem != null) 
                            && this._parent.Result.Remove(outputPinItem)))
                {
                    return true;
                }
                if (((executableNodeItem != null) 
                            && this._parent.SetupPart.Remove(executableNodeItem)))
                {
                    return true;
                }
                if (((executableNodeItem != null) 
                            && this._parent.Test.Remove(executableNodeItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.BodyOutput).Concat(this._parent.BodyPart).Concat(this._parent.Decider).Concat(this._parent.LoopVariable).Concat(this._parent.LoopVariableInput).Concat(this._parent.Result).Concat(this._parent.SetupPart).Concat(this._parent.Test).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isTestedFirst property
        /// </summary>
        private sealed class IsTestedFirstProxy : ModelPropertyChange<ILoopNode, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsTestedFirstProxy(ILoopNode modelElement) : 
                    base(modelElement, "isTestedFirst")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsTestedFirst;
                }
                set
                {
                    this.ModelElement.IsTestedFirst = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the decider property
        /// </summary>
        private sealed class DeciderProxy : ModelPropertyChange<ILoopNode, IOutputPin>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DeciderProxy(ILoopNode modelElement) : 
                    base(modelElement, "decider")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IOutputPin Value
            {
                get
                {
                    return this.ModelElement.Decider;
                }
                set
                {
                    this.ModelElement.Decider = value;
                }
            }
        }
    }
}

