//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for Component
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Component))]
    [XmlDefaultImplementationTypeAttribute(typeof(Component))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Component")]
    public interface IComponent : IModelElement, NMF.Interop.Uml.IClass
    {
        
        /// <summary>
        /// If true, the Component is defined at design-time, but at run-time (or execution-time) an object specified by the Component does not exist, that is, the Component is instantiated indirectly, through the instantiation of its realizing Classifiers or parts.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DefaultValueAttribute(true)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isIndirectlyInstantiated")]
        [DescriptionAttribute(@"If true, the Component is defined at design-time, but at run-time (or execution-time) an object specified by the Component does not exist, that is, the Component is instantiated indirectly, through the instantiation of its realizing Classifiers or parts.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Component")]
        [XmlElementNameAttribute("isIndirectlyInstantiated")]
        [XmlAttributeAttribute(true)]
        bool IsIndirectlyInstantiated
        {
            get;
            set;
        }
        
        /// <summary>
        /// The set of PackageableElements that a Component owns. In the namespace of a Component, all model elements that are involved in or related to its definition may be owned or imported explicitly. These may include e.g., Classes, Interfaces, Components, Packages, UseCases, Dependencies (e.g., mappings), and Artifacts.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packagedElement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IPackageableElement> PackagedElement
        {
            get;
        }
        
        /// <summary>
        /// The set of Realizations owned by the Component. Realizations reference the Classifiers of which the Component is an abstraction; i.e., that realize its behavior.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("realization")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("abstraction")]
        [ConstantAttribute()]
        IOrderedSetExpression<IComponentRealization> Realization
        {
            get;
        }
        
        /// <summary>
        /// A Component cannot nest Classifiers.
        ///nestedClassifier->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool No_nested_classifiers(object diagnostics, object context);
        
        /// <summary>
        /// A Component nested in a Class cannot have any packaged elements.
        ///nestingClass <> null implies packagedElement->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool No_packaged_elements(object diagnostics, object context);
        
        /// <summary>
        /// Creates a(n) (abstract) class with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new class, or null.</param>
        /// <param name="isAbstract">Whether the new class should be abstract.</param>
        NMF.Interop.Uml.IClass CreateOwnedClass(string name, bool isAbstract);
        
        /// <summary>
        /// Creates a enumeration with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new enumeration, or null.</param>
        NMF.Interop.Uml.IEnumeration CreateOwnedEnumeration(string name);
        
        /// <summary>
        /// Creates an interface with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new interface, or null.</param>
        IInterface CreateOwnedInterface(string name);
        
        /// <summary>
        /// Creates a primitive type with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new primitive type, or null.</param>
        NMF.Interop.Uml.IPrimitiveType CreateOwnedPrimitiveType(string name);
        
        /// <summary>
        /// Derivation for Component::/provided
        ///result = (let 	ris : Set(Interface) = allRealizedInterfaces(),
        ///        realizingClassifiers : Set(Classifier) =  self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        ///        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),
        ///        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allRealizedInterfaces())),
        ///        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),
        ///        providedByPorts : Set(Interface) = ports.provided->asSet()
        ///in     ris->union(realizingClassifierInterfaces) ->union(providedByPorts)->asSet())
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        ISetExpression<IInterface> GetProvideds();
        
        /// <summary>
        /// Derivation for Component::/required
        ///result = (let 	uis : Set(Interface) = allUsedInterfaces(),
        ///        realizingClassifiers : Set(Classifier) = self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        ///        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),
        ///        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allUsedInterfaces())),
        ///        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),
        ///        usedByPorts : Set(Interface) = ports.required->asSet()
        ///in	    uis->union(realizingClassifierInterfaces)->union(usedByPorts)->asSet()
        ///)
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        ISetExpression<IInterface> GetRequireds();
    }
}

