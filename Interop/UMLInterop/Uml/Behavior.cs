//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// Behavior is a specification of how its context BehavioredClassifier changes state over time. This specification may be either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution.
    ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Behavior")]
    [DebuggerDisplayAttribute("Behavior {Name}")]
    public abstract partial class Behavior : RedefinableElement, IBehavior, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _most_one_behaviorOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMost_one_behaviorOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameters_matchOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameters_matchOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _feature_of_context_classifierOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveFeature_of_context_classifierOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getContextOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetContextOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _behavioredClassifierOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBehavioredClassifierOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inputParametersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInputParametersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _outputParametersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOutputParametersOperation);
        
        /// <summary>
        /// The backing field for the IsReentrant property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private Nullable<bool> _isReentrant = true;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isReentrantAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsReentrantAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _specificationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSpecificationReference);
        
        /// <summary>
        /// The backing field for the Specification property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavioralFeature _specification;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedParameterReference);
        
        /// <summary>
        /// The backing field for the OwnedParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<NMF.Interop.Uml.IParameter> _ownedParameter;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedParameterSetReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedParameterSetReference);
        
        /// <summary>
        /// The backing field for the OwnedParameterSet property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IParameterSet> _ownedParameterSet;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _postconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePostconditionReference);
        
        /// <summary>
        /// The backing field for the Postcondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConstraint> _postcondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _preconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePreconditionReference);
        
        /// <summary>
        /// The backing field for the Precondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConstraint> _precondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedBehaviorReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedBehaviorReference);
        
        /// <summary>
        /// The backing field for the RedefinedBehavior property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IBehavior> _redefinedBehavior;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _passive_classOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrievePassive_classOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedOperationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedOperationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isMetaclassOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsMetaclassOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getExtensionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetExtensionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getSuperClassesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetSuperClassesOperation);
        
        /// <summary>
        /// The backing field for the IsActive property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isActive = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isActiveAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsActiveAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedOperationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedOperationReference);
        
        /// <summary>
        /// The backing field for the OwnedOperation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassOwnedOperationCollection _ownedOperation;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _nestedClassifierReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveNestedClassifierReference);
        
        /// <summary>
        /// The backing field for the NestedClassifier property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IClassifier> _nestedClassifier;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedReceptionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedReceptionReference);
        
        /// <summary>
        /// The backing field for the OwnedReception property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IReception> _ownedReception;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedPortsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedPortsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedPortReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedPortReference);
        
        /// <summary>
        /// The backing field for the OwnedPort property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IPort> _ownedPort;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedAttributeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedAttributeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getPartsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetPartsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allRolesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllRolesOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedConnectorReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedConnectorReference);
        
        /// <summary>
        /// The backing field for the OwnedConnector property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConnector> _ownedConnector;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _class_behaviorOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveClass_behaviorOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllImplementedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllImplementedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImplementedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImplementedInterfacesOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _classifierBehaviorReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveClassifierBehaviorReference);
        
        /// <summary>
        /// The backing field for the ClassifierBehavior property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _classifierBehavior;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _interfaceRealizationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveInterfaceRealizationReference);
        
        /// <summary>
        /// The backing field for the InterfaceRealization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private BehavioredClassifierInterfaceRealizationCollection _interfaceRealization;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _specialize_typeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSpecialize_typeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _maps_to_generalization_setOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMaps_to_generalization_setOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _non_final_parentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNon_final_parentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _no_cycles_in_generalizationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNo_cycles_in_generalizationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllAttributesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllAttributesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllOperationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllOperationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOperationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOperationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOperationOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOperationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOperationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOperationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allFeaturesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllFeaturesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allParentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllParentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getGeneralsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetGeneralsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _hasVisibilityOfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveHasVisibilityOfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inheritOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInheritOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inheritableMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInheritableMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getInheritedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetInheritedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _maySpecializeTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMaySpecializeTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _directlyRealizedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDirectlyRealizedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _directlyUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDirectlyUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allRealizedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllRealizedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allUsedInterfacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllUsedInterfacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isSubstitutableForOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsSubstitutableForOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allAttributesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllAttributesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allSlottableFeaturesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllSlottableFeaturesOperation);
        
        /// <summary>
        /// The backing field for the IsAbstract property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isAbstract = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isAbstractAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsAbstractAttribute);
        
        /// <summary>
        /// The backing field for the IsFinalSpecialization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isFinalSpecialization = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isFinalSpecializationAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsFinalSpecializationAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _generalizationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveGeneralizationReference);
        
        /// <summary>
        /// The backing field for the Generalization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierGeneralizationCollection _generalization;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _powertypeExtentReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePowertypeExtentReference);
        
        /// <summary>
        /// The backing field for the PowertypeExtent property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierPowertypeExtentCollection _powertypeExtent;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedUseCaseReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedUseCaseReference);
        
        /// <summary>
        /// The backing field for the OwnedUseCase property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IUseCase> _ownedUseCase;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _useCaseReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveUseCaseReference);
        
        /// <summary>
        /// The backing field for the UseCase property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierUseCaseCollection _useCase;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _representationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRepresentationReference);
        
        /// <summary>
        /// The backing field for the Representation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ICollaborationUse _representation;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _substitutionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSubstitutionReference);
        
        /// <summary>
        /// The backing field for the Substitution property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClassifierSubstitutionCollection _substitution;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _members_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembers_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_selfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_selfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_ownedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_ownedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createElementImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateElementImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createPackageImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreatePackageImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedElementsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _excludeCollisionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveExcludeCollisionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNamesOfMemberOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNamesOfMemberOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _importMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveImportMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _membersAreDistinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembersAreDistinguishableOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _elementImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveElementImportReference);
        
        /// <summary>
        /// The backing field for the ElementImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespaceElementImportCollection _elementImport;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageImportReference);
        
        /// <summary>
        /// The backing field for the PackageImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespacePackageImportCollection _packageImport;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createAssociationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateAssociationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAssociationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAssociationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _conformsToOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveConformsToOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageReference);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _namespace_needs_visibilityOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNamespace_needs_visibilityOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompatibleWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompatibleWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateParameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateParameterOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningTemplateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the OwningTemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _owningTemplateParameter;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameterableElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameterableElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateBindingReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateBindingReference);
        
        /// <summary>
        /// The backing field for the TemplateBinding property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TemplateableElementTemplateBindingCollection _templateBinding;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTemplateSignatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTemplateSignatureReference);
        
        /// <summary>
        /// The backing field for the OwnedTemplateSignature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateSignature _ownedTemplateSignature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Behavior()
        {
            this._ownedParameter = new ObservableCompositionOrderedSet<NMF.Interop.Uml.IParameter>(this);
            this._ownedParameter.CollectionChanging += this.OwnedParameterCollectionChanging;
            this._ownedParameter.CollectionChanged += this.OwnedParameterCollectionChanged;
            this._ownedParameterSet = new ObservableCompositionOrderedSet<IParameterSet>(this);
            this._ownedParameterSet.CollectionChanging += this.OwnedParameterSetCollectionChanging;
            this._ownedParameterSet.CollectionChanged += this.OwnedParameterSetCollectionChanged;
            this._postcondition = new ObservableCompositionOrderedSet<IConstraint>(this);
            this._postcondition.CollectionChanging += this.PostconditionCollectionChanging;
            this._postcondition.CollectionChanged += this.PostconditionCollectionChanged;
            this._precondition = new ObservableCompositionOrderedSet<IConstraint>(this);
            this._precondition.CollectionChanging += this.PreconditionCollectionChanging;
            this._precondition.CollectionChanged += this.PreconditionCollectionChanged;
            this._redefinedBehavior = new ObservableAssociationSet<IBehavior>();
            this._redefinedBehavior.CollectionChanging += this.RedefinedBehaviorCollectionChanging;
            this._redefinedBehavior.CollectionChanged += this.RedefinedBehaviorCollectionChanged;
            this._ownedOperation = new ClassOwnedOperationCollection(this);
            this._ownedOperation.CollectionChanging += this.OwnedOperationCollectionChanging;
            this._ownedOperation.CollectionChanged += this.OwnedOperationCollectionChanged;
            this._nestedClassifier = new ObservableCompositionOrderedSet<IClassifier>(this);
            this._nestedClassifier.CollectionChanging += this.NestedClassifierCollectionChanging;
            this._nestedClassifier.CollectionChanged += this.NestedClassifierCollectionChanged;
            this._ownedReception = new ObservableCompositionOrderedSet<IReception>(this);
            this._ownedReception.CollectionChanging += this.OwnedReceptionCollectionChanging;
            this._ownedReception.CollectionChanged += this.OwnedReceptionCollectionChanged;
            this._ownedPort = new ObservableCompositionOrderedSet<IPort>(this);
            this._ownedPort.CollectionChanging += this.OwnedPortCollectionChanging;
            this._ownedPort.CollectionChanged += this.OwnedPortCollectionChanged;
            this._ownedConnector = new ObservableCompositionOrderedSet<IConnector>(this);
            this._ownedConnector.CollectionChanging += this.OwnedConnectorCollectionChanging;
            this._ownedConnector.CollectionChanged += this.OwnedConnectorCollectionChanged;
            this._interfaceRealization = new BehavioredClassifierInterfaceRealizationCollection(this);
            this._interfaceRealization.CollectionChanging += this.InterfaceRealizationCollectionChanging;
            this._interfaceRealization.CollectionChanged += this.InterfaceRealizationCollectionChanged;
            this._generalization = new ClassifierGeneralizationCollection(this);
            this._generalization.CollectionChanging += this.GeneralizationCollectionChanging;
            this._generalization.CollectionChanged += this.GeneralizationCollectionChanged;
            this._powertypeExtent = new ClassifierPowertypeExtentCollection(this);
            this._powertypeExtent.CollectionChanging += this.PowertypeExtentCollectionChanging;
            this._powertypeExtent.CollectionChanged += this.PowertypeExtentCollectionChanged;
            this._ownedUseCase = new ObservableCompositionOrderedSet<IUseCase>(this);
            this._ownedUseCase.CollectionChanging += this.OwnedUseCaseCollectionChanging;
            this._ownedUseCase.CollectionChanged += this.OwnedUseCaseCollectionChanged;
            this._useCase = new ClassifierUseCaseCollection(this);
            this._useCase.CollectionChanging += this.UseCaseCollectionChanging;
            this._useCase.CollectionChanged += this.UseCaseCollectionChanged;
            this._substitution = new ClassifierSubstitutionCollection(this);
            this._substitution.CollectionChanging += this.SubstitutionCollectionChanging;
            this._substitution.CollectionChanged += this.SubstitutionCollectionChanged;
            this._elementImport = new NamespaceElementImportCollection(this);
            this._elementImport.CollectionChanging += this.ElementImportCollectionChanging;
            this._elementImport.CollectionChanged += this.ElementImportCollectionChanged;
            this._packageImport = new NamespacePackageImportCollection(this);
            this._packageImport.CollectionChanging += this.PackageImportCollectionChanging;
            this._packageImport.CollectionChanged += this.PackageImportCollectionChanged;
            this._templateBinding = new TemplateableElementTemplateBindingCollection(this);
            this._templateBinding.CollectionChanging += this.TemplateBindingCollectionChanging;
            this._templateBinding.CollectionChanged += this.TemplateBindingCollectionChanged;
        }
        
        /// <summary>
        /// Tells whether the Behavior can be invoked while it is still executing from a previous invocation.
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(true)]
        [DisplayNameAttribute("isReentrant")]
        [DescriptionAttribute("Tells whether the Behavior can be invoked while it is still executing from a prev" +
            "ious invocation.\n<p>From package UML::CommonBehavior.</p>")]
        [CategoryAttribute("Behavior")]
        [XmlElementNameAttribute("isReentrant")]
        [XmlAttributeAttribute(true)]
        public Nullable<bool> IsReentrant
        {
            get
            {
                return this._isReentrant;
            }
            set
            {
                if ((this._isReentrant != value))
                {
                    Nullable<bool> old = this._isReentrant;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsReentrant", e, _isReentrantAttribute);
                    this._isReentrant = value;
                    this.OnPropertyChanged("IsReentrant", e, _isReentrantAttribute);
                }
            }
        }
        
        /// <summary>
        /// Designates a BehavioralFeature that the Behavior implements. The BehavioralFeature must be owned by the BehavioredClassifier that owns the Behavior or be inherited by it. The Parameters of the BehavioralFeature and the implementing Behavior must match. A Behavior does not need to have a specification, in which case it either is the classifierBehavior of a BehavioredClassifier or it can only be invoked by another Behavior of the Classifier.
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("specification")]
        [DescriptionAttribute(@"Designates a BehavioralFeature that the Behavior implements. The BehavioralFeature must be owned by the BehavioredClassifier that owns the Behavior or be inherited by it. The Parameters of the BehavioralFeature and the implementing Behavior must match. A Behavior does not need to have a specification, in which case it either is the classifierBehavior of a BehavioredClassifier or it can only be invoked by another Behavior of the Classifier.
<p>From package UML::CommonBehavior.</p>")]
        [CategoryAttribute("Behavior")]
        [XmlElementNameAttribute("specification")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("method")]
        public IBehavioralFeature Specification
        {
            get
            {
                return this._specification;
            }
            set
            {
                if ((this._specification != value))
                {
                    IBehavioralFeature old = this._specification;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Specification", e, _specificationReference);
                    this._specification = value;
                    if ((old != null))
                    {
                        old.Method.Remove(this);
                        old.Deleted -= this.OnResetSpecification;
                    }
                    if ((value != null))
                    {
                        value.Method.Add(this);
                        value.Deleted += this.OnResetSpecification;
                    }
                    this.OnPropertyChanged("Specification", e, _specificationReference);
                }
            }
        }
        
        /// <summary>
        /// References a list of Parameters to the Behavior which describes the order and type of arguments that can be given when the Behavior is invoked and of the values which will be returned when the Behavior completes its execution.
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedParameter")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<NMF.Interop.Uml.IParameter> OwnedParameter
        {
            get
            {
                return this._ownedParameter;
            }
        }
        
        /// <summary>
        /// The ParameterSets owned by this Behavior.
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedParameterSet")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IParameterSet> OwnedParameterSet
        {
            get
            {
                return this._ownedParameterSet;
            }
        }
        
        /// <summary>
        /// An optional set of Constraints specifying what is fulfilled after the execution of the Behavior is completed, if its precondition was fulfilled before its invocation.
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("postcondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConstraint> Postcondition
        {
            get
            {
                return this._postcondition;
            }
        }
        
        /// <summary>
        /// An optional set of Constraints specifying what must be fulfilled before the Behavior is invoked.
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("precondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConstraint> Precondition
        {
            get
            {
                return this._precondition;
            }
        }
        
        /// <summary>
        /// References the Behavior that this Behavior redefines. A subtype of Behavior may redefine any other subtype of Behavior. If the Behavior implements a BehavioralFeature, it replaces the redefined Behavior. If the Behavior is a classifierBehavior, it extends the redefined Behavior.
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedBehavior")]
        [DescriptionAttribute(@"References the Behavior that this Behavior redefines. A subtype of Behavior may redefine any other subtype of Behavior. If the Behavior implements a BehavioralFeature, it replaces the redefined Behavior. If the Behavior is a classifierBehavior, it extends the redefined Behavior.
<p>From package UML::CommonBehavior.</p>")]
        [CategoryAttribute("Behavior")]
        [XmlElementNameAttribute("redefinedBehavior")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IBehavior> RedefinedBehavior
        {
            get
            {
                return this._redefinedBehavior;
            }
        }
        
        IListExpression<IConstraint> NMF.Interop.Uml.INamespace.OwnedRule
        {
            get
            {
                return new BehaviorOwnedRuleCollection(this);
            }
        }
        
        ICollectionExpression<IClassifier> IClassifier.RedefinedClassifier
        {
            get
            {
                return new BehaviorRedefinedClassifierCollection(this);
            }
        }
        
        /// <summary>
        /// Determines whether an object specified by this Class is active or not. If true, then the owning Class is referred to as an active Class. If false, then such a Class is referred to as a passive Class.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isActive")]
        [DescriptionAttribute("Determines whether an object specified by this Class is active or not. If true, t" +
            "hen the owning Class is referred to as an active Class. If false, then such a Cl" +
            "ass is referred to as a passive Class.\n<p>From package UML::StructuredClassifier" +
            "s.</p>")]
        [CategoryAttribute("Class")]
        [XmlElementNameAttribute("isActive")]
        [XmlAttributeAttribute(true)]
        public bool IsActive
        {
            get
            {
                return this._isActive;
            }
            set
            {
                if ((this._isActive != value))
                {
                    bool old = this._isActive;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsActive", e, _isActiveAttribute);
                    this._isActive = value;
                    this.OnPropertyChanged("IsActive", e, _isActiveAttribute);
                }
            }
        }
        
        /// <summary>
        /// The Operations owned by the Class.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedOperation")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("class")]
        [ConstantAttribute()]
        public IOrderedSetExpression<NMF.Interop.Uml.IOperation> OwnedOperation
        {
            get
            {
                return this._ownedOperation;
            }
        }
        
        /// <summary>
        /// The Classifiers owned by the Class that are not ownedBehaviors.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("nestedClassifier")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IClassifier> NestedClassifier
        {
            get
            {
                return this._nestedClassifier;
            }
        }
        
        /// <summary>
        /// The Receptions owned by the Class.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedReception")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IReception> OwnedReception
        {
            get
            {
                return this._ownedReception;
            }
        }
        
        IListExpression<ICollaborationUse> IClassifier.CollaborationUse
        {
            get
            {
                return new ClassCollaborationUseCollection(this);
            }
        }
        
        ITemplateParameter IParameterableElement.TemplateParameter
        {
            get
            {
                NMF.Interop.Uml.IClass _this = this;
                return _this.OwningTemplateParameter;
            }
            set
            {
                NMF.Interop.Uml.IClass _this = this;
                _this.OwningTemplateParameter = value;
            }
        }
        
        /// <summary>
        /// The Ports owned by the EncapsulatedClassifier.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedPort")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPort> OwnedPort
        {
            get
            {
                return this._ownedPort;
            }
        }
        
        IListExpression<IProperty> IStructuredClassifier.OwnedAttribute
        {
            get
            {
                return new EncapsulatedClassifierOwnedAttributeCollection(this);
            }
        }
        
        /// <summary>
        /// The connectors owned by the StructuredClassifier.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedConnector")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConnector> OwnedConnector
        {
            get
            {
                return this._ownedConnector;
            }
        }
        
        /// <summary>
        /// A Behavior that specifies the behavior of the BehavioredClassifier itself.
        ///&lt;p&gt;From package UML::SimpleClassifiers.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("classifierBehavior")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior ClassifierBehavior
        {
            get
            {
                return this._classifierBehavior;
            }
            set
            {
                if ((this._classifierBehavior != value))
                {
                    IBehavior old = this._classifierBehavior;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ClassifierBehavior", e, _classifierBehaviorReference);
                    this._classifierBehavior = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetClassifierBehavior;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetClassifierBehavior;
                    }
                    this.OnPropertyChanged("ClassifierBehavior", e, _classifierBehaviorReference);
                }
            }
        }
        
        /// <summary>
        /// The set of InterfaceRealizations owned by the BehavioredClassifier. Interface realizations reference the Interfaces of which the BehavioredClassifier is an implementation.
        ///&lt;p&gt;From package UML::SimpleClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("interfaceRealization")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("implementingClassifier")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IInterfaceRealization> InterfaceRealization
        {
            get
            {
                return this._interfaceRealization;
            }
        }
        
        IListExpression<IBehavior> IBehavioredClassifier.OwnedBehavior
        {
            get
            {
                return new BehavioredClassifierOwnedBehaviorCollection(this);
            }
        }
        
        /// <summary>
        /// If true, the Classifier can only be instantiated by instantiating one of its specializations. An abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations or Generalizations.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isAbstract")]
        [DescriptionAttribute(@"If true, the Classifier can only be instantiated by instantiating one of its specializations. An abstract Classifier is intended to be used by other Classifiers e.g., as the target of Associations or Generalizations.
<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isAbstract")]
        [XmlAttributeAttribute(true)]
        public bool IsAbstract
        {
            get
            {
                return this._isAbstract;
            }
            set
            {
                if ((this._isAbstract != value))
                {
                    bool old = this._isAbstract;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsAbstract", e, _isAbstractAttribute);
                    this._isAbstract = value;
                    this.OnPropertyChanged("IsAbstract", e, _isAbstractAttribute);
                }
            }
        }
        
        /// <summary>
        /// If true, the Classifier cannot be specialized.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isFinalSpecialization")]
        [DescriptionAttribute("If true, the Classifier cannot be specialized.\n<p>From package UML::Classificatio" +
            "n.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("isFinalSpecialization")]
        [XmlAttributeAttribute(true)]
        public bool IsFinalSpecialization
        {
            get
            {
                return this._isFinalSpecialization;
            }
            set
            {
                if ((this._isFinalSpecialization != value))
                {
                    bool old = this._isFinalSpecialization;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsFinalSpecialization", e, _isFinalSpecializationAttribute);
                    this._isFinalSpecialization = value;
                    this.OnPropertyChanged("IsFinalSpecialization", e, _isFinalSpecializationAttribute);
                }
            }
        }
        
        /// <summary>
        /// The Generalization relationships for this Classifier. These Generalizations navigate to more general Classifiers in the generalization hierarchy.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("generalization")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("specific")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IGeneralization> Generalization
        {
            get
            {
                return this._generalization;
            }
        }
        
        /// <summary>
        /// The GeneralizationSet of which this Classifier is a power type.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("powertypeExtent")]
        [DescriptionAttribute("The GeneralizationSet of which this Classifier is a power type.\n<p>From package U" +
            "ML::Classification.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("powertypeExtent")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("powertype")]
        [ConstantAttribute()]
        public ISetExpression<IGeneralizationSet> PowertypeExtent
        {
            get
            {
                return this._powertypeExtent;
            }
        }
        
        /// <summary>
        /// The UseCases owned by this classifier.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedUseCase")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IUseCase> OwnedUseCase
        {
            get
            {
                return this._ownedUseCase;
            }
        }
        
        /// <summary>
        /// The set of UseCases for which this Classifier is the subject.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("useCase")]
        [DescriptionAttribute("The set of UseCases for which this Classifier is the subject.\n<p>From package UML" +
            "::Classification.</p>")]
        [CategoryAttribute("Classifier")]
        [XmlElementNameAttribute("useCase")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("subject")]
        [ConstantAttribute()]
        public ISetExpression<IUseCase> UseCase
        {
            get
            {
                return this._useCase;
            }
        }
        
        /// <summary>
        /// A CollaborationUse which indicates the Collaboration that represents this Classifier.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("representation")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ICollaborationUse Representation
        {
            get
            {
                return this._representation;
            }
            set
            {
                if ((this._representation != value))
                {
                    ICollaborationUse old = this._representation;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Representation", e, _representationReference);
                    this._representation = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetRepresentation;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetRepresentation;
                    }
                    this.OnPropertyChanged("Representation", e, _representationReference);
                }
            }
        }
        
        /// <summary>
        /// The Substitutions owned by this Classifier.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("substitution")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("substitutingClassifier")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ISubstitution> Substitution
        {
            get
            {
                return this._substitution;
            }
        }
        
        /// <summary>
        /// References the ElementImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("elementImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IElementImport> ElementImport
        {
            get
            {
                return this._elementImport;
            }
        }
        
        /// <summary>
        /// References the PackageImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IPackageImport> PackageImport
        {
            get
            {
                return this._packageImport;
            }
        }
        
        /// <summary>
        /// Specifies the owning Package of this Type, if any.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("package")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedType")]
        public IPackage Package
        {
            get
            {
                return ModelHelper.CastAs<IPackage>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// The formal TemplateParameter that owns this ParameterableElement.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("owningTemplateParameter")]
        [DescriptionAttribute("The formal TemplateParameter that owns this ParameterableElement.\n<p>From package" +
            " UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("owningTemplateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedParameteredElement")]
        public ITemplateParameter OwningTemplateParameter
        {
            get
            {
                return this._owningTemplateParameter;
            }
            set
            {
                if ((this._owningTemplateParameter != value))
                {
                    ITemplateParameter old = this._owningTemplateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwningTemplateParameter", e, _owningTemplateParameterReference);
                    this._owningTemplateParameter = value;
                    if ((old != null))
                    {
                        old.OwnedParameteredElement = null;
                        old.Deleted -= this.OnResetOwningTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.OwnedParameteredElement = this;
                        value.Deleted += this.OnResetOwningTemplateParameter;
                    }
                    this.OnPropertyChanged("OwningTemplateParameter", e, _owningTemplateParameterReference);
                }
            }
        }
        
        /// <summary>
        /// The optional TemplateBindings from this TemplateableElement to one or more templates.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("templateBinding")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("boundElement")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITemplateBinding> TemplateBinding
        {
            get
            {
                return this._templateBinding;
            }
        }
        
        /// <summary>
        /// The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a TemplateableElement has a TemplateSignature, then it is a template.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedTemplateSignature")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("template")]
        public ITemplateSignature OwnedTemplateSignature
        {
            get
            {
                return this._ownedTemplateSignature;
            }
            set
            {
                if ((this._ownedTemplateSignature != value))
                {
                    ITemplateSignature old = this._ownedTemplateSignature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                    this._ownedTemplateSignature = value;
                    if ((old != null))
                    {
                        old.Template = null;
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetOwnedTemplateSignature;
                    }
                    if ((value != null))
                    {
                        value.Template = this;
                        value.Parent = this;
                        value.ParentChanged += this.OnResetOwnedTemplateSignature;
                    }
                    this.OnPropertyChanged("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new BehaviorChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new BehaviorReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Behavior")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// There may be at most one Behavior for a given pairing of BehavioredClassifier (as owner of the Behavior) and BehavioralFeature (as specification of the Behavior).
        ///specification &lt;&gt; null implies _&apos;context&apos;.ownedBehavior-&gt;select(specification=self.specification)-&gt;size() = 1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Most_one_behavior(object diagnostics, object context)
        {
            System.Func<IBehavior, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavior, object, object, bool>>(_most_one_behaviorOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method most_one_behavior registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _most_one_behaviorOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _most_one_behaviorOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _most_one_behaviorOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMost_one_behaviorOperation()
        {
            return ClassInstance.LookupOperation("most_one_behavior");
        }
        
        /// <summary>
        /// If a Behavior has a specification BehavioralFeature, then it must have the same number of ownedParameters as its specification. The Behavior Parameters must also &quot;match&quot; the BehavioralParameter Parameters, but the exact requirements for this matching are not formalized.
        ///specification &lt;&gt; null implies ownedParameter-&gt;size() = specification.ownedParameter-&gt;size()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Parameters_match(object diagnostics, object context)
        {
            System.Func<IBehavior, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavior, object, object, bool>>(_parameters_matchOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameters_match registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameters_matchOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameters_matchOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameters_matchOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameters_matchOperation()
        {
            return ClassInstance.LookupOperation("parameters_match");
        }
        
        /// <summary>
        /// The specification BehavioralFeature must be a feature (possibly inherited) of the context BehavioredClassifier of the Behavior.
        ///_&apos;context&apos;.feature-&gt;includes(specification)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Feature_of_context_classifier(object diagnostics, object context)
        {
            System.Func<IBehavior, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavior, object, object, bool>>(_feature_of_context_classifierOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method feature_of_context_classifier registered. U" +
                        "se the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _feature_of_context_classifierOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _feature_of_context_classifierOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _feature_of_context_classifierOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveFeature_of_context_classifierOperation()
        {
            return ClassInstance.LookupOperation("feature_of_context_classifier");
        }
        
        /// <summary>
        /// A Behavior that is directly owned as a nestedClassifier does not have a context. Otherwise, to determine the context of a Behavior, find the first BehavioredClassifier reached by following the chain of owner relationships from the Behavior, if any. If there is such a BehavioredClassifier, then it is the context, unless it is itself a Behavior with a non-empty context, in which case that is also the context for the original Behavior.
        ///result = (if nestingClass &lt;&gt; null then
        ///    null
        ///else
        ///    let b:BehavioredClassifier = self.behavioredClassifier(self.owner) in
        ///    if b.oclIsKindOf(Behavior) and b.oclAsType(Behavior)._&apos;context&apos; &lt;&gt; null then 
        ///        b.oclAsType(Behavior)._&apos;context&apos;
        ///    else 
        ///        b 
        ///    endif
        ///endif
        ///        )
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        public IBehavioredClassifier GetContext()
        {
            System.Func<IBehavior, IBehavioredClassifier> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavior, IBehavioredClassifier>>(_getContextOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getContext registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getContextOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getContextOperation.Value, e));
            IBehavioredClassifier result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getContextOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetContextOperation()
        {
            return ClassInstance.LookupOperation("getContext");
        }
        
        /// <summary>
        /// The first BehavioredClassifier reached by following the chain of owner relationships from the Behavior, if any.
        ///if from.oclIsKindOf(BehavioredClassifier) then
        ///    from.oclAsType(BehavioredClassifier)
        ///else if from.owner = null then
        ///    null
        ///else
        ///    self.behavioredClassifier(from.owner)
        ///endif
        ///endif
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        /// <param name="from"></param>
        public IBehavioredClassifier BehavioredClassifier(IElement from)
        {
            System.Func<IBehavior, IElement, IBehavioredClassifier> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavior, IElement, IBehavioredClassifier>>(_behavioredClassifierOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method behavioredClassifier registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _behavioredClassifierOperation.Value, from);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _behavioredClassifierOperation.Value, e));
            IBehavioredClassifier result = handler.Invoke(this, from);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _behavioredClassifierOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBehavioredClassifierOperation()
        {
            return ClassInstance.LookupOperation("behavioredClassifier");
        }
        
        /// <summary>
        /// The in and inout ownedParameters of the Behavior.
        ///result = (ownedParameter-&gt;select(direction=ParameterDirectionKind::_&apos;in&apos; or direction=ParameterDirectionKind::inout))
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        public IOrderedSetExpression<NMF.Interop.Uml.IParameter> InputParameters()
        {
            System.Func<IBehavior, IOrderedSetExpression<NMF.Interop.Uml.IParameter>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavior, IOrderedSetExpression<NMF.Interop.Uml.IParameter>>>(_inputParametersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inputParameters registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inputParametersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inputParametersOperation.Value, e));
            IOrderedSetExpression<NMF.Interop.Uml.IParameter> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inputParametersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInputParametersOperation()
        {
            return ClassInstance.LookupOperation("inputParameters");
        }
        
        /// <summary>
        /// The out, inout and return ownedParameters.
        ///result = (ownedParameter-&gt;select(direction=ParameterDirectionKind::out or direction=ParameterDirectionKind::inout or direction=ParameterDirectionKind::return))
        ///&lt;p&gt;From package UML::CommonBehavior.&lt;/p&gt;
        /// </summary>
        public IOrderedSetExpression<NMF.Interop.Uml.IParameter> OutputParameters()
        {
            System.Func<IBehavior, IOrderedSetExpression<NMF.Interop.Uml.IParameter>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavior, IOrderedSetExpression<NMF.Interop.Uml.IParameter>>>(_outputParametersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method outputParameters registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _outputParametersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _outputParametersOperation.Value, e));
            IOrderedSetExpression<NMF.Interop.Uml.IParameter> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _outputParametersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOutputParametersOperation()
        {
            return ClassInstance.LookupOperation("outputParameters");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsReentrantAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Behavior.ClassInstance)).Resolve("isReentrant")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSpecificationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Behavior.ClassInstance)).Resolve("specification")));
        }
        
        /// <summary>
        /// Handles the event that the Specification property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSpecification(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Specification))
            {
                this.Specification = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Behavior.ClassInstance)).Resolve("ownedParameter")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedParameter property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedParameter", e, _ownedParameterReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedParameter property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedParameter", e, _ownedParameterReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedParameterSetReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Behavior.ClassInstance)).Resolve("ownedParameterSet")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedParameterSet property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterSetCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedParameterSet", e, _ownedParameterSetReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedParameterSet property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterSetCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedParameterSet", e, _ownedParameterSetReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePostconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Behavior.ClassInstance)).Resolve("postcondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Postcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PostconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Postcondition", e, _postconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Postcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PostconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Postcondition", e, _postconditionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePreconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Behavior.ClassInstance)).Resolve("precondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Precondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PreconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Precondition", e, _preconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Precondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PreconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Precondition", e, _preconditionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedBehaviorReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Behavior.ClassInstance)).Resolve("redefinedBehavior")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedBehavior property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedBehaviorCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedBehavior", e, _redefinedBehaviorReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedBehavior property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedBehaviorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedBehavior", e, _redefinedBehaviorReference);
        }
        
        /// <summary>
        /// Only an active Class may own Receptions and have a classifierBehavior.
        ///not isActive implies (ownedReception-&gt;isEmpty() and classifierBehavior = null)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Passive_class(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.IClass, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IClass, object, object, bool>>(_passive_classOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method passive_class registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _passive_classOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _passive_classOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _passive_classOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrievePassive_classOperation()
        {
            return ClassInstance.LookupOperation("passive_class");
        }
        
        /// <summary>
        /// Creates an operation with the specified name, parameter names, parameter types, and return type (or null) as an owned operation of this class.
        /// </summary>
        /// <param name="name">The name for the new operation, or null.</param>
        /// <param name="parameterNames">The parameter names for the new operation, or null.</param>
        /// <param name="parameterTypes">The parameter types for the new operation, or null.</param>
        /// <param name="returnType">The return type for the new operation, or null.</param>
        public NMF.Interop.Uml.IOperation CreateOwnedOperation(string name, IEnumerable<string> parameterNames, IEnumerable<NMF.Interop.Uml.IType> parameterTypes, NMF.Interop.Uml.IType returnType)
        {
            System.Func<NMF.Interop.Uml.IClass, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, NMF.Interop.Uml.IType, NMF.Interop.Uml.IOperation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IClass, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, NMF.Interop.Uml.IType, NMF.Interop.Uml.IOperation>>(_createOwnedOperationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedOperation registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedOperationOperation.Value, name, parameterNames, parameterTypes, returnType);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedOperationOperation.Value, e));
            NMF.Interop.Uml.IOperation result = handler.Invoke(this, name, parameterNames, parameterTypes, returnType);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedOperationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedOperationOperation()
        {
            return ClassInstance.LookupOperation("createOwnedOperation");
        }
        
        /// <summary>
        /// Determines whether this class is a metaclass.
        /// </summary>
        public bool IsMetaclass()
        {
            System.Func<NMF.Interop.Uml.IClass, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IClass, bool>>(_isMetaclassOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isMetaclass registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isMetaclassOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isMetaclassOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isMetaclassOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsMetaclassOperation()
        {
            return ClassInstance.LookupOperation("isMetaclass");
        }
        
        /// <summary>
        /// Derivation for Class::/extension : Extension
        ///result = (Extension.allInstances()-&gt;select(ext | 
        ///  let endTypes : Sequence(Classifier) = ext.memberEnd-&gt;collect(type.oclAsType(Classifier)) in
        ///  endTypes-&gt;includes(self) or endTypes.allParents()-&gt;includes(self) ))
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IExtension> GetExtensions()
        {
            System.Func<NMF.Interop.Uml.IClass, ISetExpression<NMF.Interop.Uml.IExtension>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IClass, ISetExpression<NMF.Interop.Uml.IExtension>>>(_getExtensionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getExtensions registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getExtensionsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getExtensionsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IExtension> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getExtensionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetExtensionsOperation()
        {
            return ClassInstance.LookupOperation("getExtensions");
        }
        
        /// <summary>
        /// Derivation for Class::/superClass : Class
        ///result = (self.general()-&gt;select(oclIsKindOf(Class))-&gt;collect(oclAsType(Class))-&gt;asSet())
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IClass> GetSuperClasses()
        {
            System.Func<NMF.Interop.Uml.IClass, ISetExpression<NMF.Interop.Uml.IClass>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IClass, ISetExpression<NMF.Interop.Uml.IClass>>>(_getSuperClassesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getSuperClasses registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getSuperClassesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getSuperClassesOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IClass> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getSuperClassesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetSuperClassesOperation()
        {
            return ClassInstance.LookupOperation("getSuperClasses");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsActiveAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Class.ClassInstance)).Resolve("isActive")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedOperationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Class.ClassInstance)).Resolve("ownedOperation")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedOperation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedOperationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedOperation", e, _ownedOperationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedOperation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedOperationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedOperation", e, _ownedOperationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveNestedClassifierReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Class.ClassInstance)).Resolve("nestedClassifier")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the NestedClassifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void NestedClassifierCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("NestedClassifier", e, _nestedClassifierReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the NestedClassifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void NestedClassifierCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("NestedClassifier", e, _nestedClassifierReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedReceptionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Class.ClassInstance)).Resolve("ownedReception")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedReception property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedReceptionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedReception", e, _ownedReceptionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedReception property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedReceptionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedReception", e, _ownedReceptionReference);
        }
        
        /// <summary>
        /// Derivation for EncapsulatedClassifier::/ownedPort : Port
        ///result = (ownedAttribute-&gt;select(oclIsKindOf(Port))-&gt;collect(oclAsType(Port))-&gt;asOrderedSet())
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public IOrderedSetExpression<IPort> GetOwnedPorts()
        {
            System.Func<IEncapsulatedClassifier, IOrderedSetExpression<IPort>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IEncapsulatedClassifier, IOrderedSetExpression<IPort>>>(_getOwnedPortsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedPorts registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedPortsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedPortsOperation.Value, e));
            IOrderedSetExpression<IPort> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedPortsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedPortsOperation()
        {
            return ClassInstance.LookupOperation("getOwnedPorts");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedPortReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.EncapsulatedClassifier.ClassInstance)).Resolve("ownedPort")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedPort property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedPortCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedPort", e, _ownedPortReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedPort property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedPortCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedPort", e, _ownedPortReference);
        }
        
        /// <summary>
        /// Creates a property with the specified name, type, lower bound, and upper bound as an owned attribute of this structured classifier.
        /// </summary>
        /// <param name="name">The name for the new attribute, or null.</param>
        /// <param name="type">The type for the new attribute, or null.</param>
        /// <param name="lower">The lower bound for the new attribute.</param>
        /// <param name="upper">The upper bound for the new attribute.</param>
        public IProperty CreateOwnedAttribute(string name, NMF.Interop.Uml.IType type, int lower, object upper)
        {
            System.Func<IStructuredClassifier, string, NMF.Interop.Uml.IType, int, object, IProperty> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStructuredClassifier, string, NMF.Interop.Uml.IType, int, object, IProperty>>(_createOwnedAttributeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedAttribute registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedAttributeOperation.Value, name, type, lower, upper);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedAttributeOperation.Value, e));
            IProperty result = handler.Invoke(this, name, type, lower, upper);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedAttributeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedAttributeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedAttribute");
        }
        
        /// <summary>
        /// Derivation for StructuredClassifier::/part
        ///result = (ownedAttribute-&gt;select(isComposite)-&gt;asSet())
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IProperty> GetParts()
        {
            System.Func<IStructuredClassifier, ISetExpression<IProperty>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStructuredClassifier, ISetExpression<IProperty>>>(_getPartsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getParts registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getPartsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getPartsOperation.Value, e));
            ISetExpression<IProperty> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getPartsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetPartsOperation()
        {
            return ClassInstance.LookupOperation("getParts");
        }
        
        /// <summary>
        /// All features of type ConnectableElement, equivalent to all direct and inherited roles.
        ///result = (allFeatures()-&gt;select(oclIsKindOf(ConnectableElement))-&gt;collect(oclAsType(ConnectableElement))-&gt;asSet())
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IConnectableElement> AllRoles()
        {
            System.Func<IStructuredClassifier, ISetExpression<IConnectableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStructuredClassifier, ISetExpression<IConnectableElement>>>(_allRolesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allRoles registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allRolesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allRolesOperation.Value, e));
            ISetExpression<IConnectableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allRolesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllRolesOperation()
        {
            return ClassInstance.LookupOperation("allRoles");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedConnectorReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.StructuredClassifier.ClassInstance)).Resolve("ownedConnector")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedConnector property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedConnectorCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedConnector", e, _ownedConnectorReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedConnector property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedConnectorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedConnector", e, _ownedConnectorReference);
        }
        
        /// <summary>
        /// If a behavior is classifier behavior, it does not have a specification.
        ///classifierBehavior-&gt;notEmpty() implies classifierBehavior.specification-&gt;isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Class_behavior(object diagnostics, object context)
        {
            System.Func<IBehavioredClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavioredClassifier, object, object, bool>>(_class_behaviorOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method class_behavior registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _class_behaviorOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _class_behaviorOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _class_behaviorOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveClass_behaviorOperation()
        {
            return ClassInstance.LookupOperation("class_behavior");
        }
        
        /// <summary>
        /// Retrieves all the interfaces on which this behaviored classifier or any of its parents has an interface realization dependency.
        /// </summary>
        public ISetExpression<IInterface> GetAllImplementedInterfaces()
        {
            System.Func<IBehavioredClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavioredClassifier, ISetExpression<IInterface>>>(_getAllImplementedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllImplementedInterfaces registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllImplementedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllImplementedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllImplementedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllImplementedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("getAllImplementedInterfaces");
        }
        
        /// <summary>
        /// Retrieves the interfaces on which this behaviored classifier has an interface realization dependency.
        /// </summary>
        public ISetExpression<IInterface> GetImplementedInterfaces()
        {
            System.Func<IBehavioredClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavioredClassifier, ISetExpression<IInterface>>>(_getImplementedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImplementedInterfaces registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImplementedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImplementedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImplementedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImplementedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("getImplementedInterfaces");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveClassifierBehaviorReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioredClassifier.ClassInstance)).Resolve("classifierBehavior")));
        }
        
        /// <summary>
        /// Handles the event that the ClassifierBehavior property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetClassifierBehavior(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.ClassifierBehavior))
            {
                this.ClassifierBehavior = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveInterfaceRealizationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioredClassifier.ClassInstance)).Resolve("interfaceRealization")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the InterfaceRealization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void InterfaceRealizationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("InterfaceRealization", e, _interfaceRealizationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the InterfaceRealization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void InterfaceRealizationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("InterfaceRealization", e, _interfaceRealizationReference);
        }
        
        /// <summary>
        /// A Classifier may only specialize Classifiers of a valid type.
        ///parents()-&gt;forAll(c | self.maySpecializeType(c))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Specialize_type(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_specialize_typeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method specialize_type registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _specialize_typeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _specialize_typeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _specialize_typeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSpecialize_typeOperation()
        {
            return ClassInstance.LookupOperation("specialize_type");
        }
        
        /// <summary>
        /// The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generalization relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor may its instances also be its subclasses.
        ///powertypeExtent-&gt;forAll( gs | 
        ///  gs.generalization-&gt;forAll( gen | 
        ///    not (gen.general = self) and not gen.general.allParents()-&gt;includes(self) and not (gen.specific = self) and not self.allParents()-&gt;includes(gen.specific) 
        ///  ))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Maps_to_generalization_set(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_maps_to_generalization_setOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method maps_to_generalization_set registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _maps_to_generalization_setOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _maps_to_generalization_setOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _maps_to_generalization_setOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMaps_to_generalization_setOperation()
        {
            return ClassInstance.LookupOperation("maps_to_generalization_set");
        }
        
        /// <summary>
        /// The parents of a Classifier must be non-final.
        ///parents()-&gt;forAll(not isFinalSpecialization)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Non_final_parents(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_non_final_parentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method non_final_parents registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _non_final_parentsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _non_final_parentsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _non_final_parentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNon_final_parentsOperation()
        {
            return ClassInstance.LookupOperation("non_final_parents");
        }
        
        /// <summary>
        /// Generalization hierarchies must be directed and acyclical. A Classifier can not be both a transitively general and transitively specific Classifier of the same Classifier.
        ///not allParents()-&gt;includes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool No_cycles_in_generalization(object diagnostics, object context)
        {
            System.Func<IClassifier, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, object, object, bool>>(_no_cycles_in_generalizationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method no_cycles_in_generalization registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _no_cycles_in_generalizationOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _no_cycles_in_generalizationOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _no_cycles_in_generalizationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNo_cycles_in_generalizationOperation()
        {
            return ClassInstance.LookupOperation("no_cycles_in_generalization");
        }
        
        /// <summary>
        /// Retrieves all the attributes of this classifier, including those inherited from its parents.
        /// </summary>
        public ISetExpression<IProperty> GetAllAttributes()
        {
            System.Func<IClassifier, ISetExpression<IProperty>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IProperty>>>(_getAllAttributesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllAttributes registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllAttributesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllAttributesOperation.Value, e));
            ISetExpression<IProperty> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllAttributesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllAttributesOperation()
        {
            return ClassInstance.LookupOperation("getAllAttributes");
        }
        
        /// <summary>
        /// Retrieves all the operations of this classifier, including those inherited from its parents.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IOperation> GetAllOperations()
        {
            System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>>>(_getAllOperationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllOperations registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllOperationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllOperationsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IOperation> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllOperationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllOperationsOperation()
        {
            return ClassInstance.LookupOperation("getAllOperations");
        }
        
        /// <summary>
        /// Retrieves all the interfaces on which this classifier or any of its parents has a usage dependency.
        /// </summary>
        public ISetExpression<IInterface> GetAllUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_getAllUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllUsedInterfaces registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("getAllUsedInterfaces");
        }
        
        /// <summary>
        /// Retrieves the first operation with the specified name, parameter names, and parameter types from this classifier.
        /// </summary>
        /// <param name="name">The name of the operation to retrieve, or null.</param>
        /// <param name="parameterNames">The parameter names of the operation to retrieve, or null.</param>
        /// <param name="parameterTypes">The parameter types of the operation to retrieve, or null.</param>
        public NMF.Interop.Uml.IOperation GetOperation(string name, IEnumerable<string> parameterNames, IEnumerable<NMF.Interop.Uml.IType> parameterTypes)
        {
            System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, NMF.Interop.Uml.IOperation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, NMF.Interop.Uml.IOperation>>(_getOperationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOperation registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOperationOperation.Value, name, parameterNames, parameterTypes);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOperationOperation.Value, e));
            NMF.Interop.Uml.IOperation result = handler.Invoke(this, name, parameterNames, parameterTypes);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOperationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOperationOperation()
        {
            return ClassInstance.LookupOperation("getOperation");
        }
        
        /// <summary>
        /// Retrieves the first operation with the specified name, parameter names, and parameter types from this classifier, ignoring case if indicated.
        /// </summary>
        /// <param name="name">The name of the operation to retrieve, or null.</param>
        /// <param name="parameterNames">The parameter names of the operation to retrieve, or null.</param>
        /// <param name="parameterTypes">The parameter types of the operation to retrieve, or null.</param>
        /// <param name="ignoreCase">Whether to ignore case in String comparisons.</param>
        public NMF.Interop.Uml.IOperation GetOperation(string name, IEnumerable<string> parameterNames, IEnumerable<NMF.Interop.Uml.IType> parameterTypes, bool ignoreCase)
        {
            System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, bool, NMF.Interop.Uml.IOperation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, string, IEnumerable<string>, IEnumerable<NMF.Interop.Uml.IType>, bool, NMF.Interop.Uml.IOperation>>(_getOperationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOperation registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOperationOperation.Value, name, parameterNames, parameterTypes, ignoreCase);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOperationOperation.Value, e));
            NMF.Interop.Uml.IOperation result = handler.Invoke(this, name, parameterNames, parameterTypes, ignoreCase);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOperationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOperationOperation_()
        {
            return ClassInstance.LookupOperation("getOperation");
        }
        
        /// <summary>
        /// Retrieves the operations of this classifier.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IOperation> GetOperations()
        {
            System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<NMF.Interop.Uml.IOperation>>>(_getOperationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOperations registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOperationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOperationsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IOperation> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOperationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOperationsOperation()
        {
            return ClassInstance.LookupOperation("getOperations");
        }
        
        /// <summary>
        /// Retrieves the interfaces on which this classifier has a usage dependency.
        /// </summary>
        public ISetExpression<IInterface> GetUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_getUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getUsedInterfaces registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("getUsedInterfaces");
        }
        
        /// <summary>
        /// The query allFeatures() gives all of the Features in the namespace of the Classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.
        ///result = (member-&gt;select(oclIsKindOf(Feature))-&gt;collect(oclAsType(Feature))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IFeature> AllFeatures()
        {
            System.Func<IClassifier, ISetExpression<IFeature>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IFeature>>>(_allFeaturesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allFeatures registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allFeaturesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allFeaturesOperation.Value, e));
            ISetExpression<IFeature> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allFeaturesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllFeaturesOperation()
        {
            return ClassInstance.LookupOperation("allFeatures");
        }
        
        /// <summary>
        /// The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
        ///result = (parents()-&gt;union(parents()-&gt;collect(allParents())-&gt;asSet()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IClassifier> AllParents()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_allParentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allParents registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allParentsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allParentsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allParentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllParentsOperation()
        {
            return ClassInstance.LookupOperation("allParents");
        }
        
        /// <summary>
        /// The general Classifiers are the ones referenced by the Generalization relationships.
        ///result = (parents())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IClassifier> GetGenerals()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_getGeneralsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getGenerals registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getGeneralsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getGeneralsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getGeneralsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetGeneralsOperation()
        {
            return ClassInstance.LookupOperation("getGenerals");
        }
        
        /// <summary>
        /// The query hasVisibilityOf() determines whether a NamedElement is visible in the classifier. Non-private members are visible. It is only called when the argument is something owned by a parent.
        ///allParents()-&gt;including(self)-&gt;collect(member)-&gt;includes(n)
        ///result = (n.visibility &lt;&gt; VisibilityKind::private)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="n"></param>
        public bool HasVisibilityOf(INamedElement n)
        {
            System.Func<IClassifier, INamedElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, INamedElement, bool>>(_hasVisibilityOfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method hasVisibilityOf registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _hasVisibilityOfOperation.Value, n);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _hasVisibilityOfOperation.Value, e));
            bool result = handler.Invoke(this, n);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _hasVisibilityOfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveHasVisibilityOfOperation()
        {
            return ClassInstance.LookupOperation("hasVisibilityOf");
        }
        
        /// <summary>
        /// The query inherit() defines how to inherit a set of elements passed as its argument.  It excludes redefined elements from the result.
        ///result = (inhs-&gt;reject(inh |
        ///  inh.oclIsKindOf(RedefinableElement) and
        ///  ownedMember-&gt;select(oclIsKindOf(RedefinableElement))-&gt;
        ///    select(redefinedElement-&gt;includes(inh.oclAsType(RedefinableElement)))
        ///       -&gt;notEmpty()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="inhs"></param>
        public ISetExpression<INamedElement> Inherit(IEnumerable<INamedElement> inhs)
        {
            System.Func<IClassifier, IEnumerable<INamedElement>, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IEnumerable<INamedElement>, ISetExpression<INamedElement>>>(_inheritOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inherit registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inheritOperation.Value, inhs);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inheritOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this, inhs);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inheritOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInheritOperation()
        {
            return ClassInstance.LookupOperation("inherit");
        }
        
        /// <summary>
        /// The query inheritableMembers() gives all of the members of a Classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.
        ///c.allParents()-&gt;includes(self)
        ///result = (member-&gt;select(m | c.hasVisibilityOf(m)))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="c"></param>
        public ISetExpression<INamedElement> InheritableMembers(IClassifier c)
        {
            System.Func<IClassifier, IClassifier, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, ISetExpression<INamedElement>>>(_inheritableMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inheritableMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inheritableMembersOperation.Value, c);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inheritableMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this, c);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inheritableMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInheritableMembersOperation()
        {
            return ClassInstance.LookupOperation("inheritableMembers");
        }
        
        /// <summary>
        /// The inheritedMember association is derived by inheriting the inheritable members of the parents.
        ///result = (inherit(parents()-&gt;collect(inheritableMembers(self))-&gt;asSet()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<INamedElement> GetInheritedMembers()
        {
            System.Func<IClassifier, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<INamedElement>>>(_getInheritedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getInheritedMembers registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getInheritedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getInheritedMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getInheritedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetInheritedMembersOperation()
        {
            return ClassInstance.LookupOperation("getInheritedMembers");
        }
        
        /// <summary>
        /// The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.
        ///result = (self.oclIsKindOf(c.oclType()))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="c"></param>
        public bool MaySpecializeType(IClassifier c)
        {
            System.Func<IClassifier, IClassifier, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, bool>>(_maySpecializeTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method maySpecializeType registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _maySpecializeTypeOperation.Value, c);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _maySpecializeTypeOperation.Value, e));
            bool result = handler.Invoke(this, c);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _maySpecializeTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMaySpecializeTypeOperation()
        {
            return ClassInstance.LookupOperation("maySpecializeType");
        }
        
        /// <summary>
        /// The query parents() gives all of the immediate ancestors of a generalized Classifier.
        ///result = (generalization.general-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IClassifier> Parents()
        {
            System.Func<IClassifier, ISetExpression<IClassifier>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IClassifier>>>(_parentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parents registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parentsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parentsOperation.Value, e));
            ISetExpression<IClassifier> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParentsOperation()
        {
            return ClassInstance.LookupOperation("parents");
        }
        
        /// <summary>
        /// The Interfaces directly realized by this Classifier
        ///result = ((clientDependency-&gt;
        ///  select(oclIsKindOf(Realization) and supplier-&gt;forAll(oclIsKindOf(Interface))))-&gt;
        ///      collect(supplier.oclAsType(Interface))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> DirectlyRealizedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_directlyRealizedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method directlyRealizedInterfaces registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _directlyRealizedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _directlyRealizedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _directlyRealizedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDirectlyRealizedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("directlyRealizedInterfaces");
        }
        
        /// <summary>
        /// The Interfaces directly used by this Classifier
        ///result = ((supplierDependency-&gt;
        ///  select(oclIsKindOf(Usage) and client-&gt;forAll(oclIsKindOf(Interface))))-&gt;
        ///    collect(client.oclAsType(Interface))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> DirectlyUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_directlyUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method directlyUsedInterfaces registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _directlyUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _directlyUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _directlyUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDirectlyUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("directlyUsedInterfaces");
        }
        
        /// <summary>
        /// The Interfaces realized by this Classifier and all of its generalizations
        ///result = (directlyRealizedInterfaces()-&gt;union(self.allParents()-&gt;collect(directlyRealizedInterfaces()))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> AllRealizedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_allRealizedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allRealizedInterfaces registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allRealizedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allRealizedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allRealizedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllRealizedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("allRealizedInterfaces");
        }
        
        /// <summary>
        /// The Interfaces used by this Classifier and all of its generalizations
        ///result = (directlyUsedInterfaces()-&gt;union(self.allParents()-&gt;collect(directlyUsedInterfaces()))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> AllUsedInterfaces()
        {
            System.Func<IClassifier, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IInterface>>>(_allUsedInterfacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allUsedInterfaces registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allUsedInterfacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allUsedInterfacesOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allUsedInterfacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllUsedInterfacesOperation()
        {
            return ClassInstance.LookupOperation("allUsedInterfaces");
        }
        
        /// <summary>
        /// result = (substitution.contract-&gt;includes(contract))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        /// <param name="contract"></param>
        public bool IsSubstitutableFor(IClassifier contract)
        {
            System.Func<IClassifier, IClassifier, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IClassifier, bool>>(_isSubstitutableForOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isSubstitutableFor registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isSubstitutableForOperation.Value, contract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isSubstitutableForOperation.Value, e));
            bool result = handler.Invoke(this, contract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isSubstitutableForOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsSubstitutableForOperation()
        {
            return ClassInstance.LookupOperation("isSubstitutableFor");
        }
        
        /// <summary>
        /// The query allAttributes gives an ordered set of all owned and inherited attributes of the Classifier. All owned attributes appear before any inherited attributes, and the attributes inherited from any more specific parent Classifier appear before those of any more general parent Classifier. However, if the Classifier has multiple immediate parents, then the relative ordering of the sets of attributes from those parents is not defined.
        ///result = (attribute-&gt;asSequence()-&gt;union(parents()-&gt;asSequence().allAttributes())-&gt;select(p | member-&gt;includes(p))-&gt;asOrderedSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public IOrderedSetExpression<IProperty> AllAttributes()
        {
            System.Func<IClassifier, IOrderedSetExpression<IProperty>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, IOrderedSetExpression<IProperty>>>(_allAttributesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allAttributes registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allAttributesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allAttributesOperation.Value, e));
            IOrderedSetExpression<IProperty> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allAttributesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllAttributesOperation()
        {
            return ClassInstance.LookupOperation("allAttributes");
        }
        
        /// <summary>
        /// All StructuralFeatures related to the Classifier that may have Slots, including direct attributes, inherited attributes, private attributes in generalizations, and memberEnds of Associations, but excluding redefined StructuralFeatures.
        ///result = (member-&gt;select(oclIsKindOf(StructuralFeature))-&gt;
        ///  collect(oclAsType(StructuralFeature))-&gt;
        ///   union(self.inherit(self.allParents()-&gt;collect(p | p.attribute)-&gt;asSet())-&gt;
        ///     collect(oclAsType(StructuralFeature)))-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IStructuralFeature> AllSlottableFeatures()
        {
            System.Func<IClassifier, ISetExpression<IStructuralFeature>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClassifier, ISetExpression<IStructuralFeature>>>(_allSlottableFeaturesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allSlottableFeatures registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allSlottableFeaturesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allSlottableFeaturesOperation.Value, e));
            ISetExpression<IStructuralFeature> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allSlottableFeaturesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllSlottableFeaturesOperation()
        {
            return ClassInstance.LookupOperation("allSlottableFeatures");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsAbstractAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("isAbstract")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsFinalSpecializationAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("isFinalSpecialization")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveGeneralizationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("generalization")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Generalization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void GeneralizationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Generalization", e, _generalizationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Generalization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void GeneralizationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Generalization", e, _generalizationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePowertypeExtentReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("powertypeExtent")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PowertypeExtent property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PowertypeExtentCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PowertypeExtent", e, _powertypeExtentReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PowertypeExtent property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PowertypeExtentCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PowertypeExtent", e, _powertypeExtentReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedUseCaseReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("ownedUseCase")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedUseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedUseCaseCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedUseCase", e, _ownedUseCaseReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedUseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedUseCaseCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedUseCase", e, _ownedUseCaseReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveUseCaseReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("useCase")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the UseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void UseCaseCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("UseCase", e, _useCaseReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the UseCase property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void UseCaseCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("UseCase", e, _useCaseReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRepresentationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("representation")));
        }
        
        /// <summary>
        /// Handles the event that the Representation property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRepresentation(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Representation))
            {
                this.Representation = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSubstitutionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Classifier.ClassInstance)).Resolve("substitution")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Substitution property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SubstitutionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Substitution", e, _substitutionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Substitution property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SubstitutionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Substitution", e, _substitutionReference);
        }
        
        /// <summary>
        /// All the members of a Namespace are distinguishable within it.
        ///membersAreDistinguishable()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Members_distinguishable(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_members_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method members_distinguishable registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _members_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _members_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _members_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembers_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("members_distinguishable");
        }
        
        /// <summary>
        /// A Namespace cannot have a PackageImport to itself.
        ///packageImport.importedPackage.oclAsType(Namespace)-&gt;excludes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_self(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_selfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_self registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_selfOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_selfOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_selfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_selfOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_self");
        }
        
        /// <summary>
        /// A Namespace cannot have an ElementImport to one of its ownedMembers.
        ///elementImport.importedElement.oclAsType(Element)-&gt;excludesAll(ownedMember)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_ownedMembers(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_ownedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_ownedMembers registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_ownedMembersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_ownedMembersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_ownedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_ownedMembersOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_ownedMembers");
        }
        
        /// <summary>
        /// Creates an import of the specified element into this namespace with the specified visibility.
        /// </summary>
        /// <param name="element">The element to import.</param>
        /// <param name="visibility">The visibility for the new element import.</param>
        public IElementImport CreateElementImport(IPackageableElement element, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport>>(_createElementImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createElementImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createElementImportOperation.Value, element, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createElementImportOperation.Value, e));
            IElementImport result = handler.Invoke(this, element, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createElementImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateElementImportOperation()
        {
            return ClassInstance.LookupOperation("createElementImport");
        }
        
        /// <summary>
        /// Creates an import of the specified package into this namespace with the specified visibility.
        /// </summary>
        /// <param name="package_">The package to import.</param>
        /// <param name="visibility">The visibility for the new package import.</param>
        public IPackageImport CreatePackageImport(IPackage package_, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport>>(_createPackageImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createPackageImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createPackageImportOperation.Value, package_, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createPackageImportOperation.Value, e));
            IPackageImport result = handler.Invoke(this, package_, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createPackageImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreatePackageImportOperation()
        {
            return ClassInstance.LookupOperation("createPackageImport");
        }
        
        /// <summary>
        /// Retrieves the elements imported by this namespace.
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedElements()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedElements registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedElementsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedElementsOperation()
        {
            return ClassInstance.LookupOperation("getImportedElements");
        }
        
        /// <summary>
        /// Retrieves the packages imported by this namespace.
        /// </summary>
        public ISetExpression<IPackage> GetImportedPackages()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>>>(_getImportedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedPackages registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getImportedPackages");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public ISetExpression<INamedElement> GetOwnedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>>>(_getOwnedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedMembers registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedMembersOperation()
        {
            return ClassInstance.LookupOperation("getOwnedMembers");
        }
        
        /// <summary>
        /// The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this Namespace.
        ///result = (imps-&gt;reject(imp1  | imps-&gt;exists(imp2 | not imp1.isDistinguishableFrom(imp2, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ExcludeCollisions(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_excludeCollisionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method excludeCollisions registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _excludeCollisionsOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _excludeCollisionsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _excludeCollisionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveExcludeCollisionsOperation()
        {
            return ClassInstance.LookupOperation("excludeCollisions");
        }
        
        /// <summary>
        /// The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace, taking importing into account. In general a member can have multiple names in a Namespace if it is imported more than once with different aliases.
        ///result = (if self.ownedMember -&gt;includes(element)
        ///then Set{element.name}
        ///else let elementImports : Set(ElementImport) = self.elementImport-&gt;select(ei | ei.importedElement = element) in
        ///  if elementImports-&gt;notEmpty()
        ///  then
        ///     elementImports-&gt;collect(el | el.getName())-&gt;asSet()
        ///  else 
        ///     self.packageImport-&gt;select(pi | pi.importedPackage.visibleMembers().oclAsType(NamedElement)-&gt;includes(element))-&gt; collect(pi | pi.importedPackage.getNamesOfMember(element))-&gt;asSet()
        ///  endif
        ///endif)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="element"></param>
        public ISetExpression<string> GetNamesOfMember(INamedElement element)
        {
            System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>>>(_getNamesOfMemberOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNamesOfMember registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNamesOfMemberOperation.Value, element);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNamesOfMemberOperation.Value, e));
            ISetExpression<string> result = handler.Invoke(this, element);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNamesOfMemberOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNamesOfMemberOperation()
        {
            return ClassInstance.LookupOperation("getNamesOfMember");
        }
        
        /// <summary>
        /// The query importMembers() defines which of a set of PackageableElements are actually imported into the Namespace. This excludes hidden ones, i.e., those which have names that conflict with names of ownedMembers, and it also excludes PackageableElements that would have the indistinguishable names when imported.
        ///result = (self.excludeCollisions(imps)-&gt;select(imp | self.ownedMember-&gt;forAll(mem | imp.isDistinguishableFrom(mem, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ImportMembers(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_importMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method importMembers registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _importMembersOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _importMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _importMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveImportMembersOperation()
        {
            return ClassInstance.LookupOperation("importMembers");
        }
        
        /// <summary>
        /// The importedMember property is derived as the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
        ///result = (self.importMembers(elementImport.importedElement-&gt;asSet()-&gt;union(packageImport.importedPackage-&gt;collect(p | p.visibleMembers()))-&gt;asSet()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedMembersOperation()
        {
            return ClassInstance.LookupOperation("getImportedMembers");
        }
        
        /// <summary>
        /// The Boolean query membersAreDistinguishable() determines whether all of the Namespace&apos;s members are distinguishable within it.
        ///result = (member-&gt;forAll( memb |
        ///   member-&gt;excluding(memb)-&gt;forAll(other |
        ///       memb.isDistinguishableFrom(other, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool MembersAreDistinguishable()
        {
            System.Func<NMF.Interop.Uml.INamespace, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, bool>>(_membersAreDistinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method membersAreDistinguishable registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _membersAreDistinguishableOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _membersAreDistinguishableOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _membersAreDistinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembersAreDistinguishableOperation()
        {
            return ClassInstance.LookupOperation("membersAreDistinguishable");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveElementImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("elementImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ElementImport", e, _elementImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ElementImport", e, _elementImportReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("packageImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// Creates a(n) (binary) association between this type and the specified other type, with the specified navigabilities, aggregations, names, lower bounds, and upper bounds, and owned by this type&apos;s nearest package.
        /// </summary>
        /// <param name="end1IsNavigable">The navigability for the first end of the new association.</param>
        /// <param name="end1Aggregation">The aggregation for the first end of the new association.</param>
        /// <param name="end1Name">The name for the first end of the new association.</param>
        /// <param name="end1Lower">The lower bound for the first end of the new association.</param>
        /// <param name="end1Upper">The upper bound for the first end of the new association.</param>
        /// <param name="end1Type">The type for the first end of the new association.</param>
        /// <param name="end2IsNavigable">The navigability for the second end of the new association.</param>
        /// <param name="end2Aggregation">The aggregation for the second end of the new association.</param>
        /// <param name="end2Name">The name for the second end of the new association.</param>
        /// <param name="end2Lower">The lower bound for the second end of the new association.</param>
        /// <param name="end2Upper">The upper bound for the second end of the new association.</param>
        public IAssociation CreateAssociation(bool end1IsNavigable, AggregationKind end1Aggregation, string end1Name, int end1Lower, object end1Upper, NMF.Interop.Uml.IType end1Type, bool end2IsNavigable, AggregationKind end2Aggregation, string end2Name, int end2Lower, object end2Upper)
        {
            System.Func<NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, IAssociation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, NMF.Interop.Uml.IType, bool, AggregationKind, string, int, object, IAssociation>>(_createAssociationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createAssociation registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createAssociationOperation.Value, end1IsNavigable, end1Aggregation, end1Name, end1Lower, end1Upper, end1Type, end2IsNavigable, end2Aggregation, end2Name, end2Lower, end2Upper);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createAssociationOperation.Value, e));
            IAssociation result = handler.Invoke(this, end1IsNavigable, end1Aggregation, end1Name, end1Lower, end1Upper, end1Type, end2IsNavigable, end2Aggregation, end2Name, end2Lower, end2Upper);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createAssociationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateAssociationOperation()
        {
            return ClassInstance.LookupOperation("createAssociation");
        }
        
        /// <summary>
        /// Retrieves the associations in which this type is involved.
        /// </summary>
        public ISetExpression<IAssociation> GetAssociations()
        {
            System.Func<NMF.Interop.Uml.IType, ISetExpression<IAssociation>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IType, ISetExpression<IAssociation>>>(_getAssociationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAssociations registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAssociationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAssociationsOperation.Value, e));
            ISetExpression<IAssociation> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAssociationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAssociationsOperation()
        {
            return ClassInstance.LookupOperation("getAssociations");
        }
        
        /// <summary>
        /// The query conformsTo() gives true for a Type that conforms to another. By default, two Types do not conform to each other. This query is intended to be redefined for specific conformance situations.
        ///result = (false)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="other"></param>
        public bool ConformsTo(NMF.Interop.Uml.IType other)
        {
            System.Func<NMF.Interop.Uml.IType, NMF.Interop.Uml.IType, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IType, NMF.Interop.Uml.IType, bool>>(_conformsToOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method conformsTo registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _conformsToOperation.Value, other);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _conformsToOperation.Value, e));
            bool result = handler.Invoke(this, other);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _conformsToOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveConformsToOperation()
        {
            return ClassInstance.LookupOperation("conformsTo");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Type.ClassInstance)).Resolve("package")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newPackage = ModelHelper.CastAs<IPackage>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldPackage, newPackage);
            this.OnPropertyChanging("Package", e, _packageReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newPackage = ModelHelper.CastAs<IPackage>(newParent);
            if ((oldPackage != null))
            {
                oldPackage.OwnedType.Remove(this);
            }
            if ((newPackage != null))
            {
                newPackage.OwnedType.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldPackage, newPackage);
            this.OnPropertyChanged("Package", e, _packageReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// A PackageableElement owned by a Namespace must have a visibility.
        ///visibility = null implies namespace = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Namespace_needs_visibility(object diagnostics, object context)
        {
            System.Func<IPackageableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackageableElement, object, object, bool>>(_namespace_needs_visibilityOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method namespace_needs_visibility registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _namespace_needs_visibilityOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _namespace_needs_visibilityOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _namespace_needs_visibilityOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNamespace_needs_visibilityOperation()
        {
            return ClassInstance.LookupOperation("namespace_needs_visibility");
        }
        
        /// <summary>
        /// The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified ParameterableElement. By default, this ParameterableElement is compatible with another ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. Subclasses of ParameterableElement should override this operation to specify different compatibility constraints.
        ///result = (self.oclIsKindOf(p.oclType()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="p"></param>
        public bool IsCompatibleWith(IParameterableElement p)
        {
            System.Func<IParameterableElement, IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, IParameterableElement, bool>>(_isCompatibleWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isCompatibleWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompatibleWithOperation.Value, p);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompatibleWithOperation.Value, e));
            bool result = handler.Invoke(this, p);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompatibleWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompatibleWithOperation()
        {
            return ClassInstance.LookupOperation("isCompatibleWith");
        }
        
        /// <summary>
        /// The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal TemplateParameter.
        ///result = (templateParameter-&gt;notEmpty())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplateParameter()
        {
            System.Func<IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, bool>>(_isTemplateParameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplateParameter registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateParameterOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateParameterOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateParameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateParameterOperation()
        {
            return ClassInstance.LookupOperation("isTemplateParameter");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("owningTemplateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the OwningTemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwningTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwningTemplateParameter))
            {
                this.OwningTemplateParameter = null;
            }
        }
        
        /// <summary>
        /// The query isTemplate() returns whether this TemplateableElement is actually a template.
        ///result = (ownedTemplateSignature &lt;&gt; null)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplate()
        {
            System.Func<ITemplateableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, bool>>(_isTemplateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplate registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateOperation()
        {
            return ClassInstance.LookupOperation("isTemplate");
        }
        
        /// <summary>
        /// The query parameterableElements() returns the set of ParameterableElements that may be used as the parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all the ownedElements. Subclasses may override this operation if they choose to restrict the set of ParameterableElements.
        ///result = (self.allOwnedElements()-&gt;select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)-&gt;asSet())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IParameterableElement> ParameterableElements()
        {
            System.Func<ITemplateableElement, ISetExpression<IParameterableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, ISetExpression<IParameterableElement>>>(_parameterableElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameterableElements registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameterableElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameterableElementsOperation.Value, e));
            ISetExpression<IParameterableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameterableElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameterableElementsOperation()
        {
            return ClassInstance.LookupOperation("parameterableElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateBindingReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("templateBinding")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TemplateBinding", e, _templateBindingReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TemplateBinding", e, _templateBindingReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTemplateSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("ownedTemplateSignature")));
        }
        
        /// <summary>
        /// Handles the event that the OwnedTemplateSignature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwnedTemplateSignature(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwnedTemplateSignature))
            {
                this.OwnedTemplateSignature = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int ownedParameterIndex = ModelHelper.IndexOfReference(this.OwnedParameter, element);
            if ((ownedParameterIndex != -1))
            {
                return ModelHelper.CreatePath("ownedParameter", ownedParameterIndex);
            }
            int ownedParameterSetIndex = ModelHelper.IndexOfReference(this.OwnedParameterSet, element);
            if ((ownedParameterSetIndex != -1))
            {
                return ModelHelper.CreatePath("ownedParameterSet", ownedParameterSetIndex);
            }
            int postconditionIndex = ModelHelper.IndexOfReference(this.Postcondition, element);
            if ((postconditionIndex != -1))
            {
                return ModelHelper.CreatePath("postcondition", postconditionIndex);
            }
            int preconditionIndex = ModelHelper.IndexOfReference(this.Precondition, element);
            if ((preconditionIndex != -1))
            {
                return ModelHelper.CreatePath("precondition", preconditionIndex);
            }
            int ownedOperationIndex = ModelHelper.IndexOfReference(this.OwnedOperation, element);
            if ((ownedOperationIndex != -1))
            {
                return ModelHelper.CreatePath("ownedOperation", ownedOperationIndex);
            }
            int nestedClassifierIndex = ModelHelper.IndexOfReference(this.NestedClassifier, element);
            if ((nestedClassifierIndex != -1))
            {
                return ModelHelper.CreatePath("nestedClassifier", nestedClassifierIndex);
            }
            int ownedReceptionIndex = ModelHelper.IndexOfReference(this.OwnedReception, element);
            if ((ownedReceptionIndex != -1))
            {
                return ModelHelper.CreatePath("ownedReception", ownedReceptionIndex);
            }
            int ownedPortIndex = ModelHelper.IndexOfReference(this.OwnedPort, element);
            if ((ownedPortIndex != -1))
            {
                return ModelHelper.CreatePath("ownedPort", ownedPortIndex);
            }
            int ownedConnectorIndex = ModelHelper.IndexOfReference(this.OwnedConnector, element);
            if ((ownedConnectorIndex != -1))
            {
                return ModelHelper.CreatePath("ownedConnector", ownedConnectorIndex);
            }
            int generalizationIndex = ModelHelper.IndexOfReference(this.Generalization, element);
            if ((generalizationIndex != -1))
            {
                return ModelHelper.CreatePath("generalization", generalizationIndex);
            }
            int ownedUseCaseIndex = ModelHelper.IndexOfReference(this.OwnedUseCase, element);
            if ((ownedUseCaseIndex != -1))
            {
                return ModelHelper.CreatePath("ownedUseCase", ownedUseCaseIndex);
            }
            if ((element == this.Representation))
            {
                return ModelHelper.CreatePath("representation");
            }
            int substitutionIndex = ModelHelper.IndexOfReference(this.Substitution, element);
            if ((substitutionIndex != -1))
            {
                return ModelHelper.CreatePath("substitution", substitutionIndex);
            }
            int elementImportIndex = ModelHelper.IndexOfReference(this.ElementImport, element);
            if ((elementImportIndex != -1))
            {
                return ModelHelper.CreatePath("elementImport", elementImportIndex);
            }
            int packageImportIndex = ModelHelper.IndexOfReference(this.PackageImport, element);
            if ((packageImportIndex != -1))
            {
                return ModelHelper.CreatePath("packageImport", packageImportIndex);
            }
            int templateBindingIndex = ModelHelper.IndexOfReference(this.TemplateBinding, element);
            if ((templateBindingIndex != -1))
            {
                return ModelHelper.CreatePath("templateBinding", templateBindingIndex);
            }
            if ((element == this.OwnedTemplateSignature))
            {
                return ModelHelper.CreatePath("ownedTemplateSignature");
            }
            if ((element == this.ClassifierBehavior))
            {
                return ModelHelper.CreatePath("classifierBehavior");
            }
            int interfaceRealizationIndex = ModelHelper.IndexOfReference(this.InterfaceRealization, element);
            if ((interfaceRealizationIndex != -1))
            {
                return ModelHelper.CreatePath("interfaceRealization", interfaceRealizationIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "SPECIFICATION"))
            {
                return this.Specification;
            }
            if ((reference == "OWNEDPARAMETER"))
            {
                if ((index < this.OwnedParameter.Count))
                {
                    return this.OwnedParameter[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDPARAMETERSET"))
            {
                if ((index < this.OwnedParameterSet.Count))
                {
                    return this.OwnedParameterSet[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "POSTCONDITION"))
            {
                if ((index < this.Postcondition.Count))
                {
                    return this.Postcondition[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PRECONDITION"))
            {
                if ((index < this.Precondition.Count))
                {
                    return this.Precondition[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDOPERATION"))
            {
                if ((index < this.OwnedOperation.Count))
                {
                    return this.OwnedOperation[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "NESTEDCLASSIFIER"))
            {
                if ((index < this.NestedClassifier.Count))
                {
                    return this.NestedClassifier[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDRECEPTION"))
            {
                if ((index < this.OwnedReception.Count))
                {
                    return this.OwnedReception[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDPORT"))
            {
                if ((index < this.OwnedPort.Count))
                {
                    return this.OwnedPort[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDCONNECTOR"))
            {
                if ((index < this.OwnedConnector.Count))
                {
                    return this.OwnedConnector[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "GENERALIZATION"))
            {
                if ((index < this.Generalization.Count))
                {
                    return this.Generalization[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDUSECASE"))
            {
                if ((index < this.OwnedUseCase.Count))
                {
                    return this.OwnedUseCase[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "REPRESENTATION"))
            {
                return this.Representation;
            }
            if ((reference == "SUBSTITUTION"))
            {
                if ((index < this.Substitution.Count))
                {
                    return this.Substitution[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "ELEMENTIMPORT"))
            {
                if ((index < this.ElementImport.Count))
                {
                    return this.ElementImport[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGEIMPORT"))
            {
                if ((index < this.PackageImport.Count))
                {
                    return this.PackageImport[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGE"))
            {
                return this.Package;
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return this.OwningTemplateParameter;
            }
            if ((reference == "TEMPLATEBINDING"))
            {
                if ((index < this.TemplateBinding.Count))
                {
                    return this.TemplateBinding[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return this.OwnedTemplateSignature;
            }
            if ((reference == "CLASSIFIERBEHAVIOR"))
            {
                return this.ClassifierBehavior;
            }
            if ((reference == "INTERFACEREALIZATION"))
            {
                if ((index < this.InterfaceRealization.Count))
                {
                    return this.InterfaceRealization[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISREENTRANT"))
            {
                return this.IsReentrant;
            }
            if ((attribute == "ISACTIVE"))
            {
                return this.IsActive;
            }
            if ((attribute == "ISABSTRACT"))
            {
                return this.IsAbstract;
            }
            if ((attribute == "ISFINALSPECIALIZATION"))
            {
                return this.IsFinalSpecialization;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "OWNEDPARAMETER"))
            {
                return this._ownedParameter;
            }
            if ((feature == "OWNEDPARAMETERSET"))
            {
                return this._ownedParameterSet;
            }
            if ((feature == "POSTCONDITION"))
            {
                return this._postcondition;
            }
            if ((feature == "PRECONDITION"))
            {
                return this._precondition;
            }
            if ((feature == "REDEFINEDBEHAVIOR"))
            {
                return this._redefinedBehavior;
            }
            if ((feature == "OWNEDOPERATION"))
            {
                return this._ownedOperation;
            }
            if ((feature == "NESTEDCLASSIFIER"))
            {
                return this._nestedClassifier;
            }
            if ((feature == "OWNEDRECEPTION"))
            {
                return this._ownedReception;
            }
            if ((feature == "OWNEDPORT"))
            {
                return this._ownedPort;
            }
            if ((feature == "OWNEDCONNECTOR"))
            {
                return this._ownedConnector;
            }
            if ((feature == "GENERALIZATION"))
            {
                return this._generalization;
            }
            if ((feature == "POWERTYPEEXTENT"))
            {
                return this._powertypeExtent;
            }
            if ((feature == "OWNEDUSECASE"))
            {
                return this._ownedUseCase;
            }
            if ((feature == "USECASE"))
            {
                return this._useCase;
            }
            if ((feature == "SUBSTITUTION"))
            {
                return this._substitution;
            }
            if ((feature == "ELEMENTIMPORT"))
            {
                return this._elementImport;
            }
            if ((feature == "PACKAGEIMPORT"))
            {
                return this._packageImport;
            }
            if ((feature == "TEMPLATEBINDING"))
            {
                return this._templateBinding;
            }
            if ((feature == "INTERFACEREALIZATION"))
            {
                return this._interfaceRealization;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "SPECIFICATION"))
            {
                this.Specification = ((IBehavioralFeature)(value));
                return;
            }
            if ((feature == "REPRESENTATION"))
            {
                this.Representation = ((ICollaborationUse)(value));
                return;
            }
            if ((feature == "PACKAGE"))
            {
                this.Package = ((IPackage)(value));
                return;
            }
            if ((feature == "OWNINGTEMPLATEPARAMETER"))
            {
                this.OwningTemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "OWNEDTEMPLATESIGNATURE"))
            {
                this.OwnedTemplateSignature = ((ITemplateSignature)(value));
                return;
            }
            if ((feature == "CLASSIFIERBEHAVIOR"))
            {
                this.ClassifierBehavior = ((IBehavior)(value));
                return;
            }
            if ((feature == "ISREENTRANT"))
            {
                this.IsReentrant = ((bool)(value));
                return;
            }
            if ((feature == "ISACTIVE"))
            {
                this.IsActive = ((bool)(value));
                return;
            }
            if ((feature == "ISABSTRACT"))
            {
                this.IsAbstract = ((bool)(value));
                return;
            }
            if ((feature == "ISFINALSPECIALIZATION"))
            {
                this.IsFinalSpecialization = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISREENTRANT"))
            {
                return Observable.Box(new IsReentrantProxy(this));
            }
            if ((attribute == "ISACTIVE"))
            {
                return Observable.Box(new IsActiveProxy(this));
            }
            if ((attribute == "ISABSTRACT"))
            {
                return Observable.Box(new IsAbstractProxy(this));
            }
            if ((attribute == "ISFINALSPECIALIZATION"))
            {
                return Observable.Box(new IsFinalSpecializationProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "SPECIFICATION"))
            {
                return new SpecificationProxy(this);
            }
            if ((reference == "REPRESENTATION"))
            {
                return new RepresentationProxy(this);
            }
            if ((reference == "PACKAGE"))
            {
                return new PackageProxy(this);
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return new OwningTemplateParameterProxy(this);
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return new OwnedTemplateSignatureProxy(this);
            }
            if ((reference == "CLASSIFIERBEHAVIOR"))
            {
                return new ClassifierBehaviorProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._ownedParameter))
            {
                return "ownedParameter";
            }
            if ((container == this._ownedParameterSet))
            {
                return "ownedParameterSet";
            }
            if ((container == this._postcondition))
            {
                return "postcondition";
            }
            if ((container == this._precondition))
            {
                return "precondition";
            }
            if ((container == this._ownedOperation))
            {
                return "ownedOperation";
            }
            if ((container == this._nestedClassifier))
            {
                return "nestedClassifier";
            }
            if ((container == this._ownedReception))
            {
                return "ownedReception";
            }
            if ((container == this._ownedPort))
            {
                return "ownedPort";
            }
            if ((container == this._ownedConnector))
            {
                return "ownedConnector";
            }
            if ((container == this._generalization))
            {
                return "generalization";
            }
            if ((container == this._ownedUseCase))
            {
                return "ownedUseCase";
            }
            if ((container == this._substitution))
            {
                return "substitution";
            }
            if ((container == this._elementImport))
            {
                return "elementImport";
            }
            if ((container == this._packageImport))
            {
                return "packageImport";
            }
            if ((container == this._templateBinding))
            {
                return "templateBinding";
            }
            if ((container == this._interfaceRealization))
            {
                return "interfaceRealization";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Behavior")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Behavior class
        /// </summary>
        public class BehaviorChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Behavior _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public BehaviorChildrenCollection(Behavior parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Behavior class
        /// </summary>
        public class BehaviorReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Behavior _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public BehaviorReferencedElementsCollection(Behavior parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isReentrant property
        /// </summary>
        private sealed class IsReentrantProxy : ModelPropertyChange<IBehavior, Nullable<bool>>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsReentrantProxy(IBehavior modelElement) : 
                    base(modelElement, "isReentrant")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override Nullable<bool> Value
            {
                get
                {
                    return this.ModelElement.IsReentrant;
                }
                set
                {
                    this.ModelElement.IsReentrant = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the specification property
        /// </summary>
        private sealed class SpecificationProxy : ModelPropertyChange<IBehavior, IBehavioralFeature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SpecificationProxy(IBehavior modelElement) : 
                    base(modelElement, "specification")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavioralFeature Value
            {
                get
                {
                    return this.ModelElement.Specification;
                }
                set
                {
                    this.ModelElement.Specification = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isActive property
        /// </summary>
        private sealed class IsActiveProxy : ModelPropertyChange<NMF.Interop.Uml.IClass, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsActiveProxy(NMF.Interop.Uml.IClass modelElement) : 
                    base(modelElement, "isActive")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsActive;
                }
                set
                {
                    this.ModelElement.IsActive = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the classifierBehavior property
        /// </summary>
        private sealed class ClassifierBehaviorProxy : ModelPropertyChange<IBehavioredClassifier, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ClassifierBehaviorProxy(IBehavioredClassifier modelElement) : 
                    base(modelElement, "classifierBehavior")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.ClassifierBehavior;
                }
                set
                {
                    this.ModelElement.ClassifierBehavior = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isAbstract property
        /// </summary>
        private sealed class IsAbstractProxy : ModelPropertyChange<IClassifier, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsAbstractProxy(IClassifier modelElement) : 
                    base(modelElement, "isAbstract")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsAbstract;
                }
                set
                {
                    this.ModelElement.IsAbstract = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isFinalSpecialization property
        /// </summary>
        private sealed class IsFinalSpecializationProxy : ModelPropertyChange<IClassifier, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsFinalSpecializationProxy(IClassifier modelElement) : 
                    base(modelElement, "isFinalSpecialization")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsFinalSpecialization;
                }
                set
                {
                    this.ModelElement.IsFinalSpecialization = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the representation property
        /// </summary>
        private sealed class RepresentationProxy : ModelPropertyChange<IClassifier, ICollaborationUse>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RepresentationProxy(IClassifier modelElement) : 
                    base(modelElement, "representation")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ICollaborationUse Value
            {
                get
                {
                    return this.ModelElement.Representation;
                }
                set
                {
                    this.ModelElement.Representation = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the package property
        /// </summary>
        private sealed class PackageProxy : ModelPropertyChange<NMF.Interop.Uml.IType, IPackage>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public PackageProxy(NMF.Interop.Uml.IType modelElement) : 
                    base(modelElement, "package")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IPackage Value
            {
                get
                {
                    return this.ModelElement.Package;
                }
                set
                {
                    this.ModelElement.Package = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningTemplateParameter property
        /// </summary>
        private sealed class OwningTemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningTemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "owningTemplateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.OwningTemplateParameter;
                }
                set
                {
                    this.ModelElement.OwningTemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the templateParameter property
        /// </summary>
        private sealed class TemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "templateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.TemplateParameter;
                }
                set
                {
                    this.ModelElement.TemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the ownedTemplateSignature property
        /// </summary>
        private sealed class OwnedTemplateSignatureProxy : ModelPropertyChange<ITemplateableElement, ITemplateSignature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwnedTemplateSignatureProxy(ITemplateableElement modelElement) : 
                    base(modelElement, "ownedTemplateSignature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateSignature Value
            {
                get
                {
                    return this.ModelElement.OwnedTemplateSignature;
                }
                set
                {
                    this.ModelElement.OwnedTemplateSignature = value;
                }
            }
        }
    }
}
