//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for InteractionUse
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(InteractionUse))]
    [XmlDefaultImplementationTypeAttribute(typeof(InteractionUse))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//InteractionUse")]
    public interface IInteractionUse : IModelElement, IInteractionFragment
    {
        
        /// <summary>
        /// The actual gates of the InteractionUse.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("actualGate")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IGate> ActualGate
        {
            get;
        }
        
        /// <summary>
        /// The actual arguments of the Interaction.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("argument")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IValueSpecification> Argument
        {
            get;
        }
        
        /// <summary>
        /// Refers to the Interaction that defines its meaning.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("refersTo")]
        [DescriptionAttribute("Refers to the Interaction that defines its meaning.\n<p>From package UML::Interact" +
            "ions.</p>")]
        [CategoryAttribute("InteractionUse")]
        [XmlElementNameAttribute("refersTo")]
        [XmlAttributeAttribute(true)]
        IInteraction RefersTo
        {
            get;
            set;
        }
        
        /// <summary>
        /// The value of the executed Interaction.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("returnValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification ReturnValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// The recipient of the return value.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("returnValueRecipient")]
        [DescriptionAttribute("The recipient of the return value.\n<p>From package UML::Interactions.</p>")]
        [CategoryAttribute("InteractionUse")]
        [XmlElementNameAttribute("returnValueRecipient")]
        [XmlAttributeAttribute(true)]
        IProperty ReturnValueRecipient
        {
            get;
            set;
        }
        
        /// <summary>
        /// Actual Gates of the InteractionUse must match Formal Gates of the referred Interaction. Gates match when their names are equal and their messages correspond.
        ///actualGate->notEmpty() implies 
        ///refersTo.formalGate->forAll( fg : Gate | self.actualGate->select(matches(fg))->size()=1) and
        ///self.actualGate->forAll(ag : Gate | refersTo.formalGate->select(matches(ag))->size()=1)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Gates_match(object diagnostics, object context);
        
        /// <summary>
        /// The arguments must only be constants, parameters of the enclosing Interaction or attributes of the classifier owning the enclosing Interaction.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Arguments_are_constants(object diagnostics, object context);
        
        /// <summary>
        /// The returnValueRecipient must be a Property of a ConnectableElement that is represented by a Lifeline covered by this InteractionUse.
        ///returnValueRecipient->asSet()->notEmpty() implies
        ///let covCE : Set(ConnectableElement) = covered.represents->asSet() in 
        ///covCE->notEmpty() and let classes:Set(Classifier) = covCE.type.oclIsKindOf(Classifier).oclAsType(Classifier)->asSet() in 
        ///let allProps : Set(Property) = classes.attribute->union(classes.allParents().attribute)->asSet() in 
        ///allProps->includes(returnValueRecipient)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool ReturnValueRecipient_coverage(object diagnostics, object context);
        
        /// <summary>
        /// The arguments of the InteractionUse must correspond to parameters of the referred Interaction.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Arguments_correspond_to_parameters(object diagnostics, object context);
        
        /// <summary>
        /// The type of the returnValue must correspond to the type of the returnValueRecipient.
        ///returnValue.type->asSequence()->notEmpty() implies returnValue.type->asSequence()->first() = returnValueRecipient.type->asSequence()->first()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool ReturnValue_type_recipient_correspondence(object diagnostics, object context);
        
        /// <summary>
        /// The InteractionUse must cover all Lifelines of the enclosing Interaction that are common with the lifelines covered by the referred Interaction. Lifelines are common if they have the same selector and represents associationEnd values.
        ///let parentInteraction : Set(Interaction) = enclosingInteraction->asSet()->
        ///union(enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->
        ///collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in
        ///parentInteraction->size()=1 and let refInteraction : Interaction = refersTo in
        ///parentInteraction.covered-> forAll(intLifeline : Lifeline | refInteraction.covered->
        ///forAll( refLifeline : Lifeline | refLifeline.represents = intLifeline.represents and 
        ///(
        ///( refLifeline.selector.oclIsKindOf(LiteralString) implies
        ///  intLifeline.selector.oclIsKindOf(LiteralString) and 
        ///  refLifeline.selector.oclAsType(LiteralString).value = intLifeline.selector.oclAsType(LiteralString).value ) and
        ///( refLifeline.selector.oclIsKindOf(LiteralInteger) implies
        ///  intLifeline.selector.oclIsKindOf(LiteralInteger) and 
        ///  refLifeline.selector.oclAsType(LiteralInteger).value = intLifeline.selector.oclAsType(LiteralInteger).value )
        ///)
        /// implies self.covered->asSet()->includes(intLifeline)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool All_lifelines(object diagnostics, object context);
    }
}

