//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A package can have one or more profile applications to indicate which profiles have been applied. Because a profile is a package, it is possible to apply a profile not only to packages, but also to profiles.
    ///Package specializes TemplateableElement and PackageableElement specializes ParameterableElement to specify that a package can be used as a template and a PackageableElement as a template parameter.
    ///A package is used to group elements, and provides a namespace for the grouped elements.
    ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Package")]
    [DebuggerDisplayAttribute("Package {Name}")]
    public partial class Package : Namespace, IPackage, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _elements_public_or_privateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveElements_public_or_privateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _applyProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveApplyProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedClassOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedClassOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedEnumerationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedEnumerationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedInterfaceOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedInterfaceOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedPrimitiveTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedPrimitiveTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedStereotypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedStereotypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllAppliedProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllAppliedProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllProfileApplicationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllProfileApplicationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfileOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProfileApplicationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProfileApplicationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProfileApplicationOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProfileApplicationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isModelLibraryOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsModelLibraryOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isProfileAppliedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsProfileAppliedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _unapplyProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveUnapplyProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _applyProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveApplyProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allApplicableStereotypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllApplicableStereotypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _makesVisibleOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMakesVisibleOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNestedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNestedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedStereotypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedStereotypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedTypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedTypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _visibleMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveVisibleMembersOperation);
        
        /// <summary>
        /// The backing field for the URI property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _uRI;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _uRIAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveURIAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _nestedPackageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveNestedPackageReference);
        
        /// <summary>
        /// The backing field for the NestedPackage property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackageNestedPackageCollection _nestedPackage;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedStereotypeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedStereotypeReference);
        
        /// <summary>
        /// The backing field for the OwnedStereotype property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IStereotype> _ownedStereotype;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTypeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTypeReference);
        
        /// <summary>
        /// The backing field for the OwnedType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackageOwnedTypeCollection _ownedType;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageMergeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageMergeReference);
        
        /// <summary>
        /// The backing field for the PackageMerge property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackagePackageMergeCollection _packageMerge;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _profileApplicationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveProfileApplicationReference);
        
        /// <summary>
        /// The backing field for the ProfileApplication property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackageProfileApplicationCollection _profileApplication;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _nestingPackageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveNestingPackageReference);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _namespace_needs_visibilityOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNamespace_needs_visibilityOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompatibleWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompatibleWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateParameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateParameterOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningTemplateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the OwningTemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _owningTemplateParameter;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the TemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _templateParameter;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameterableElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameterableElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateBindingReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateBindingReference);
        
        /// <summary>
        /// The backing field for the TemplateBinding property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TemplateableElementTemplateBindingCollection _templateBinding;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTemplateSignatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTemplateSignatureReference);
        
        /// <summary>
        /// The backing field for the OwnedTemplateSignature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateSignature _ownedTemplateSignature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Package()
        {
            this._nestedPackage = new PackageNestedPackageCollection(this);
            this._nestedPackage.CollectionChanging += this.NestedPackageCollectionChanging;
            this._nestedPackage.CollectionChanged += this.NestedPackageCollectionChanged;
            this._ownedStereotype = new ObservableCompositionOrderedSet<IStereotype>(this);
            this._ownedStereotype.CollectionChanging += this.OwnedStereotypeCollectionChanging;
            this._ownedStereotype.CollectionChanged += this.OwnedStereotypeCollectionChanged;
            this._ownedType = new PackageOwnedTypeCollection(this);
            this._ownedType.CollectionChanging += this.OwnedTypeCollectionChanging;
            this._ownedType.CollectionChanged += this.OwnedTypeCollectionChanged;
            this._packageMerge = new PackagePackageMergeCollection(this);
            this._packageMerge.CollectionChanging += this.PackageMergeCollectionChanging;
            this._packageMerge.CollectionChanged += this.PackageMergeCollectionChanged;
            this._profileApplication = new PackageProfileApplicationCollection(this);
            this._profileApplication.CollectionChanging += this.ProfileApplicationCollectionChanging;
            this._profileApplication.CollectionChanged += this.ProfileApplicationCollectionChanged;
            this._templateBinding = new TemplateableElementTemplateBindingCollection(this);
            this._templateBinding.CollectionChanging += this.TemplateBindingCollectionChanging;
            this._templateBinding.CollectionChanged += this.TemplateBindingCollectionChanged;
        }
        
        /// <summary>
        /// Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DescriptionAttribute(@"Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
<p>From package UML::Packages.</p>")]
        [CategoryAttribute("Package")]
        [XmlAttributeAttribute(true)]
        public string URI
        {
            get
            {
                return this._uRI;
            }
            set
            {
                if ((this._uRI != value))
                {
                    string old = this._uRI;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("URI", e, _uRIAttribute);
                    this._uRI = value;
                    this.OnPropertyChanged("URI", e, _uRIAttribute);
                }
            }
        }
        
        /// <summary>
        /// References the packaged elements that are Packages.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("nestedPackage")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("nestingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackage> NestedPackage
        {
            get
            {
                return this._nestedPackage;
            }
        }
        
        /// <summary>
        /// References the Stereotypes that are owned by the Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedStereotype")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IStereotype> OwnedStereotype
        {
            get
            {
                return this._ownedStereotype;
            }
        }
        
        /// <summary>
        /// References the packaged elements that are Types.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("package")]
        [ConstantAttribute()]
        public IOrderedSetExpression<NMF.Interop.Uml.IType> OwnedType
        {
            get
            {
                return this._ownedType;
            }
        }
        
        /// <summary>
        /// References the PackageMerges that are owned by this Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageMerge")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("receivingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackageMerge> PackageMerge
        {
            get
            {
                return this._packageMerge;
            }
        }
        
        /// <summary>
        /// References the ProfileApplications that indicate which profiles have been applied to the Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("profileApplication")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("applyingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IProfileApplication> ProfileApplication
        {
            get
            {
                return this._profileApplication;
            }
        }
        
        /// <summary>
        /// References the Package that owns this Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("nestingPackage")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("nestedPackage")]
        public IPackage NestingPackage
        {
            get
            {
                return ModelHelper.CastAs<IPackage>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        IListExpression<IPackageableElement> IPackage.PackagedElement
        {
            get
            {
                return new PackagePackagedElementCollection(this);
            }
        }
        
        /// <summary>
        /// The formal TemplateParameter that owns this ParameterableElement.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("owningTemplateParameter")]
        [DescriptionAttribute("The formal TemplateParameter that owns this ParameterableElement.\n<p>From package" +
            " UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("owningTemplateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedParameteredElement")]
        public ITemplateParameter OwningTemplateParameter
        {
            get
            {
                return this._owningTemplateParameter;
            }
            set
            {
                if ((this._owningTemplateParameter != value))
                {
                    ITemplateParameter old = this._owningTemplateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwningTemplateParameter", e, _owningTemplateParameterReference);
                    this._owningTemplateParameter = value;
                    if ((old != null))
                    {
                        old.OwnedParameteredElement = null;
                        old.Deleted -= this.OnResetOwningTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.OwnedParameteredElement = this;
                        value.Deleted += this.OnResetOwningTemplateParameter;
                    }
                    this.OnPropertyChanged("OwningTemplateParameter", e, _owningTemplateParameterReference);
                }
            }
        }
        
        /// <summary>
        /// The TemplateParameter that exposes this ParameterableElement as a formal parameter.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("templateParameter")]
        [DescriptionAttribute("The TemplateParameter that exposes this ParameterableElement as a formal paramete" +
            "r.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("templateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("parameteredElement")]
        public ITemplateParameter TemplateParameter
        {
            get
            {
                return this._templateParameter;
            }
            set
            {
                if ((this._templateParameter != value))
                {
                    ITemplateParameter old = this._templateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TemplateParameter", e, _templateParameterReference);
                    this._templateParameter = value;
                    if ((old != null))
                    {
                        old.ParameteredElement = null;
                        old.Deleted -= this.OnResetTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.ParameteredElement = this;
                        value.Deleted += this.OnResetTemplateParameter;
                    }
                    this.OnPropertyChanged("TemplateParameter", e, _templateParameterReference);
                }
            }
        }
        
        ITemplateParameter IParameterableElement.TemplateParameter
        {
            get
            {
                IParameterableElement _this = this;
                return _this.OwningTemplateParameter;
            }
            set
            {
                IParameterableElement _this = this;
                _this.OwningTemplateParameter = value;
            }
        }
        
        /// <summary>
        /// The optional TemplateBindings from this TemplateableElement to one or more templates.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("templateBinding")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("boundElement")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITemplateBinding> TemplateBinding
        {
            get
            {
                return this._templateBinding;
            }
        }
        
        /// <summary>
        /// The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a TemplateableElement has a TemplateSignature, then it is a template.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedTemplateSignature")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("template")]
        public ITemplateSignature OwnedTemplateSignature
        {
            get
            {
                return this._ownedTemplateSignature;
            }
            set
            {
                if ((this._ownedTemplateSignature != value))
                {
                    ITemplateSignature old = this._ownedTemplateSignature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                    this._ownedTemplateSignature = value;
                    if ((old != null))
                    {
                        old.Template = null;
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetOwnedTemplateSignature;
                    }
                    if ((value != null))
                    {
                        value.Template = this;
                        value.Parent = this;
                        value.ParentChanged += this.OnResetOwnedTemplateSignature;
                    }
                    this.OnPropertyChanged("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new PackageChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new PackageReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Package")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// If an element that is owned by a package has visibility, it is public or private.
        ///packagedElement-&gt;forAll(e | e.visibility&lt;&gt; null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Elements_public_or_private(object diagnostics, object context)
        {
            System.Func<IPackage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, object, object, bool>>(_elements_public_or_privateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method elements_public_or_private registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _elements_public_or_privateOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _elements_public_or_privateOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _elements_public_or_privateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveElements_public_or_privateOperation()
        {
            return ClassInstance.LookupOperation("elements_public_or_private");
        }
        
        /// <summary>
        /// Applies the current definition of the specified profile to this package and automatically applies required stereotypes in the profile to elements within this package&apos;s namespace hieararchy. If a different definition is already applied, automatically migrates any associated stereotype values on a &quot;best effort&quot; basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profile">The profile to apply.</param>
        public ISetExpression<IEObject> ApplyProfile(IProfile profile)
        {
            System.Func<IPackage, IProfile, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, ISetExpression<IEObject>>>(_applyProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method applyProfile registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _applyProfileOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _applyProfileOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _applyProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveApplyProfileOperation()
        {
            return ClassInstance.LookupOperation("applyProfile");
        }
        
        /// <summary>
        /// Creates a(n) (abstract) class with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new class, or null.</param>
        /// <param name="isAbstract">Whether the new class should be abstract.</param>
        public NMF.Interop.Uml.IClass CreateOwnedClass(string name, bool isAbstract)
        {
            System.Func<IPackage, string, bool, NMF.Interop.Uml.IClass> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, NMF.Interop.Uml.IClass>>(_createOwnedClassOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedClass registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedClassOperation.Value, name, isAbstract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedClassOperation.Value, e));
            NMF.Interop.Uml.IClass result = handler.Invoke(this, name, isAbstract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedClassOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedClassOperation()
        {
            return ClassInstance.LookupOperation("createOwnedClass");
        }
        
        /// <summary>
        /// Creates a enumeration with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new enumeration, or null.</param>
        public NMF.Interop.Uml.IEnumeration CreateOwnedEnumeration(string name)
        {
            System.Func<IPackage, string, NMF.Interop.Uml.IEnumeration> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, NMF.Interop.Uml.IEnumeration>>(_createOwnedEnumerationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedEnumeration registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedEnumerationOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedEnumerationOperation.Value, e));
            NMF.Interop.Uml.IEnumeration result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedEnumerationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedEnumerationOperation()
        {
            return ClassInstance.LookupOperation("createOwnedEnumeration");
        }
        
        /// <summary>
        /// Creates an interface with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new interface, or null.</param>
        public IInterface CreateOwnedInterface(string name)
        {
            System.Func<IPackage, string, IInterface> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, IInterface>>(_createOwnedInterfaceOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedInterface registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedInterfaceOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedInterfaceOperation.Value, e));
            IInterface result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedInterfaceOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedInterfaceOperation()
        {
            return ClassInstance.LookupOperation("createOwnedInterface");
        }
        
        /// <summary>
        /// Creates a primitive type with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new primitive type, or null.</param>
        public NMF.Interop.Uml.IPrimitiveType CreateOwnedPrimitiveType(string name)
        {
            System.Func<IPackage, string, NMF.Interop.Uml.IPrimitiveType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, NMF.Interop.Uml.IPrimitiveType>>(_createOwnedPrimitiveTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedPrimitiveType registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedPrimitiveTypeOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedPrimitiveTypeOperation.Value, e));
            NMF.Interop.Uml.IPrimitiveType result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedPrimitiveTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedPrimitiveTypeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedPrimitiveType");
        }
        
        /// <summary>
        /// Creates a(n) (abstract) stereotype with the specified name as an owned stereotype of this profile.
        /// </summary>
        /// <param name="name">The name for the new stereotype, or null.</param>
        /// <param name="isAbstract">Whether the new stereotype should be abstract.</param>
        public IStereotype CreateOwnedStereotype(string name, bool isAbstract)
        {
            System.Func<IPackage, string, bool, IStereotype> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, IStereotype>>(_createOwnedStereotypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedStereotype registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedStereotypeOperation.Value, name, isAbstract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedStereotypeOperation.Value, e));
            IStereotype result = handler.Invoke(this, name, isAbstract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedStereotypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedStereotypeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedStereotype");
        }
        
        /// <summary>
        /// Retrieves all the profiles that are applied to this package, including profiles applied to its nesting package(s).
        /// </summary>
        public ISetExpression<IProfile> GetAllAppliedProfiles()
        {
            System.Func<IPackage, ISetExpression<IProfile>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfile>>>(_getAllAppliedProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllAppliedProfiles registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllAppliedProfilesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllAppliedProfilesOperation.Value, e));
            ISetExpression<IProfile> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllAppliedProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllAppliedProfilesOperation()
        {
            return ClassInstance.LookupOperation("getAllAppliedProfiles");
        }
        
        /// <summary>
        /// Retrieves all the profile applications for this package, including profile applications for its nesting package(s).
        /// </summary>
        public ISetExpression<IProfileApplication> GetAllProfileApplications()
        {
            System.Func<IPackage, ISetExpression<IProfileApplication>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfileApplication>>>(_getAllProfileApplicationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllProfileApplications registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllProfileApplicationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllProfileApplicationsOperation.Value, e));
            ISetExpression<IProfileApplication> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllProfileApplicationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllProfileApplicationsOperation()
        {
            return ClassInstance.LookupOperation("getAllProfileApplications");
        }
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        public IProfile GetAppliedProfile(string qualifiedName)
        {
            System.Func<IPackage, string, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, IProfile>>(_getAppliedProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfileOperation.Value, qualifiedName);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfileOperation.Value, e));
            IProfile result = handler.Invoke(this, qualifiedName);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfileOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        public IProfile GetAppliedProfile(string qualifiedName, bool recurse)
        {
            System.Func<IPackage, string, bool, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, IProfile>>(_getAppliedProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfileOperation.Value, qualifiedName, recurse);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfileOperation.Value, e));
            IProfile result = handler.Invoke(this, qualifiedName, recurse);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfileOperation()
        {
            return ClassInstance.LookupOperation("getAppliedProfile");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfileOperation_()
        {
            return ClassInstance.LookupOperation("getAppliedProfile");
        }
        
        /// <summary>
        /// Retrieves the profiles that are applied to this package.
        /// </summary>
        public ISetExpression<IProfile> GetAppliedProfiles()
        {
            System.Func<IPackage, ISetExpression<IProfile>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfile>>>(_getAppliedProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfiles registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfilesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfilesOperation.Value, e));
            ISetExpression<IProfile> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfilesOperation()
        {
            return ClassInstance.LookupOperation("getAppliedProfiles");
        }
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        public IProfileApplication GetProfileApplication(IProfile profile)
        {
            System.Func<IPackage, IProfile, IProfileApplication> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, IProfileApplication>>(_getProfileApplicationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProfileApplication registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProfileApplicationOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProfileApplicationOperation.Value, e));
            IProfileApplication result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProfileApplicationOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        public IProfileApplication GetProfileApplication(IProfile profile, bool recurse)
        {
            System.Func<IPackage, IProfile, bool, IProfileApplication> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, bool, IProfileApplication>>(_getProfileApplicationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProfileApplication registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProfileApplicationOperation.Value, profile, recurse);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProfileApplicationOperation.Value, e));
            IProfileApplication result = handler.Invoke(this, profile, recurse);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProfileApplicationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProfileApplicationOperation()
        {
            return ClassInstance.LookupOperation("getProfileApplication");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProfileApplicationOperation_()
        {
            return ClassInstance.LookupOperation("getProfileApplication");
        }
        
        /// <summary>
        /// Determines whether this package is a model library.
        /// </summary>
        public bool IsModelLibrary()
        {
            System.Func<IPackage, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, bool>>(_isModelLibraryOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isModelLibrary registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isModelLibraryOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isModelLibraryOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isModelLibraryOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsModelLibraryOperation()
        {
            return ClassInstance.LookupOperation("isModelLibrary");
        }
        
        /// <summary>
        /// Determines whether the specified profile is applied to this package.
        /// </summary>
        /// <param name="profile">The profile in question.</param>
        public bool IsProfileApplied(IProfile profile)
        {
            System.Func<IPackage, IProfile, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, bool>>(_isProfileAppliedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isProfileApplied registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isProfileAppliedOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isProfileAppliedOperation.Value, e));
            bool result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isProfileAppliedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsProfileAppliedOperation()
        {
            return ClassInstance.LookupOperation("isProfileApplied");
        }
        
        /// <summary>
        /// Unapplies the specified profile from this package and automatically unapplies stereotypes in the profile from elements within this package&apos;s namespace hieararchy.
        /// </summary>
        /// <param name="profile">The profile to unapply.</param>
        public ISetExpression<IEObject> UnapplyProfile(IProfile profile)
        {
            System.Func<IPackage, IProfile, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, ISetExpression<IEObject>>>(_unapplyProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method unapplyProfile registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _unapplyProfileOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _unapplyProfileOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _unapplyProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveUnapplyProfileOperation()
        {
            return ClassInstance.LookupOperation("unapplyProfile");
        }
        
        /// <summary>
        /// Applies the current definitions of the specified profiles to this package and automatically applies required stereotypes in the profiles to elements within this package&apos;s namespace hieararchy. If different definitions are already applied, automatically migrates any associated stereotype values on a &quot;best effort&quot; basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profiles">The profiles to apply.</param>
        public ISetExpression<IEObject> ApplyProfiles([LowerBoundAttribute(1)] IEnumerable<IProfile> profiles)
        {
            System.Func<IPackage, IEnumerable<IProfile>, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IEnumerable<IProfile>, ISetExpression<IEObject>>>(_applyProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method applyProfiles registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _applyProfilesOperation.Value, profiles);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _applyProfilesOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profiles);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _applyProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveApplyProfilesOperation()
        {
            return ClassInstance.LookupOperation("applyProfiles");
        }
        
        /// <summary>
        /// The query allApplicableStereotypes() returns all the directly or indirectly owned stereotypes, including stereotypes contained in sub-profiles.
        ///result = (let ownedPackages : Bag(Package) = ownedMember-&gt;select(oclIsKindOf(Package))-&gt;collect(oclAsType(Package)) in
        /// ownedStereotype-&gt;union(ownedPackages.allApplicableStereotypes())-&gt;flatten()-&gt;asSet()
        ///)
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IStereotype> AllApplicableStereotypes()
        {
            System.Func<IPackage, ISetExpression<IStereotype>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IStereotype>>>(_allApplicableStereotypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allApplicableStereotypes registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allApplicableStereotypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allApplicableStereotypesOperation.Value, e));
            ISetExpression<IStereotype> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allApplicableStereotypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllApplicableStereotypesOperation()
        {
            return ClassInstance.LookupOperation("allApplicableStereotypes");
        }
        
        /// <summary>
        /// The query containingProfile() returns the closest profile directly or indirectly containing this package (or this package itself, if it is a profile).
        ///result = (if self.oclIsKindOf(Profile) then 
        ///	self.oclAsType(Profile)
        ///else
        ///	self.namespace.oclAsType(Package).containingProfile()
        ///endif)
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public IProfile ContainingProfile()
        {
            System.Func<IPackage, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile>>(_containingProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingProfileOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingProfileOperation.Value, e));
            IProfile result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingProfileOperation()
        {
            return ClassInstance.LookupOperation("containingProfile");
        }
        
        /// <summary>
        /// The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility and elements with public visibility are made visible.
        ///member-&gt;includes(el)
        ///result = (ownedMember-&gt;includes(el) or
        ///(elementImport-&gt;select(ei|ei.importedElement = VisibilityKind::public)-&gt;collect(importedElement.oclAsType(NamedElement))-&gt;includes(el)) or
        ///(packageImport-&gt;select(visibility = VisibilityKind::public)-&gt;collect(importedPackage.member-&gt;includes(el))-&gt;notEmpty()))
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        /// <param name="el"></param>
        public bool MakesVisible(INamedElement el)
        {
            System.Func<IPackage, INamedElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, INamedElement, bool>>(_makesVisibleOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method makesVisible registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _makesVisibleOperation.Value, el);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _makesVisibleOperation.Value, e));
            bool result = handler.Invoke(this, el);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _makesVisibleOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMakesVisibleOperation()
        {
            return ClassInstance.LookupOperation("makesVisible");
        }
        
        /// <summary>
        /// Derivation for Package::/nestedPackage
        ///result = (packagedElement-&gt;select(oclIsKindOf(Package))-&gt;collect(oclAsType(Package))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackage> GetNestedPackages()
        {
            System.Func<IPackage, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IPackage>>>(_getNestedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNestedPackages registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNestedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNestedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNestedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNestedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getNestedPackages");
        }
        
        /// <summary>
        /// Derivation for Package::/ownedStereotype
        ///result = (packagedElement-&gt;select(oclIsKindOf(Stereotype))-&gt;collect(oclAsType(Stereotype))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IStereotype> GetOwnedStereotypes()
        {
            System.Func<IPackage, ISetExpression<IStereotype>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IStereotype>>>(_getOwnedStereotypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedStereotypes registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedStereotypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedStereotypesOperation.Value, e));
            ISetExpression<IStereotype> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedStereotypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedStereotypesOperation()
        {
            return ClassInstance.LookupOperation("getOwnedStereotypes");
        }
        
        /// <summary>
        /// Derivation for Package::/ownedType
        ///result = (packagedElement-&gt;select(oclIsKindOf(Type))-&gt;collect(oclAsType(Type))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IType> GetOwnedTypes()
        {
            System.Func<IPackage, ISetExpression<NMF.Interop.Uml.IType>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<NMF.Interop.Uml.IType>>>(_getOwnedTypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedTypes registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedTypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedTypesOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IType> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedTypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedTypesOperation()
        {
            return ClassInstance.LookupOperation("getOwnedTypes");
        }
        
        /// <summary>
        /// The query visibleMembers() defines which members of a Package can be accessed outside it.
        ///result = (member-&gt;select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))-&gt;collect(oclAsType(PackageableElement))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> VisibleMembers()
        {
            System.Func<IPackage, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IPackageableElement>>>(_visibleMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method visibleMembers registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _visibleMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _visibleMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _visibleMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveVisibleMembersOperation()
        {
            return ClassInstance.LookupOperation("visibleMembers");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveURIAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("URI")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveNestedPackageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("nestedPackage")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the NestedPackage property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void NestedPackageCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("NestedPackage", e, _nestedPackageReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the NestedPackage property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void NestedPackageCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("NestedPackage", e, _nestedPackageReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedStereotypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("ownedStereotype")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedStereotype property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedStereotypeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedStereotype", e, _ownedStereotypeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedStereotype property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedStereotypeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedStereotype", e, _ownedStereotypeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("ownedType")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedType property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedTypeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedType", e, _ownedTypeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedType property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedTypeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedType", e, _ownedTypeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageMergeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("packageMerge")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackageMerge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageMergeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackageMerge", e, _packageMergeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackageMerge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageMergeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackageMerge", e, _packageMergeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveProfileApplicationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("profileApplication")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ProfileApplication property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ProfileApplicationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ProfileApplication", e, _profileApplicationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ProfileApplication property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ProfileApplicationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ProfileApplication", e, _profileApplicationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveNestingPackageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("nestingPackage")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldNestingPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newNestingPackage = ModelHelper.CastAs<IPackage>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldNestingPackage, newNestingPackage);
            this.OnPropertyChanging("NestingPackage", e, _nestingPackageReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldNestingPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newNestingPackage = ModelHelper.CastAs<IPackage>(newParent);
            if ((oldNestingPackage != null))
            {
                oldNestingPackage.NestedPackage.Remove(this);
            }
            if ((newNestingPackage != null))
            {
                newNestingPackage.NestedPackage.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldNestingPackage, newNestingPackage);
            this.OnPropertyChanged("NestingPackage", e, _nestingPackageReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// A PackageableElement owned by a Namespace must have a visibility.
        ///visibility = null implies namespace = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Namespace_needs_visibility(object diagnostics, object context)
        {
            System.Func<IPackageableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackageableElement, object, object, bool>>(_namespace_needs_visibilityOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method namespace_needs_visibility registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _namespace_needs_visibilityOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _namespace_needs_visibilityOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _namespace_needs_visibilityOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNamespace_needs_visibilityOperation()
        {
            return ClassInstance.LookupOperation("namespace_needs_visibility");
        }
        
        /// <summary>
        /// The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified ParameterableElement. By default, this ParameterableElement is compatible with another ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. Subclasses of ParameterableElement should override this operation to specify different compatibility constraints.
        ///result = (self.oclIsKindOf(p.oclType()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="p"></param>
        public bool IsCompatibleWith(IParameterableElement p)
        {
            System.Func<IParameterableElement, IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, IParameterableElement, bool>>(_isCompatibleWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isCompatibleWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompatibleWithOperation.Value, p);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompatibleWithOperation.Value, e));
            bool result = handler.Invoke(this, p);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompatibleWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompatibleWithOperation()
        {
            return ClassInstance.LookupOperation("isCompatibleWith");
        }
        
        /// <summary>
        /// The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal TemplateParameter.
        ///result = (templateParameter-&gt;notEmpty())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplateParameter()
        {
            System.Func<IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, bool>>(_isTemplateParameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplateParameter registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateParameterOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateParameterOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateParameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateParameterOperation()
        {
            return ClassInstance.LookupOperation("isTemplateParameter");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("owningTemplateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the OwningTemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwningTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwningTemplateParameter))
            {
                this.OwningTemplateParameter = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("templateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the TemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.TemplateParameter))
            {
                this.TemplateParameter = null;
            }
        }
        
        /// <summary>
        /// The query isTemplate() returns whether this TemplateableElement is actually a template.
        ///result = (ownedTemplateSignature &lt;&gt; null)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplate()
        {
            System.Func<ITemplateableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, bool>>(_isTemplateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplate registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateOperation()
        {
            return ClassInstance.LookupOperation("isTemplate");
        }
        
        /// <summary>
        /// The query parameterableElements() returns the set of ParameterableElements that may be used as the parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all the ownedElements. Subclasses may override this operation if they choose to restrict the set of ParameterableElements.
        ///result = (self.allOwnedElements()-&gt;select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)-&gt;asSet())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IParameterableElement> ParameterableElements()
        {
            System.Func<ITemplateableElement, ISetExpression<IParameterableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, ISetExpression<IParameterableElement>>>(_parameterableElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameterableElements registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameterableElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameterableElementsOperation.Value, e));
            ISetExpression<IParameterableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameterableElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameterableElementsOperation()
        {
            return ClassInstance.LookupOperation("parameterableElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateBindingReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("templateBinding")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TemplateBinding", e, _templateBindingReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TemplateBinding", e, _templateBindingReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTemplateSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("ownedTemplateSignature")));
        }
        
        /// <summary>
        /// Handles the event that the OwnedTemplateSignature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwnedTemplateSignature(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwnedTemplateSignature))
            {
                this.OwnedTemplateSignature = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int nestedPackageIndex = ModelHelper.IndexOfReference(this.NestedPackage, element);
            if ((nestedPackageIndex != -1))
            {
                return ModelHelper.CreatePath("nestedPackage", nestedPackageIndex);
            }
            int ownedStereotypeIndex = ModelHelper.IndexOfReference(this.OwnedStereotype, element);
            if ((ownedStereotypeIndex != -1))
            {
                return ModelHelper.CreatePath("ownedStereotype", ownedStereotypeIndex);
            }
            int ownedTypeIndex = ModelHelper.IndexOfReference(this.OwnedType, element);
            if ((ownedTypeIndex != -1))
            {
                return ModelHelper.CreatePath("ownedType", ownedTypeIndex);
            }
            int packageMergeIndex = ModelHelper.IndexOfReference(this.PackageMerge, element);
            if ((packageMergeIndex != -1))
            {
                return ModelHelper.CreatePath("packageMerge", packageMergeIndex);
            }
            int profileApplicationIndex = ModelHelper.IndexOfReference(this.ProfileApplication, element);
            if ((profileApplicationIndex != -1))
            {
                return ModelHelper.CreatePath("profileApplication", profileApplicationIndex);
            }
            int templateBindingIndex = ModelHelper.IndexOfReference(this.TemplateBinding, element);
            if ((templateBindingIndex != -1))
            {
                return ModelHelper.CreatePath("templateBinding", templateBindingIndex);
            }
            if ((element == this.OwnedTemplateSignature))
            {
                return ModelHelper.CreatePath("ownedTemplateSignature");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "NESTEDPACKAGE"))
            {
                if ((index < this.NestedPackage.Count))
                {
                    return this.NestedPackage[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDSTEREOTYPE"))
            {
                if ((index < this.OwnedStereotype.Count))
                {
                    return this.OwnedStereotype[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTYPE"))
            {
                if ((index < this.OwnedType.Count))
                {
                    return this.OwnedType[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGEMERGE"))
            {
                if ((index < this.PackageMerge.Count))
                {
                    return this.PackageMerge[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PROFILEAPPLICATION"))
            {
                if ((index < this.ProfileApplication.Count))
                {
                    return this.ProfileApplication[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "NESTINGPACKAGE"))
            {
                return this.NestingPackage;
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return this.OwningTemplateParameter;
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return this.TemplateParameter;
            }
            if ((reference == "TEMPLATEBINDING"))
            {
                if ((index < this.TemplateBinding.Count))
                {
                    return this.TemplateBinding[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return this.OwnedTemplateSignature;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "URI"))
            {
                return this.URI;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "NESTEDPACKAGE"))
            {
                return this._nestedPackage;
            }
            if ((feature == "OWNEDSTEREOTYPE"))
            {
                return this._ownedStereotype;
            }
            if ((feature == "OWNEDTYPE"))
            {
                return this._ownedType;
            }
            if ((feature == "PACKAGEMERGE"))
            {
                return this._packageMerge;
            }
            if ((feature == "PROFILEAPPLICATION"))
            {
                return this._profileApplication;
            }
            if ((feature == "TEMPLATEBINDING"))
            {
                return this._templateBinding;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NESTINGPACKAGE"))
            {
                this.NestingPackage = ((IPackage)(value));
                return;
            }
            if ((feature == "OWNINGTEMPLATEPARAMETER"))
            {
                this.OwningTemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "TEMPLATEPARAMETER"))
            {
                this.TemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "OWNEDTEMPLATESIGNATURE"))
            {
                this.OwnedTemplateSignature = ((ITemplateSignature)(value));
                return;
            }
            if ((feature == "URI"))
            {
                this.URI = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "URI"))
            {
                return new URIProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "NESTINGPACKAGE"))
            {
                return new NestingPackageProxy(this);
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return new OwningTemplateParameterProxy(this);
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return new TemplateParameterProxy(this);
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return new OwnedTemplateSignatureProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._nestedPackage))
            {
                return "nestedPackage";
            }
            if ((container == this._ownedStereotype))
            {
                return "ownedStereotype";
            }
            if ((container == this._ownedType))
            {
                return "ownedType";
            }
            if ((container == this._packageMerge))
            {
                return "packageMerge";
            }
            if ((container == this._profileApplication))
            {
                return "profileApplication";
            }
            if ((container == this._templateBinding))
            {
                return "templateBinding";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Package")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Package class
        /// </summary>
        public class PackageChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Package _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public PackageChildrenCollection(Package parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Package class
        /// </summary>
        public class PackageReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Package _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public PackageReferencedElementsCollection(Package parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the URI property
        /// </summary>
        private sealed class URIProxy : ModelPropertyChange<IPackage, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public URIProxy(IPackage modelElement) : 
                    base(modelElement, "URI")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.URI;
                }
                set
                {
                    this.ModelElement.URI = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the nestingPackage property
        /// </summary>
        private sealed class NestingPackageProxy : ModelPropertyChange<IPackage, IPackage>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NestingPackageProxy(IPackage modelElement) : 
                    base(modelElement, "nestingPackage")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IPackage Value
            {
                get
                {
                    return this.ModelElement.NestingPackage;
                }
                set
                {
                    this.ModelElement.NestingPackage = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningTemplateParameter property
        /// </summary>
        private sealed class OwningTemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningTemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "owningTemplateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.OwningTemplateParameter;
                }
                set
                {
                    this.ModelElement.OwningTemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the templateParameter property
        /// </summary>
        private sealed class TemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "templateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.TemplateParameter;
                }
                set
                {
                    this.ModelElement.TemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the ownedTemplateSignature property
        /// </summary>
        private sealed class OwnedTemplateSignatureProxy : ModelPropertyChange<ITemplateableElement, ITemplateSignature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwnedTemplateSignatureProxy(ITemplateableElement modelElement) : 
                    base(modelElement, "ownedTemplateSignature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateSignature Value
            {
                get
                {
                    return this.ModelElement.OwnedTemplateSignature;
                }
                set
                {
                    this.ModelElement.OwnedTemplateSignature = value;
                }
            }
        }
    }
}
