//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A package can have one or more profile applications to indicate which profiles have been applied. Because a profile is a package, it is possible to apply a profile not only to packages, but also to profiles.
    ///Package specializes TemplateableElement and PackageableElement specializes ParameterableElement to specify that a package can be used as a template and a PackageableElement as a template parameter.
    ///A package is used to group elements, and provides a namespace for the grouped elements.
    ///<p>From package UML::Packages.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Package")]
    [DebuggerDisplayAttribute("Package {Name}")]
    public partial class Package : Namespace, IPackage, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _elements_public_or_privateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveElements_public_or_privateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _applyProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveApplyProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedClassOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedClassOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedEnumerationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedEnumerationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedInterfaceOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedInterfaceOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedPrimitiveTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedPrimitiveTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedStereotypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedStereotypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllAppliedProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllAppliedProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllProfileApplicationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllProfileApplicationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfileOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProfileApplicationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProfileApplicationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProfileApplicationOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProfileApplicationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isModelLibraryOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsModelLibraryOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isProfileAppliedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsProfileAppliedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _unapplyProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveUnapplyProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _applyProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveApplyProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allApplicableStereotypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllApplicableStereotypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _makesVisibleOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMakesVisibleOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNestedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNestedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedStereotypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedStereotypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedTypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedTypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _visibleMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveVisibleMembersOperation);
        
        /// <summary>
        /// The backing field for the URI property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _uRI;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _uRIAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveURIAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageMergeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageMergeReference);
        
        /// <summary>
        /// The backing field for the PackageMerge property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackagePackageMergeCollection _packageMerge;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packagedElementReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackagedElementReference);
        
        /// <summary>
        /// The backing field for the PackagedElement property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IPackageableElement> _packagedElement;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _profileApplicationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveProfileApplicationReference);
        
        /// <summary>
        /// The backing field for the ProfileApplication property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackageProfileApplicationCollection _profileApplication;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _namespace_needs_visibilityOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNamespace_needs_visibilityOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompatibleWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompatibleWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateParameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateParameterOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningTemplateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningTemplateParameterReference);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the TemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _templateParameter;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameterableElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameterableElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateBindingReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateBindingReference);
        
        /// <summary>
        /// The backing field for the TemplateBinding property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TemplateableElementTemplateBindingCollection _templateBinding;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTemplateSignatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTemplateSignatureReference);
        
        /// <summary>
        /// The backing field for the OwnedTemplateSignature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateSignature _ownedTemplateSignature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Package()
        {
            this._packageMerge = new PackagePackageMergeCollection(this);
            this._packageMerge.CollectionChanging += this.PackageMergeCollectionChanging;
            this._packageMerge.CollectionChanged += this.PackageMergeCollectionChanged;
            this._packagedElement = new ObservableCompositionOrderedSet<IPackageableElement>(this);
            this._packagedElement.CollectionChanging += this.PackagedElementCollectionChanging;
            this._packagedElement.CollectionChanged += this.PackagedElementCollectionChanged;
            this._profileApplication = new PackageProfileApplicationCollection(this);
            this._profileApplication.CollectionChanging += this.ProfileApplicationCollectionChanging;
            this._profileApplication.CollectionChanged += this.ProfileApplicationCollectionChanged;
            this._templateBinding = new TemplateableElementTemplateBindingCollection(this);
            this._templateBinding.CollectionChanging += this.TemplateBindingCollectionChanging;
            this._templateBinding.CollectionChanged += this.TemplateBindingCollectionChanged;
        }
        
        /// <summary>
        /// Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DescriptionAttribute(@"Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
<p>From package UML::Packages.</p>")]
        [CategoryAttribute("Package")]
        [XmlAttributeAttribute(true)]
        public string URI
        {
            get
            {
                return this._uRI;
            }
            set
            {
                if ((this._uRI != value))
                {
                    string old = this._uRI;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("URI", e, _uRIAttribute);
                    this._uRI = value;
                    this.OnPropertyChanged("URI", e, _uRIAttribute);
                }
            }
        }
        
        /// <summary>
        /// References the PackageMerges that are owned by this Package.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageMerge")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("receivingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackageMerge> PackageMerge
        {
            get
            {
                return this._packageMerge;
            }
        }
        
        /// <summary>
        /// Specifies the packageable elements that are owned by this Package.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packagedElement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackageableElement> PackagedElement
        {
            get
            {
                return this._packagedElement;
            }
        }
        
        /// <summary>
        /// References the ProfileApplications that indicate which profiles have been applied to the Package.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("profileApplication")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("applyingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IProfileApplication> ProfileApplication
        {
            get
            {
                return this._profileApplication;
            }
        }
        
        /// <summary>
        /// The formal TemplateParameter that owns this ParameterableElement.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("owningTemplateParameter")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedParameteredElement")]
        public ITemplateParameter OwningTemplateParameter
        {
            get
            {
                return ModelHelper.CastAs<ITemplateParameter>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// The TemplateParameter that exposes this ParameterableElement as a formal parameter.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DisplayNameAttribute("templateParameter")]
        [DescriptionAttribute("The TemplateParameter that exposes this ParameterableElement as a formal paramete" +
            "r.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("templateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("parameteredElement")]
        public ITemplateParameter TemplateParameter
        {
            get
            {
                return this._templateParameter;
            }
            set
            {
                if ((this._templateParameter != value))
                {
                    ITemplateParameter old = this._templateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TemplateParameter", e, _templateParameterReference);
                    this._templateParameter = value;
                    if ((old != null))
                    {
                        old.ParameteredElement = null;
                        old.Deleted -= this.OnResetTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.ParameteredElement = this;
                        value.Deleted += this.OnResetTemplateParameter;
                    }
                    this.OnPropertyChanged("TemplateParameter", e, _templateParameterReference);
                }
            }
        }
        
        /// <summary>
        /// The optional TemplateBindings from this TemplateableElement to one or more templates.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("templateBinding")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("boundElement")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITemplateBinding> TemplateBinding
        {
            get
            {
                return this._templateBinding;
            }
        }
        
        /// <summary>
        /// The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a TemplateableElement has a TemplateSignature, then it is a template.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedTemplateSignature")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("template")]
        public ITemplateSignature OwnedTemplateSignature
        {
            get
            {
                return this._ownedTemplateSignature;
            }
            set
            {
                if ((this._ownedTemplateSignature != value))
                {
                    ITemplateSignature old = this._ownedTemplateSignature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                    this._ownedTemplateSignature = value;
                    if ((old != null))
                    {
                        old.Template = null;
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetOwnedTemplateSignature;
                    }
                    if ((value != null))
                    {
                        value.Template = this;
                        value.Parent = this;
                        value.ParentChanged += this.OnResetOwnedTemplateSignature;
                    }
                    this.OnPropertyChanged("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new PackageChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new PackageReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Package")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// If an element that is owned by a package has visibility, it is public or private.
        ///packagedElement->forAll(e | e.visibility<> null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Elements_public_or_private(object diagnostics, object context)
        {
            System.Func<IPackage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, object, object, bool>>(_elements_public_or_privateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method elements_public_or_private registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _elements_public_or_privateOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _elements_public_or_privateOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _elements_public_or_privateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveElements_public_or_privateOperation()
        {
            return ClassInstance.LookupOperation("elements_public_or_private");
        }
        
        /// <summary>
        /// Applies the current definition of the specified profile to this package and automatically applies required stereotypes in the profile to elements within this package's namespace hieararchy. If a different definition is already applied, automatically migrates any associated stereotype values on a "best effort" basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profile">The profile to apply.</param>
        public ISetExpression<IEObject> ApplyProfile(IProfile profile)
        {
            System.Func<IPackage, IProfile, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, ISetExpression<IEObject>>>(_applyProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method applyProfile registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _applyProfileOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _applyProfileOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _applyProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveApplyProfileOperation()
        {
            return ClassInstance.LookupOperation("applyProfile");
        }
        
        /// <summary>
        /// Creates a(n) (abstract) class with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new class, or null.</param>
        /// <param name="isAbstract">Whether the new class should be abstract.</param>
        public NMF.Interop.Uml.IClass CreateOwnedClass(string name, bool isAbstract)
        {
            System.Func<IPackage, string, bool, NMF.Interop.Uml.IClass> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, NMF.Interop.Uml.IClass>>(_createOwnedClassOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedClass registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedClassOperation.Value, name, isAbstract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedClassOperation.Value, e));
            NMF.Interop.Uml.IClass result = handler.Invoke(this, name, isAbstract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedClassOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedClassOperation()
        {
            return ClassInstance.LookupOperation("createOwnedClass");
        }
        
        /// <summary>
        /// Creates a enumeration with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new enumeration, or null.</param>
        public NMF.Interop.Uml.IEnumeration CreateOwnedEnumeration(string name)
        {
            System.Func<IPackage, string, NMF.Interop.Uml.IEnumeration> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, NMF.Interop.Uml.IEnumeration>>(_createOwnedEnumerationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedEnumeration registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedEnumerationOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedEnumerationOperation.Value, e));
            NMF.Interop.Uml.IEnumeration result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedEnumerationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedEnumerationOperation()
        {
            return ClassInstance.LookupOperation("createOwnedEnumeration");
        }
        
        /// <summary>
        /// Creates an interface with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new interface, or null.</param>
        public IInterface CreateOwnedInterface(string name)
        {
            System.Func<IPackage, string, IInterface> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, IInterface>>(_createOwnedInterfaceOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedInterface registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedInterfaceOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedInterfaceOperation.Value, e));
            IInterface result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedInterfaceOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedInterfaceOperation()
        {
            return ClassInstance.LookupOperation("createOwnedInterface");
        }
        
        /// <summary>
        /// Creates a primitive type with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new primitive type, or null.</param>
        public NMF.Interop.Uml.IPrimitiveType CreateOwnedPrimitiveType(string name)
        {
            System.Func<IPackage, string, NMF.Interop.Uml.IPrimitiveType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, NMF.Interop.Uml.IPrimitiveType>>(_createOwnedPrimitiveTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedPrimitiveType registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedPrimitiveTypeOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedPrimitiveTypeOperation.Value, e));
            NMF.Interop.Uml.IPrimitiveType result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedPrimitiveTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedPrimitiveTypeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedPrimitiveType");
        }
        
        /// <summary>
        /// Creates a(n) (abstract) stereotype with the specified name as an owned stereotype of this profile.
        /// </summary>
        /// <param name="name">The name for the new stereotype, or null.</param>
        /// <param name="isAbstract">Whether the new stereotype should be abstract.</param>
        public IStereotype CreateOwnedStereotype(string name, bool isAbstract)
        {
            System.Func<IPackage, string, bool, IStereotype> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, IStereotype>>(_createOwnedStereotypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedStereotype registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedStereotypeOperation.Value, name, isAbstract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedStereotypeOperation.Value, e));
            IStereotype result = handler.Invoke(this, name, isAbstract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedStereotypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedStereotypeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedStereotype");
        }
        
        /// <summary>
        /// Retrieves all the profiles that are applied to this package, including profiles applied to its nesting package(s).
        /// </summary>
        public ISetExpression<IProfile> GetAllAppliedProfiles()
        {
            System.Func<IPackage, ISetExpression<IProfile>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfile>>>(_getAllAppliedProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllAppliedProfiles registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllAppliedProfilesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllAppliedProfilesOperation.Value, e));
            ISetExpression<IProfile> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllAppliedProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllAppliedProfilesOperation()
        {
            return ClassInstance.LookupOperation("getAllAppliedProfiles");
        }
        
        /// <summary>
        /// Retrieves all the profile applications for this package, including profile applications for its nesting package(s).
        /// </summary>
        public ISetExpression<IProfileApplication> GetAllProfileApplications()
        {
            System.Func<IPackage, ISetExpression<IProfileApplication>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfileApplication>>>(_getAllProfileApplicationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllProfileApplications registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllProfileApplicationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllProfileApplicationsOperation.Value, e));
            ISetExpression<IProfileApplication> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllProfileApplicationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllProfileApplicationsOperation()
        {
            return ClassInstance.LookupOperation("getAllProfileApplications");
        }
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        public IProfile GetAppliedProfile(string qualifiedName)
        {
            System.Func<IPackage, string, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, IProfile>>(_getAppliedProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfileOperation.Value, qualifiedName);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfileOperation.Value, e));
            IProfile result = handler.Invoke(this, qualifiedName);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfileOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        public IProfile GetAppliedProfile(string qualifiedName, bool recurse)
        {
            System.Func<IPackage, string, bool, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, IProfile>>(_getAppliedProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfileOperation.Value, qualifiedName, recurse);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfileOperation.Value, e));
            IProfile result = handler.Invoke(this, qualifiedName, recurse);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfileOperation()
        {
            return ClassInstance.LookupOperation("getAppliedProfile");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfileOperation_()
        {
            return ClassInstance.LookupOperation("getAppliedProfile");
        }
        
        /// <summary>
        /// Retrieves the profiles that are applied to this package.
        /// </summary>
        public ISetExpression<IProfile> GetAppliedProfiles()
        {
            System.Func<IPackage, ISetExpression<IProfile>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfile>>>(_getAppliedProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfiles registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfilesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfilesOperation.Value, e));
            ISetExpression<IProfile> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfilesOperation()
        {
            return ClassInstance.LookupOperation("getAppliedProfiles");
        }
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        public IProfileApplication GetProfileApplication(IProfile profile)
        {
            System.Func<IPackage, IProfile, IProfileApplication> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, IProfileApplication>>(_getProfileApplicationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProfileApplication registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProfileApplicationOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProfileApplicationOperation.Value, e));
            IProfileApplication result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProfileApplicationOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        public IProfileApplication GetProfileApplication(IProfile profile, bool recurse)
        {
            System.Func<IPackage, IProfile, bool, IProfileApplication> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, bool, IProfileApplication>>(_getProfileApplicationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProfileApplication registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProfileApplicationOperation.Value, profile, recurse);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProfileApplicationOperation.Value, e));
            IProfileApplication result = handler.Invoke(this, profile, recurse);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProfileApplicationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProfileApplicationOperation()
        {
            return ClassInstance.LookupOperation("getProfileApplication");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProfileApplicationOperation_()
        {
            return ClassInstance.LookupOperation("getProfileApplication");
        }
        
        /// <summary>
        /// Determines whether this package is a model library.
        /// </summary>
        public bool IsModelLibrary()
        {
            System.Func<IPackage, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, bool>>(_isModelLibraryOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isModelLibrary registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isModelLibraryOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isModelLibraryOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isModelLibraryOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsModelLibraryOperation()
        {
            return ClassInstance.LookupOperation("isModelLibrary");
        }
        
        /// <summary>
        /// Determines whether the specified profile is applied to this package.
        /// </summary>
        /// <param name="profile">The profile in question.</param>
        public bool IsProfileApplied(IProfile profile)
        {
            System.Func<IPackage, IProfile, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, bool>>(_isProfileAppliedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isProfileApplied registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isProfileAppliedOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isProfileAppliedOperation.Value, e));
            bool result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isProfileAppliedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsProfileAppliedOperation()
        {
            return ClassInstance.LookupOperation("isProfileApplied");
        }
        
        /// <summary>
        /// Unapplies the specified profile from this package and automatically unapplies stereotypes in the profile from elements within this package's namespace hieararchy.
        /// </summary>
        /// <param name="profile">The profile to unapply.</param>
        public ISetExpression<IEObject> UnapplyProfile(IProfile profile)
        {
            System.Func<IPackage, IProfile, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, ISetExpression<IEObject>>>(_unapplyProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method unapplyProfile registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _unapplyProfileOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _unapplyProfileOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _unapplyProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveUnapplyProfileOperation()
        {
            return ClassInstance.LookupOperation("unapplyProfile");
        }
        
        /// <summary>
        /// Applies the current definitions of the specified profiles to this package and automatically applies required stereotypes in the profiles to elements within this package's namespace hieararchy. If different definitions are already applied, automatically migrates any associated stereotype values on a "best effort" basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profiles">The profiles to apply.</param>
        public ISetExpression<IEObject> ApplyProfiles([LowerBoundAttribute(1)] IEnumerable<IProfile> profiles)
        {
            System.Func<IPackage, IEnumerable<IProfile>, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IEnumerable<IProfile>, ISetExpression<IEObject>>>(_applyProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method applyProfiles registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _applyProfilesOperation.Value, profiles);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _applyProfilesOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profiles);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _applyProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveApplyProfilesOperation()
        {
            return ClassInstance.LookupOperation("applyProfiles");
        }
        
        /// <summary>
        /// The query allApplicableStereotypes() returns all the directly or indirectly owned stereotypes, including stereotypes contained in sub-profiles.
        ///result = (let ownedPackages : Bag(Package) = ownedMember->select(oclIsKindOf(Package))->collect(oclAsType(Package)) in
        /// ownedStereotype->union(ownedPackages.allApplicableStereotypes())->flatten()->asSet()
        ///)
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public ISetExpression<IStereotype> AllApplicableStereotypes()
        {
            System.Func<IPackage, ISetExpression<IStereotype>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IStereotype>>>(_allApplicableStereotypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allApplicableStereotypes registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allApplicableStereotypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allApplicableStereotypesOperation.Value, e));
            ISetExpression<IStereotype> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allApplicableStereotypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllApplicableStereotypesOperation()
        {
            return ClassInstance.LookupOperation("allApplicableStereotypes");
        }
        
        /// <summary>
        /// The query containingProfile() returns the closest profile directly or indirectly containing this package (or this package itself, if it is a profile).
        ///result = (if self.oclIsKindOf(Profile) then 
        ///	self.oclAsType(Profile)
        ///else
        ///	self.namespace.oclAsType(Package).containingProfile()
        ///endif)
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public IProfile ContainingProfile()
        {
            System.Func<IPackage, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile>>(_containingProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingProfileOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingProfileOperation.Value, e));
            IProfile result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingProfileOperation()
        {
            return ClassInstance.LookupOperation("containingProfile");
        }
        
        /// <summary>
        /// The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility and elements with public visibility are made visible.
        ///member->includes(el)
        ///result = (ownedMember->includes(el) or
        ///(elementImport->select(ei|ei.importedElement = VisibilityKind::public)->collect(importedElement.oclAsType(NamedElement))->includes(el)) or
        ///(packageImport->select(visibility = VisibilityKind::public)->collect(importedPackage.member->includes(el))->notEmpty()))
        ///<p>From package UML::Packages.</p>
        /// </summary>
        /// <param name="el"></param>
        public bool MakesVisible(INamedElement el)
        {
            System.Func<IPackage, INamedElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, INamedElement, bool>>(_makesVisibleOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method makesVisible registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _makesVisibleOperation.Value, el);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _makesVisibleOperation.Value, e));
            bool result = handler.Invoke(this, el);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _makesVisibleOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMakesVisibleOperation()
        {
            return ClassInstance.LookupOperation("makesVisible");
        }
        
        /// <summary>
        /// Derivation for Package::/nestedPackage
        ///result = (packagedElement->select(oclIsKindOf(Package))->collect(oclAsType(Package))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public ISetExpression<IPackage> GetNestedPackages()
        {
            System.Func<IPackage, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IPackage>>>(_getNestedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNestedPackages registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNestedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNestedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNestedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNestedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getNestedPackages");
        }
        
        /// <summary>
        /// Derivation for Package::/ownedStereotype
        ///result = (packagedElement->select(oclIsKindOf(Stereotype))->collect(oclAsType(Stereotype))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public ISetExpression<IStereotype> GetOwnedStereotypes()
        {
            System.Func<IPackage, ISetExpression<IStereotype>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IStereotype>>>(_getOwnedStereotypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedStereotypes registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedStereotypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedStereotypesOperation.Value, e));
            ISetExpression<IStereotype> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedStereotypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedStereotypesOperation()
        {
            return ClassInstance.LookupOperation("getOwnedStereotypes");
        }
        
        /// <summary>
        /// Derivation for Package::/ownedType
        ///result = (packagedElement->select(oclIsKindOf(Type))->collect(oclAsType(Type))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IType> GetOwnedTypes()
        {
            System.Func<IPackage, ISetExpression<NMF.Interop.Uml.IType>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<NMF.Interop.Uml.IType>>>(_getOwnedTypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedTypes registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedTypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedTypesOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IType> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedTypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedTypesOperation()
        {
            return ClassInstance.LookupOperation("getOwnedTypes");
        }
        
        /// <summary>
        /// The query visibleMembers() defines which members of a Package can be accessed outside it.
        ///result = (member->select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))->collect(oclAsType(PackageableElement))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public ISetExpression<IPackageableElement> VisibleMembers()
        {
            System.Func<IPackage, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IPackageableElement>>>(_visibleMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method visibleMembers registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _visibleMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _visibleMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _visibleMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveVisibleMembersOperation()
        {
            return ClassInstance.LookupOperation("visibleMembers");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveURIAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("URI")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageMergeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("packageMerge")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackageMerge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageMergeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackageMerge", e, _packageMergeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackageMerge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageMergeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackageMerge", e, _packageMergeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackagedElementReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("packagedElement")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackagedElement property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackagedElementCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackagedElement", e, _packagedElementReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackagedElement property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackagedElementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackagedElement", e, _packagedElementReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveProfileApplicationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("profileApplication")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ProfileApplication property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ProfileApplicationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ProfileApplication", e, _profileApplicationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ProfileApplication property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ProfileApplicationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ProfileApplication", e, _profileApplicationReference);
        }
        
        /// <summary>
        /// A PackageableElement owned by a Namespace must have a visibility.
        ///visibility = null implies namespace = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Namespace_needs_visibility(object diagnostics, object context)
        {
            System.Func<IPackageableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackageableElement, object, object, bool>>(_namespace_needs_visibilityOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method namespace_needs_visibility registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _namespace_needs_visibilityOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _namespace_needs_visibilityOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _namespace_needs_visibilityOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNamespace_needs_visibilityOperation()
        {
            return ClassInstance.LookupOperation("namespace_needs_visibility");
        }
        
        /// <summary>
        /// The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified ParameterableElement. By default, this ParameterableElement is compatible with another ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. Subclasses of ParameterableElement should override this operation to specify different compatibility constraints.
        ///result = (self.oclIsKindOf(p.oclType()))
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        /// <param name="p"></param>
        public bool IsCompatibleWith(IParameterableElement p)
        {
            System.Func<IParameterableElement, IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, IParameterableElement, bool>>(_isCompatibleWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isCompatibleWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompatibleWithOperation.Value, p);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompatibleWithOperation.Value, e));
            bool result = handler.Invoke(this, p);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompatibleWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompatibleWithOperation()
        {
            return ClassInstance.LookupOperation("isCompatibleWith");
        }
        
        /// <summary>
        /// The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal TemplateParameter.
        ///result = (templateParameter->notEmpty())
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public bool IsTemplateParameter()
        {
            System.Func<IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, bool>>(_isTemplateParameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplateParameter registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateParameterOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateParameterOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateParameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateParameterOperation()
        {
            return ClassInstance.LookupOperation("isTemplateParameter");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("owningTemplateParameter")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            ITemplateParameter oldOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(oldParent);
            ITemplateParameter newOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldOwningTemplateParameter, newOwningTemplateParameter);
            this.OnPropertyChanging("OwningTemplateParameter", e, _owningTemplateParameterReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            ITemplateParameter oldOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(oldParent);
            ITemplateParameter newOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(newParent);
            if ((oldOwningTemplateParameter != null))
            {
                oldOwningTemplateParameter.OwnedParameteredElement = null;
            }
            if ((newOwningTemplateParameter != null))
            {
                newOwningTemplateParameter.OwnedParameteredElement = this;
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldOwningTemplateParameter, newOwningTemplateParameter);
            this.OnPropertyChanged("OwningTemplateParameter", e, _owningTemplateParameterReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("templateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the TemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            this.TemplateParameter = null;
        }
        
        /// <summary>
        /// The query isTemplate() returns whether this TemplateableElement is actually a template.
        ///result = (ownedTemplateSignature <> null)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public bool IsTemplate()
        {
            System.Func<ITemplateableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, bool>>(_isTemplateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplate registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateOperation()
        {
            return ClassInstance.LookupOperation("isTemplate");
        }
        
        /// <summary>
        /// The query parameterableElements() returns the set of ParameterableElements that may be used as the parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all the ownedElements. Subclasses may override this operation if they choose to restrict the set of ParameterableElements.
        ///result = (self.allOwnedElements()->select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)->asSet())
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public ISetExpression<IParameterableElement> ParameterableElements()
        {
            System.Func<ITemplateableElement, ISetExpression<IParameterableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, ISetExpression<IParameterableElement>>>(_parameterableElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameterableElements registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameterableElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameterableElementsOperation.Value, e));
            ISetExpression<IParameterableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameterableElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameterableElementsOperation()
        {
            return ClassInstance.LookupOperation("parameterableElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateBindingReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("templateBinding")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TemplateBinding", e, _templateBindingReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TemplateBinding", e, _templateBindingReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTemplateSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("ownedTemplateSignature")));
        }
        
        /// <summary>
        /// Handles the event that the OwnedTemplateSignature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwnedTemplateSignature(object sender, System.EventArgs eventArgs)
        {
            this.OwnedTemplateSignature = null;
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int packageMergeIndex = ModelHelper.IndexOfReference(this.PackageMerge, element);
            if ((packageMergeIndex != -1))
            {
                return ModelHelper.CreatePath("packageMerge", packageMergeIndex);
            }
            int packagedElementIndex = ModelHelper.IndexOfReference(this.PackagedElement, element);
            if ((packagedElementIndex != -1))
            {
                return ModelHelper.CreatePath("packagedElement", packagedElementIndex);
            }
            int profileApplicationIndex = ModelHelper.IndexOfReference(this.ProfileApplication, element);
            if ((profileApplicationIndex != -1))
            {
                return ModelHelper.CreatePath("profileApplication", profileApplicationIndex);
            }
            int templateBindingIndex = ModelHelper.IndexOfReference(this.TemplateBinding, element);
            if ((templateBindingIndex != -1))
            {
                return ModelHelper.CreatePath("templateBinding", templateBindingIndex);
            }
            if ((element == this.OwnedTemplateSignature))
            {
                return ModelHelper.CreatePath("ownedTemplateSignature");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "PACKAGEMERGE"))
            {
                if ((index < this.PackageMerge.Count))
                {
                    return this.PackageMerge[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGEDELEMENT"))
            {
                if ((index < this.PackagedElement.Count))
                {
                    return this.PackagedElement[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PROFILEAPPLICATION"))
            {
                if ((index < this.ProfileApplication.Count))
                {
                    return this.ProfileApplication[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return this.OwningTemplateParameter;
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return this.TemplateParameter;
            }
            if ((reference == "TEMPLATEBINDING"))
            {
                if ((index < this.TemplateBinding.Count))
                {
                    return this.TemplateBinding[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return this.OwnedTemplateSignature;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "URI"))
            {
                return this.URI;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "PACKAGEMERGE"))
            {
                return this._packageMerge;
            }
            if ((feature == "PACKAGEDELEMENT"))
            {
                return this._packagedElement;
            }
            if ((feature == "PROFILEAPPLICATION"))
            {
                return this._profileApplication;
            }
            if ((feature == "TEMPLATEBINDING"))
            {
                return this._templateBinding;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "OWNINGTEMPLATEPARAMETER"))
            {
                this.OwningTemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "TEMPLATEPARAMETER"))
            {
                this.TemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "OWNEDTEMPLATESIGNATURE"))
            {
                this.OwnedTemplateSignature = ((ITemplateSignature)(value));
                return;
            }
            if ((feature == "URI"))
            {
                this.URI = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "URI"))
            {
                return new URIProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return new OwningTemplateParameterProxy(this);
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return new TemplateParameterProxy(this);
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return new OwnedTemplateSignatureProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._packageMerge))
            {
                return "packageMerge";
            }
            if ((container == this._packagedElement))
            {
                return "packagedElement";
            }
            if ((container == this._profileApplication))
            {
                return "profileApplication";
            }
            if ((container == this._templateBinding))
            {
                return "templateBinding";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Package")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Package class
        /// </summary>
        public class PackageChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Package _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public PackageChildrenCollection(Package parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.PackageMerge.Count);
                    count = (count + this._parent.PackagedElement.Count);
                    count = (count + this._parent.ProfileApplication.Count);
                    count = (count + this._parent.TemplateBinding.Count);
                    if ((this._parent.OwnedTemplateSignature != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.PackageMerge.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.PackagedElement.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.ProfileApplication.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.PackageMerge.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.PackagedElement.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.ProfileApplication.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IPackageMerge packageMergeCasted = item.As<IPackageMerge>();
                if ((packageMergeCasted != null))
                {
                    this._parent.PackageMerge.Add(packageMergeCasted);
                }
                IPackageableElement packagedElementCasted = item.As<IPackageableElement>();
                if ((packagedElementCasted != null))
                {
                    this._parent.PackagedElement.Add(packagedElementCasted);
                }
                IProfileApplication profileApplicationCasted = item.As<IProfileApplication>();
                if ((profileApplicationCasted != null))
                {
                    this._parent.ProfileApplication.Add(profileApplicationCasted);
                }
                ITemplateBinding templateBindingCasted = item.As<ITemplateBinding>();
                if ((templateBindingCasted != null))
                {
                    this._parent.TemplateBinding.Add(templateBindingCasted);
                }
                if ((this._parent.OwnedTemplateSignature == null))
                {
                    ITemplateSignature ownedTemplateSignatureCasted = item.As<ITemplateSignature>();
                    if ((ownedTemplateSignatureCasted != null))
                    {
                        this._parent.OwnedTemplateSignature = ownedTemplateSignatureCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.PackageMerge.Clear();
                this._parent.PackagedElement.Clear();
                this._parent.ProfileApplication.Clear();
                this._parent.TemplateBinding.Clear();
                this._parent.OwnedTemplateSignature = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.PackageMerge.Contains(item))
                {
                    return true;
                }
                if (this._parent.PackagedElement.Contains(item))
                {
                    return true;
                }
                if (this._parent.ProfileApplication.Contains(item))
                {
                    return true;
                }
                if (this._parent.TemplateBinding.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.OwnedTemplateSignature))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> packageMergeEnumerator = this._parent.PackageMerge.GetEnumerator();
                try
                {
                    for (
                    ; packageMergeEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = packageMergeEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    packageMergeEnumerator.Dispose();
                }
                IEnumerator<IModelElement> packagedElementEnumerator = this._parent.PackagedElement.GetEnumerator();
                try
                {
                    for (
                    ; packagedElementEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = packagedElementEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    packagedElementEnumerator.Dispose();
                }
                IEnumerator<IModelElement> profileApplicationEnumerator = this._parent.ProfileApplication.GetEnumerator();
                try
                {
                    for (
                    ; profileApplicationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = profileApplicationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    profileApplicationEnumerator.Dispose();
                }
                IEnumerator<IModelElement> templateBindingEnumerator = this._parent.TemplateBinding.GetEnumerator();
                try
                {
                    for (
                    ; templateBindingEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = templateBindingEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    templateBindingEnumerator.Dispose();
                }
                if ((this._parent.OwnedTemplateSignature != null))
                {
                    array[arrayIndex] = this._parent.OwnedTemplateSignature;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IPackageMerge packageMergeItem = item.As<IPackageMerge>();
                if (((packageMergeItem != null) 
                            && this._parent.PackageMerge.Remove(packageMergeItem)))
                {
                    return true;
                }
                IPackageableElement packageableElementItem = item.As<IPackageableElement>();
                if (((packageableElementItem != null) 
                            && this._parent.PackagedElement.Remove(packageableElementItem)))
                {
                    return true;
                }
                IProfileApplication profileApplicationItem = item.As<IProfileApplication>();
                if (((profileApplicationItem != null) 
                            && this._parent.ProfileApplication.Remove(profileApplicationItem)))
                {
                    return true;
                }
                ITemplateBinding templateBindingItem = item.As<ITemplateBinding>();
                if (((templateBindingItem != null) 
                            && this._parent.TemplateBinding.Remove(templateBindingItem)))
                {
                    return true;
                }
                if ((this._parent.OwnedTemplateSignature == item))
                {
                    this._parent.OwnedTemplateSignature = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.PackageMerge).Concat(this._parent.PackagedElement).Concat(this._parent.ProfileApplication).Concat(this._parent.TemplateBinding).Concat(this._parent.OwnedTemplateSignature).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Package class
        /// </summary>
        public class PackageReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Package _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public PackageReferencedElementsCollection(Package parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.PackageMerge.Count);
                    count = (count + this._parent.PackagedElement.Count);
                    count = (count + this._parent.ProfileApplication.Count);
                    if ((this._parent.OwningTemplateParameter != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.TemplateParameter != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.TemplateBinding.Count);
                    if ((this._parent.OwnedTemplateSignature != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.PackageMerge.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.PackagedElement.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.ProfileApplication.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.PackageMerge.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.PackagedElement.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.ProfileApplication.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IPackageMerge packageMergeCasted = item.As<IPackageMerge>();
                if ((packageMergeCasted != null))
                {
                    this._parent.PackageMerge.Add(packageMergeCasted);
                }
                IPackageableElement packagedElementCasted = item.As<IPackageableElement>();
                if ((packagedElementCasted != null))
                {
                    this._parent.PackagedElement.Add(packagedElementCasted);
                }
                IProfileApplication profileApplicationCasted = item.As<IProfileApplication>();
                if ((profileApplicationCasted != null))
                {
                    this._parent.ProfileApplication.Add(profileApplicationCasted);
                }
                if ((this._parent.OwningTemplateParameter == null))
                {
                    ITemplateParameter owningTemplateParameterCasted = item.As<ITemplateParameter>();
                    if ((owningTemplateParameterCasted != null))
                    {
                        this._parent.OwningTemplateParameter = owningTemplateParameterCasted;
                        return;
                    }
                }
                if ((this._parent.TemplateParameter == null))
                {
                    ITemplateParameter templateParameterCasted = item.As<ITemplateParameter>();
                    if ((templateParameterCasted != null))
                    {
                        this._parent.TemplateParameter = templateParameterCasted;
                        return;
                    }
                }
                ITemplateBinding templateBindingCasted = item.As<ITemplateBinding>();
                if ((templateBindingCasted != null))
                {
                    this._parent.TemplateBinding.Add(templateBindingCasted);
                }
                if ((this._parent.OwnedTemplateSignature == null))
                {
                    ITemplateSignature ownedTemplateSignatureCasted = item.As<ITemplateSignature>();
                    if ((ownedTemplateSignatureCasted != null))
                    {
                        this._parent.OwnedTemplateSignature = ownedTemplateSignatureCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.PackageMerge.Clear();
                this._parent.PackagedElement.Clear();
                this._parent.ProfileApplication.Clear();
                this._parent.OwningTemplateParameter = null;
                this._parent.TemplateParameter = null;
                this._parent.TemplateBinding.Clear();
                this._parent.OwnedTemplateSignature = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.PackageMerge.Contains(item))
                {
                    return true;
                }
                if (this._parent.PackagedElement.Contains(item))
                {
                    return true;
                }
                if (this._parent.ProfileApplication.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.OwningTemplateParameter))
                {
                    return true;
                }
                if ((item == this._parent.TemplateParameter))
                {
                    return true;
                }
                if (this._parent.TemplateBinding.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.OwnedTemplateSignature))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> packageMergeEnumerator = this._parent.PackageMerge.GetEnumerator();
                try
                {
                    for (
                    ; packageMergeEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = packageMergeEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    packageMergeEnumerator.Dispose();
                }
                IEnumerator<IModelElement> packagedElementEnumerator = this._parent.PackagedElement.GetEnumerator();
                try
                {
                    for (
                    ; packagedElementEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = packagedElementEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    packagedElementEnumerator.Dispose();
                }
                IEnumerator<IModelElement> profileApplicationEnumerator = this._parent.ProfileApplication.GetEnumerator();
                try
                {
                    for (
                    ; profileApplicationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = profileApplicationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    profileApplicationEnumerator.Dispose();
                }
                if ((this._parent.OwningTemplateParameter != null))
                {
                    array[arrayIndex] = this._parent.OwningTemplateParameter;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.TemplateParameter != null))
                {
                    array[arrayIndex] = this._parent.TemplateParameter;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> templateBindingEnumerator = this._parent.TemplateBinding.GetEnumerator();
                try
                {
                    for (
                    ; templateBindingEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = templateBindingEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    templateBindingEnumerator.Dispose();
                }
                if ((this._parent.OwnedTemplateSignature != null))
                {
                    array[arrayIndex] = this._parent.OwnedTemplateSignature;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IPackageMerge packageMergeItem = item.As<IPackageMerge>();
                if (((packageMergeItem != null) 
                            && this._parent.PackageMerge.Remove(packageMergeItem)))
                {
                    return true;
                }
                IPackageableElement packageableElementItem = item.As<IPackageableElement>();
                if (((packageableElementItem != null) 
                            && this._parent.PackagedElement.Remove(packageableElementItem)))
                {
                    return true;
                }
                IProfileApplication profileApplicationItem = item.As<IProfileApplication>();
                if (((profileApplicationItem != null) 
                            && this._parent.ProfileApplication.Remove(profileApplicationItem)))
                {
                    return true;
                }
                if ((this._parent.OwningTemplateParameter == item))
                {
                    this._parent.OwningTemplateParameter = null;
                    return true;
                }
                if ((this._parent.TemplateParameter == item))
                {
                    this._parent.TemplateParameter = null;
                    return true;
                }
                ITemplateBinding templateBindingItem = item.As<ITemplateBinding>();
                if (((templateBindingItem != null) 
                            && this._parent.TemplateBinding.Remove(templateBindingItem)))
                {
                    return true;
                }
                if ((this._parent.OwnedTemplateSignature == item))
                {
                    this._parent.OwnedTemplateSignature = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.PackageMerge).Concat(this._parent.PackagedElement).Concat(this._parent.ProfileApplication).Concat(this._parent.OwningTemplateParameter).Concat(this._parent.TemplateParameter).Concat(this._parent.TemplateBinding).Concat(this._parent.OwnedTemplateSignature).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the URI property
        /// </summary>
        private sealed class URIProxy : ModelPropertyChange<IPackage, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public URIProxy(IPackage modelElement) : 
                    base(modelElement, "URI")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.URI;
                }
                set
                {
                    this.ModelElement.URI = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningTemplateParameter property
        /// </summary>
        private sealed class OwningTemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningTemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "owningTemplateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.OwningTemplateParameter;
                }
                set
                {
                    this.ModelElement.OwningTemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the templateParameter property
        /// </summary>
        private sealed class TemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "templateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.TemplateParameter;
                }
                set
                {
                    this.ModelElement.TemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the ownedTemplateSignature property
        /// </summary>
        private sealed class OwnedTemplateSignatureProxy : ModelPropertyChange<ITemplateableElement, ITemplateSignature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwnedTemplateSignatureProxy(ITemplateableElement modelElement) : 
                    base(modelElement, "ownedTemplateSignature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateSignature Value
            {
                get
                {
                    return this.ModelElement.OwnedTemplateSignature;
                }
                set
                {
                    this.ModelElement.OwnedTemplateSignature = value;
                }
            }
        }
    }
}

