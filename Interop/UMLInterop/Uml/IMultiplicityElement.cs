//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for MultiplicityElement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(MultiplicityElement))]
    [XmlDefaultImplementationTypeAttribute(typeof(MultiplicityElement))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//MultiplicityElement")]
    public interface IMultiplicityElement : IModelElement, IElement
    {
        
        /// <summary>
        /// For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this MultiplicityElement are sequentially ordered.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isOrdered")]
        [DescriptionAttribute("For a multivalued multiplicity, this attribute specifies whether the values in an" +
            " instantiation of this MultiplicityElement are sequentially ordered.\n<p>From pac" +
            "kage UML::CommonStructure.</p>")]
        [CategoryAttribute("MultiplicityElement")]
        [XmlElementNameAttribute("isOrdered")]
        [XmlAttributeAttribute(true)]
        bool IsOrdered
        {
            get;
            set;
        }
        
        /// <summary>
        /// For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of this MultiplicityElement are unique.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(true)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isUnique")]
        [DescriptionAttribute("For a multivalued multiplicity, this attributes specifies whether the values in a" +
            "n instantiation of this MultiplicityElement are unique.\n<p>From package UML::Com" +
            "monStructure.</p>")]
        [CategoryAttribute("MultiplicityElement")]
        [XmlElementNameAttribute("isUnique")]
        [XmlAttributeAttribute(true)]
        bool IsUnique
        {
            get;
            set;
        }
        
        /// <summary>
        /// The specification of the lower bound for this multiplicity.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("lowerValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification LowerValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// The specification of the upper bound for this multiplicity.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("upperValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification UpperValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// The upper bound must be greater than or equal to the lower bound.
        ///upperBound() &gt;= lowerBound()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Upper_ge_lower(object diagnostics, object context);
        
        /// <summary>
        /// The lower bound must be a non-negative integer literal.
        ///lowerBound() &gt;= 0
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Lower_ge_0(object diagnostics, object context);
        
        /// <summary>
        /// If a non-literal ValueSpecification is used for lowerValue or upperValue, then evaluating that specification must not have side effects.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Value_specification_no_side_effects(object diagnostics, object context);
        
        /// <summary>
        /// If a non-literal ValueSpecification is used for lowerValue or upperValue, then that specification must be a constant expression.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Value_specification_constant(object diagnostics, object context);
        
        /// <summary>
        /// If it is not empty, then lowerValue must have an Integer value.
        ///lowerValue &lt;&gt; null implies lowerValue.integerValue() &lt;&gt; null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Lower_is_integer(object diagnostics, object context);
        
        /// <summary>
        /// If it is not empty, then upperValue must have an UnlimitedNatural value.
        ///upperValue &lt;&gt; null implies upperValue.unlimitedValue() &lt;&gt; null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Upper_is_unlimitedNatural(object diagnostics, object context);
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newLower"></param>
        void SetLower(int newLower);
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newUpper"></param>
        void SetUpper(object newUpper);
        
        /// <summary>
        /// The operation compatibleWith takes another multiplicity as input. It returns true if the other multiplicity is wider than, or the same as, self.
        ///result = ((other.lowerBound() &lt;= self.lowerBound()) and ((other.upperBound() = *) or (self.upperBound() &lt;= other.upperBound())))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="other"></param>
        bool CompatibleWith(IMultiplicityElement other);
        
        /// <summary>
        /// The query includesMultiplicity() checks whether this multiplicity includes all the cardinalities allowed by the specified multiplicity.
        ///self.upperBound()-&gt;notEmpty() and self.lowerBound()-&gt;notEmpty() and M.upperBound()-&gt;notEmpty() and M.lowerBound()-&gt;notEmpty()
        ///result = ((self.lowerBound() &lt;= M.lowerBound()) and (self.upperBound() &gt;= M.upperBound()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="m"></param>
        bool IncludesMultiplicity(IMultiplicityElement m);
        
        /// <summary>
        /// The operation is determines if the upper and lower bound of the ranges are the ones given.
        ///result = (lowerbound = self.lowerBound() and upperbound = self.upperBound())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="lowerbound"></param>
        /// <param name="upperbound"></param>
        bool Is(int lowerbound, object upperbound);
        
        /// <summary>
        /// The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
        ///upperBound()-&gt;notEmpty()
        ///result = (upperBound() &gt; 1)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        bool IsMultivalued();
        
        /// <summary>
        /// The derived lower attribute must equal the lowerBound.
        ///result = (lowerBound())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        int GetLower();
        
        /// <summary>
        /// The query lowerBound() returns the lower bound of the multiplicity as an integer, which is the integerValue of lowerValue, if this is given, and 1 otherwise.
        ///result = (if (lowerValue=null or lowerValue.integerValue()=null) then 1 else lowerValue.integerValue() endif)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        int LowerBound();
        
        /// <summary>
        /// The derived upper attribute must equal the upperBound.
        ///result = (upperBound())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        void GetUpper();
        
        /// <summary>
        /// The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited natural, which is the unlimitedNaturalValue of upperValue, if given, and 1, otherwise.
        ///result = (if (upperValue=null or upperValue.unlimitedValue()=null) then 1 else upperValue.unlimitedValue() endif)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        void UpperBound();
    }
}
