//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A ProtocolTransition specifies a legal Transition for an Operation. Transitions of ProtocolStateMachines have the following information: a pre-condition (guard), a Trigger, and a post-condition. Every ProtocolTransition is associated with at most one BehavioralFeature belonging to the context Classifier of the ProtocolStateMachine.
    ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//ProtocolTransition")]
    [DebuggerDisplayAttribute("ProtocolTransition {Name}")]
    public partial class ProtocolTransition : RedefinableElement, IProtocolTransition, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _refers_to_operationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRefers_to_operationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _associated_actionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAssociated_actionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _belongs_to_psmOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBelongs_to_psmOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getReferredsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetReferredsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _postConditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePostConditionReference);
        
        /// <summary>
        /// The backing field for the PostCondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _postCondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _preConditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePreConditionReference);
        
        /// <summary>
        /// The backing field for the PreCondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _preCondition;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _state_is_externalOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveState_is_externalOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _join_segment_guardsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveJoin_segment_guardsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _state_is_internalOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveState_is_internalOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _outgoing_pseudostatesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOutgoing_pseudostatesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _join_segment_stateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveJoin_segment_stateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _fork_segment_stateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveFork_segment_stateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _state_is_localOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveState_is_localOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _initial_transitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInitial_transitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _fork_segment_guardsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveFork_segment_guardsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingStateMachineOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingStateMachineOperation);
        
        /// <summary>
        /// The backing field for the Kind property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TransitionKind _kind = TransitionKind.External;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _kindAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveKindAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _effectReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveEffectReference);
        
        /// <summary>
        /// The backing field for the Effect property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _effect;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedTransitionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedTransitionReference);
        
        /// <summary>
        /// The backing field for the RedefinedTransition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITransition _redefinedTransition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _sourceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSourceReference);
        
        /// <summary>
        /// The backing field for the Source property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IVertex _source;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _targetReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTargetReference);
        
        /// <summary>
        /// The backing field for the Target property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IVertex _target;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _triggerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTriggerReference);
        
        /// <summary>
        /// The backing field for the Trigger property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<ITrigger> _trigger;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _containerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveContainerReference);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _members_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembers_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_selfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_selfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_ownedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_ownedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createElementImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateElementImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createPackageImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreatePackageImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedElementsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _excludeCollisionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveExcludeCollisionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNamesOfMemberOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNamesOfMemberOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _importMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveImportMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _membersAreDistinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembersAreDistinguishableOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _elementImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveElementImportReference);
        
        /// <summary>
        /// The backing field for the ElementImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespaceElementImportCollection _elementImport;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageImportReference);
        
        /// <summary>
        /// The backing field for the PackageImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespacePackageImportCollection _packageImport;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public ProtocolTransition()
        {
            this._trigger = new ObservableCompositionOrderedSet<ITrigger>(this);
            this._trigger.CollectionChanging += this.TriggerCollectionChanging;
            this._trigger.CollectionChanged += this.TriggerCollectionChanged;
            this._elementImport = new NamespaceElementImportCollection(this);
            this._elementImport.CollectionChanging += this.ElementImportCollectionChanging;
            this._elementImport.CollectionChanged += this.ElementImportCollectionChanged;
            this._packageImport = new NamespacePackageImportCollection(this);
            this._packageImport.CollectionChanging += this.PackageImportCollectionChanging;
            this._packageImport.CollectionChanged += this.PackageImportCollectionChanged;
        }
        
        /// <summary>
        /// Specifies the post condition of the Transition which is the Condition that should be obtained once the Transition is triggered. This post condition is part of the post condition of the Operation connected to the Transition.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("postCondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IConstraint PostCondition
        {
            get
            {
                return this._postCondition;
            }
            set
            {
                if ((this._postCondition != value))
                {
                    IConstraint old = this._postCondition;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("PostCondition", e, _postConditionReference);
                    this._postCondition = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetPostCondition;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetPostCondition;
                    }
                    this.OnPropertyChanged("PostCondition", e, _postConditionReference);
                }
            }
        }
        
        /// <summary>
        /// Specifies the precondition of the Transition. It specifies the Condition that should be verified before triggering the Transition. This guard condition added to the source State will be evaluated as part of the precondition of the Operation referred by the Transition if any.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("preCondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IConstraint PreCondition
        {
            get
            {
                return this._preCondition;
            }
            set
            {
                if ((this._preCondition != value))
                {
                    IConstraint old = this._preCondition;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("PreCondition", e, _preConditionReference);
                    this._preCondition = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetPreCondition;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetPreCondition;
                    }
                    this.OnPropertyChanged("PreCondition", e, _preConditionReference);
                }
            }
        }
        
        IListExpression<IConstraint> NMF.Interop.Uml.INamespace.OwnedRule
        {
            get
            {
                return new ProtocolTransitionOwnedRuleCollection(this);
            }
        }
        
        IConstraint ITransition.Guard
        {
            get
            {
                IProtocolTransition _this = this;
                return _this.PreCondition;
            }
            set
            {
                IProtocolTransition _this = this;
                _this.PreCondition = value;
            }
        }
        
        /// <summary>
        /// Indicates the precise type of the Transition.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(TransitionKind.External)]
        [DisplayNameAttribute("kind")]
        [DescriptionAttribute("Indicates the precise type of the Transition.\n<p>From package UML::StateMachines." +
            "</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("kind")]
        [XmlAttributeAttribute(true)]
        public TransitionKind Kind
        {
            get
            {
                return this._kind;
            }
            set
            {
                if ((this._kind != value))
                {
                    TransitionKind old = this._kind;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Kind", e, _kindAttribute);
                    this._kind = value;
                    this.OnPropertyChanged("Kind", e, _kindAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies an optional behavior to be performed when the Transition fires.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("effect")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior Effect
        {
            get
            {
                return this._effect;
            }
            set
            {
                if ((this._effect != value))
                {
                    IBehavior old = this._effect;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Effect", e, _effectReference);
                    this._effect = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetEffect;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetEffect;
                    }
                    this.OnPropertyChanged("Effect", e, _effectReference);
                }
            }
        }
        
        /// <summary>
        /// The Transition that is redefined by this Transition.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("redefinedTransition")]
        [DescriptionAttribute("The Transition that is redefined by this Transition.\n<p>From package UML::StateMa" +
            "chines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("redefinedTransition")]
        [XmlAttributeAttribute(true)]
        public ITransition RedefinedTransition
        {
            get
            {
                return this._redefinedTransition;
            }
            set
            {
                if ((this._redefinedTransition != value))
                {
                    ITransition old = this._redefinedTransition;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("RedefinedTransition", e, _redefinedTransitionReference);
                    this._redefinedTransition = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetRedefinedTransition;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetRedefinedTransition;
                    }
                    this.OnPropertyChanged("RedefinedTransition", e, _redefinedTransitionReference);
                }
            }
        }
        
        /// <summary>
        /// Designates the originating Vertex (State or Pseudostate) of the Transition.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("source")]
        [DescriptionAttribute("Designates the originating Vertex (State or Pseudostate) of the Transition.\n<p>Fr" +
            "om package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("source")]
        [XmlAttributeAttribute(true)]
        public IVertex Source
        {
            get
            {
                return this._source;
            }
            set
            {
                if ((this._source != value))
                {
                    IVertex old = this._source;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Source", e, _sourceReference);
                    this._source = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetSource;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetSource;
                    }
                    this.OnPropertyChanged("Source", e, _sourceReference);
                }
            }
        }
        
        /// <summary>
        /// Designates the target Vertex that is reached when the Transition is taken.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("target")]
        [DescriptionAttribute("Designates the target Vertex that is reached when the Transition is taken.\n<p>Fro" +
            "m package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(true)]
        public IVertex Target
        {
            get
            {
                return this._target;
            }
            set
            {
                if ((this._target != value))
                {
                    IVertex old = this._target;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Target", e, _targetReference);
                    this._target = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetTarget;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetTarget;
                    }
                    this.OnPropertyChanged("Target", e, _targetReference);
                }
            }
        }
        
        /// <summary>
        /// Specifies the Triggers that may fire the transition.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("trigger")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITrigger> Trigger
        {
            get
            {
                return this._trigger;
            }
        }
        
        /// <summary>
        /// Designates the Region that owns this Transition.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("container")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("transition")]
        public IRegion Container
        {
            get
            {
                return ModelHelper.CastAs<IRegion>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// References the ElementImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("elementImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IElementImport> ElementImport
        {
            get
            {
                return this._elementImport;
            }
        }
        
        /// <summary>
        /// References the PackageImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IPackageImport> PackageImport
        {
            get
            {
                return this._packageImport;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ProtocolTransitionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ProtocolTransitionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//ProtocolTransition")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// If a ProtocolTransition refers to an Operation (i.e., has a CallEvent trigger corresponding to an Operation), then that Operation should apply to the context Classifier of the StateMachine of the ProtocolTransition.
        ///if (referred()-&gt;notEmpty() and containingStateMachine()._&apos;context&apos;-&gt;notEmpty()) then 
        ///    containingStateMachine()._&apos;context&apos;.oclAsType(BehavioredClassifier).allFeatures()-&gt;includesAll(referred())
        ///else true endif
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Refers_to_operation(object diagnostics, object context)
        {
            System.Func<IProtocolTransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProtocolTransition, object, object, bool>>(_refers_to_operationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method refers_to_operation registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _refers_to_operationOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _refers_to_operationOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _refers_to_operationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRefers_to_operationOperation()
        {
            return ClassInstance.LookupOperation("refers_to_operation");
        }
        
        /// <summary>
        /// A ProtocolTransition never has associated Behaviors.
        ///effect = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Associated_actions(object diagnostics, object context)
        {
            System.Func<IProtocolTransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProtocolTransition, object, object, bool>>(_associated_actionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method associated_actions registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _associated_actionsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _associated_actionsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _associated_actionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAssociated_actionsOperation()
        {
            return ClassInstance.LookupOperation("associated_actions");
        }
        
        /// <summary>
        /// A ProtocolTransition always belongs to a ProtocolStateMachine.
        ///container.belongsToPSM()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Belongs_to_psm(object diagnostics, object context)
        {
            System.Func<IProtocolTransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProtocolTransition, object, object, bool>>(_belongs_to_psmOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method belongs_to_psm registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _belongs_to_psmOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _belongs_to_psmOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _belongs_to_psmOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBelongs_to_psmOperation()
        {
            return ClassInstance.LookupOperation("belongs_to_psm");
        }
        
        /// <summary>
        /// Derivation for ProtocolTransition::/referred
        ///result = (trigger-&gt;collect(event)-&gt;select(oclIsKindOf(CallEvent))-&gt;collect(oclAsType(CallEvent).operation)-&gt;asSet())
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IOperation> GetReferreds()
        {
            System.Func<IProtocolTransition, ISetExpression<NMF.Interop.Uml.IOperation>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProtocolTransition, ISetExpression<NMF.Interop.Uml.IOperation>>>(_getReferredsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getReferreds registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getReferredsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getReferredsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IOperation> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getReferredsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetReferredsOperation()
        {
            return ClassInstance.LookupOperation("getReferreds");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePostConditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ProtocolTransition.ClassInstance)).Resolve("postCondition")));
        }
        
        /// <summary>
        /// Handles the event that the PostCondition property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetPostCondition(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.PostCondition))
            {
                this.PostCondition = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePreConditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ProtocolTransition.ClassInstance)).Resolve("preCondition")));
        }
        
        /// <summary>
        /// Handles the event that the PreCondition property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetPreCondition(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.PreCondition))
            {
                this.PreCondition = null;
            }
        }
        
        /// <summary>
        /// A Transition with kind external can source any Vertex except entry points.
        ///(kind = TransitionKind::external) implies
        ///	not (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool State_is_external(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_state_is_externalOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method state_is_external registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _state_is_externalOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _state_is_externalOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _state_is_externalOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveState_is_externalOperation()
        {
            return ClassInstance.LookupOperation("state_is_external");
        }
        
        /// <summary>
        /// A join segment must not have Guards or Triggers.
        ///(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (guard = null and trigger-&gt;isEmpty())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Join_segment_guards(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_join_segment_guardsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method join_segment_guards registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _join_segment_guardsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _join_segment_guardsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _join_segment_guardsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveJoin_segment_guardsOperation()
        {
            return ClassInstance.LookupOperation("join_segment_guards");
        }
        
        /// <summary>
        /// A Transition with kind internal must have a State as its source, and its source and target must be equal.
        ///(kind = TransitionKind::internal) implies
        ///		(source.oclIsKindOf (State) and source = target)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool State_is_internal(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_state_is_internalOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method state_is_internal registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _state_is_internalOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _state_is_internalOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _state_is_internalOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveState_is_internalOperation()
        {
            return ClassInstance.LookupOperation("state_is_internal");
        }
        
        /// <summary>
        /// Transitions outgoing Pseudostates may not have a Trigger.
        ///source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind &lt;&gt; PseudostateKind::initial) implies trigger-&gt;isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Outgoing_pseudostates(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_outgoing_pseudostatesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method outgoing_pseudostates registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _outgoing_pseudostatesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _outgoing_pseudostatesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _outgoing_pseudostatesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOutgoing_pseudostatesOperation()
        {
            return ClassInstance.LookupOperation("outgoing_pseudostates");
        }
        
        /// <summary>
        /// A join segment must always originate from a State.
        ///(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (source.oclIsKindOf(State))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Join_segment_state(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_join_segment_stateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method join_segment_state registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _join_segment_stateOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _join_segment_stateOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _join_segment_stateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveJoin_segment_stateOperation()
        {
            return ClassInstance.LookupOperation("join_segment_state");
        }
        
        /// <summary>
        /// A fork segment must always target a State.
        ///(source.oclIsKindOf(Pseudostate) and  source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (target.oclIsKindOf(State))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Fork_segment_state(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_fork_segment_stateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method fork_segment_state registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _fork_segment_stateOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _fork_segment_stateOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _fork_segment_stateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveFork_segment_stateOperation()
        {
            return ClassInstance.LookupOperation("fork_segment_state");
        }
        
        /// <summary>
        /// A Transition with kind local must have a composite State or an entry point as its source.
        ///(kind = TransitionKind::local) implies
        ///		((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or
        ///		(source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool State_is_local(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_state_is_localOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method state_is_local registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _state_is_localOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _state_is_localOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _state_is_localOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveState_is_localOperation()
        {
            return ClassInstance.LookupOperation("state_is_local");
        }
        
        /// <summary>
        /// An initial Transition at the topmost level Region of a StateMachine that has no Trigger.
        ///(source.oclIsKindOf(Pseudostate) and container.stateMachine-&gt;notEmpty()) implies
        ///	trigger-&gt;isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Initial_transition(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_initial_transitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method initial_transition registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _initial_transitionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _initial_transitionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _initial_transitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInitial_transitionOperation()
        {
            return ClassInstance.LookupOperation("initial_transition");
        }
        
        /// <summary>
        /// A fork segment must not have Guards or Triggers.
        ///(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (guard = null and trigger-&gt;isEmpty())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Fork_segment_guards(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_fork_segment_guardsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method fork_segment_guards registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _fork_segment_guardsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _fork_segment_guardsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _fork_segment_guardsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveFork_segment_guardsOperation()
        {
            return ClassInstance.LookupOperation("fork_segment_guards");
        }
        
        /// <summary>
        /// The query containingStateMachine() returns the StateMachine that contains the Transition either directly or transitively.
        ///result = (container.containingStateMachine())
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        public IStateMachine ContainingStateMachine()
        {
            System.Func<ITransition, IStateMachine> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, IStateMachine>>(_containingStateMachineOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingStateMachine registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingStateMachineOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingStateMachineOperation.Value, e));
            IStateMachine result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingStateMachineOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingStateMachineOperation()
        {
            return ClassInstance.LookupOperation("containingStateMachine");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveKindAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("kind")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveEffectReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("effect")));
        }
        
        /// <summary>
        /// Handles the event that the Effect property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetEffect(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Effect))
            {
                this.Effect = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedTransitionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("redefinedTransition")));
        }
        
        /// <summary>
        /// Handles the event that the RedefinedTransition property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRedefinedTransition(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.RedefinedTransition))
            {
                this.RedefinedTransition = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSourceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("source")));
        }
        
        /// <summary>
        /// Handles the event that the Source property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSource(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Source))
            {
                this.Source = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTargetReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("target")));
        }
        
        /// <summary>
        /// Handles the event that the Target property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTarget(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Target))
            {
                this.Target = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTriggerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("trigger")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Trigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TriggerCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Trigger", e, _triggerReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Trigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TriggerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Trigger", e, _triggerReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveContainerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("container")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanging("Container", e, _containerReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            if ((oldContainer != null))
            {
                oldContainer.Transition.Remove(this);
            }
            if ((newContainer != null))
            {
                newContainer.Transition.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanged("Container", e, _containerReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// All the members of a Namespace are distinguishable within it.
        ///membersAreDistinguishable()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Members_distinguishable(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_members_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method members_distinguishable registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _members_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _members_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _members_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembers_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("members_distinguishable");
        }
        
        /// <summary>
        /// A Namespace cannot have a PackageImport to itself.
        ///packageImport.importedPackage.oclAsType(Namespace)-&gt;excludes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_self(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_selfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_self registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_selfOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_selfOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_selfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_selfOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_self");
        }
        
        /// <summary>
        /// A Namespace cannot have an ElementImport to one of its ownedMembers.
        ///elementImport.importedElement.oclAsType(Element)-&gt;excludesAll(ownedMember)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_ownedMembers(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_ownedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_ownedMembers registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_ownedMembersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_ownedMembersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_ownedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_ownedMembersOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_ownedMembers");
        }
        
        /// <summary>
        /// Creates an import of the specified element into this namespace with the specified visibility.
        /// </summary>
        /// <param name="element">The element to import.</param>
        /// <param name="visibility">The visibility for the new element import.</param>
        public IElementImport CreateElementImport(IPackageableElement element, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport>>(_createElementImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createElementImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createElementImportOperation.Value, element, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createElementImportOperation.Value, e));
            IElementImport result = handler.Invoke(this, element, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createElementImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateElementImportOperation()
        {
            return ClassInstance.LookupOperation("createElementImport");
        }
        
        /// <summary>
        /// Creates an import of the specified package into this namespace with the specified visibility.
        /// </summary>
        /// <param name="package_">The package to import.</param>
        /// <param name="visibility">The visibility for the new package import.</param>
        public IPackageImport CreatePackageImport(IPackage package_, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport>>(_createPackageImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createPackageImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createPackageImportOperation.Value, package_, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createPackageImportOperation.Value, e));
            IPackageImport result = handler.Invoke(this, package_, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createPackageImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreatePackageImportOperation()
        {
            return ClassInstance.LookupOperation("createPackageImport");
        }
        
        /// <summary>
        /// Retrieves the elements imported by this namespace.
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedElements()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedElements registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedElementsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedElementsOperation()
        {
            return ClassInstance.LookupOperation("getImportedElements");
        }
        
        /// <summary>
        /// Retrieves the packages imported by this namespace.
        /// </summary>
        public ISetExpression<IPackage> GetImportedPackages()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>>>(_getImportedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedPackages registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getImportedPackages");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public ISetExpression<INamedElement> GetOwnedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>>>(_getOwnedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedMembers registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedMembersOperation()
        {
            return ClassInstance.LookupOperation("getOwnedMembers");
        }
        
        /// <summary>
        /// The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this Namespace.
        ///result = (imps-&gt;reject(imp1  | imps-&gt;exists(imp2 | not imp1.isDistinguishableFrom(imp2, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ExcludeCollisions(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_excludeCollisionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method excludeCollisions registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _excludeCollisionsOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _excludeCollisionsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _excludeCollisionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveExcludeCollisionsOperation()
        {
            return ClassInstance.LookupOperation("excludeCollisions");
        }
        
        /// <summary>
        /// The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace, taking importing into account. In general a member can have multiple names in a Namespace if it is imported more than once with different aliases.
        ///result = (if self.ownedMember -&gt;includes(element)
        ///then Set{element.name}
        ///else let elementImports : Set(ElementImport) = self.elementImport-&gt;select(ei | ei.importedElement = element) in
        ///  if elementImports-&gt;notEmpty()
        ///  then
        ///     elementImports-&gt;collect(el | el.getName())-&gt;asSet()
        ///  else 
        ///     self.packageImport-&gt;select(pi | pi.importedPackage.visibleMembers().oclAsType(NamedElement)-&gt;includes(element))-&gt; collect(pi | pi.importedPackage.getNamesOfMember(element))-&gt;asSet()
        ///  endif
        ///endif)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="element"></param>
        public ISetExpression<string> GetNamesOfMember(INamedElement element)
        {
            System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>>>(_getNamesOfMemberOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNamesOfMember registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNamesOfMemberOperation.Value, element);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNamesOfMemberOperation.Value, e));
            ISetExpression<string> result = handler.Invoke(this, element);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNamesOfMemberOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNamesOfMemberOperation()
        {
            return ClassInstance.LookupOperation("getNamesOfMember");
        }
        
        /// <summary>
        /// The query importMembers() defines which of a set of PackageableElements are actually imported into the Namespace. This excludes hidden ones, i.e., those which have names that conflict with names of ownedMembers, and it also excludes PackageableElements that would have the indistinguishable names when imported.
        ///result = (self.excludeCollisions(imps)-&gt;select(imp | self.ownedMember-&gt;forAll(mem | imp.isDistinguishableFrom(mem, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ImportMembers(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_importMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method importMembers registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _importMembersOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _importMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _importMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveImportMembersOperation()
        {
            return ClassInstance.LookupOperation("importMembers");
        }
        
        /// <summary>
        /// The importedMember property is derived as the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
        ///result = (self.importMembers(elementImport.importedElement-&gt;asSet()-&gt;union(packageImport.importedPackage-&gt;collect(p | p.visibleMembers()))-&gt;asSet()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedMembersOperation()
        {
            return ClassInstance.LookupOperation("getImportedMembers");
        }
        
        /// <summary>
        /// The Boolean query membersAreDistinguishable() determines whether all of the Namespace&apos;s members are distinguishable within it.
        ///result = (member-&gt;forAll( memb |
        ///   member-&gt;excluding(memb)-&gt;forAll(other |
        ///       memb.isDistinguishableFrom(other, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool MembersAreDistinguishable()
        {
            System.Func<NMF.Interop.Uml.INamespace, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, bool>>(_membersAreDistinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method membersAreDistinguishable registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _membersAreDistinguishableOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _membersAreDistinguishableOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _membersAreDistinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembersAreDistinguishableOperation()
        {
            return ClassInstance.LookupOperation("membersAreDistinguishable");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveElementImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("elementImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ElementImport", e, _elementImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ElementImport", e, _elementImportReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("packageImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.PostCondition))
            {
                return ModelHelper.CreatePath("postCondition");
            }
            if ((element == this.PreCondition))
            {
                return ModelHelper.CreatePath("preCondition");
            }
            if ((element == this.Effect))
            {
                return ModelHelper.CreatePath("effect");
            }
            int triggerIndex = ModelHelper.IndexOfReference(this.Trigger, element);
            if ((triggerIndex != -1))
            {
                return ModelHelper.CreatePath("trigger", triggerIndex);
            }
            int elementImportIndex = ModelHelper.IndexOfReference(this.ElementImport, element);
            if ((elementImportIndex != -1))
            {
                return ModelHelper.CreatePath("elementImport", elementImportIndex);
            }
            int packageImportIndex = ModelHelper.IndexOfReference(this.PackageImport, element);
            if ((packageImportIndex != -1))
            {
                return ModelHelper.CreatePath("packageImport", packageImportIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "POSTCONDITION"))
            {
                return this.PostCondition;
            }
            if ((reference == "PRECONDITION"))
            {
                return this.PreCondition;
            }
            if ((reference == "EFFECT"))
            {
                return this.Effect;
            }
            if ((reference == "REDEFINEDTRANSITION"))
            {
                return this.RedefinedTransition;
            }
            if ((reference == "SOURCE"))
            {
                return this.Source;
            }
            if ((reference == "TARGET"))
            {
                return this.Target;
            }
            if ((reference == "TRIGGER"))
            {
                if ((index < this.Trigger.Count))
                {
                    return this.Trigger[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CONTAINER"))
            {
                return this.Container;
            }
            if ((reference == "ELEMENTIMPORT"))
            {
                if ((index < this.ElementImport.Count))
                {
                    return this.ElementImport[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGEIMPORT"))
            {
                if ((index < this.PackageImport.Count))
                {
                    return this.PackageImport[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "KIND"))
            {
                return this.Kind;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "TRIGGER"))
            {
                return this._trigger;
            }
            if ((feature == "ELEMENTIMPORT"))
            {
                return this._elementImport;
            }
            if ((feature == "PACKAGEIMPORT"))
            {
                return this._packageImport;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "POSTCONDITION"))
            {
                this.PostCondition = ((IConstraint)(value));
                return;
            }
            if ((feature == "PRECONDITION"))
            {
                this.PreCondition = ((IConstraint)(value));
                return;
            }
            if ((feature == "EFFECT"))
            {
                this.Effect = ((IBehavior)(value));
                return;
            }
            if ((feature == "REDEFINEDTRANSITION"))
            {
                this.RedefinedTransition = ((ITransition)(value));
                return;
            }
            if ((feature == "SOURCE"))
            {
                this.Source = ((IVertex)(value));
                return;
            }
            if ((feature == "TARGET"))
            {
                this.Target = ((IVertex)(value));
                return;
            }
            if ((feature == "CONTAINER"))
            {
                this.Container = ((IRegion)(value));
                return;
            }
            if ((feature == "KIND"))
            {
                this.Kind = ((TransitionKind)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "KIND"))
            {
                return Observable.Box(new KindProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "POSTCONDITION"))
            {
                return new PostConditionProxy(this);
            }
            if ((reference == "PRECONDITION"))
            {
                return new PreConditionProxy(this);
            }
            if ((reference == "EFFECT"))
            {
                return new EffectProxy(this);
            }
            if ((reference == "REDEFINEDTRANSITION"))
            {
                return new RedefinedTransitionProxy(this);
            }
            if ((reference == "SOURCE"))
            {
                return new SourceProxy(this);
            }
            if ((reference == "TARGET"))
            {
                return new TargetProxy(this);
            }
            if ((reference == "CONTAINER"))
            {
                return new ContainerProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._trigger))
            {
                return "trigger";
            }
            if ((container == this._elementImport))
            {
                return "elementImport";
            }
            if ((container == this._packageImport))
            {
                return "packageImport";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//ProtocolTransition")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ProtocolTransition class
        /// </summary>
        public class ProtocolTransitionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ProtocolTransition _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ProtocolTransitionChildrenCollection(ProtocolTransition parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ProtocolTransition class
        /// </summary>
        public class ProtocolTransitionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ProtocolTransition _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ProtocolTransitionReferencedElementsCollection(ProtocolTransition parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the postCondition property
        /// </summary>
        private sealed class PostConditionProxy : ModelPropertyChange<IProtocolTransition, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public PostConditionProxy(IProtocolTransition modelElement) : 
                    base(modelElement, "postCondition")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.PostCondition;
                }
                set
                {
                    this.ModelElement.PostCondition = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the preCondition property
        /// </summary>
        private sealed class PreConditionProxy : ModelPropertyChange<IProtocolTransition, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public PreConditionProxy(IProtocolTransition modelElement) : 
                    base(modelElement, "preCondition")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.PreCondition;
                }
                set
                {
                    this.ModelElement.PreCondition = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the kind property
        /// </summary>
        private sealed class KindProxy : ModelPropertyChange<ITransition, TransitionKind>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public KindProxy(ITransition modelElement) : 
                    base(modelElement, "kind")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override TransitionKind Value
            {
                get
                {
                    return this.ModelElement.Kind;
                }
                set
                {
                    this.ModelElement.Kind = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the effect property
        /// </summary>
        private sealed class EffectProxy : ModelPropertyChange<ITransition, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public EffectProxy(ITransition modelElement) : 
                    base(modelElement, "effect")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.Effect;
                }
                set
                {
                    this.ModelElement.Effect = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the guard property
        /// </summary>
        private sealed class GuardProxy : ModelPropertyChange<ITransition, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public GuardProxy(ITransition modelElement) : 
                    base(modelElement, "guard")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.Guard;
                }
                set
                {
                    this.ModelElement.Guard = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the redefinedTransition property
        /// </summary>
        private sealed class RedefinedTransitionProxy : ModelPropertyChange<ITransition, ITransition>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RedefinedTransitionProxy(ITransition modelElement) : 
                    base(modelElement, "redefinedTransition")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITransition Value
            {
                get
                {
                    return this.ModelElement.RedefinedTransition;
                }
                set
                {
                    this.ModelElement.RedefinedTransition = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the source property
        /// </summary>
        private sealed class SourceProxy : ModelPropertyChange<ITransition, IVertex>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SourceProxy(ITransition modelElement) : 
                    base(modelElement, "source")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IVertex Value
            {
                get
                {
                    return this.ModelElement.Source;
                }
                set
                {
                    this.ModelElement.Source = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the target property
        /// </summary>
        private sealed class TargetProxy : ModelPropertyChange<ITransition, IVertex>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TargetProxy(ITransition modelElement) : 
                    base(modelElement, "target")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IVertex Value
            {
                get
                {
                    return this.ModelElement.Target;
                }
                set
                {
                    this.ModelElement.Target = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the container property
        /// </summary>
        private sealed class ContainerProxy : ModelPropertyChange<ITransition, IRegion>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ContainerProxy(ITransition modelElement) : 
                    base(modelElement, "container")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IRegion Value
            {
                get
                {
                    return this.ModelElement.Container;
                }
                set
                {
                    this.ModelElement.Container = value;
                }
            }
        }
    }
}
