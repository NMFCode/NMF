//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// An Operation is a BehavioralFeature of a Classifier that specifies the name, type, parameters, and constraints for invoking an associated Behavior. An Operation may invoke both the execution of method behaviors as well as other behavioral responses. Operation specializes TemplateableElement in order to support specification of template operations and bound operations. Operation specializes ParameterableElement to specify that an operation can be exposed as a formal template parameter, and provided as an actual parameter in a binding of a template.
    ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Operation")]
    [DebuggerDisplayAttribute("Operation {Name}")]
    public partial class Operation : Feature, NMF.Interop.Uml.IOperation, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _at_most_one_returnOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAt_most_one_returnOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _only_body_for_queryOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOnly_body_for_queryOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getReturnResultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetReturnResultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setIsOrderedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetIsOrderedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setIsUniqueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetIsUniqueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setLowerOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetLowerOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setUpperOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetUpperOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getLowerOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetLowerOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _returnResultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveReturnResultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getUpperOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetUpperOperation);
        
        /// <summary>
        /// The backing field for the IsQuery property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isQuery = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isQueryAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsQueryAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _bodyConditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBodyConditionReference);
        
        /// <summary>
        /// The backing field for the BodyCondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _bodyCondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _classReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveClassReference);
        
        /// <summary>
        /// The backing field for the Class property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NMF.Interop.Uml.IClass _class;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _datatypeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDatatypeReference);
        
        /// <summary>
        /// The backing field for the Datatype property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NMF.Interop.Uml.IDataType _datatype;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _interfaceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveInterfaceReference);
        
        /// <summary>
        /// The backing field for the Interface property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IInterface _interface;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _postconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePostconditionReference);
        
        /// <summary>
        /// The backing field for the Postcondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConstraint> _postcondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _preconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePreconditionReference);
        
        /// <summary>
        /// The backing field for the Precondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConstraint> _precondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedOperationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedOperationReference);
        
        /// <summary>
        /// The backing field for the RedefinedOperation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<NMF.Interop.Uml.IOperation> _redefinedOperation;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _abstract_no_methodOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAbstract_no_methodOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createReturnResultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateReturnResultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inputParametersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInputParametersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _outputParametersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOutputParametersOperation);
        
        /// <summary>
        /// The backing field for the Concurrency property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private CallConcurrencyKind _concurrency = CallConcurrencyKind.Sequential;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _concurrencyAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConcurrencyAttribute);
        
        /// <summary>
        /// The backing field for the IsAbstract property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isAbstract = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isAbstractAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsAbstractAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _methodReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveMethodReference);
        
        /// <summary>
        /// The backing field for the Method property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private BehavioralFeatureMethodCollection _method;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedParameterReference);
        
        /// <summary>
        /// The backing field for the OwnedParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<NMF.Interop.Uml.IParameter> _ownedParameter;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedParameterSetReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedParameterSetReference);
        
        /// <summary>
        /// The backing field for the OwnedParameterSet property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IParameterSet> _ownedParameterSet;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _raisedExceptionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRaisedExceptionReference);
        
        /// <summary>
        /// The backing field for the RaisedException property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<NMF.Interop.Uml.IType> _raisedException;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _members_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembers_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_selfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_selfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_ownedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_ownedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createElementImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateElementImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createPackageImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreatePackageImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedElementsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _excludeCollisionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveExcludeCollisionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNamesOfMemberOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNamesOfMemberOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _importMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveImportMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _membersAreDistinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembersAreDistinguishableOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _elementImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveElementImportReference);
        
        /// <summary>
        /// The backing field for the ElementImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespaceElementImportCollection _elementImport;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageImportReference);
        
        /// <summary>
        /// The backing field for the PackageImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespacePackageImportCollection _packageImport;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompatibleWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompatibleWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateParameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateParameterOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningTemplateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the OwningTemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _owningTemplateParameter;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the TemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _templateParameter;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameterableElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameterableElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateBindingReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateBindingReference);
        
        /// <summary>
        /// The backing field for the TemplateBinding property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TemplateableElementTemplateBindingCollection _templateBinding;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTemplateSignatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTemplateSignatureReference);
        
        /// <summary>
        /// The backing field for the OwnedTemplateSignature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateSignature _ownedTemplateSignature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Operation()
        {
            this._postcondition = new ObservableCompositionOrderedSet<IConstraint>(this);
            this._postcondition.CollectionChanging += this.PostconditionCollectionChanging;
            this._postcondition.CollectionChanged += this.PostconditionCollectionChanged;
            this._precondition = new ObservableCompositionOrderedSet<IConstraint>(this);
            this._precondition.CollectionChanging += this.PreconditionCollectionChanging;
            this._precondition.CollectionChanged += this.PreconditionCollectionChanged;
            this._redefinedOperation = new ObservableAssociationSet<NMF.Interop.Uml.IOperation>();
            this._redefinedOperation.CollectionChanging += this.RedefinedOperationCollectionChanging;
            this._redefinedOperation.CollectionChanged += this.RedefinedOperationCollectionChanged;
            this._method = new BehavioralFeatureMethodCollection(this);
            this._method.CollectionChanging += this.MethodCollectionChanging;
            this._method.CollectionChanged += this.MethodCollectionChanged;
            this._ownedParameter = new ObservableCompositionOrderedSet<NMF.Interop.Uml.IParameter>(this);
            this._ownedParameter.CollectionChanging += this.OwnedParameterCollectionChanging;
            this._ownedParameter.CollectionChanged += this.OwnedParameterCollectionChanged;
            this._ownedParameterSet = new ObservableCompositionOrderedSet<IParameterSet>(this);
            this._ownedParameterSet.CollectionChanging += this.OwnedParameterSetCollectionChanging;
            this._ownedParameterSet.CollectionChanged += this.OwnedParameterSetCollectionChanged;
            this._raisedException = new ObservableAssociationSet<NMF.Interop.Uml.IType>();
            this._raisedException.CollectionChanging += this.RaisedExceptionCollectionChanging;
            this._raisedException.CollectionChanged += this.RaisedExceptionCollectionChanged;
            this._elementImport = new NamespaceElementImportCollection(this);
            this._elementImport.CollectionChanging += this.ElementImportCollectionChanging;
            this._elementImport.CollectionChanged += this.ElementImportCollectionChanged;
            this._packageImport = new NamespacePackageImportCollection(this);
            this._packageImport.CollectionChanging += this.PackageImportCollectionChanging;
            this._packageImport.CollectionChanged += this.PackageImportCollectionChanged;
            this._templateBinding = new TemplateableElementTemplateBindingCollection(this);
            this._templateBinding.CollectionChanging += this.TemplateBindingCollectionChanging;
            this._templateBinding.CollectionChanged += this.TemplateBindingCollectionChanged;
        }
        
        /// <summary>
        /// Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged (isQuery=true) or whether side effects may occur (isQuery=false).
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isQuery")]
        [DescriptionAttribute("Specifies whether an execution of the BehavioralFeature leaves the state of the s" +
            "ystem unchanged (isQuery=true) or whether side effects may occur (isQuery=false)" +
            ".\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Operation")]
        [XmlElementNameAttribute("isQuery")]
        [XmlAttributeAttribute(true)]
        public bool IsQuery
        {
            get
            {
                return this._isQuery;
            }
            set
            {
                if ((this._isQuery != value))
                {
                    bool old = this._isQuery;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsQuery", e, _isQueryAttribute);
                    this._isQuery = value;
                    this.OnPropertyChanged("IsQuery", e, _isQueryAttribute);
                }
            }
        }
        
        /// <summary>
        /// An optional Constraint on the result values of an invocation of this Operation.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("bodyCondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IConstraint BodyCondition
        {
            get
            {
                return this._bodyCondition;
            }
            set
            {
                if ((this._bodyCondition != value))
                {
                    IConstraint old = this._bodyCondition;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("BodyCondition", e, _bodyConditionReference);
                    this._bodyCondition = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetBodyCondition;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetBodyCondition;
                    }
                    this.OnPropertyChanged("BodyCondition", e, _bodyConditionReference);
                }
            }
        }
        
        /// <summary>
        /// The Class that owns this operation, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("class")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedOperation")]
        public NMF.Interop.Uml.IClass Class
        {
            get
            {
                return this._class;
            }
            set
            {
                if ((this._class != value))
                {
                    NMF.Interop.Uml.IClass old = this._class;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Class", e, _classReference);
                    this._class = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedOperation.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedOperation.Add(this);
                    }
                    this.OnPropertyChanged("Class", e, _classReference);
                }
            }
        }
        
        /// <summary>
        /// The DataType that owns this Operation, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("datatype")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedOperation")]
        public NMF.Interop.Uml.IDataType Datatype
        {
            get
            {
                return this._datatype;
            }
            set
            {
                if ((this._datatype != value))
                {
                    NMF.Interop.Uml.IDataType old = this._datatype;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Datatype", e, _datatypeReference);
                    this._datatype = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedOperation.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedOperation.Add(this);
                    }
                    this.OnPropertyChanged("Datatype", e, _datatypeReference);
                }
            }
        }
        
        /// <summary>
        /// The Interface that owns this Operation, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("interface")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedOperation")]
        public IInterface Interface
        {
            get
            {
                return this._interface;
            }
            set
            {
                if ((this._interface != value))
                {
                    IInterface old = this._interface;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Interface", e, _interfaceReference);
                    this._interface = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedOperation.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedOperation.Add(this);
                    }
                    this.OnPropertyChanged("Interface", e, _interfaceReference);
                }
            }
        }
        
        /// <summary>
        /// An optional set of Constraints specifying the state of the system when the Operation is completed.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("postcondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConstraint> Postcondition
        {
            get
            {
                return this._postcondition;
            }
        }
        
        /// <summary>
        /// An optional set of Constraints on the state of the system when the Operation is invoked.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("precondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConstraint> Precondition
        {
            get
            {
                return this._precondition;
            }
        }
        
        /// <summary>
        /// The Operations that are redefined by this Operation.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedOperation")]
        [DescriptionAttribute("The Operations that are redefined by this Operation.\n<p>From package UML::Classif" +
            "ication.</p>")]
        [CategoryAttribute("Operation")]
        [XmlElementNameAttribute("redefinedOperation")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<NMF.Interop.Uml.IOperation> RedefinedOperation
        {
            get
            {
                return this._redefinedOperation;
            }
        }
        
        IListExpression<IConstraint> NMF.Interop.Uml.INamespace.OwnedRule
        {
            get
            {
                return new OperationOwnedRuleCollection(this);
            }
        }
        
        /// <summary>
        /// Specifies the semantics of concurrent calls to the same passive instance (i.e., an instance originating from a Class with isActive being false). Active instances control access to their own BehavioralFeatures.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(CallConcurrencyKind.Sequential)]
        [DisplayNameAttribute("concurrency")]
        [DescriptionAttribute("Specifies the semantics of concurrent calls to the same passive instance (i.e., a" +
            "n instance originating from a Class with isActive being false). Active instances" +
            " control access to their own BehavioralFeatures.\n<p>From package UML::Classifica" +
            "tion.</p>")]
        [CategoryAttribute("BehavioralFeature")]
        [XmlElementNameAttribute("concurrency")]
        [XmlAttributeAttribute(true)]
        public CallConcurrencyKind Concurrency
        {
            get
            {
                return this._concurrency;
            }
            set
            {
                if ((this._concurrency != value))
                {
                    CallConcurrencyKind old = this._concurrency;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Concurrency", e, _concurrencyAttribute);
                    this._concurrency = value;
                    this.OnPropertyChanged("Concurrency", e, _concurrencyAttribute);
                }
            }
        }
        
        /// <summary>
        /// If true, then the BehavioralFeature does not have an implementation, and one must be supplied by a more specific Classifier. If false, the BehavioralFeature must have an implementation in the Classifier or one must be inherited.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isAbstract")]
        [DescriptionAttribute(@"If true, then the BehavioralFeature does not have an implementation, and one must be supplied by a more specific Classifier. If false, the BehavioralFeature must have an implementation in the Classifier or one must be inherited.
<p>From package UML::Classification.</p>")]
        [CategoryAttribute("BehavioralFeature")]
        [XmlElementNameAttribute("isAbstract")]
        [XmlAttributeAttribute(true)]
        public bool IsAbstract
        {
            get
            {
                return this._isAbstract;
            }
            set
            {
                if ((this._isAbstract != value))
                {
                    bool old = this._isAbstract;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsAbstract", e, _isAbstractAttribute);
                    this._isAbstract = value;
                    this.OnPropertyChanged("IsAbstract", e, _isAbstractAttribute);
                }
            }
        }
        
        /// <summary>
        /// A Behavior that implements the BehavioralFeature. There may be at most one Behavior for a particular pairing of a Classifier (as owner of the Behavior) and a BehavioralFeature (as specification of the Behavior).
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("method")]
        [DescriptionAttribute("A Behavior that implements the BehavioralFeature. There may be at most one Behavi" +
            "or for a particular pairing of a Classifier (as owner of the Behavior) and a Beh" +
            "avioralFeature (as specification of the Behavior).\n<p>From package UML::Classifi" +
            "cation.</p>")]
        [CategoryAttribute("BehavioralFeature")]
        [XmlElementNameAttribute("method")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("specification")]
        [ConstantAttribute()]
        public ISetExpression<IBehavior> Method
        {
            get
            {
                return this._method;
            }
        }
        
        /// <summary>
        /// The ordered set of formal Parameters of this BehavioralFeature.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedParameter")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<NMF.Interop.Uml.IParameter> OwnedParameter
        {
            get
            {
                return this._ownedParameter;
            }
        }
        
        /// <summary>
        /// The ParameterSets owned by this BehavioralFeature.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedParameterSet")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IParameterSet> OwnedParameterSet
        {
            get
            {
                return this._ownedParameterSet;
            }
        }
        
        /// <summary>
        /// The Types representing exceptions that may be raised during an invocation of this BehavioralFeature.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("raisedException")]
        [DescriptionAttribute("The Types representing exceptions that may be raised during an invocation of this" +
            " BehavioralFeature.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("BehavioralFeature")]
        [XmlElementNameAttribute("raisedException")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<NMF.Interop.Uml.IType> RaisedException
        {
            get
            {
                return this._raisedException;
            }
        }
        
        /// <summary>
        /// References the ElementImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("elementImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IElementImport> ElementImport
        {
            get
            {
                return this._elementImport;
            }
        }
        
        /// <summary>
        /// References the PackageImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IPackageImport> PackageImport
        {
            get
            {
                return this._packageImport;
            }
        }
        
        /// <summary>
        /// The formal TemplateParameter that owns this ParameterableElement.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("owningTemplateParameter")]
        [DescriptionAttribute("The formal TemplateParameter that owns this ParameterableElement.\n<p>From package" +
            " UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("owningTemplateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedParameteredElement")]
        public ITemplateParameter OwningTemplateParameter
        {
            get
            {
                return this._owningTemplateParameter;
            }
            set
            {
                if ((this._owningTemplateParameter != value))
                {
                    ITemplateParameter old = this._owningTemplateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwningTemplateParameter", e, _owningTemplateParameterReference);
                    this._owningTemplateParameter = value;
                    if ((old != null))
                    {
                        old.OwnedParameteredElement = null;
                        old.Deleted -= this.OnResetOwningTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.OwnedParameteredElement = this;
                        value.Deleted += this.OnResetOwningTemplateParameter;
                    }
                    this.OnPropertyChanged("OwningTemplateParameter", e, _owningTemplateParameterReference);
                }
            }
        }
        
        /// <summary>
        /// The TemplateParameter that exposes this ParameterableElement as a formal parameter.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("templateParameter")]
        [DescriptionAttribute("The TemplateParameter that exposes this ParameterableElement as a formal paramete" +
            "r.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("templateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("parameteredElement")]
        public ITemplateParameter TemplateParameter
        {
            get
            {
                return this._templateParameter;
            }
            set
            {
                if ((this._templateParameter != value))
                {
                    ITemplateParameter old = this._templateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TemplateParameter", e, _templateParameterReference);
                    this._templateParameter = value;
                    if ((old != null))
                    {
                        old.ParameteredElement = null;
                        old.Deleted -= this.OnResetTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.ParameteredElement = this;
                        value.Deleted += this.OnResetTemplateParameter;
                    }
                    this.OnPropertyChanged("TemplateParameter", e, _templateParameterReference);
                }
            }
        }
        
        ITemplateParameter IParameterableElement.TemplateParameter
        {
            get
            {
                IParameterableElement _this = this;
                return _this.OwningTemplateParameter;
            }
            set
            {
                IParameterableElement _this = this;
                _this.OwningTemplateParameter = value;
            }
        }
        
        /// <summary>
        /// The optional TemplateBindings from this TemplateableElement to one or more templates.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("templateBinding")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("boundElement")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITemplateBinding> TemplateBinding
        {
            get
            {
                return this._templateBinding;
            }
        }
        
        /// <summary>
        /// The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a TemplateableElement has a TemplateSignature, then it is a template.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedTemplateSignature")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("template")]
        public ITemplateSignature OwnedTemplateSignature
        {
            get
            {
                return this._ownedTemplateSignature;
            }
            set
            {
                if ((this._ownedTemplateSignature != value))
                {
                    ITemplateSignature old = this._ownedTemplateSignature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                    this._ownedTemplateSignature = value;
                    if ((old != null))
                    {
                        old.Template = null;
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetOwnedTemplateSignature;
                    }
                    if ((value != null))
                    {
                        value.Template = this;
                        value.Parent = this;
                        value.ParentChanged += this.OnResetOwnedTemplateSignature;
                    }
                    this.OnPropertyChanged("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new OperationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new OperationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Operation")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// An Operation can have at most one return parameter; i.e., an owned parameter with the direction set to &apos;return.&apos;
        ///self.ownedParameter-&gt;select(direction = ParameterDirectionKind::return)-&gt;size() &lt;= 1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool At_most_one_return(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.IOperation, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, object, object, bool>>(_at_most_one_returnOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method at_most_one_return registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _at_most_one_returnOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _at_most_one_returnOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _at_most_one_returnOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAt_most_one_returnOperation()
        {
            return ClassInstance.LookupOperation("at_most_one_return");
        }
        
        /// <summary>
        /// A bodyCondition can only be specified for a query Operation.
        ///bodyCondition &lt;&gt; null implies isQuery
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Only_body_for_query(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.IOperation, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, object, object, bool>>(_only_body_for_queryOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method only_body_for_query registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _only_body_for_queryOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _only_body_for_queryOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _only_body_for_queryOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOnly_body_for_queryOperation()
        {
            return ClassInstance.LookupOperation("only_body_for_query");
        }
        
        /// <summary>
        /// Retrieves the (only) return result parameter for this operation.
        /// </summary>
        public NMF.Interop.Uml.IParameter GetReturnResult()
        {
            System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IParameter> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IParameter>>(_getReturnResultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getReturnResult registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getReturnResultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getReturnResultOperation.Value, e));
            NMF.Interop.Uml.IParameter result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getReturnResultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetReturnResultOperation()
        {
            return ClassInstance.LookupOperation("getReturnResult");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newIsOrdered"></param>
        public void SetIsOrdered(bool newIsOrdered)
        {
            System.Action<NMF.Interop.Uml.IOperation, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, bool>>(_setIsOrderedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setIsOrdered registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setIsOrderedOperation.Value, newIsOrdered);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setIsOrderedOperation.Value, e));
            handler.Invoke(this, newIsOrdered);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setIsOrderedOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetIsOrderedOperation()
        {
            return ClassInstance.LookupOperation("setIsOrdered");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newIsUnique"></param>
        public void SetIsUnique(bool newIsUnique)
        {
            System.Action<NMF.Interop.Uml.IOperation, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, bool>>(_setIsUniqueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setIsUnique registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setIsUniqueOperation.Value, newIsUnique);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setIsUniqueOperation.Value, e));
            handler.Invoke(this, newIsUnique);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setIsUniqueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetIsUniqueOperation()
        {
            return ClassInstance.LookupOperation("setIsUnique");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newLower"></param>
        public void SetLower(int newLower)
        {
            System.Action<NMF.Interop.Uml.IOperation, int> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, int>>(_setLowerOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setLower registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setLowerOperation.Value, newLower);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setLowerOperation.Value, e));
            handler.Invoke(this, newLower);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setLowerOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetLowerOperation()
        {
            return ClassInstance.LookupOperation("setLower");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newType"></param>
        public void SetType(NMF.Interop.Uml.IType newType)
        {
            System.Action<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType>>(_setTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setType registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setTypeOperation.Value, newType);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setTypeOperation.Value, e));
            handler.Invoke(this, newType);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setTypeOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetTypeOperation()
        {
            return ClassInstance.LookupOperation("setType");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newUpper"></param>
        public void SetUpper(object newUpper)
        {
            System.Action<NMF.Interop.Uml.IOperation, object> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, object>>(_setUpperOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setUpper registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setUpperOperation.Value, newUpper);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setUpperOperation.Value, e));
            handler.Invoke(this, newUpper);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setUpperOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetUpperOperation()
        {
            return ClassInstance.LookupOperation("setUpper");
        }
        
        /// <summary>
        /// If this operation has a return parameter, lower equals the value of lower for that parameter. Otherwise lower has no value.
        ///result = (if returnResult()-&gt;notEmpty() then returnResult()-&gt;any(true).lower else null endif)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public int GetLower()
        {
            System.Func<NMF.Interop.Uml.IOperation, int> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, int>>(_getLowerOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getLower registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getLowerOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getLowerOperation.Value, e));
            int result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getLowerOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetLowerOperation()
        {
            return ClassInstance.LookupOperation("getLower");
        }
        
        /// <summary>
        /// The query returnResult() returns the set containing the return parameter of the Operation if one exists, otherwise, it returns an empty set
        ///result = (ownedParameter-&gt;select (direction = ParameterDirectionKind::return)-&gt;asSet())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IParameter> ReturnResult()
        {
            System.Func<NMF.Interop.Uml.IOperation, ISetExpression<NMF.Interop.Uml.IParameter>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, ISetExpression<NMF.Interop.Uml.IParameter>>>(_returnResultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method returnResult registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _returnResultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _returnResultOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IParameter> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _returnResultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveReturnResultOperation()
        {
            return ClassInstance.LookupOperation("returnResult");
        }
        
        /// <summary>
        /// If this operation has a return parameter, type equals the value of type for that parameter. Otherwise type has no value.
        ///result = (if returnResult()-&gt;notEmpty() then returnResult()-&gt;any(true).type else null endif)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public NMF.Interop.Uml.IType GetType()
        {
            System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType>>(_getTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getType registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getTypeOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getTypeOperation.Value, e));
            NMF.Interop.Uml.IType result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetTypeOperation()
        {
            return ClassInstance.LookupOperation("getType");
        }
        
        /// <summary>
        /// If this operation has a return parameter, upper equals the value of upper for that parameter. Otherwise upper has no value.
        ///result = (if returnResult()-&gt;notEmpty() then returnResult()-&gt;any(true).upper else null endif)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public void GetUpper()
        {
            System.Action<NMF.Interop.Uml.IOperation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation>>(_getUpperOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getUpper registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getUpperOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getUpperOperation.Value, e));
            handler.Invoke(this);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getUpperOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetUpperOperation()
        {
            return ClassInstance.LookupOperation("getUpper");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsQueryAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("isQuery")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBodyConditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("bodyCondition")));
        }
        
        /// <summary>
        /// Handles the event that the BodyCondition property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetBodyCondition(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.BodyCondition))
            {
                this.BodyCondition = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveClassReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("class")));
        }
        
        /// <summary>
        /// Handles the event that the Class property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetClass(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Class))
            {
                this.Class = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDatatypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("datatype")));
        }
        
        /// <summary>
        /// Handles the event that the Datatype property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDatatype(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Datatype))
            {
                this.Datatype = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveInterfaceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("interface")));
        }
        
        /// <summary>
        /// Handles the event that the Interface property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetInterface(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Interface))
            {
                this.Interface = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePostconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("postcondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Postcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PostconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Postcondition", e, _postconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Postcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PostconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Postcondition", e, _postconditionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePreconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("precondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Precondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PreconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Precondition", e, _preconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Precondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PreconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Precondition", e, _preconditionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedOperationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("redefinedOperation")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedOperation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedOperationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedOperation", e, _redefinedOperationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedOperation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedOperationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedOperation", e, _redefinedOperationReference);
        }
        
        /// <summary>
        /// When isAbstract is true there are no methods.
        ///isAbstract implies method-&gt;isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Abstract_no_method(object diagnostics, object context)
        {
            System.Func<IBehavioralFeature, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavioralFeature, object, object, bool>>(_abstract_no_methodOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method abstract_no_method registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _abstract_no_methodOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _abstract_no_methodOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _abstract_no_methodOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAbstract_no_methodOperation()
        {
            return ClassInstance.LookupOperation("abstract_no_method");
        }
        
        /// <summary>
        /// Creates a return result parameter with the specified name and type.
        /// </summary>
        /// <param name="name">The name for the new return result, or null.</param>
        /// <param name="type">The type for the new return result, or null.</param>
        public NMF.Interop.Uml.IParameter CreateReturnResult(string name, NMF.Interop.Uml.IType type)
        {
            System.Func<IBehavioralFeature, string, NMF.Interop.Uml.IType, NMF.Interop.Uml.IParameter> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavioralFeature, string, NMF.Interop.Uml.IType, NMF.Interop.Uml.IParameter>>(_createReturnResultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createReturnResult registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createReturnResultOperation.Value, name, type);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createReturnResultOperation.Value, e));
            NMF.Interop.Uml.IParameter result = handler.Invoke(this, name, type);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createReturnResultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateReturnResultOperation()
        {
            return ClassInstance.LookupOperation("createReturnResult");
        }
        
        /// <summary>
        /// The ownedParameters with direction in and inout.
        ///result = (ownedParameter-&gt;select(direction=ParameterDirectionKind::_&apos;in&apos; or direction=ParameterDirectionKind::inout))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public IOrderedSetExpression<NMF.Interop.Uml.IParameter> InputParameters()
        {
            System.Func<IBehavioralFeature, IOrderedSetExpression<NMF.Interop.Uml.IParameter>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavioralFeature, IOrderedSetExpression<NMF.Interop.Uml.IParameter>>>(_inputParametersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inputParameters registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inputParametersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inputParametersOperation.Value, e));
            IOrderedSetExpression<NMF.Interop.Uml.IParameter> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inputParametersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInputParametersOperation()
        {
            return ClassInstance.LookupOperation("inputParameters");
        }
        
        /// <summary>
        /// The ownedParameters with direction out, inout, or return.
        ///result = (ownedParameter-&gt;select(direction=ParameterDirectionKind::out or direction=ParameterDirectionKind::inout or direction=ParameterDirectionKind::return))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public IOrderedSetExpression<NMF.Interop.Uml.IParameter> OutputParameters()
        {
            System.Func<IBehavioralFeature, IOrderedSetExpression<NMF.Interop.Uml.IParameter>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IBehavioralFeature, IOrderedSetExpression<NMF.Interop.Uml.IParameter>>>(_outputParametersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method outputParameters registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _outputParametersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _outputParametersOperation.Value, e));
            IOrderedSetExpression<NMF.Interop.Uml.IParameter> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _outputParametersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOutputParametersOperation()
        {
            return ClassInstance.LookupOperation("outputParameters");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConcurrencyAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioralFeature.ClassInstance)).Resolve("concurrency")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsAbstractAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioralFeature.ClassInstance)).Resolve("isAbstract")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveMethodReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioralFeature.ClassInstance)).Resolve("method")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Method property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MethodCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Method", e, _methodReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Method property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MethodCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Method", e, _methodReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioralFeature.ClassInstance)).Resolve("ownedParameter")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedParameter property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedParameter", e, _ownedParameterReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedParameter property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedParameter", e, _ownedParameterReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedParameterSetReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioralFeature.ClassInstance)).Resolve("ownedParameterSet")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedParameterSet property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterSetCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedParameterSet", e, _ownedParameterSetReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedParameterSet property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedParameterSetCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedParameterSet", e, _ownedParameterSetReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRaisedExceptionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.BehavioralFeature.ClassInstance)).Resolve("raisedException")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RaisedException property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RaisedExceptionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RaisedException", e, _raisedExceptionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RaisedException property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RaisedExceptionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RaisedException", e, _raisedExceptionReference);
        }
        
        /// <summary>
        /// All the members of a Namespace are distinguishable within it.
        ///membersAreDistinguishable()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Members_distinguishable(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_members_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method members_distinguishable registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _members_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _members_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _members_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembers_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("members_distinguishable");
        }
        
        /// <summary>
        /// A Namespace cannot have a PackageImport to itself.
        ///packageImport.importedPackage.oclAsType(Namespace)-&gt;excludes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_self(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_selfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_self registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_selfOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_selfOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_selfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_selfOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_self");
        }
        
        /// <summary>
        /// A Namespace cannot have an ElementImport to one of its ownedMembers.
        ///elementImport.importedElement.oclAsType(Element)-&gt;excludesAll(ownedMember)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_ownedMembers(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_ownedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_ownedMembers registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_ownedMembersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_ownedMembersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_ownedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_ownedMembersOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_ownedMembers");
        }
        
        /// <summary>
        /// Creates an import of the specified element into this namespace with the specified visibility.
        /// </summary>
        /// <param name="element">The element to import.</param>
        /// <param name="visibility">The visibility for the new element import.</param>
        public IElementImport CreateElementImport(IPackageableElement element, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport>>(_createElementImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createElementImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createElementImportOperation.Value, element, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createElementImportOperation.Value, e));
            IElementImport result = handler.Invoke(this, element, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createElementImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateElementImportOperation()
        {
            return ClassInstance.LookupOperation("createElementImport");
        }
        
        /// <summary>
        /// Creates an import of the specified package into this namespace with the specified visibility.
        /// </summary>
        /// <param name="package_">The package to import.</param>
        /// <param name="visibility">The visibility for the new package import.</param>
        public IPackageImport CreatePackageImport(IPackage package_, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport>>(_createPackageImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createPackageImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createPackageImportOperation.Value, package_, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createPackageImportOperation.Value, e));
            IPackageImport result = handler.Invoke(this, package_, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createPackageImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreatePackageImportOperation()
        {
            return ClassInstance.LookupOperation("createPackageImport");
        }
        
        /// <summary>
        /// Retrieves the elements imported by this namespace.
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedElements()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedElements registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedElementsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedElementsOperation()
        {
            return ClassInstance.LookupOperation("getImportedElements");
        }
        
        /// <summary>
        /// Retrieves the packages imported by this namespace.
        /// </summary>
        public ISetExpression<IPackage> GetImportedPackages()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>>>(_getImportedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedPackages registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getImportedPackages");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public ISetExpression<INamedElement> GetOwnedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>>>(_getOwnedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedMembers registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedMembersOperation()
        {
            return ClassInstance.LookupOperation("getOwnedMembers");
        }
        
        /// <summary>
        /// The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this Namespace.
        ///result = (imps-&gt;reject(imp1  | imps-&gt;exists(imp2 | not imp1.isDistinguishableFrom(imp2, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ExcludeCollisions(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_excludeCollisionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method excludeCollisions registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _excludeCollisionsOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _excludeCollisionsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _excludeCollisionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveExcludeCollisionsOperation()
        {
            return ClassInstance.LookupOperation("excludeCollisions");
        }
        
        /// <summary>
        /// The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace, taking importing into account. In general a member can have multiple names in a Namespace if it is imported more than once with different aliases.
        ///result = (if self.ownedMember -&gt;includes(element)
        ///then Set{element.name}
        ///else let elementImports : Set(ElementImport) = self.elementImport-&gt;select(ei | ei.importedElement = element) in
        ///  if elementImports-&gt;notEmpty()
        ///  then
        ///     elementImports-&gt;collect(el | el.getName())-&gt;asSet()
        ///  else 
        ///     self.packageImport-&gt;select(pi | pi.importedPackage.visibleMembers().oclAsType(NamedElement)-&gt;includes(element))-&gt; collect(pi | pi.importedPackage.getNamesOfMember(element))-&gt;asSet()
        ///  endif
        ///endif)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="element"></param>
        public ISetExpression<string> GetNamesOfMember(INamedElement element)
        {
            System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>>>(_getNamesOfMemberOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNamesOfMember registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNamesOfMemberOperation.Value, element);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNamesOfMemberOperation.Value, e));
            ISetExpression<string> result = handler.Invoke(this, element);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNamesOfMemberOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNamesOfMemberOperation()
        {
            return ClassInstance.LookupOperation("getNamesOfMember");
        }
        
        /// <summary>
        /// The query importMembers() defines which of a set of PackageableElements are actually imported into the Namespace. This excludes hidden ones, i.e., those which have names that conflict with names of ownedMembers, and it also excludes PackageableElements that would have the indistinguishable names when imported.
        ///result = (self.excludeCollisions(imps)-&gt;select(imp | self.ownedMember-&gt;forAll(mem | imp.isDistinguishableFrom(mem, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ImportMembers(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_importMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method importMembers registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _importMembersOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _importMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _importMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveImportMembersOperation()
        {
            return ClassInstance.LookupOperation("importMembers");
        }
        
        /// <summary>
        /// The importedMember property is derived as the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
        ///result = (self.importMembers(elementImport.importedElement-&gt;asSet()-&gt;union(packageImport.importedPackage-&gt;collect(p | p.visibleMembers()))-&gt;asSet()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedMembersOperation()
        {
            return ClassInstance.LookupOperation("getImportedMembers");
        }
        
        /// <summary>
        /// The Boolean query membersAreDistinguishable() determines whether all of the Namespace&apos;s members are distinguishable within it.
        ///result = (member-&gt;forAll( memb |
        ///   member-&gt;excluding(memb)-&gt;forAll(other |
        ///       memb.isDistinguishableFrom(other, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool MembersAreDistinguishable()
        {
            System.Func<NMF.Interop.Uml.INamespace, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, bool>>(_membersAreDistinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method membersAreDistinguishable registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _membersAreDistinguishableOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _membersAreDistinguishableOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _membersAreDistinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembersAreDistinguishableOperation()
        {
            return ClassInstance.LookupOperation("membersAreDistinguishable");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveElementImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("elementImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ElementImport", e, _elementImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ElementImport", e, _elementImportReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("packageImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified ParameterableElement. By default, this ParameterableElement is compatible with another ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. Subclasses of ParameterableElement should override this operation to specify different compatibility constraints.
        ///result = (self.oclIsKindOf(p.oclType()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="p"></param>
        public bool IsCompatibleWith(IParameterableElement p)
        {
            System.Func<IParameterableElement, IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, IParameterableElement, bool>>(_isCompatibleWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isCompatibleWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompatibleWithOperation.Value, p);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompatibleWithOperation.Value, e));
            bool result = handler.Invoke(this, p);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompatibleWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompatibleWithOperation()
        {
            return ClassInstance.LookupOperation("isCompatibleWith");
        }
        
        /// <summary>
        /// The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal TemplateParameter.
        ///result = (templateParameter-&gt;notEmpty())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplateParameter()
        {
            System.Func<IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, bool>>(_isTemplateParameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplateParameter registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateParameterOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateParameterOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateParameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateParameterOperation()
        {
            return ClassInstance.LookupOperation("isTemplateParameter");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("owningTemplateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the OwningTemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwningTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwningTemplateParameter))
            {
                this.OwningTemplateParameter = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("templateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the TemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.TemplateParameter))
            {
                this.TemplateParameter = null;
            }
        }
        
        /// <summary>
        /// The query isTemplate() returns whether this TemplateableElement is actually a template.
        ///result = (ownedTemplateSignature &lt;&gt; null)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplate()
        {
            System.Func<ITemplateableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, bool>>(_isTemplateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplate registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateOperation()
        {
            return ClassInstance.LookupOperation("isTemplate");
        }
        
        /// <summary>
        /// The query parameterableElements() returns the set of ParameterableElements that may be used as the parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all the ownedElements. Subclasses may override this operation if they choose to restrict the set of ParameterableElements.
        ///result = (self.allOwnedElements()-&gt;select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)-&gt;asSet())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IParameterableElement> ParameterableElements()
        {
            System.Func<ITemplateableElement, ISetExpression<IParameterableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, ISetExpression<IParameterableElement>>>(_parameterableElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameterableElements registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameterableElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameterableElementsOperation.Value, e));
            ISetExpression<IParameterableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameterableElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameterableElementsOperation()
        {
            return ClassInstance.LookupOperation("parameterableElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateBindingReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("templateBinding")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TemplateBinding", e, _templateBindingReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TemplateBinding", e, _templateBindingReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTemplateSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("ownedTemplateSignature")));
        }
        
        /// <summary>
        /// Handles the event that the OwnedTemplateSignature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwnedTemplateSignature(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwnedTemplateSignature))
            {
                this.OwnedTemplateSignature = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.BodyCondition))
            {
                return ModelHelper.CreatePath("bodyCondition");
            }
            int postconditionIndex = ModelHelper.IndexOfReference(this.Postcondition, element);
            if ((postconditionIndex != -1))
            {
                return ModelHelper.CreatePath("postcondition", postconditionIndex);
            }
            int preconditionIndex = ModelHelper.IndexOfReference(this.Precondition, element);
            if ((preconditionIndex != -1))
            {
                return ModelHelper.CreatePath("precondition", preconditionIndex);
            }
            int ownedParameterIndex = ModelHelper.IndexOfReference(this.OwnedParameter, element);
            if ((ownedParameterIndex != -1))
            {
                return ModelHelper.CreatePath("ownedParameter", ownedParameterIndex);
            }
            int ownedParameterSetIndex = ModelHelper.IndexOfReference(this.OwnedParameterSet, element);
            if ((ownedParameterSetIndex != -1))
            {
                return ModelHelper.CreatePath("ownedParameterSet", ownedParameterSetIndex);
            }
            int elementImportIndex = ModelHelper.IndexOfReference(this.ElementImport, element);
            if ((elementImportIndex != -1))
            {
                return ModelHelper.CreatePath("elementImport", elementImportIndex);
            }
            int packageImportIndex = ModelHelper.IndexOfReference(this.PackageImport, element);
            if ((packageImportIndex != -1))
            {
                return ModelHelper.CreatePath("packageImport", packageImportIndex);
            }
            int templateBindingIndex = ModelHelper.IndexOfReference(this.TemplateBinding, element);
            if ((templateBindingIndex != -1))
            {
                return ModelHelper.CreatePath("templateBinding", templateBindingIndex);
            }
            if ((element == this.OwnedTemplateSignature))
            {
                return ModelHelper.CreatePath("ownedTemplateSignature");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BODYCONDITION"))
            {
                return this.BodyCondition;
            }
            if ((reference == "CLASS"))
            {
                return this.Class;
            }
            if ((reference == "DATATYPE"))
            {
                return this.Datatype;
            }
            if ((reference == "INTERFACE"))
            {
                return this.Interface;
            }
            if ((reference == "POSTCONDITION"))
            {
                if ((index < this.Postcondition.Count))
                {
                    return this.Postcondition[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PRECONDITION"))
            {
                if ((index < this.Precondition.Count))
                {
                    return this.Precondition[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDPARAMETER"))
            {
                if ((index < this.OwnedParameter.Count))
                {
                    return this.OwnedParameter[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDPARAMETERSET"))
            {
                if ((index < this.OwnedParameterSet.Count))
                {
                    return this.OwnedParameterSet[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "ELEMENTIMPORT"))
            {
                if ((index < this.ElementImport.Count))
                {
                    return this.ElementImport[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGEIMPORT"))
            {
                if ((index < this.PackageImport.Count))
                {
                    return this.PackageImport[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return this.OwningTemplateParameter;
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return this.TemplateParameter;
            }
            if ((reference == "TEMPLATEBINDING"))
            {
                if ((index < this.TemplateBinding.Count))
                {
                    return this.TemplateBinding[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return this.OwnedTemplateSignature;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISQUERY"))
            {
                return this.IsQuery;
            }
            if ((attribute == "CONCURRENCY"))
            {
                return this.Concurrency;
            }
            if ((attribute == "ISABSTRACT"))
            {
                return this.IsAbstract;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "POSTCONDITION"))
            {
                return this._postcondition;
            }
            if ((feature == "PRECONDITION"))
            {
                return this._precondition;
            }
            if ((feature == "REDEFINEDOPERATION"))
            {
                return this._redefinedOperation;
            }
            if ((feature == "METHOD"))
            {
                return this._method;
            }
            if ((feature == "OWNEDPARAMETER"))
            {
                return this._ownedParameter;
            }
            if ((feature == "OWNEDPARAMETERSET"))
            {
                return this._ownedParameterSet;
            }
            if ((feature == "RAISEDEXCEPTION"))
            {
                return this._raisedException;
            }
            if ((feature == "ELEMENTIMPORT"))
            {
                return this._elementImport;
            }
            if ((feature == "PACKAGEIMPORT"))
            {
                return this._packageImport;
            }
            if ((feature == "TEMPLATEBINDING"))
            {
                return this._templateBinding;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BODYCONDITION"))
            {
                this.BodyCondition = ((IConstraint)(value));
                return;
            }
            if ((feature == "CLASS"))
            {
                this.Class = ((NMF.Interop.Uml.IClass)(value));
                return;
            }
            if ((feature == "DATATYPE"))
            {
                this.Datatype = ((NMF.Interop.Uml.IDataType)(value));
                return;
            }
            if ((feature == "INTERFACE"))
            {
                this.Interface = ((IInterface)(value));
                return;
            }
            if ((feature == "OWNINGTEMPLATEPARAMETER"))
            {
                this.OwningTemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "TEMPLATEPARAMETER"))
            {
                this.TemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "OWNEDTEMPLATESIGNATURE"))
            {
                this.OwnedTemplateSignature = ((ITemplateSignature)(value));
                return;
            }
            if ((feature == "ISQUERY"))
            {
                this.IsQuery = ((bool)(value));
                return;
            }
            if ((feature == "CONCURRENCY"))
            {
                this.Concurrency = ((CallConcurrencyKind)(value));
                return;
            }
            if ((feature == "ISABSTRACT"))
            {
                this.IsAbstract = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISQUERY"))
            {
                return Observable.Box(new IsQueryProxy(this));
            }
            if ((attribute == "CONCURRENCY"))
            {
                return Observable.Box(new ConcurrencyProxy(this));
            }
            if ((attribute == "ISABSTRACT"))
            {
                return Observable.Box(new IsAbstractProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "BODYCONDITION"))
            {
                return new BodyConditionProxy(this);
            }
            if ((reference == "CLASS"))
            {
                return new ClassProxy(this);
            }
            if ((reference == "DATATYPE"))
            {
                return new DatatypeProxy(this);
            }
            if ((reference == "INTERFACE"))
            {
                return new InterfaceProxy(this);
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return new OwningTemplateParameterProxy(this);
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return new TemplateParameterProxy(this);
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return new OwnedTemplateSignatureProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._postcondition))
            {
                return "postcondition";
            }
            if ((container == this._precondition))
            {
                return "precondition";
            }
            if ((container == this._ownedParameter))
            {
                return "ownedParameter";
            }
            if ((container == this._ownedParameterSet))
            {
                return "ownedParameterSet";
            }
            if ((container == this._elementImport))
            {
                return "elementImport";
            }
            if ((container == this._packageImport))
            {
                return "packageImport";
            }
            if ((container == this._templateBinding))
            {
                return "templateBinding";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Operation")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Operation class
        /// </summary>
        public class OperationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Operation _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public OperationChildrenCollection(Operation parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Operation class
        /// </summary>
        public class OperationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Operation _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public OperationReferencedElementsCollection(Operation parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isQuery property
        /// </summary>
        private sealed class IsQueryProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsQueryProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "isQuery")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsQuery;
                }
                set
                {
                    this.ModelElement.IsQuery = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the bodyCondition property
        /// </summary>
        private sealed class BodyConditionProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BodyConditionProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "bodyCondition")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.BodyCondition;
                }
                set
                {
                    this.ModelElement.BodyCondition = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the class property
        /// </summary>
        private sealed class ClassProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IClass>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ClassProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "class")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override NMF.Interop.Uml.IClass Value
            {
                get
                {
                    return this.ModelElement.Class;
                }
                set
                {
                    this.ModelElement.Class = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the datatype property
        /// </summary>
        private sealed class DatatypeProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IDataType>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DatatypeProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "datatype")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override NMF.Interop.Uml.IDataType Value
            {
                get
                {
                    return this.ModelElement.Datatype;
                }
                set
                {
                    this.ModelElement.Datatype = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the interface property
        /// </summary>
        private sealed class InterfaceProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, IInterface>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public InterfaceProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "interface")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IInterface Value
            {
                get
                {
                    return this.ModelElement.Interface;
                }
                set
                {
                    this.ModelElement.Interface = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the concurrency property
        /// </summary>
        private sealed class ConcurrencyProxy : ModelPropertyChange<IBehavioralFeature, CallConcurrencyKind>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ConcurrencyProxy(IBehavioralFeature modelElement) : 
                    base(modelElement, "concurrency")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override CallConcurrencyKind Value
            {
                get
                {
                    return this.ModelElement.Concurrency;
                }
                set
                {
                    this.ModelElement.Concurrency = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isAbstract property
        /// </summary>
        private sealed class IsAbstractProxy : ModelPropertyChange<IBehavioralFeature, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsAbstractProxy(IBehavioralFeature modelElement) : 
                    base(modelElement, "isAbstract")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsAbstract;
                }
                set
                {
                    this.ModelElement.IsAbstract = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningTemplateParameter property
        /// </summary>
        private sealed class OwningTemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningTemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "owningTemplateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.OwningTemplateParameter;
                }
                set
                {
                    this.ModelElement.OwningTemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the templateParameter property
        /// </summary>
        private sealed class TemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "templateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.TemplateParameter;
                }
                set
                {
                    this.ModelElement.TemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the ownedTemplateSignature property
        /// </summary>
        private sealed class OwnedTemplateSignatureProxy : ModelPropertyChange<ITemplateableElement, ITemplateSignature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwnedTemplateSignatureProxy(ITemplateableElement modelElement) : 
                    base(modelElement, "ownedTemplateSignature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateSignature Value
            {
                get
                {
                    return this.ModelElement.OwnedTemplateSignature;
                }
                set
                {
                    this.ModelElement.OwnedTemplateSignature = value;
                }
            }
        }
    }
}
