//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// An Operation is a BehavioralFeature of a Classifier that specifies the name, type, parameters, and constraints for invoking an associated Behavior. An Operation may invoke both the execution of method behaviors as well as other behavioral responses. Operation specializes TemplateableElement in order to support specification of template operations and bound operations. Operation specializes ParameterableElement to specify that an operation can be exposed as a formal template parameter, and provided as an actual parameter in a binding of a template.
    ///<p>From package UML::Classification.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Operation")]
    [DebuggerDisplayAttribute("Operation {Name}")]
    public partial class Operation : BehavioralFeature, NMF.Interop.Uml.IOperation, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _at_most_one_returnOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAt_most_one_returnOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _only_body_for_queryOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOnly_body_for_queryOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getReturnResultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetReturnResultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setIsOrderedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetIsOrderedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setIsUniqueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetIsUniqueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setLowerOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetLowerOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setUpperOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetUpperOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isOrderedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsOrderedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isUniqueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsUniqueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getLowerOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetLowerOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _returnResultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveReturnResultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getUpperOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetUpperOperation);
        
        /// <summary>
        /// The backing field for the IsQuery property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isQuery = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isQueryAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsQueryAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _bodyConditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBodyConditionReference);
        
        /// <summary>
        /// The backing field for the BodyCondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _bodyCondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _classReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveClassReference);
        
        /// <summary>
        /// The backing field for the Class property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NMF.Interop.Uml.IClass _class;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _datatypeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDatatypeReference);
        
        /// <summary>
        /// The backing field for the Datatype property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NMF.Interop.Uml.IDataType _datatype;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _interfaceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveInterfaceReference);
        
        /// <summary>
        /// The backing field for the Interface property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IInterface _interface;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _postconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePostconditionReference);
        
        /// <summary>
        /// The backing field for the Postcondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IConstraint> _postcondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _preconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePreconditionReference);
        
        /// <summary>
        /// The backing field for the Precondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IConstraint> _precondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedOperationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedOperationReference);
        
        /// <summary>
        /// The backing field for the RedefinedOperation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<NMF.Interop.Uml.IOperation> _redefinedOperation;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompatibleWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompatibleWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateParameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateParameterOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningTemplateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningTemplateParameterReference);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the TemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _templateParameter;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameterableElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameterableElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateBindingReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateBindingReference);
        
        /// <summary>
        /// The backing field for the TemplateBinding property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TemplateableElementTemplateBindingCollection _templateBinding;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTemplateSignatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTemplateSignatureReference);
        
        /// <summary>
        /// The backing field for the OwnedTemplateSignature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateSignature _ownedTemplateSignature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Operation()
        {
            this._postcondition = new ObservableAssociationSet<IConstraint>();
            this._postcondition.CollectionChanging += this.PostconditionCollectionChanging;
            this._postcondition.CollectionChanged += this.PostconditionCollectionChanged;
            this._precondition = new ObservableAssociationSet<IConstraint>();
            this._precondition.CollectionChanging += this.PreconditionCollectionChanging;
            this._precondition.CollectionChanged += this.PreconditionCollectionChanged;
            this._redefinedOperation = new ObservableAssociationSet<NMF.Interop.Uml.IOperation>();
            this._redefinedOperation.CollectionChanging += this.RedefinedOperationCollectionChanging;
            this._redefinedOperation.CollectionChanged += this.RedefinedOperationCollectionChanged;
            this._templateBinding = new TemplateableElementTemplateBindingCollection(this);
            this._templateBinding.CollectionChanging += this.TemplateBindingCollectionChanging;
            this._templateBinding.CollectionChanged += this.TemplateBindingCollectionChanged;
        }
        
        /// <summary>
        /// Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged (isQuery=true) or whether side effects may occur (isQuery=false).
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isQuery")]
        [DescriptionAttribute("Specifies whether an execution of the BehavioralFeature leaves the state of the s" +
            "ystem unchanged (isQuery=true) or whether side effects may occur (isQuery=false)" +
            ".\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Operation")]
        [XmlElementNameAttribute("isQuery")]
        [XmlAttributeAttribute(true)]
        public bool IsQuery
        {
            get
            {
                return this._isQuery;
            }
            set
            {
                if ((this._isQuery != value))
                {
                    bool old = this._isQuery;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsQuery", e, _isQueryAttribute);
                    this._isQuery = value;
                    this.OnPropertyChanged("IsQuery", e, _isQueryAttribute);
                }
            }
        }
        
        /// <summary>
        /// An optional Constraint on the result values of an invocation of this Operation.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DisplayNameAttribute("bodyCondition")]
        [DescriptionAttribute("An optional Constraint on the result values of an invocation of this Operation.\n<" +
            "p>From package UML::Classification.</p>")]
        [CategoryAttribute("Operation")]
        [XmlElementNameAttribute("bodyCondition")]
        [XmlAttributeAttribute(true)]
        public IConstraint BodyCondition
        {
            get
            {
                return this._bodyCondition;
            }
            set
            {
                if ((this._bodyCondition != value))
                {
                    IConstraint old = this._bodyCondition;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("BodyCondition", e, _bodyConditionReference);
                    this._bodyCondition = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetBodyCondition;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetBodyCondition;
                    }
                    this.OnPropertyChanged("BodyCondition", e, _bodyConditionReference);
                }
            }
        }
        
        /// <summary>
        /// The Class that owns this operation, if any.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("class")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedOperation")]
        public NMF.Interop.Uml.IClass Class
        {
            get
            {
                return this._class;
            }
            set
            {
                if ((this._class != value))
                {
                    NMF.Interop.Uml.IClass old = this._class;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Class", e, _classReference);
                    this._class = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedOperation.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedOperation.Add(this);
                    }
                    this.OnPropertyChanged("Class", e, _classReference);
                }
            }
        }
        
        /// <summary>
        /// The DataType that owns this Operation, if any.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("datatype")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedOperation")]
        public NMF.Interop.Uml.IDataType Datatype
        {
            get
            {
                return this._datatype;
            }
            set
            {
                if ((this._datatype != value))
                {
                    NMF.Interop.Uml.IDataType old = this._datatype;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Datatype", e, _datatypeReference);
                    this._datatype = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedOperation.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedOperation.Add(this);
                    }
                    this.OnPropertyChanged("Datatype", e, _datatypeReference);
                }
            }
        }
        
        /// <summary>
        /// The Interface that owns this Operation, if any.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("interface")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedOperation")]
        public IInterface Interface
        {
            get
            {
                return this._interface;
            }
            set
            {
                if ((this._interface != value))
                {
                    IInterface old = this._interface;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Interface", e, _interfaceReference);
                    this._interface = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedOperation.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedOperation.Add(this);
                    }
                    this.OnPropertyChanged("Interface", e, _interfaceReference);
                }
            }
        }
        
        /// <summary>
        /// An optional set of Constraints specifying the state of the system when the Operation is completed.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("postcondition")]
        [DescriptionAttribute("An optional set of Constraints specifying the state of the system when the Operat" +
            "ion is completed.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Operation")]
        [XmlElementNameAttribute("postcondition")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IConstraint> Postcondition
        {
            get
            {
                return this._postcondition;
            }
        }
        
        /// <summary>
        /// An optional set of Constraints on the state of the system when the Operation is invoked.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("precondition")]
        [DescriptionAttribute("An optional set of Constraints on the state of the system when the Operation is i" +
            "nvoked.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Operation")]
        [XmlElementNameAttribute("precondition")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IConstraint> Precondition
        {
            get
            {
                return this._precondition;
            }
        }
        
        /// <summary>
        /// The Operations that are redefined by this Operation.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedOperation")]
        [DescriptionAttribute("The Operations that are redefined by this Operation.\n<p>From package UML::Classif" +
            "ication.</p>")]
        [CategoryAttribute("Operation")]
        [XmlElementNameAttribute("redefinedOperation")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<NMF.Interop.Uml.IOperation> RedefinedOperation
        {
            get
            {
                return this._redefinedOperation;
            }
        }
        
        /// <summary>
        /// The formal TemplateParameter that owns this ParameterableElement.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("owningTemplateParameter")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedParameteredElement")]
        public ITemplateParameter OwningTemplateParameter
        {
            get
            {
                return ModelHelper.CastAs<ITemplateParameter>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// The TemplateParameter that exposes this ParameterableElement as a formal parameter.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DisplayNameAttribute("templateParameter")]
        [DescriptionAttribute("The TemplateParameter that exposes this ParameterableElement as a formal paramete" +
            "r.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("templateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("parameteredElement")]
        public ITemplateParameter TemplateParameter
        {
            get
            {
                return this._templateParameter;
            }
            set
            {
                if ((this._templateParameter != value))
                {
                    ITemplateParameter old = this._templateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TemplateParameter", e, _templateParameterReference);
                    this._templateParameter = value;
                    if ((old != null))
                    {
                        old.ParameteredElement = null;
                        old.Deleted -= this.OnResetTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.ParameteredElement = this;
                        value.Deleted += this.OnResetTemplateParameter;
                    }
                    this.OnPropertyChanged("TemplateParameter", e, _templateParameterReference);
                }
            }
        }
        
        /// <summary>
        /// The optional TemplateBindings from this TemplateableElement to one or more templates.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("templateBinding")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("boundElement")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITemplateBinding> TemplateBinding
        {
            get
            {
                return this._templateBinding;
            }
        }
        
        /// <summary>
        /// The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a TemplateableElement has a TemplateSignature, then it is a template.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedTemplateSignature")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("template")]
        public ITemplateSignature OwnedTemplateSignature
        {
            get
            {
                return this._ownedTemplateSignature;
            }
            set
            {
                if ((this._ownedTemplateSignature != value))
                {
                    ITemplateSignature old = this._ownedTemplateSignature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                    this._ownedTemplateSignature = value;
                    if ((old != null))
                    {
                        old.Template = null;
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetOwnedTemplateSignature;
                    }
                    if ((value != null))
                    {
                        value.Template = this;
                        value.Parent = this;
                        value.ParentChanged += this.OnResetOwnedTemplateSignature;
                    }
                    this.OnPropertyChanged("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new OperationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new OperationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Operation")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// An Operation can have at most one return parameter; i.e., an owned parameter with the direction set to 'return.'
        ///self.ownedParameter->select(direction = ParameterDirectionKind::return)->size() <= 1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool At_most_one_return(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.IOperation, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, object, object, bool>>(_at_most_one_returnOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method at_most_one_return registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _at_most_one_returnOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _at_most_one_returnOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _at_most_one_returnOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAt_most_one_returnOperation()
        {
            return ClassInstance.LookupOperation("at_most_one_return");
        }
        
        /// <summary>
        /// A bodyCondition can only be specified for a query Operation.
        ///bodyCondition <> null implies isQuery
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Only_body_for_query(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.IOperation, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, object, object, bool>>(_only_body_for_queryOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method only_body_for_query registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _only_body_for_queryOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _only_body_for_queryOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _only_body_for_queryOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOnly_body_for_queryOperation()
        {
            return ClassInstance.LookupOperation("only_body_for_query");
        }
        
        /// <summary>
        /// Retrieves the (only) return result parameter for this operation.
        /// </summary>
        public NMF.Interop.Uml.IParameter GetReturnResult()
        {
            System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IParameter> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IParameter>>(_getReturnResultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getReturnResult registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getReturnResultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getReturnResultOperation.Value, e));
            NMF.Interop.Uml.IParameter result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getReturnResultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetReturnResultOperation()
        {
            return ClassInstance.LookupOperation("getReturnResult");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newIsOrdered"></param>
        public void SetIsOrdered(bool newIsOrdered)
        {
            System.Action<NMF.Interop.Uml.IOperation, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, bool>>(_setIsOrderedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setIsOrdered registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setIsOrderedOperation.Value, newIsOrdered);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setIsOrderedOperation.Value, e));
            handler.Invoke(this, newIsOrdered);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setIsOrderedOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetIsOrderedOperation()
        {
            return ClassInstance.LookupOperation("setIsOrdered");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newIsUnique"></param>
        public void SetIsUnique(bool newIsUnique)
        {
            System.Action<NMF.Interop.Uml.IOperation, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, bool>>(_setIsUniqueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setIsUnique registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setIsUniqueOperation.Value, newIsUnique);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setIsUniqueOperation.Value, e));
            handler.Invoke(this, newIsUnique);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setIsUniqueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetIsUniqueOperation()
        {
            return ClassInstance.LookupOperation("setIsUnique");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newLower"></param>
        public void SetLower(int newLower)
        {
            System.Action<NMF.Interop.Uml.IOperation, int> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, int>>(_setLowerOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setLower registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setLowerOperation.Value, newLower);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setLowerOperation.Value, e));
            handler.Invoke(this, newLower);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setLowerOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetLowerOperation()
        {
            return ClassInstance.LookupOperation("setLower");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newType"></param>
        public void SetType(NMF.Interop.Uml.IType newType)
        {
            System.Action<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType>>(_setTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setType registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setTypeOperation.Value, newType);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setTypeOperation.Value, e));
            handler.Invoke(this, newType);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setTypeOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetTypeOperation()
        {
            return ClassInstance.LookupOperation("setType");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newUpper"></param>
        public void SetUpper(object newUpper)
        {
            System.Action<NMF.Interop.Uml.IOperation, object> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation, object>>(_setUpperOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setUpper registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setUpperOperation.Value, newUpper);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setUpperOperation.Value, e));
            handler.Invoke(this, newUpper);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setUpperOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetUpperOperation()
        {
            return ClassInstance.LookupOperation("setUpper");
        }
        
        /// <summary>
        /// If this operation has a return parameter, isOrdered equals the value of isOrdered for that parameter. Otherwise isOrdered is false.
        ///result = (if returnResult()->notEmpty() then returnResult()-> exists(isOrdered) else false endif)
        ///<p>From package UML::Classification.</p>
        /// </summary>
        public bool IsOrdered()
        {
            System.Func<NMF.Interop.Uml.IOperation, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, bool>>(_isOrderedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isOrdered registered. Use the method broker" +
                        " to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isOrderedOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isOrderedOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isOrderedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsOrderedOperation()
        {
            return ClassInstance.LookupOperation("isOrdered");
        }
        
        /// <summary>
        /// If this operation has a return parameter, isUnique equals the value of isUnique for that parameter. Otherwise isUnique is true.
        ///result = (if returnResult()->notEmpty() then returnResult()->exists(isUnique) else true endif)
        ///<p>From package UML::Classification.</p>
        /// </summary>
        public bool IsUnique()
        {
            System.Func<NMF.Interop.Uml.IOperation, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, bool>>(_isUniqueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isUnique registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isUniqueOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isUniqueOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isUniqueOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsUniqueOperation()
        {
            return ClassInstance.LookupOperation("isUnique");
        }
        
        /// <summary>
        /// If this operation has a return parameter, lower equals the value of lower for that parameter. Otherwise lower has no value.
        ///result = (if returnResult()->notEmpty() then returnResult()->any(true).lower else null endif)
        ///<p>From package UML::Classification.</p>
        /// </summary>
        public int GetLower()
        {
            System.Func<NMF.Interop.Uml.IOperation, int> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, int>>(_getLowerOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getLower registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getLowerOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getLowerOperation.Value, e));
            int result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getLowerOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetLowerOperation()
        {
            return ClassInstance.LookupOperation("getLower");
        }
        
        /// <summary>
        /// The query returnResult() returns the set containing the return parameter of the Operation if one exists, otherwise, it returns an empty set
        ///result = (ownedParameter->select (direction = ParameterDirectionKind::return)->asSet())
        ///<p>From package UML::Classification.</p>
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IParameter> ReturnResult()
        {
            System.Func<NMF.Interop.Uml.IOperation, ISetExpression<NMF.Interop.Uml.IParameter>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, ISetExpression<NMF.Interop.Uml.IParameter>>>(_returnResultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method returnResult registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _returnResultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _returnResultOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IParameter> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _returnResultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveReturnResultOperation()
        {
            return ClassInstance.LookupOperation("returnResult");
        }
        
        /// <summary>
        /// If this operation has a return parameter, type equals the value of type for that parameter. Otherwise type has no value.
        ///result = (if returnResult()->notEmpty() then returnResult()->any(true).type else null endif)
        ///<p>From package UML::Classification.</p>
        /// </summary>
        public NMF.Interop.Uml.IType GetType()
        {
            System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IType>>(_getTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getType registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getTypeOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getTypeOperation.Value, e));
            NMF.Interop.Uml.IType result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetTypeOperation()
        {
            return ClassInstance.LookupOperation("getType");
        }
        
        /// <summary>
        /// If this operation has a return parameter, upper equals the value of upper for that parameter. Otherwise upper has no value.
        ///result = (if returnResult()->notEmpty() then returnResult()->any(true).upper else null endif)
        ///<p>From package UML::Classification.</p>
        /// </summary>
        public void GetUpper()
        {
            System.Action<NMF.Interop.Uml.IOperation> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<NMF.Interop.Uml.IOperation>>(_getUpperOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getUpper registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getUpperOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getUpperOperation.Value, e));
            handler.Invoke(this);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getUpperOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetUpperOperation()
        {
            return ClassInstance.LookupOperation("getUpper");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsQueryAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("isQuery")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBodyConditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("bodyCondition")));
        }
        
        /// <summary>
        /// Handles the event that the BodyCondition property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetBodyCondition(object sender, System.EventArgs eventArgs)
        {
            this.BodyCondition = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveClassReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("class")));
        }
        
        /// <summary>
        /// Handles the event that the Class property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetClass(object sender, System.EventArgs eventArgs)
        {
            this.Class = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDatatypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("datatype")));
        }
        
        /// <summary>
        /// Handles the event that the Datatype property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDatatype(object sender, System.EventArgs eventArgs)
        {
            this.Datatype = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveInterfaceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("interface")));
        }
        
        /// <summary>
        /// Handles the event that the Interface property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetInterface(object sender, System.EventArgs eventArgs)
        {
            this.Interface = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePostconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("postcondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Postcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PostconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Postcondition", e, _postconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Postcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PostconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Postcondition", e, _postconditionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePreconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("precondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Precondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PreconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Precondition", e, _preconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Precondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PreconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Precondition", e, _preconditionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedOperationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Operation.ClassInstance)).Resolve("redefinedOperation")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedOperation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedOperationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedOperation", e, _redefinedOperationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedOperation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedOperationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedOperation", e, _redefinedOperationReference);
        }
        
        /// <summary>
        /// The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified ParameterableElement. By default, this ParameterableElement is compatible with another ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. Subclasses of ParameterableElement should override this operation to specify different compatibility constraints.
        ///result = (self.oclIsKindOf(p.oclType()))
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        /// <param name="p"></param>
        public bool IsCompatibleWith(IParameterableElement p)
        {
            System.Func<IParameterableElement, IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, IParameterableElement, bool>>(_isCompatibleWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isCompatibleWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompatibleWithOperation.Value, p);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompatibleWithOperation.Value, e));
            bool result = handler.Invoke(this, p);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompatibleWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompatibleWithOperation()
        {
            return ClassInstance.LookupOperation("isCompatibleWith");
        }
        
        /// <summary>
        /// The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal TemplateParameter.
        ///result = (templateParameter->notEmpty())
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public bool IsTemplateParameter()
        {
            System.Func<IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, bool>>(_isTemplateParameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplateParameter registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateParameterOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateParameterOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateParameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateParameterOperation()
        {
            return ClassInstance.LookupOperation("isTemplateParameter");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("owningTemplateParameter")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            ITemplateParameter oldOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(oldParent);
            ITemplateParameter newOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldOwningTemplateParameter, newOwningTemplateParameter);
            this.OnPropertyChanging("OwningTemplateParameter", e, _owningTemplateParameterReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            ITemplateParameter oldOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(oldParent);
            ITemplateParameter newOwningTemplateParameter = ModelHelper.CastAs<ITemplateParameter>(newParent);
            if ((oldOwningTemplateParameter != null))
            {
                oldOwningTemplateParameter.OwnedParameteredElement = null;
            }
            if ((newOwningTemplateParameter != null))
            {
                newOwningTemplateParameter.OwnedParameteredElement = this;
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldOwningTemplateParameter, newOwningTemplateParameter);
            this.OnPropertyChanged("OwningTemplateParameter", e, _owningTemplateParameterReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("templateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the TemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            this.TemplateParameter = null;
        }
        
        /// <summary>
        /// The query isTemplate() returns whether this TemplateableElement is actually a template.
        ///result = (ownedTemplateSignature <> null)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public bool IsTemplate()
        {
            System.Func<ITemplateableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, bool>>(_isTemplateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplate registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateOperation()
        {
            return ClassInstance.LookupOperation("isTemplate");
        }
        
        /// <summary>
        /// The query parameterableElements() returns the set of ParameterableElements that may be used as the parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all the ownedElements. Subclasses may override this operation if they choose to restrict the set of ParameterableElements.
        ///result = (self.allOwnedElements()->select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)->asSet())
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public ISetExpression<IParameterableElement> ParameterableElements()
        {
            System.Func<ITemplateableElement, ISetExpression<IParameterableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, ISetExpression<IParameterableElement>>>(_parameterableElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameterableElements registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameterableElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameterableElementsOperation.Value, e));
            ISetExpression<IParameterableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameterableElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameterableElementsOperation()
        {
            return ClassInstance.LookupOperation("parameterableElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateBindingReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("templateBinding")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TemplateBinding", e, _templateBindingReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TemplateBinding", e, _templateBindingReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTemplateSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("ownedTemplateSignature")));
        }
        
        /// <summary>
        /// Handles the event that the OwnedTemplateSignature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwnedTemplateSignature(object sender, System.EventArgs eventArgs)
        {
            this.OwnedTemplateSignature = null;
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int templateBindingIndex = ModelHelper.IndexOfReference(this.TemplateBinding, element);
            if ((templateBindingIndex != -1))
            {
                return ModelHelper.CreatePath("templateBinding", templateBindingIndex);
            }
            if ((element == this.OwnedTemplateSignature))
            {
                return ModelHelper.CreatePath("ownedTemplateSignature");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BODYCONDITION"))
            {
                return this.BodyCondition;
            }
            if ((reference == "CLASS"))
            {
                return this.Class;
            }
            if ((reference == "DATATYPE"))
            {
                return this.Datatype;
            }
            if ((reference == "INTERFACE"))
            {
                return this.Interface;
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return this.OwningTemplateParameter;
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return this.TemplateParameter;
            }
            if ((reference == "TEMPLATEBINDING"))
            {
                if ((index < this.TemplateBinding.Count))
                {
                    return this.TemplateBinding[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return this.OwnedTemplateSignature;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISQUERY"))
            {
                return this.IsQuery;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "POSTCONDITION"))
            {
                return this._postcondition;
            }
            if ((feature == "PRECONDITION"))
            {
                return this._precondition;
            }
            if ((feature == "REDEFINEDOPERATION"))
            {
                return this._redefinedOperation;
            }
            if ((feature == "TEMPLATEBINDING"))
            {
                return this._templateBinding;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BODYCONDITION"))
            {
                this.BodyCondition = ((IConstraint)(value));
                return;
            }
            if ((feature == "CLASS"))
            {
                this.Class = ((NMF.Interop.Uml.IClass)(value));
                return;
            }
            if ((feature == "DATATYPE"))
            {
                this.Datatype = ((NMF.Interop.Uml.IDataType)(value));
                return;
            }
            if ((feature == "INTERFACE"))
            {
                this.Interface = ((IInterface)(value));
                return;
            }
            if ((feature == "OWNINGTEMPLATEPARAMETER"))
            {
                this.OwningTemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "TEMPLATEPARAMETER"))
            {
                this.TemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "OWNEDTEMPLATESIGNATURE"))
            {
                this.OwnedTemplateSignature = ((ITemplateSignature)(value));
                return;
            }
            if ((feature == "ISQUERY"))
            {
                this.IsQuery = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISQUERY"))
            {
                return Observable.Box(new IsQueryProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "BODYCONDITION"))
            {
                return new BodyConditionProxy(this);
            }
            if ((reference == "CLASS"))
            {
                return new ClassProxy(this);
            }
            if ((reference == "DATATYPE"))
            {
                return new DatatypeProxy(this);
            }
            if ((reference == "INTERFACE"))
            {
                return new InterfaceProxy(this);
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return new OwningTemplateParameterProxy(this);
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return new TemplateParameterProxy(this);
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return new OwnedTemplateSignatureProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._templateBinding))
            {
                return "templateBinding";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Operation")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Operation class
        /// </summary>
        public class OperationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Operation _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public OperationChildrenCollection(Operation parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.TemplateBinding.Count);
                    if ((this._parent.OwnedTemplateSignature != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITemplateBinding templateBindingCasted = item.As<ITemplateBinding>();
                if ((templateBindingCasted != null))
                {
                    this._parent.TemplateBinding.Add(templateBindingCasted);
                }
                if ((this._parent.OwnedTemplateSignature == null))
                {
                    ITemplateSignature ownedTemplateSignatureCasted = item.As<ITemplateSignature>();
                    if ((ownedTemplateSignatureCasted != null))
                    {
                        this._parent.OwnedTemplateSignature = ownedTemplateSignatureCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TemplateBinding.Clear();
                this._parent.OwnedTemplateSignature = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.TemplateBinding.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.OwnedTemplateSignature))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> templateBindingEnumerator = this._parent.TemplateBinding.GetEnumerator();
                try
                {
                    for (
                    ; templateBindingEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = templateBindingEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    templateBindingEnumerator.Dispose();
                }
                if ((this._parent.OwnedTemplateSignature != null))
                {
                    array[arrayIndex] = this._parent.OwnedTemplateSignature;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITemplateBinding templateBindingItem = item.As<ITemplateBinding>();
                if (((templateBindingItem != null) 
                            && this._parent.TemplateBinding.Remove(templateBindingItem)))
                {
                    return true;
                }
                if ((this._parent.OwnedTemplateSignature == item))
                {
                    this._parent.OwnedTemplateSignature = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TemplateBinding).Concat(this._parent.OwnedTemplateSignature).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Operation class
        /// </summary>
        public class OperationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Operation _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public OperationReferencedElementsCollection(Operation parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.BodyCondition != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Class != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Datatype != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Interface != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Postcondition.Count);
                    count = (count + this._parent.Precondition.Count);
                    count = (count + this._parent.RedefinedOperation.Count);
                    if ((this._parent.OwningTemplateParameter != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.TemplateParameter != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.TemplateBinding.Count);
                    if ((this._parent.OwnedTemplateSignature != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Postcondition.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Precondition.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.RedefinedOperation.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Postcondition.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Precondition.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.RedefinedOperation.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.TemplateBinding.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.BodyCondition == null))
                {
                    IConstraint bodyConditionCasted = item.As<IConstraint>();
                    if ((bodyConditionCasted != null))
                    {
                        this._parent.BodyCondition = bodyConditionCasted;
                        return;
                    }
                }
                if ((this._parent.Class == null))
                {
                    NMF.Interop.Uml.IClass classCasted = item.As<NMF.Interop.Uml.IClass>();
                    if ((classCasted != null))
                    {
                        this._parent.Class = classCasted;
                        return;
                    }
                }
                if ((this._parent.Datatype == null))
                {
                    NMF.Interop.Uml.IDataType datatypeCasted = item.As<NMF.Interop.Uml.IDataType>();
                    if ((datatypeCasted != null))
                    {
                        this._parent.Datatype = datatypeCasted;
                        return;
                    }
                }
                if ((this._parent.Interface == null))
                {
                    IInterface interfaceCasted = item.As<IInterface>();
                    if ((interfaceCasted != null))
                    {
                        this._parent.Interface = interfaceCasted;
                        return;
                    }
                }
                IConstraint postconditionCasted = item.As<IConstraint>();
                if ((postconditionCasted != null))
                {
                    this._parent.Postcondition.Add(postconditionCasted);
                }
                IConstraint preconditionCasted = item.As<IConstraint>();
                if ((preconditionCasted != null))
                {
                    this._parent.Precondition.Add(preconditionCasted);
                }
                NMF.Interop.Uml.IOperation redefinedOperationCasted = item.As<NMF.Interop.Uml.IOperation>();
                if ((redefinedOperationCasted != null))
                {
                    this._parent.RedefinedOperation.Add(redefinedOperationCasted);
                }
                if ((this._parent.OwningTemplateParameter == null))
                {
                    ITemplateParameter owningTemplateParameterCasted = item.As<ITemplateParameter>();
                    if ((owningTemplateParameterCasted != null))
                    {
                        this._parent.OwningTemplateParameter = owningTemplateParameterCasted;
                        return;
                    }
                }
                if ((this._parent.TemplateParameter == null))
                {
                    ITemplateParameter templateParameterCasted = item.As<ITemplateParameter>();
                    if ((templateParameterCasted != null))
                    {
                        this._parent.TemplateParameter = templateParameterCasted;
                        return;
                    }
                }
                ITemplateBinding templateBindingCasted = item.As<ITemplateBinding>();
                if ((templateBindingCasted != null))
                {
                    this._parent.TemplateBinding.Add(templateBindingCasted);
                }
                if ((this._parent.OwnedTemplateSignature == null))
                {
                    ITemplateSignature ownedTemplateSignatureCasted = item.As<ITemplateSignature>();
                    if ((ownedTemplateSignatureCasted != null))
                    {
                        this._parent.OwnedTemplateSignature = ownedTemplateSignatureCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.BodyCondition = null;
                this._parent.Class = null;
                this._parent.Datatype = null;
                this._parent.Interface = null;
                this._parent.Postcondition.Clear();
                this._parent.Precondition.Clear();
                this._parent.RedefinedOperation.Clear();
                this._parent.OwningTemplateParameter = null;
                this._parent.TemplateParameter = null;
                this._parent.TemplateBinding.Clear();
                this._parent.OwnedTemplateSignature = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.BodyCondition))
                {
                    return true;
                }
                if ((item == this._parent.Class))
                {
                    return true;
                }
                if ((item == this._parent.Datatype))
                {
                    return true;
                }
                if ((item == this._parent.Interface))
                {
                    return true;
                }
                if (this._parent.Postcondition.Contains(item))
                {
                    return true;
                }
                if (this._parent.Precondition.Contains(item))
                {
                    return true;
                }
                if (this._parent.RedefinedOperation.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.OwningTemplateParameter))
                {
                    return true;
                }
                if ((item == this._parent.TemplateParameter))
                {
                    return true;
                }
                if (this._parent.TemplateBinding.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.OwnedTemplateSignature))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.BodyCondition != null))
                {
                    array[arrayIndex] = this._parent.BodyCondition;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Class != null))
                {
                    array[arrayIndex] = this._parent.Class;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Datatype != null))
                {
                    array[arrayIndex] = this._parent.Datatype;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Interface != null))
                {
                    array[arrayIndex] = this._parent.Interface;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> postconditionEnumerator = this._parent.Postcondition.GetEnumerator();
                try
                {
                    for (
                    ; postconditionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = postconditionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    postconditionEnumerator.Dispose();
                }
                IEnumerator<IModelElement> preconditionEnumerator = this._parent.Precondition.GetEnumerator();
                try
                {
                    for (
                    ; preconditionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = preconditionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    preconditionEnumerator.Dispose();
                }
                IEnumerator<IModelElement> redefinedOperationEnumerator = this._parent.RedefinedOperation.GetEnumerator();
                try
                {
                    for (
                    ; redefinedOperationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = redefinedOperationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    redefinedOperationEnumerator.Dispose();
                }
                if ((this._parent.OwningTemplateParameter != null))
                {
                    array[arrayIndex] = this._parent.OwningTemplateParameter;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.TemplateParameter != null))
                {
                    array[arrayIndex] = this._parent.TemplateParameter;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> templateBindingEnumerator = this._parent.TemplateBinding.GetEnumerator();
                try
                {
                    for (
                    ; templateBindingEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = templateBindingEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    templateBindingEnumerator.Dispose();
                }
                if ((this._parent.OwnedTemplateSignature != null))
                {
                    array[arrayIndex] = this._parent.OwnedTemplateSignature;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.BodyCondition == item))
                {
                    this._parent.BodyCondition = null;
                    return true;
                }
                if ((this._parent.Class == item))
                {
                    this._parent.Class = null;
                    return true;
                }
                if ((this._parent.Datatype == item))
                {
                    this._parent.Datatype = null;
                    return true;
                }
                if ((this._parent.Interface == item))
                {
                    this._parent.Interface = null;
                    return true;
                }
                IConstraint constraintItem = item.As<IConstraint>();
                if (((constraintItem != null) 
                            && this._parent.Postcondition.Remove(constraintItem)))
                {
                    return true;
                }
                if (((constraintItem != null) 
                            && this._parent.Precondition.Remove(constraintItem)))
                {
                    return true;
                }
                NMF.Interop.Uml.IOperation operationItem = item.As<NMF.Interop.Uml.IOperation>();
                if (((operationItem != null) 
                            && this._parent.RedefinedOperation.Remove(operationItem)))
                {
                    return true;
                }
                if ((this._parent.OwningTemplateParameter == item))
                {
                    this._parent.OwningTemplateParameter = null;
                    return true;
                }
                if ((this._parent.TemplateParameter == item))
                {
                    this._parent.TemplateParameter = null;
                    return true;
                }
                ITemplateBinding templateBindingItem = item.As<ITemplateBinding>();
                if (((templateBindingItem != null) 
                            && this._parent.TemplateBinding.Remove(templateBindingItem)))
                {
                    return true;
                }
                if ((this._parent.OwnedTemplateSignature == item))
                {
                    this._parent.OwnedTemplateSignature = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.BodyCondition).Concat(this._parent.Class).Concat(this._parent.Datatype).Concat(this._parent.Interface).Concat(this._parent.Postcondition).Concat(this._parent.Precondition).Concat(this._parent.RedefinedOperation).Concat(this._parent.OwningTemplateParameter).Concat(this._parent.TemplateParameter).Concat(this._parent.TemplateBinding).Concat(this._parent.OwnedTemplateSignature).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isQuery property
        /// </summary>
        private sealed class IsQueryProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsQueryProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "isQuery")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsQuery;
                }
                set
                {
                    this.ModelElement.IsQuery = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the bodyCondition property
        /// </summary>
        private sealed class BodyConditionProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BodyConditionProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "bodyCondition")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.BodyCondition;
                }
                set
                {
                    this.ModelElement.BodyCondition = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the class property
        /// </summary>
        private sealed class ClassProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IClass>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ClassProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "class")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override NMF.Interop.Uml.IClass Value
            {
                get
                {
                    return this.ModelElement.Class;
                }
                set
                {
                    this.ModelElement.Class = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the datatype property
        /// </summary>
        private sealed class DatatypeProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, NMF.Interop.Uml.IDataType>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DatatypeProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "datatype")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override NMF.Interop.Uml.IDataType Value
            {
                get
                {
                    return this.ModelElement.Datatype;
                }
                set
                {
                    this.ModelElement.Datatype = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the interface property
        /// </summary>
        private sealed class InterfaceProxy : ModelPropertyChange<NMF.Interop.Uml.IOperation, IInterface>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public InterfaceProxy(NMF.Interop.Uml.IOperation modelElement) : 
                    base(modelElement, "interface")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IInterface Value
            {
                get
                {
                    return this.ModelElement.Interface;
                }
                set
                {
                    this.ModelElement.Interface = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningTemplateParameter property
        /// </summary>
        private sealed class OwningTemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningTemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "owningTemplateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.OwningTemplateParameter;
                }
                set
                {
                    this.ModelElement.OwningTemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the templateParameter property
        /// </summary>
        private sealed class TemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "templateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.TemplateParameter;
                }
                set
                {
                    this.ModelElement.TemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the ownedTemplateSignature property
        /// </summary>
        private sealed class OwnedTemplateSignatureProxy : ModelPropertyChange<ITemplateableElement, ITemplateSignature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwnedTemplateSignatureProxy(ITemplateableElement modelElement) : 
                    base(modelElement, "ownedTemplateSignature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateSignature Value
            {
                get
                {
                    return this.ModelElement.OwnedTemplateSignature;
                }
                set
                {
                    this.ModelElement.OwnedTemplateSignature = value;
                }
            }
        }
    }
}

