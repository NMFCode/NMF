//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for UseCase
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(UseCase))]
    [XmlDefaultImplementationTypeAttribute(typeof(UseCase))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//UseCase")]
    public interface IUseCase : IModelElement, IBehavioredClassifier
    {
        
        /// <summary>
        /// The Extend relationships owned by this UseCase.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("extend")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("extension")]
        [ConstantAttribute()]
        IOrderedSetExpression<IExtend> Extend
        {
            get;
        }
        
        /// <summary>
        /// The ExtensionPoints owned by this UseCase.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("extensionPoint")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("useCase")]
        [ConstantAttribute()]
        IOrderedSetExpression<IExtensionPoint> ExtensionPoint
        {
            get;
        }
        
        /// <summary>
        /// The Include relationships owned by this UseCase.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("include")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("includingCase")]
        [ConstantAttribute()]
        IOrderedSetExpression<IInclude> Include
        {
            get;
        }
        
        /// <summary>
        /// The subjects to which this UseCase applies. Each subject or its parts realize all the UseCases that apply to it.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("subject")]
        [DescriptionAttribute("The subjects to which this UseCase applies. Each subject or its parts realize all" +
            " the UseCases that apply to it.\n<p>From package UML::UseCases.</p>")]
        [CategoryAttribute("UseCase")]
        [XmlElementNameAttribute("subject")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("useCase")]
        [ConstantAttribute()]
        ISetExpression<IClassifier> Subject
        {
            get;
        }
        
        /// <summary>
        /// UseCases can only be involved in binary Associations.
        ///Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies a.memberEnd->size() = 2)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Binary_associations(object diagnostics, object context);
        
        /// <summary>
        /// UseCases cannot have Associations to UseCases specifying the same subject.
        ///Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies 
        ///   (
        ///   let usecases: Set(UseCase) = a.memberEnd.type->select(oclIsKindOf(UseCase))->collect(oclAsType(UseCase))->asSet() in
        ///   usecases->size() > 1 implies usecases->collect(subject)->size() > 1
        ///   )
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool No_association_to_use_case(object diagnostics, object context);
        
        /// <summary>
        /// A UseCase cannot include UseCases that directly or indirectly include it.
        ///not allIncludedUseCases()->includes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Cannot_include_self(object diagnostics, object context);
        
        /// <summary>
        /// A UseCase must have a name.
        ///name -> notEmpty ()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Must_have_name(object diagnostics, object context);
        
        /// <summary>
        /// The query allIncludedUseCases() returns the transitive closure of all UseCases (directly or indirectly) included by this UseCase.
        ///result = (self.include.addition->union(self.include.addition->collect(uc | uc.allIncludedUseCases()))->asSet())
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        ISetExpression<IUseCase> AllIncludedUseCases();
    }
}

