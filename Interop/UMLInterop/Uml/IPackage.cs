//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for Package
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Package))]
    [XmlDefaultImplementationTypeAttribute(typeof(Package))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Package")]
    public interface IPackage : IModelElement, ITemplateableElement, IPackageableElement, NMF.Interop.Uml.INamespace
    {
        
        /// <summary>
        /// Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DescriptionAttribute(@"Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
<p>From package UML::Packages.</p>")]
        [CategoryAttribute("Package")]
        [XmlAttributeAttribute(true)]
        string URI
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the PackageMerges that are owned by this Package.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageMerge")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("receivingPackage")]
        [ConstantAttribute()]
        IOrderedSetExpression<IPackageMerge> PackageMerge
        {
            get;
        }
        
        /// <summary>
        /// Specifies the packageable elements that are owned by this Package.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packagedElement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IPackageableElement> PackagedElement
        {
            get;
        }
        
        /// <summary>
        /// References the ProfileApplications that indicate which profiles have been applied to the Package.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("profileApplication")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("applyingPackage")]
        [ConstantAttribute()]
        IOrderedSetExpression<IProfileApplication> ProfileApplication
        {
            get;
        }
        
        /// <summary>
        /// If an element that is owned by a package has visibility, it is public or private.
        ///packagedElement->forAll(e | e.visibility<> null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Elements_public_or_private(object diagnostics, object context);
        
        /// <summary>
        /// Applies the current definition of the specified profile to this package and automatically applies required stereotypes in the profile to elements within this package's namespace hieararchy. If a different definition is already applied, automatically migrates any associated stereotype values on a "best effort" basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profile">The profile to apply.</param>
        ISetExpression<IEObject> ApplyProfile(IProfile profile);
        
        /// <summary>
        /// Creates a(n) (abstract) class with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new class, or null.</param>
        /// <param name="isAbstract">Whether the new class should be abstract.</param>
        NMF.Interop.Uml.IClass CreateOwnedClass(string name, bool isAbstract);
        
        /// <summary>
        /// Creates a enumeration with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new enumeration, or null.</param>
        NMF.Interop.Uml.IEnumeration CreateOwnedEnumeration(string name);
        
        /// <summary>
        /// Creates an interface with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new interface, or null.</param>
        IInterface CreateOwnedInterface(string name);
        
        /// <summary>
        /// Creates a primitive type with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new primitive type, or null.</param>
        NMF.Interop.Uml.IPrimitiveType CreateOwnedPrimitiveType(string name);
        
        /// <summary>
        /// Creates a(n) (abstract) stereotype with the specified name as an owned stereotype of this profile.
        /// </summary>
        /// <param name="name">The name for the new stereotype, or null.</param>
        /// <param name="isAbstract">Whether the new stereotype should be abstract.</param>
        IStereotype CreateOwnedStereotype(string name, bool isAbstract);
        
        /// <summary>
        /// Retrieves all the profiles that are applied to this package, including profiles applied to its nesting package(s).
        /// </summary>
        ISetExpression<IProfile> GetAllAppliedProfiles();
        
        /// <summary>
        /// Retrieves all the profile applications for this package, including profile applications for its nesting package(s).
        /// </summary>
        ISetExpression<IProfileApplication> GetAllProfileApplications();
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        IProfile GetAppliedProfile(string qualifiedName);
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        IProfile GetAppliedProfile(string qualifiedName, bool recurse);
        
        /// <summary>
        /// Retrieves the profiles that are applied to this package.
        /// </summary>
        ISetExpression<IProfile> GetAppliedProfiles();
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        IProfileApplication GetProfileApplication(IProfile profile);
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        IProfileApplication GetProfileApplication(IProfile profile, bool recurse);
        
        /// <summary>
        /// Determines whether this package is a model library.
        /// </summary>
        bool IsModelLibrary();
        
        /// <summary>
        /// Determines whether the specified profile is applied to this package.
        /// </summary>
        /// <param name="profile">The profile in question.</param>
        bool IsProfileApplied(IProfile profile);
        
        /// <summary>
        /// Unapplies the specified profile from this package and automatically unapplies stereotypes in the profile from elements within this package's namespace hieararchy.
        /// </summary>
        /// <param name="profile">The profile to unapply.</param>
        ISetExpression<IEObject> UnapplyProfile(IProfile profile);
        
        /// <summary>
        /// Applies the current definitions of the specified profiles to this package and automatically applies required stereotypes in the profiles to elements within this package's namespace hieararchy. If different definitions are already applied, automatically migrates any associated stereotype values on a "best effort" basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profiles">The profiles to apply.</param>
        ISetExpression<IEObject> ApplyProfiles([LowerBoundAttribute(1)] IEnumerable<IProfile> profiles);
        
        /// <summary>
        /// The query allApplicableStereotypes() returns all the directly or indirectly owned stereotypes, including stereotypes contained in sub-profiles.
        ///result = (let ownedPackages : Bag(Package) = ownedMember->select(oclIsKindOf(Package))->collect(oclAsType(Package)) in
        /// ownedStereotype->union(ownedPackages.allApplicableStereotypes())->flatten()->asSet()
        ///)
        ///<p>From package UML::Packages.</p>
        /// </summary>
        ISetExpression<IStereotype> AllApplicableStereotypes();
        
        /// <summary>
        /// The query containingProfile() returns the closest profile directly or indirectly containing this package (or this package itself, if it is a profile).
        ///result = (if self.oclIsKindOf(Profile) then 
        ///	self.oclAsType(Profile)
        ///else
        ///	self.namespace.oclAsType(Package).containingProfile()
        ///endif)
        ///<p>From package UML::Packages.</p>
        /// </summary>
        IProfile ContainingProfile();
        
        /// <summary>
        /// The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility and elements with public visibility are made visible.
        ///member->includes(el)
        ///result = (ownedMember->includes(el) or
        ///(elementImport->select(ei|ei.importedElement = VisibilityKind::public)->collect(importedElement.oclAsType(NamedElement))->includes(el)) or
        ///(packageImport->select(visibility = VisibilityKind::public)->collect(importedPackage.member->includes(el))->notEmpty()))
        ///<p>From package UML::Packages.</p>
        /// </summary>
        /// <param name="el"></param>
        bool MakesVisible(INamedElement el);
        
        /// <summary>
        /// Derivation for Package::/nestedPackage
        ///result = (packagedElement->select(oclIsKindOf(Package))->collect(oclAsType(Package))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        ISetExpression<IPackage> GetNestedPackages();
        
        /// <summary>
        /// Derivation for Package::/ownedStereotype
        ///result = (packagedElement->select(oclIsKindOf(Stereotype))->collect(oclAsType(Stereotype))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        ISetExpression<IStereotype> GetOwnedStereotypes();
        
        /// <summary>
        /// Derivation for Package::/ownedType
        ///result = (packagedElement->select(oclIsKindOf(Type))->collect(oclAsType(Type))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        ISetExpression<NMF.Interop.Uml.IType> GetOwnedTypes();
        
        /// <summary>
        /// The query visibleMembers() defines which members of a Package can be accessed outside it.
        ///result = (member->select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))->collect(oclAsType(PackageableElement))->asSet())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        ISetExpression<IPackageableElement> VisibleMembers();
    }
}

