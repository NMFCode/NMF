//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for Message
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Message))]
    [XmlDefaultImplementationTypeAttribute(typeof(Message))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Message")]
    public interface IMessage : IModelElement, INamedElement
    {
        
        /// <summary>
        /// The sort of communication reflected by the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DefaultValueAttribute(MessageSort.SynchCall)]
        [DisplayNameAttribute("messageSort")]
        [DescriptionAttribute("The sort of communication reflected by the Message.\n<p>From package UML::Interact" +
            "ions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("messageSort")]
        [XmlAttributeAttribute(true)]
        MessageSort MessageSort
        {
            get;
            set;
        }
        
        /// <summary>
        /// The arguments of the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("argument")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IValueSpecification> Argument
        {
            get;
        }
        
        /// <summary>
        /// The Connector on which this Message is sent.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("connector")]
        [DescriptionAttribute("The Connector on which this Message is sent.\n<p>From package UML::Interactions.</" +
            "p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("connector")]
        [XmlAttributeAttribute(true)]
        IConnector Connector
        {
            get;
            set;
        }
        
        /// <summary>
        /// The enclosing Interaction owning the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("interaction")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("message")]
        IInteraction Interaction
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the Receiving of the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("receiveEvent")]
        [DescriptionAttribute("References the Receiving of the Message.\n<p>From package UML::Interactions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("receiveEvent")]
        [XmlAttributeAttribute(true)]
        IMessageEnd ReceiveEvent
        {
            get;
            set;
        }
        
        /// <summary>
        /// References the Sending of the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("sendEvent")]
        [DescriptionAttribute("References the Sending of the Message.\n<p>From package UML::Interactions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("sendEvent")]
        [XmlAttributeAttribute(true)]
        IMessageEnd SendEvent
        {
            get;
            set;
        }
        
        /// <summary>
        /// The signature of the Message is the specification of its content. It refers either an Operation or a Signal.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("signature")]
        [DescriptionAttribute("The signature of the Message is the specification of its content. It refers eithe" +
            "r an Operation or a Signal.\n<p>From package UML::Interactions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("signature")]
        [XmlAttributeAttribute(true)]
        INamedElement Signature
        {
            get;
            set;
        }
        
        /// <summary>
        /// If the sendEvent and the receiveEvent of the same Message are on the same Lifeline, the sendEvent must be ordered before the receiveEvent.
        ///receiveEvent.oclIsKindOf(MessageOccurrenceSpecification)
        ///implies
        ///let f :  Lifeline = sendEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered in
        ///f = receiveEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered  implies
        ///f.events->indexOf(sendEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() ) < 
        ///f.events->indexOf(receiveEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() )
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Sending_receiving_message_event(object diagnostics, object context);
        
        /// <summary>
        /// Arguments of a Message must only be: i) attributes of the sending lifeline, ii) constants, iii) symbolic values (which are wildcard values representing any legal value), iv) explicit parameters of the enclosing Interaction, v) attributes of the class owning the Interaction.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Arguments(object diagnostics, object context);
        
        /// <summary>
        /// Messages cannot cross boundaries of CombinedFragments or their operands.  This is true if and only if both MessageEnds are enclosed within the same InteractionFragment (i.e., an InteractionOperand or an Interaction).
        ///sendEvent->notEmpty() and receiveEvent->notEmpty() implies
        ///let sendEnclosingFrag : Set(InteractionFragment) = 
        ///sendEvent->asOrderedSet()->first().enclosingFragment()
        ///in 
        ///let receiveEnclosingFrag : Set(InteractionFragment) = 
        ///receiveEvent->asOrderedSet()->first().enclosingFragment()
        ///in  sendEnclosingFrag = receiveEnclosingFrag
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Cannot_cross_boundaries(object diagnostics, object context);
        
        /// <summary>
        /// In the case when the Message signature is a Signal, the arguments of the Message must correspond to the attributes of the Signal. A Message Argument corresponds to a Signal Attribute if the Argument is of the same Class or a specialization of that of the Attribute.
        ///(messageSort = MessageSort::asynchSignal ) and signature.oclIsKindOf(Signal) implies
        ///   let signalAttributes : OrderedSet(Property) = signature.oclAsType(Signal).inheritedMember()->
        ///             select(n:NamedElement | n.oclIsTypeOf(Property))->collect(oclAsType(Property))->asOrderedSet()
        ///   in signalAttributes->size() = self.argument->size()
        ///   and self.argument->forAll( o: ValueSpecification |
        ///          not (o.oclIsKindOf(Expression)
        ///          and o.oclAsType(Expression).symbol->size()=0
        ///          and o.oclAsType(Expression).operand->isEmpty() ) implies
        ///              let p : Property = signalAttributes->at(self.argument->indexOf(o))
        ///              in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Signature_is_signal(object diagnostics, object context);
        
        /// <summary>
        /// If the MessageEnds are both OccurrenceSpecifications, then the connector must go between the Parts represented by the Lifelines of the two MessageEnds.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Occurrence_specifications(object diagnostics, object context);
        
        /// <summary>
        /// The signature must either refer an Operation (in which case messageSort is either synchCall or asynchCall or reply) or a Signal (in which case messageSort is asynchSignal). The name of the NamedElement referenced by signature must be the same as that of the Message.
        ///signature->notEmpty() implies 
        ///((signature.oclIsKindOf(Operation) and 
        ///(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or messageSort = MessageSort::reply) 
        ///) or (signature.oclIsKindOf(Signal)  and messageSort = MessageSort::asynchSignal )
        /// ) and name = signature.name
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Signature_refer_to(object diagnostics, object context);
        
        /// <summary>
        /// In the case when a Message with messageSort synchCall or asynchCall has a non empty Operation signature, the arguments of the Message must correspond to the in and inout parameters of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.
        ///(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall) and signature.oclIsKindOf(Operation)  implies 
        /// let requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
        /// select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::_'in'  )
        ///in requestParms->size() = self.argument->size() and
        ///self.argument->forAll( o: ValueSpecification | 
        ///not (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and o.oclAsType(Expression).operand->isEmpty() ) implies 
        ///let p : Parameter = requestParms->at(self.argument->indexOf(o)) in
        ///o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Signature_is_operation_request(object diagnostics, object context);
        
        /// <summary>
        /// In the case when a Message with messageSort reply has a non empty Operation signature, the arguments of the Message must correspond to the out, inout, and return parameters of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.
        ///(messageSort = MessageSort::reply) and signature.oclIsKindOf(Operation) implies 
        /// let replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
        ///select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::return)
        ///in replyParms->size() = self.argument->size() and
        ///self.argument->forAll( o: ValueSpecification | o.oclIsKindOf(Expression) and let e : Expression = o.oclAsType(Expression) in
        ///e.operand->notEmpty()  implies 
        ///let p : Parameter = replyParms->at(self.argument->indexOf(o)) in
        ///e.operand->asSequence()->first().type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Signature_is_operation_reply(object diagnostics, object context);
        
        /// <summary>
        /// This query returns the MessageKind value for this Message.
        ///result = (messageKind)
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        MessageKind GetMessageKind();
    }
}

