//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for Property
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Property))]
    [XmlDefaultImplementationTypeAttribute(typeof(Property))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Property")]
    public interface IProperty : IModelElement, IDeploymentTarget, IConnectableElement, IStructuralFeature
    {
        
        /// <summary>
        /// Specifies the kind of aggregation that applies to the Property.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(AggregationKind.None)]
        [DisplayNameAttribute("aggregation")]
        [DescriptionAttribute("Specifies the kind of aggregation that applies to the Property.\n<p>From package U" +
            "ML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("aggregation")]
        [XmlAttributeAttribute(true)]
        AggregationKind Aggregation
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies whether the Property is derived, i.e., whether its value or values can be computed from other information.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerived")]
        [DescriptionAttribute("Specifies whether the Property is derived, i.e., whether its value or values can " +
            "be computed from other information.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerived")]
        [XmlAttributeAttribute(true)]
        bool IsDerived
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies whether the property is derived as the union of all of the Properties that are constrained to subset it.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerivedUnion")]
        [DescriptionAttribute("Specifies whether the property is derived as the union of all of the Properties t" +
            "hat are constrained to subset it.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerivedUnion")]
        [XmlAttributeAttribute(true)]
        bool IsDerivedUnion
        {
            get;
            set;
        }
        
        /// <summary>
        /// True indicates this property can be used to uniquely identify an instance of the containing Class.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isID")]
        [DescriptionAttribute("True indicates this property can be used to uniquely identify an instance of the " +
            "containing Class.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isID")]
        [XmlAttributeAttribute(true)]
        bool IsID
        {
            get;
            set;
        }
        
        /// <summary>
        /// The DataType that owns this Property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("datatype")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedAttribute")]
        NMF.Interop.Uml.IDataType Datatype
        {
            get;
            set;
        }
        
        /// <summary>
        /// The Interface that owns this Property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("interface")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedAttribute")]
        IInterface Interface
        {
            get;
            set;
        }
        
        /// <summary>
        /// Designates the optional association end that owns a qualifier attribute.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("associationEnd")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("qualifier")]
        IProperty AssociationEnd
        {
            get;
            set;
        }
        
        /// <summary>
        /// An optional list of ordered qualifier attributes for the end.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("qualifier")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("associationEnd")]
        [ConstantAttribute()]
        IOrderedSetExpression<IProperty> Qualifier
        {
            get;
        }
        
        /// <summary>
        /// The Class that owns this Property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("class")]
        [DescriptionAttribute("The Class that owns this Property, if any.\n<p>From package UML::Classification.</" +
            "p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("class")]
        [XmlAttributeAttribute(true)]
        NMF.Interop.Uml.IClass Class
        {
            get;
            set;
        }
        
        /// <summary>
        /// A ValueSpecification that is evaluated to give a default value for the Property when an instance of the owning Classifier is instantiated.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("defaultValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IValueSpecification DefaultValue
        {
            get;
            set;
        }
        
        /// <summary>
        /// The owning association of this property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("owningAssociation")]
        [DescriptionAttribute("The owning association of this property, if any.\n<p>From package UML::Classificat" +
            "ion.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("owningAssociation")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedEnd")]
        IAssociation OwningAssociation
        {
            get;
            set;
        }
        
        /// <summary>
        /// The properties that are redefined by this property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedProperty")]
        [DescriptionAttribute("The properties that are redefined by this property, if any.\n<p>From package UML::" +
            "Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("redefinedProperty")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<IProperty> RedefinedProperty
        {
            get;
        }
        
        /// <summary>
        /// The properties of which this Property is constrained to be a subset, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("subsettedProperty")]
        [DescriptionAttribute("The properties of which this Property is constrained to be a subset, if any.\n<p>F" +
            "rom package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("subsettedProperty")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IProperty> SubsettedProperty
        {
            get;
        }
        
        /// <summary>
        /// The Association of which this Property is a member, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("association")]
        [DescriptionAttribute("The Association of which this Property is a member, if any.\n<p>From package UML::" +
            "Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("association")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("memberEnd")]
        IAssociation Association
        {
            get;
            set;
        }
        
        /// <summary>
        /// Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.
        ///subsettedProperty-&gt;notEmpty() implies
        ///  (subsettingContext()-&gt;notEmpty() and subsettingContext()-&gt;forAll (sc |
        ///    subsettedProperty-&gt;forAll(sp |
        ///      sp.subsettingContext()-&gt;exists(c | sc.conformsTo(c)))))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetting_context_conforms(object diagnostics, object context);
        
        /// <summary>
        /// A derived union is read only.
        ///isDerivedUnion implies isReadOnly
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Derived_union_is_read_only(object diagnostics, object context);
        
        /// <summary>
        /// A multiplicity on the composing end of a composite aggregation must not have an upper bound greater than 1.
        ///isComposite and association &lt;&gt; null implies opposite.upperBound() &lt;= 1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Multiplicity_of_composite(object diagnostics, object context);
        
        /// <summary>
        /// A redefined Property must be inherited from a more general Classifier.
        ///(redefinedProperty-&gt;notEmpty()) implies
        ///  (redefinitionContext-&gt;notEmpty() and
        ///      redefinedProperty-&gt;forAll(rp|
        ///        ((redefinitionContext-&gt;collect(fc|
        ///          fc.allParents()))-&gt;asSet())-&gt;collect(c| c.allFeatures())-&gt;asSet()-&gt;includes(rp)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Redefined_property_inherited(object diagnostics, object context);
        
        /// <summary>
        /// A subsetting Property may strengthen the type of the subsetted Property, and its upper bound may be less.
        ///subsettedProperty-&gt;forAll(sp |
        ///  self.type.conformsTo(sp.type) and
        ///    ((self.upperBound()-&gt;notEmpty() and sp.upperBound()-&gt;notEmpty()) implies
        ///      self.upperBound() &lt;= sp.upperBound() ))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetting_rules(object diagnostics, object context);
        
        /// <summary>
        /// A binding of a PropertyTemplateParameter representing an attribute must be to an attribute.
        ///(self.isAttribute()
        ///and (templateParameterSubstitution-&gt;notEmpty())
        ///implies (templateParameterSubstitution-&gt;forAll(ts |
        ///    ts.formal.oclIsKindOf(Property)
        ///    and ts.formal.oclAsType(Property).isAttribute())))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Binding_to_attribute(object diagnostics, object context);
        
        /// <summary>
        /// A derived union is derived.
        ///isDerivedUnion implies isDerived
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Derived_union_is_derived(object diagnostics, object context);
        
        /// <summary>
        /// A Property can be a DeploymentTarget if it is a kind of Node and functions as a part in the internal structure of an encompassing Node.
        ///deployment-&gt;notEmpty() implies owner.oclIsKindOf(Node) and Node.allInstances()-&gt;exists(n | n.part-&gt;exists(p | p = self))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Deployment_target(object diagnostics, object context);
        
        /// <summary>
        /// A Property may not subset a Property with the same name.
        ///subsettedProperty-&gt;forAll(sp | sp.name &lt;&gt; name)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Subsetted_property_names(object diagnostics, object context);
        
        /// <summary>
        /// If a Property is a classifier-owned end of a binary Association, its owner must be the type of the opposite end.
        ///(opposite-&gt;notEmpty() and owningAssociation-&gt;isEmpty()) implies classifier = opposite.type
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Type_of_opposite_end(object diagnostics, object context);
        
        /// <summary>
        /// All qualified Properties must be Association ends
        ///qualifier-&gt;notEmpty() implies association-&gt;notEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Qualified_is_association_end(object diagnostics, object context);
        
        /// <summary>
        /// Retrieves a string representation of the default value for this property.
        /// </summary>
        string GetDefault();
        
        /// <summary>
        /// Retrieves the other end of the (binary) association in which this property is a member end.
        /// </summary>
        IProperty GetOtherEnd();
        
        /// <summary>
        /// 
        /// </summary>
        bool IsSetDefault();
        
        /// <summary>
        /// Sets the default value for this property to the specified Boolean value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        void SetBooleanDefaultValue(bool value);
        
        /// <summary>
        /// Sets the default value for this property based on the specified string representation.
        /// </summary>
        /// <param name="newDefault">A string repesentation of the new default value.</param>
        void SetDefault(string newDefault);
        
        /// <summary>
        /// Sets the default value for this property to the specified integer value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        void SetIntegerDefaultValue(int value);
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newIsComposite"></param>
        void SetIsComposite(bool newIsComposite);
        
        /// <summary>
        /// Sets the navigability of this property as indicated.
        /// </summary>
        /// <param name="isNavigable">The new navigability.</param>
        void SetIsNavigable(bool isNavigable);
        
        /// <summary>
        /// Sets the default value for this property to the null value.
        /// </summary>
        void SetNullDefaultValue();
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newOpposite"></param>
        void SetOpposite(IProperty newOpposite);
        
        /// <summary>
        /// Sets the default value for this property to the specified real value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        void SetRealDefaultValue(double value);
        
        /// <summary>
        /// Sets the default value for this property to the specified string value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        void SetStringDefaultValue(string value);
        
        /// <summary>
        /// Sets the default value for this property to the specified unlimited natural value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        void SetUnlimitedNaturalDefaultValue(object value);
        
        /// <summary>
        /// 
        /// </summary>
        void UnsetDefault();
        
        /// <summary>
        /// The query isAttribute() is true if the Property is defined as an attribute of some Classifier.
        ///result = (not classifier-&gt;isEmpty())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        bool IsAttribute();
        
        /// <summary>
        /// The query isNavigable() indicates whether it is possible to navigate across the property.
        ///result = (not classifier-&gt;isEmpty() or association.navigableOwnedEnd-&gt;includes(self))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        bool IsNavigable();
        
        /// <summary>
        /// If this property is a memberEnd of a binary association, then opposite gives the other end.
        ///result = (if association &lt;&gt; null and association.memberEnd-&gt;size() = 2
        ///then
        ///    association.memberEnd-&gt;any(e | e &lt;&gt; self)
        ///else
        ///    null
        ///endif)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        IProperty GetOpposite();
        
        /// <summary>
        /// The query subsettingContext() gives the context for subsetting a Property. It consists, in the case of an attribute, of the corresponding Classifier, and in the case of an association end, all of the Classifiers at the other ends.
        ///result = (if association &lt;&gt; null
        ///then association.memberEnd-&gt;excluding(self)-&gt;collect(type)-&gt;asSet()
        ///else 
        ///  if classifier&lt;&gt;null
        ///  then classifier-&gt;asSet()
        ///  else Set{} 
        ///  endif
        ///endif)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        ISetExpression<NMF.Interop.Uml.IType> SubsettingContext();
    }
}
