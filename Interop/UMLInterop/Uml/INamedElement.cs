//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for NamedElement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(NamedElement))]
    [XmlDefaultImplementationTypeAttribute(typeof(NamedElement))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement")]
    public interface INamedElement : IModelElement, IElement
    {
        
        /// <summary>
        /// The name of the NamedElement.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DisplayNameAttribute("name")]
        [DescriptionAttribute("The name of the NamedElement.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("NamedElement")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// Determines whether and how the NamedElement is visible outside its owning Namespace.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DisplayNameAttribute("visibility")]
        [DescriptionAttribute("Determines whether and how the NamedElement is visible outside its owning Namespa" +
            "ce.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("NamedElement")]
        [XmlElementNameAttribute("visibility")]
        [XmlAttributeAttribute(true)]
        Nullable<VisibilityKind> Visibility
        {
            get;
            set;
        }
        
        /// <summary>
        /// The StringExpression used to define the name of this NamedElement.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("nameExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IStringExpression NameExpression
        {
            get;
            set;
        }
        
        /// <summary>
        /// If a NamedElement is owned by something other than a Namespace, it does not have a visibility. One that is not owned by anything (and hence must be a Package, as this is the only kind of NamedElement that overrides mustBeOwned()) may have a visibility.
        ///(namespace = null and owner <> null) implies visibility = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Visibility_needs_ownership(object diagnostics, object context);
        
        /// <summary>
        /// When there is a name, and all of the containing Namespaces have a name, the qualifiedName is constructed from the name of the NamedElement and the names of the containing Namespaces.
        ///(name <> null and allNamespaces()->select(ns | ns.name = null)->isEmpty()) implies
        ///  qualifiedName = allNamespaces()->iterate( ns : Namespace; agg: String = name | ns.name.concat(self.separator()).concat(agg))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Has_qualified_name(object diagnostics, object context);
        
        /// <summary>
        /// If there is no name, or one of the containing Namespaces has no name, there is no qualifiedName.
        ///name=null or allNamespaces()->select( ns | ns.name=null )->notEmpty() implies qualifiedName = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Has_no_qualified_name(object diagnostics, object context);
        
        /// <summary>
        /// Creates a dependency between this named element and the specified supplier, owned by this named element's nearest package.
        /// </summary>
        /// <param name="supplier">The supplier for the new dependency.</param>
        IDependency CreateDependency(INamedElement supplier);
        
        /// <summary>
        /// Creates a usage between this named element and the specified supplier, owned by this named element's nearest package.
        /// </summary>
        /// <param name="supplier">The supplier for the new usage.</param>
        IUsage CreateUsage(INamedElement supplier);
        
        /// <summary>
        /// Retrieves a localized label for this named element.
        /// </summary>
        string GetLabel();
        
        /// <summary>
        /// Retrieves a label for this named element, localized if indicated.
        /// </summary>
        /// <param name="localize">Whether to localize the label.</param>
        string GetLabel(bool localize);
        
        /// <summary>
        /// 
        /// </summary>
        NMF.Interop.Uml.INamespace GetNamespace();
        
        /// <summary>
        /// The query allNamespaces() gives the sequence of Namespaces in which the NamedElement is nested, working outwards.
        ///result = (
        ///if owner = null
        ///  then OrderedSet{}
        ///else
        ///  let enclosingNamespace : Namespace =
        ///    if owner.oclIsKindOf(TemplateParameter) and owner.oclAsType(TemplateParameter).signature.template.oclIsKindOf(Namespace)
        ///      then owner.oclAsType(TemplateParameter).signature.template.oclAsType(Namespace)
        ///    else
        ///      namespace
        ///    endif
        ///  in enclosingNamespace.allNamespaces()->prepend(enclosingNamespace)
        ///endif)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        IOrderedSetExpression<NMF.Interop.Uml.INamespace> AllNamespaces();
        
        /// <summary>
        /// The query allOwningPackages() returns the set of all the enclosing Namespaces of this NamedElement, working outwards, that are Packages, up to but not including the first such Namespace that is not a Package.
        ///result = (if namespace.oclIsKindOf(Package)
        ///then
        ///  let owningPackage : Package = namespace.oclAsType(Package) in
        ///    owningPackage->union(owningPackage.allOwningPackages())
        ///else
        ///  null
        ///endif)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        ISetExpression<IPackage> AllOwningPackages();
        
        /// <summary>
        /// The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a Namespace. By default, two named elements are distinguishable if (a) they have types neither of which is a kind of the other or (b) they have different names.
        ///result = ((self.oclIsKindOf(n.oclType()) or n.oclIsKindOf(self.oclType())) implies
        ///    ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()
        ///)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        /// <param name="n"></param>
        /// <param name="ns"></param>
        bool IsDistinguishableFrom(INamedElement n, NMF.Interop.Uml.INamespace ns);
        
        /// <summary>
        /// When a NamedElement has a name, and all of its containing Namespaces have a name, the qualifiedName is constructed from the name of the NamedElement and the names of the containing Namespaces.
        ///result = (if self.name <> null and self.allNamespaces()->select( ns | ns.name=null )->isEmpty()
        ///then 
        ///    self.allNamespaces()->iterate( ns : Namespace; agg: String = self.name | ns.name.concat(self.separator()).concat(agg))
        ///else
        ///   null
        ///endif)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        string GetQualifiedName();
        
        /// <summary>
        /// The query separator() gives the string that is used to separate names when constructing a qualifiedName.
        ///result = ('::')
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        string Separator();
        
        /// <summary>
        /// result = (Dependency.allInstances()->select(d | d.client->includes(self)))
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        ISetExpression<IDependency> GetClientDependencies();
    }
}

