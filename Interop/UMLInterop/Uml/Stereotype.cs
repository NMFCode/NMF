//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A stereotype defines how an existing metaclass may be extended, and enables the use of platform or domain specific terminology or notation in place of, or in addition to, the ones used for the extended metaclass.
    ///<p>From package UML::Packages.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Stereotype")]
    [DebuggerDisplayAttribute("Stereotype {Name}")]
    public partial class Stereotype : Class, IStereotype, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _binaryAssociationsOnlyOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBinaryAssociationsOnlyOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _generalizeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGeneralizeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _name_not_clashOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveName_not_clashOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _associationEndOwnershipOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAssociationEndOwnershipOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _base_property_upper_boundOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBase_property_upper_boundOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _base_property_multiplicity_single_extensionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBase_property_multiplicity_single_extensionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _base_property_multiplicity_multiple_extensionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBase_property_multiplicity_multiple_extensionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createExtensionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateExtensionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createIconOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateIconOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createIconOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateIconOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllExtendedMetaclassesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllExtendedMetaclassesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getDefinitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetDefinitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getExtendedMetaclassesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetExtendedMetaclassesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getKeywordOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetKeywordOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getKeywordOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetKeywordOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProfileOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _iconReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIconReference);
        
        /// <summary>
        /// The backing field for the Icon property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IImage> _icon;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Stereotype()
        {
            this._icon = new ObservableCompositionOrderedSet<IImage>(this);
            this._icon.CollectionChanging += this.IconCollectionChanging;
            this._icon.CollectionChanged += this.IconCollectionChanged;
        }
        
        /// <summary>
        /// Stereotype can change the graphical appearance of the extended model element by using attached icons. When this association is not null, it references the location of the icon content to be displayed within diagrams presenting the extended model elements.
        ///<p>From package UML::Packages.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("icon")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IImage> Icon
        {
            get
            {
                return this._icon;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new StereotypeChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new StereotypeReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Stereotype")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Stereotypes may only participate in binary associations.
        ///ownedAttribute.association->forAll(memberEnd->size()=2)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool BinaryAssociationsOnly(object diagnostics, object context)
        {
            System.Func<IStereotype, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, object, object, bool>>(_binaryAssociationsOnlyOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method binaryAssociationsOnly registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _binaryAssociationsOnlyOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _binaryAssociationsOnlyOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _binaryAssociationsOnlyOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBinaryAssociationsOnlyOperation()
        {
            return ClassInstance.LookupOperation("binaryAssociationsOnly");
        }
        
        /// <summary>
        /// A Stereotype may only generalize or specialize another Stereotype.
        ///allParents()->forAll(oclIsKindOf(Stereotype)) 
        ///and Classifier.allInstances()->forAll(c | c.allParents()->exists(oclIsKindOf(Stereotype)) implies c.oclIsKindOf(Stereotype))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Generalize(object diagnostics, object context)
        {
            System.Func<IStereotype, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, object, object, bool>>(_generalizeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method generalize registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _generalizeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _generalizeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _generalizeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGeneralizeOperation()
        {
            return ClassInstance.LookupOperation("generalize");
        }
        
        /// <summary>
        /// Stereotype names should not clash with keyword names for the extended model element.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Name_not_clash(object diagnostics, object context)
        {
            System.Func<IStereotype, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, object, object, bool>>(_name_not_clashOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method name_not_clash registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _name_not_clashOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _name_not_clashOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _name_not_clashOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveName_not_clashOperation()
        {
            return ClassInstance.LookupOperation("name_not_clash");
        }
        
        /// <summary>
        /// Where a stereotypeâ€™s property is an association end for an association other than a kind of extension, and the other end is not a stereotype, the other end must be owned by the association itself.
        ///ownedAttribute
        ///->select(association->notEmpty() and not association.oclIsKindOf(Extension) and not type.oclIsKindOf(Stereotype))
        ///->forAll(opposite.owner = association)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool AssociationEndOwnership(object diagnostics, object context)
        {
            System.Func<IStereotype, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, object, object, bool>>(_associationEndOwnershipOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method associationEndOwnership registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _associationEndOwnershipOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _associationEndOwnershipOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _associationEndOwnershipOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAssociationEndOwnershipOperation()
        {
            return ClassInstance.LookupOperation("associationEndOwnership");
        }
        
        /// <summary>
        /// The upper bound of base-properties is exactly 1.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Base_property_upper_bound(object diagnostics, object context)
        {
            System.Func<IStereotype, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, object, object, bool>>(_base_property_upper_boundOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method base_property_upper_bound registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _base_property_upper_boundOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _base_property_upper_boundOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _base_property_upper_boundOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBase_property_upper_boundOperation()
        {
            return ClassInstance.LookupOperation("base_property_upper_bound");
        }
        
        /// <summary>
        /// If a Stereotype extends only one metaclass, the multiplicity of the corresponding base-property shall be 1..1.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Base_property_multiplicity_single_extension(object diagnostics, object context)
        {
            System.Func<IStereotype, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, object, object, bool>>(_base_property_multiplicity_single_extensionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method base_property_multiplicity_single_extension" +
                        " registered. Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _base_property_multiplicity_single_extensionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _base_property_multiplicity_single_extensionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _base_property_multiplicity_single_extensionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBase_property_multiplicity_single_extensionOperation()
        {
            return ClassInstance.LookupOperation("base_property_multiplicity_single_extension");
        }
        
        /// <summary>
        /// If a Stereotype extends more than one metaclass, the multiplicity of the corresponding base-properties shall be [0..1]. At any point in time, only one of these base-properties can contain a metaclass instance during runtime.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Base_property_multiplicity_multiple_extension(object diagnostics, object context)
        {
            System.Func<IStereotype, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, object, object, bool>>(_base_property_multiplicity_multiple_extensionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method base_property_multiplicity_multiple_extensi" +
                        "on registered. Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _base_property_multiplicity_multiple_extensionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _base_property_multiplicity_multiple_extensionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _base_property_multiplicity_multiple_extensionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBase_property_multiplicity_multiple_extensionOperation()
        {
            return ClassInstance.LookupOperation("base_property_multiplicity_multiple_extension");
        }
        
        /// <summary>
        /// Creates a(n) (required) extension of the specified metaclass with this stereotype.
        /// </summary>
        /// <param name="metaclass">The metaclass for the new extension.</param>
        /// <param name="isRequired">Whether the new extension should be required.</param>
        public NMF.Interop.Uml.IExtension CreateExtension(NMF.Interop.Uml.IClass metaclass, bool isRequired)
        {
            System.Func<IStereotype, NMF.Interop.Uml.IClass, bool, NMF.Interop.Uml.IExtension> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, NMF.Interop.Uml.IClass, bool, NMF.Interop.Uml.IExtension>>(_createExtensionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createExtension registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createExtensionOperation.Value, metaclass, isRequired);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createExtensionOperation.Value, e));
            NMF.Interop.Uml.IExtension result = handler.Invoke(this, metaclass, isRequired);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createExtensionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateExtensionOperation()
        {
            return ClassInstance.LookupOperation("createExtension");
        }
        
        /// <summary>
        /// Creates an icon with the specified location for this stereotype.
        /// </summary>
        /// <param name="location">The location for the new icon.</param>
        public IImage CreateIcon(string location)
        {
            System.Func<IStereotype, string, IImage> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, string, IImage>>(_createIconOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createIcon registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createIconOperation.Value, location);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createIconOperation.Value, e));
            IImage result = handler.Invoke(this, location);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createIconOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Creates an icon with the specified format and content for this stereotype.
        /// </summary>
        /// <param name="format">The format for the new icon.</param>
        /// <param name="content">The content for the new icon.</param>
        public IImage CreateIcon(string format, string content)
        {
            System.Func<IStereotype, string, string, IImage> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, string, string, IImage>>(_createIconOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createIcon registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createIconOperation.Value, format, content);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createIconOperation.Value, e));
            IImage result = handler.Invoke(this, format, content);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createIconOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateIconOperation()
        {
            return ClassInstance.LookupOperation("createIcon");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateIconOperation_()
        {
            return ClassInstance.LookupOperation("createIcon");
        }
        
        /// <summary>
        /// Retrieves all the metaclasses extended by this stereotype, including the metaclasses extended by its superstereotypes.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IClass> GetAllExtendedMetaclasses()
        {
            System.Func<IStereotype, ISetExpression<NMF.Interop.Uml.IClass>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, ISetExpression<NMF.Interop.Uml.IClass>>>(_getAllExtendedMetaclassesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllExtendedMetaclasses registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllExtendedMetaclassesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllExtendedMetaclassesOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IClass> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllExtendedMetaclassesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllExtendedMetaclassesOperation()
        {
            return ClassInstance.LookupOperation("getAllExtendedMetaclasses");
        }
        
        /// <summary>
        /// Retrieves the current definition (Ecore representation) of this stereotype.
        /// </summary>
        public IEClass GetDefinition()
        {
            System.Func<IStereotype, IEClass> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, IEClass>>(_getDefinitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getDefinition registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getDefinitionOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getDefinitionOperation.Value, e));
            IEClass result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getDefinitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetDefinitionOperation()
        {
            return ClassInstance.LookupOperation("getDefinition");
        }
        
        /// <summary>
        /// Retrieves the metaclasses extended by this stereotype.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IClass> GetExtendedMetaclasses()
        {
            System.Func<IStereotype, ISetExpression<NMF.Interop.Uml.IClass>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, ISetExpression<NMF.Interop.Uml.IClass>>>(_getExtendedMetaclassesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getExtendedMetaclasses registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getExtendedMetaclassesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getExtendedMetaclassesOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IClass> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getExtendedMetaclassesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetExtendedMetaclassesOperation()
        {
            return ClassInstance.LookupOperation("getExtendedMetaclasses");
        }
        
        /// <summary>
        /// Retrieves the localized keyword for this stereotype.
        /// </summary>
        public string GetKeyword()
        {
            System.Func<IStereotype, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, string>>(_getKeywordOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getKeyword registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getKeywordOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getKeywordOperation.Value, e));
            string result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getKeywordOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves the keyword for this stereotype, localized if indicated.
        /// </summary>
        /// <param name="localize">Whether to localize the keyword.</param>
        public string GetKeyword(bool localize)
        {
            System.Func<IStereotype, bool, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, bool, string>>(_getKeywordOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getKeyword registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getKeywordOperation.Value, localize);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getKeywordOperation.Value, e));
            string result = handler.Invoke(this, localize);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getKeywordOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetKeywordOperation()
        {
            return ClassInstance.LookupOperation("getKeyword");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetKeywordOperation_()
        {
            return ClassInstance.LookupOperation("getKeyword");
        }
        
        /// <summary>
        /// The query containingProfile returns the closest profile directly or indirectly containing this stereotype.
        ///result = (self.namespace.oclAsType(Package).containingProfile())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public IProfile ContainingProfile()
        {
            System.Func<IStereotype, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, IProfile>>(_containingProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingProfileOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingProfileOperation.Value, e));
            IProfile result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingProfileOperation()
        {
            return ClassInstance.LookupOperation("containingProfile");
        }
        
        /// <summary>
        /// A stereotype must be contained, directly or indirectly, in a profile.
        ///result = (self.containingProfile())
        ///<p>From package UML::Packages.</p>
        /// </summary>
        public IProfile GetProfile()
        {
            System.Func<IStereotype, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IStereotype, IProfile>>(_getProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProfile registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProfileOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProfileOperation.Value, e));
            IProfile result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProfileOperation()
        {
            return ClassInstance.LookupOperation("getProfile");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIconReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Stereotype.ClassInstance)).Resolve("icon")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Icon property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void IconCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Icon", e, _iconReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Icon property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void IconCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Icon", e, _iconReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int iconIndex = ModelHelper.IndexOfReference(this.Icon, element);
            if ((iconIndex != -1))
            {
                return ModelHelper.CreatePath("icon", iconIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "ICON"))
            {
                if ((index < this.Icon.Count))
                {
                    return this.Icon[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ICON"))
            {
                return this._icon;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._icon))
            {
                return "icon";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Stereotype")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Stereotype class
        /// </summary>
        public class StereotypeChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Stereotype _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public StereotypeChildrenCollection(Stereotype parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Icon.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Icon.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Icon.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IImage iconCasted = item.As<IImage>();
                if ((iconCasted != null))
                {
                    this._parent.Icon.Add(iconCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Icon.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Icon.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> iconEnumerator = this._parent.Icon.GetEnumerator();
                try
                {
                    for (
                    ; iconEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = iconEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    iconEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IImage imageItem = item.As<IImage>();
                if (((imageItem != null) 
                            && this._parent.Icon.Remove(imageItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Icon).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Stereotype class
        /// </summary>
        public class StereotypeReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Stereotype _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public StereotypeReferencedElementsCollection(Stereotype parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Icon.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Icon.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Icon.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IImage iconCasted = item.As<IImage>();
                if ((iconCasted != null))
                {
                    this._parent.Icon.Add(iconCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Icon.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Icon.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> iconEnumerator = this._parent.Icon.GetEnumerator();
                try
                {
                    for (
                    ; iconEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = iconEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    iconEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IImage imageItem = item.As<IImage>();
                if (((imageItem != null) 
                            && this._parent.Icon.Remove(imageItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Icon).GetEnumerator();
            }
        }
    }
}

