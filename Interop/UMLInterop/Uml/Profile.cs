//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A profile defines limited extensions to a reference metamodel with the purpose of adapting the metamodel to a specific platform or domain.
    ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Profile")]
    [DebuggerDisplayAttribute("Profile {Name}")]
    public partial class Profile : PackageableElement, IProfile, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _metaclass_reference_not_specializedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMetaclass_reference_not_specializedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _references_same_metamodelOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveReferences_same_metamodelOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _defineOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDefineOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _defineOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDefineOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getDefinitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetDefinitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getDefinitionOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetDefinitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedExtensionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedExtensionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getReferencedMetaclassesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetReferencedMetaclassesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getReferencedMetamodelsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetReferencedMetamodelsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isDefinedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsDefinedOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _metaclassReferenceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveMetaclassReferenceReference);
        
        /// <summary>
        /// The backing field for the MetaclassReference property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IElementImport> _metaclassReference;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _metamodelReferenceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveMetamodelReferenceReference);
        
        /// <summary>
        /// The backing field for the MetamodelReference property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IPackageImport> _metamodelReference;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _elements_public_or_privateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveElements_public_or_privateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _applyProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveApplyProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedClassOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedClassOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedEnumerationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedEnumerationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedInterfaceOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedInterfaceOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedPrimitiveTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedPrimitiveTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedStereotypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedStereotypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllAppliedProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllAppliedProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAllProfileApplicationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAllProfileApplicationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfileOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getAppliedProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetAppliedProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProfileApplicationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProfileApplicationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProfileApplicationOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProfileApplicationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isModelLibraryOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsModelLibraryOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isProfileAppliedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsProfileAppliedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _unapplyProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveUnapplyProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _applyProfilesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveApplyProfilesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allApplicableStereotypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllApplicableStereotypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingProfileOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingProfileOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _makesVisibleOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMakesVisibleOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNestedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNestedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedStereotypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedStereotypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedTypesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedTypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _visibleMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveVisibleMembersOperation);
        
        /// <summary>
        /// The backing field for the URI property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _uRI;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _uRIAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveURIAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _nestedPackageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveNestedPackageReference);
        
        /// <summary>
        /// The backing field for the NestedPackage property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackageNestedPackageCollection _nestedPackage;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedStereotypeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedStereotypeReference);
        
        /// <summary>
        /// The backing field for the OwnedStereotype property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IStereotype> _ownedStereotype;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTypeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTypeReference);
        
        /// <summary>
        /// The backing field for the OwnedType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackageOwnedTypeCollection _ownedType;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageMergeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageMergeReference);
        
        /// <summary>
        /// The backing field for the PackageMerge property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackagePackageMergeCollection _packageMerge;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _profileApplicationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveProfileApplicationReference);
        
        /// <summary>
        /// The backing field for the ProfileApplication property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PackageProfileApplicationCollection _profileApplication;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _nestingPackageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveNestingPackageReference);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _members_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembers_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_selfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_selfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_ownedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_ownedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createElementImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateElementImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createPackageImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreatePackageImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedElementsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _excludeCollisionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveExcludeCollisionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNamesOfMemberOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNamesOfMemberOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _importMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveImportMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _membersAreDistinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembersAreDistinguishableOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedRuleReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedRuleReference);
        
        /// <summary>
        /// The backing field for the OwnedRule property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespaceOwnedRuleCollection _ownedRule;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _parameterableElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveParameterableElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateBindingReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateBindingReference);
        
        /// <summary>
        /// The backing field for the TemplateBinding property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TemplateableElementTemplateBindingCollection _templateBinding;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedTemplateSignatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedTemplateSignatureReference);
        
        /// <summary>
        /// The backing field for the OwnedTemplateSignature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateSignature _ownedTemplateSignature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Profile()
        {
            this._metaclassReference = new ObservableCompositionOrderedSet<IElementImport>(this);
            this._metaclassReference.CollectionChanging += this.MetaclassReferenceCollectionChanging;
            this._metaclassReference.CollectionChanged += this.MetaclassReferenceCollectionChanged;
            this._metamodelReference = new ObservableCompositionOrderedSet<IPackageImport>(this);
            this._metamodelReference.CollectionChanging += this.MetamodelReferenceCollectionChanging;
            this._metamodelReference.CollectionChanged += this.MetamodelReferenceCollectionChanged;
            this._nestedPackage = new PackageNestedPackageCollection(this);
            this._nestedPackage.CollectionChanging += this.NestedPackageCollectionChanging;
            this._nestedPackage.CollectionChanged += this.NestedPackageCollectionChanged;
            this._ownedStereotype = new ObservableCompositionOrderedSet<IStereotype>(this);
            this._ownedStereotype.CollectionChanging += this.OwnedStereotypeCollectionChanging;
            this._ownedStereotype.CollectionChanged += this.OwnedStereotypeCollectionChanged;
            this._ownedType = new PackageOwnedTypeCollection(this);
            this._ownedType.CollectionChanging += this.OwnedTypeCollectionChanging;
            this._ownedType.CollectionChanged += this.OwnedTypeCollectionChanged;
            this._packageMerge = new PackagePackageMergeCollection(this);
            this._packageMerge.CollectionChanging += this.PackageMergeCollectionChanging;
            this._packageMerge.CollectionChanged += this.PackageMergeCollectionChanged;
            this._profileApplication = new PackageProfileApplicationCollection(this);
            this._profileApplication.CollectionChanging += this.ProfileApplicationCollectionChanging;
            this._profileApplication.CollectionChanged += this.ProfileApplicationCollectionChanged;
            this._ownedRule = new NamespaceOwnedRuleCollection(this);
            this._ownedRule.CollectionChanging += this.OwnedRuleCollectionChanging;
            this._ownedRule.CollectionChanged += this.OwnedRuleCollectionChanged;
            this._templateBinding = new TemplateableElementTemplateBindingCollection(this);
            this._templateBinding.CollectionChanging += this.TemplateBindingCollectionChanging;
            this._templateBinding.CollectionChanged += this.TemplateBindingCollectionChanged;
        }
        
        /// <summary>
        /// References a metaclass that may be extended.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("metaclassReference")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IElementImport> MetaclassReference
        {
            get
            {
                return this._metaclassReference;
            }
        }
        
        /// <summary>
        /// References a package containing (directly or indirectly) metaclasses that may be extended.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("metamodelReference")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackageImport> MetamodelReference
        {
            get
            {
                return this._metamodelReference;
            }
        }
        
        IListExpression<IElementImport> NMF.Interop.Uml.INamespace.ElementImport
        {
            get
            {
                return new ProfileElementImportCollection(this);
            }
        }
        
        IListExpression<IPackageImport> NMF.Interop.Uml.INamespace.PackageImport
        {
            get
            {
                return new ProfilePackageImportCollection(this);
            }
        }
        
        /// <summary>
        /// Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DescriptionAttribute(@"Provides an identifier for the package that can be used for many purposes. A URI is the universally unique identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and it must comply with those syntax rules.
<p>From package UML::Packages.</p>")]
        [CategoryAttribute("Package")]
        [XmlAttributeAttribute(true)]
        public string URI
        {
            get
            {
                return this._uRI;
            }
            set
            {
                if ((this._uRI != value))
                {
                    string old = this._uRI;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("URI", e, _uRIAttribute);
                    this._uRI = value;
                    this.OnPropertyChanged("URI", e, _uRIAttribute);
                }
            }
        }
        
        /// <summary>
        /// References the packaged elements that are Packages.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("nestedPackage")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("nestingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackage> NestedPackage
        {
            get
            {
                return this._nestedPackage;
            }
        }
        
        /// <summary>
        /// References the Stereotypes that are owned by the Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedStereotype")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IStereotype> OwnedStereotype
        {
            get
            {
                return this._ownedStereotype;
            }
        }
        
        /// <summary>
        /// References the packaged elements that are Types.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("package")]
        [ConstantAttribute()]
        public IOrderedSetExpression<NMF.Interop.Uml.IType> OwnedType
        {
            get
            {
                return this._ownedType;
            }
        }
        
        /// <summary>
        /// References the PackageMerges that are owned by this Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageMerge")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("receivingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackageMerge> PackageMerge
        {
            get
            {
                return this._packageMerge;
            }
        }
        
        /// <summary>
        /// References the ProfileApplications that indicate which profiles have been applied to the Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("profileApplication")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("applyingPackage")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IProfileApplication> ProfileApplication
        {
            get
            {
                return this._profileApplication;
            }
        }
        
        /// <summary>
        /// References the Package that owns this Package.
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("nestingPackage")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("nestedPackage")]
        public IPackage NestingPackage
        {
            get
            {
                return ModelHelper.CastAs<IPackage>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        IListExpression<IPackageableElement> IPackage.PackagedElement
        {
            get
            {
                return new PackagePackagedElementCollection(this);
            }
        }
        
        /// <summary>
        /// Specifies a set of Constraints owned by this Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedRule")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("context")]
        [ConstantAttribute()]
        public IListExpression<IConstraint> OwnedRule
        {
            get
            {
                return this._ownedRule;
            }
        }
        
        /// <summary>
        /// The optional TemplateBindings from this TemplateableElement to one or more templates.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("templateBinding")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("boundElement")]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITemplateBinding> TemplateBinding
        {
            get
            {
                return this._templateBinding;
            }
        }
        
        /// <summary>
        /// The optional TemplateSignature specifying the formal TemplateParameters for this TemplateableElement. If a TemplateableElement has a TemplateSignature, then it is a template.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("ownedTemplateSignature")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("template")]
        public ITemplateSignature OwnedTemplateSignature
        {
            get
            {
                return this._ownedTemplateSignature;
            }
            set
            {
                if ((this._ownedTemplateSignature != value))
                {
                    ITemplateSignature old = this._ownedTemplateSignature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                    this._ownedTemplateSignature = value;
                    if ((old != null))
                    {
                        old.Template = null;
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetOwnedTemplateSignature;
                    }
                    if ((value != null))
                    {
                        value.Template = this;
                        value.Parent = this;
                        value.ParentChanged += this.OnResetOwnedTemplateSignature;
                    }
                    this.OnPropertyChanged("OwnedTemplateSignature", e, _ownedTemplateSignatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ProfileChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ProfileReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Profile")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// An element imported as a metaclassReference is not specialized or generalized in a Profile.
        ///metaclassReference.importedElement-&gt;
        ///	select(c | c.oclIsKindOf(Classifier) and
        ///		(c.oclAsType(Classifier).allParents()-&gt;collect(namespace)-&gt;includes(self)))-&gt;isEmpty()
        ///and 
        ///packagedElement-&gt;
        ///    select(oclIsKindOf(Classifier))-&gt;collect(oclAsType(Classifier).allParents())-&gt;
        ///       intersection(metaclassReference.importedElement-&gt;select(oclIsKindOf(Classifier))-&gt;collect(oclAsType(Classifier)))-&gt;isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Metaclass_reference_not_specialized(object diagnostics, object context)
        {
            System.Func<IProfile, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, object, object, bool>>(_metaclass_reference_not_specializedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method metaclass_reference_not_specialized registe" +
                        "red. Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _metaclass_reference_not_specializedOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _metaclass_reference_not_specializedOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _metaclass_reference_not_specializedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMetaclass_reference_not_specializedOperation()
        {
            return ClassInstance.LookupOperation("metaclass_reference_not_specialized");
        }
        
        /// <summary>
        /// All elements imported either as metaclassReferences or through metamodelReferences are members of the same base reference metamodel.
        ///metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()-&gt;
        ///  union(metaclassReference.importedElement.allOwningPackages() )-&gt;notEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool References_same_metamodel(object diagnostics, object context)
        {
            System.Func<IProfile, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, object, object, bool>>(_references_same_metamodelOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method references_same_metamodel registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _references_same_metamodelOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _references_same_metamodelOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _references_same_metamodelOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveReferences_same_metamodelOperation()
        {
            return ClassInstance.LookupOperation("references_same_metamodel");
        }
        
        /// <summary>
        /// Creates and returns an instance of (the Ecore representation of) the specified classifier defined in this profile.
        /// </summary>
        /// <param name="classifier">The classifier of which to create an instance.</param>
        public IEObject Create(IClassifier classifier)
        {
            System.Func<IProfile, IClassifier, IEObject> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, IClassifier, IEObject>>(_createOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method create registered. Use the method broker to" +
                        " register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOperation.Value, classifier);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOperation.Value, e));
            IEObject result = handler.Invoke(this, classifier);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOperation()
        {
            return ClassInstance.LookupOperation("create");
        }
        
        /// <summary>
        /// Defines this profile by (re)creating Ecore representations of its current contents.
        /// </summary>
        public IEPackage Define()
        {
            System.Func<IProfile, IEPackage> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, IEPackage>>(_defineOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method define registered. Use the method broker to" +
                        " register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _defineOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _defineOperation.Value, e));
            IEPackage result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _defineOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Defines this profile by (re)creating Ecore representations of its current contents, using the specified options, diagnostics, and context.
        /// </summary>
        /// <param name="options">The options to use.</param>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public IEPackage Define(object options, object diagnostics, object context)
        {
            System.Func<IProfile, object, object, object, IEPackage> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, object, object, object, IEPackage>>(_defineOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method define registered. Use the method broker to" +
                        " register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _defineOperation.Value, options, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _defineOperation.Value, e));
            IEPackage result = handler.Invoke(this, options, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _defineOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDefineOperation()
        {
            return ClassInstance.LookupOperation("define");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDefineOperation_()
        {
            return ClassInstance.LookupOperation("define");
        }
        
        /// <summary>
        /// Retrieves the current definition (Ecore representation) of this profile.
        /// </summary>
        public IEPackage GetDefinition()
        {
            System.Func<IProfile, IEPackage> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, IEPackage>>(_getDefinitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getDefinition registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getDefinitionOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getDefinitionOperation.Value, e));
            IEPackage result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getDefinitionOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves the current definition (Ecore representation) of the specified named element in this profile.
        /// </summary>
        /// <param name="namedElement">The named element whose definition to retrieve.</param>
        public IENamedElement GetDefinition(INamedElement namedElement)
        {
            System.Func<IProfile, INamedElement, IENamedElement> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, INamedElement, IENamedElement>>(_getDefinitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getDefinition registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getDefinitionOperation.Value, namedElement);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getDefinitionOperation.Value, e));
            IENamedElement result = handler.Invoke(this, namedElement);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getDefinitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetDefinitionOperation()
        {
            return ClassInstance.LookupOperation("getDefinition");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetDefinitionOperation_()
        {
            return ClassInstance.LookupOperation("getDefinition");
        }
        
        /// <summary>
        /// Retrieves the extensions owned by this profile, excluding non-required extensions if indicated.
        /// </summary>
        /// <param name="requiredOnly">Whether to retrieve only required extensions.</param>
        public ISetExpression<NMF.Interop.Uml.IExtension> GetOwnedExtensions(bool requiredOnly)
        {
            System.Func<IProfile, bool, ISetExpression<NMF.Interop.Uml.IExtension>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, bool, ISetExpression<NMF.Interop.Uml.IExtension>>>(_getOwnedExtensionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedExtensions registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedExtensionsOperation.Value, requiredOnly);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedExtensionsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IExtension> result = handler.Invoke(this, requiredOnly);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedExtensionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedExtensionsOperation()
        {
            return ClassInstance.LookupOperation("getOwnedExtensions");
        }
        
        /// <summary>
        /// Retrieves the metaclasses referenced by this profile.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IClass> GetReferencedMetaclasses()
        {
            System.Func<IProfile, ISetExpression<NMF.Interop.Uml.IClass>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, ISetExpression<NMF.Interop.Uml.IClass>>>(_getReferencedMetaclassesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getReferencedMetaclasses registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getReferencedMetaclassesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getReferencedMetaclassesOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IClass> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getReferencedMetaclassesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetReferencedMetaclassesOperation()
        {
            return ClassInstance.LookupOperation("getReferencedMetaclasses");
        }
        
        /// <summary>
        /// Retrieves the metamodels referenced by this profile.
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IModel> GetReferencedMetamodels()
        {
            System.Func<IProfile, ISetExpression<NMF.Interop.Uml.IModel>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, ISetExpression<NMF.Interop.Uml.IModel>>>(_getReferencedMetamodelsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getReferencedMetamodels registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getReferencedMetamodelsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getReferencedMetamodelsOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IModel> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getReferencedMetamodelsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetReferencedMetamodelsOperation()
        {
            return ClassInstance.LookupOperation("getReferencedMetamodels");
        }
        
        /// <summary>
        /// Determines whether this profile is defined.
        /// </summary>
        public bool IsDefined()
        {
            System.Func<IProfile, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProfile, bool>>(_isDefinedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isDefined registered. Use the method broker" +
                        " to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isDefinedOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isDefinedOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isDefinedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsDefinedOperation()
        {
            return ClassInstance.LookupOperation("isDefined");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveMetaclassReferenceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Profile.ClassInstance)).Resolve("metaclassReference")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the MetaclassReference property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MetaclassReferenceCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("MetaclassReference", e, _metaclassReferenceReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the MetaclassReference property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MetaclassReferenceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("MetaclassReference", e, _metaclassReferenceReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveMetamodelReferenceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Profile.ClassInstance)).Resolve("metamodelReference")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the MetamodelReference property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MetamodelReferenceCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("MetamodelReference", e, _metamodelReferenceReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the MetamodelReference property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MetamodelReferenceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("MetamodelReference", e, _metamodelReferenceReference);
        }
        
        /// <summary>
        /// If an element that is owned by a package has visibility, it is public or private.
        ///packagedElement-&gt;forAll(e | e.visibility&lt;&gt; null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Elements_public_or_private(object diagnostics, object context)
        {
            System.Func<IPackage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, object, object, bool>>(_elements_public_or_privateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method elements_public_or_private registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _elements_public_or_privateOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _elements_public_or_privateOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _elements_public_or_privateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveElements_public_or_privateOperation()
        {
            return ClassInstance.LookupOperation("elements_public_or_private");
        }
        
        /// <summary>
        /// Applies the current definition of the specified profile to this package and automatically applies required stereotypes in the profile to elements within this package&apos;s namespace hieararchy. If a different definition is already applied, automatically migrates any associated stereotype values on a &quot;best effort&quot; basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profile">The profile to apply.</param>
        public ISetExpression<IEObject> ApplyProfile(IProfile profile)
        {
            System.Func<IPackage, IProfile, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, ISetExpression<IEObject>>>(_applyProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method applyProfile registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _applyProfileOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _applyProfileOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _applyProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveApplyProfileOperation()
        {
            return ClassInstance.LookupOperation("applyProfile");
        }
        
        /// <summary>
        /// Creates a(n) (abstract) class with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new class, or null.</param>
        /// <param name="isAbstract">Whether the new class should be abstract.</param>
        public NMF.Interop.Uml.IClass CreateOwnedClass(string name, bool isAbstract)
        {
            System.Func<IPackage, string, bool, NMF.Interop.Uml.IClass> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, NMF.Interop.Uml.IClass>>(_createOwnedClassOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedClass registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedClassOperation.Value, name, isAbstract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedClassOperation.Value, e));
            NMF.Interop.Uml.IClass result = handler.Invoke(this, name, isAbstract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedClassOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedClassOperation()
        {
            return ClassInstance.LookupOperation("createOwnedClass");
        }
        
        /// <summary>
        /// Creates a enumeration with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new enumeration, or null.</param>
        public NMF.Interop.Uml.IEnumeration CreateOwnedEnumeration(string name)
        {
            System.Func<IPackage, string, NMF.Interop.Uml.IEnumeration> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, NMF.Interop.Uml.IEnumeration>>(_createOwnedEnumerationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedEnumeration registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedEnumerationOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedEnumerationOperation.Value, e));
            NMF.Interop.Uml.IEnumeration result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedEnumerationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedEnumerationOperation()
        {
            return ClassInstance.LookupOperation("createOwnedEnumeration");
        }
        
        /// <summary>
        /// Creates an interface with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new interface, or null.</param>
        public IInterface CreateOwnedInterface(string name)
        {
            System.Func<IPackage, string, IInterface> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, IInterface>>(_createOwnedInterfaceOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedInterface registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedInterfaceOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedInterfaceOperation.Value, e));
            IInterface result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedInterfaceOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedInterfaceOperation()
        {
            return ClassInstance.LookupOperation("createOwnedInterface");
        }
        
        /// <summary>
        /// Creates a primitive type with the specified name as an owned type of this package.
        /// </summary>
        /// <param name="name">The name for the new primitive type, or null.</param>
        public NMF.Interop.Uml.IPrimitiveType CreateOwnedPrimitiveType(string name)
        {
            System.Func<IPackage, string, NMF.Interop.Uml.IPrimitiveType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, NMF.Interop.Uml.IPrimitiveType>>(_createOwnedPrimitiveTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedPrimitiveType registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedPrimitiveTypeOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedPrimitiveTypeOperation.Value, e));
            NMF.Interop.Uml.IPrimitiveType result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedPrimitiveTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedPrimitiveTypeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedPrimitiveType");
        }
        
        /// <summary>
        /// Creates a(n) (abstract) stereotype with the specified name as an owned stereotype of this profile.
        /// </summary>
        /// <param name="name">The name for the new stereotype, or null.</param>
        /// <param name="isAbstract">Whether the new stereotype should be abstract.</param>
        public IStereotype CreateOwnedStereotype(string name, bool isAbstract)
        {
            System.Func<IPackage, string, bool, IStereotype> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, IStereotype>>(_createOwnedStereotypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedStereotype registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedStereotypeOperation.Value, name, isAbstract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedStereotypeOperation.Value, e));
            IStereotype result = handler.Invoke(this, name, isAbstract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedStereotypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedStereotypeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedStereotype");
        }
        
        /// <summary>
        /// Retrieves all the profiles that are applied to this package, including profiles applied to its nesting package(s).
        /// </summary>
        public ISetExpression<IProfile> GetAllAppliedProfiles()
        {
            System.Func<IPackage, ISetExpression<IProfile>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfile>>>(_getAllAppliedProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllAppliedProfiles registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllAppliedProfilesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllAppliedProfilesOperation.Value, e));
            ISetExpression<IProfile> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllAppliedProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllAppliedProfilesOperation()
        {
            return ClassInstance.LookupOperation("getAllAppliedProfiles");
        }
        
        /// <summary>
        /// Retrieves all the profile applications for this package, including profile applications for its nesting package(s).
        /// </summary>
        public ISetExpression<IProfileApplication> GetAllProfileApplications()
        {
            System.Func<IPackage, ISetExpression<IProfileApplication>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfileApplication>>>(_getAllProfileApplicationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAllProfileApplications registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAllProfileApplicationsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAllProfileApplicationsOperation.Value, e));
            ISetExpression<IProfileApplication> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAllProfileApplicationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAllProfileApplicationsOperation()
        {
            return ClassInstance.LookupOperation("getAllProfileApplications");
        }
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        public IProfile GetAppliedProfile(string qualifiedName)
        {
            System.Func<IPackage, string, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, IProfile>>(_getAppliedProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfileOperation.Value, qualifiedName);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfileOperation.Value, e));
            IProfile result = handler.Invoke(this, qualifiedName);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfileOperation()
        {
            return ClassInstance.LookupOperation("getAppliedProfile");
        }
        
        /// <summary>
        /// Retrieves the profile with the specified qualified name that is applied to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="qualifiedName">The qualified name of the applied profile to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        public IProfile GetAppliedProfile(string qualifiedName, bool recurse)
        {
            System.Func<IPackage, string, bool, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, string, bool, IProfile>>(_getAppliedProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfileOperation.Value, qualifiedName, recurse);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfileOperation.Value, e));
            IProfile result = handler.Invoke(this, qualifiedName, recurse);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfileOperation_()
        {
            return ClassInstance.LookupOperation("getAppliedProfile");
        }
        
        /// <summary>
        /// Retrieves the profiles that are applied to this package.
        /// </summary>
        public ISetExpression<IProfile> GetAppliedProfiles()
        {
            System.Func<IPackage, ISetExpression<IProfile>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IProfile>>>(_getAppliedProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getAppliedProfiles registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getAppliedProfilesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getAppliedProfilesOperation.Value, e));
            ISetExpression<IProfile> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getAppliedProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetAppliedProfilesOperation()
        {
            return ClassInstance.LookupOperation("getAppliedProfiles");
        }
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package, or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        public IProfileApplication GetProfileApplication(IProfile profile)
        {
            System.Func<IPackage, IProfile, IProfileApplication> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, IProfileApplication>>(_getProfileApplicationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProfileApplication registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProfileApplicationOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProfileApplicationOperation.Value, e));
            IProfileApplication result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProfileApplicationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProfileApplicationOperation()
        {
            return ClassInstance.LookupOperation("getProfileApplication");
        }
        
        /// <summary>
        /// Retrieves the application of the specified profile to this package or any of its nesting packages (if indicated), or null if no such profile is applied.
        /// </summary>
        /// <param name="profile">The profile whose application to retrieve.</param>
        /// <param name="recurse">Whether to look in nesting packages.</param>
        public IProfileApplication GetProfileApplication(IProfile profile, bool recurse)
        {
            System.Func<IPackage, IProfile, bool, IProfileApplication> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, bool, IProfileApplication>>(_getProfileApplicationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProfileApplication registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProfileApplicationOperation.Value, profile, recurse);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProfileApplicationOperation.Value, e));
            IProfileApplication result = handler.Invoke(this, profile, recurse);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProfileApplicationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProfileApplicationOperation_()
        {
            return ClassInstance.LookupOperation("getProfileApplication");
        }
        
        /// <summary>
        /// Determines whether this package is a model library.
        /// </summary>
        public bool IsModelLibrary()
        {
            System.Func<IPackage, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, bool>>(_isModelLibraryOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isModelLibrary registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isModelLibraryOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isModelLibraryOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isModelLibraryOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsModelLibraryOperation()
        {
            return ClassInstance.LookupOperation("isModelLibrary");
        }
        
        /// <summary>
        /// Determines whether the specified profile is applied to this package.
        /// </summary>
        /// <param name="profile">The profile in question.</param>
        public bool IsProfileApplied(IProfile profile)
        {
            System.Func<IPackage, IProfile, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, bool>>(_isProfileAppliedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isProfileApplied registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isProfileAppliedOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isProfileAppliedOperation.Value, e));
            bool result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isProfileAppliedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsProfileAppliedOperation()
        {
            return ClassInstance.LookupOperation("isProfileApplied");
        }
        
        /// <summary>
        /// Unapplies the specified profile from this package and automatically unapplies stereotypes in the profile from elements within this package&apos;s namespace hieararchy.
        /// </summary>
        /// <param name="profile">The profile to unapply.</param>
        public ISetExpression<IEObject> UnapplyProfile(IProfile profile)
        {
            System.Func<IPackage, IProfile, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile, ISetExpression<IEObject>>>(_unapplyProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method unapplyProfile registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _unapplyProfileOperation.Value, profile);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _unapplyProfileOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profile);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _unapplyProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveUnapplyProfileOperation()
        {
            return ClassInstance.LookupOperation("unapplyProfile");
        }
        
        /// <summary>
        /// Applies the current definitions of the specified profiles to this package and automatically applies required stereotypes in the profiles to elements within this package&apos;s namespace hieararchy. If different definitions are already applied, automatically migrates any associated stereotype values on a &quot;best effort&quot; basis (matching classifiers and structural features by name).
        /// </summary>
        /// <param name="profiles">The profiles to apply.</param>
        public ISetExpression<IEObject> ApplyProfiles([LowerBoundAttribute(1)] IEnumerable<IProfile> profiles)
        {
            System.Func<IPackage, IEnumerable<IProfile>, ISetExpression<IEObject>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IEnumerable<IProfile>, ISetExpression<IEObject>>>(_applyProfilesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method applyProfiles registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _applyProfilesOperation.Value, profiles);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _applyProfilesOperation.Value, e));
            ISetExpression<IEObject> result = handler.Invoke(this, profiles);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _applyProfilesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveApplyProfilesOperation()
        {
            return ClassInstance.LookupOperation("applyProfiles");
        }
        
        /// <summary>
        /// The query allApplicableStereotypes() returns all the directly or indirectly owned stereotypes, including stereotypes contained in sub-profiles.
        ///result = (let ownedPackages : Bag(Package) = ownedMember-&gt;select(oclIsKindOf(Package))-&gt;collect(oclAsType(Package)) in
        /// ownedStereotype-&gt;union(ownedPackages.allApplicableStereotypes())-&gt;flatten()-&gt;asSet()
        ///)
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IStereotype> AllApplicableStereotypes()
        {
            System.Func<IPackage, ISetExpression<IStereotype>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IStereotype>>>(_allApplicableStereotypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allApplicableStereotypes registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allApplicableStereotypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allApplicableStereotypesOperation.Value, e));
            ISetExpression<IStereotype> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allApplicableStereotypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllApplicableStereotypesOperation()
        {
            return ClassInstance.LookupOperation("allApplicableStereotypes");
        }
        
        /// <summary>
        /// The query containingProfile() returns the closest profile directly or indirectly containing this package (or this package itself, if it is a profile).
        ///result = (if self.oclIsKindOf(Profile) then 
        ///	self.oclAsType(Profile)
        ///else
        ///	self.namespace.oclAsType(Package).containingProfile()
        ///endif)
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public IProfile ContainingProfile()
        {
            System.Func<IPackage, IProfile> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, IProfile>>(_containingProfileOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingProfile registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingProfileOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingProfileOperation.Value, e));
            IProfile result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingProfileOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingProfileOperation()
        {
            return ClassInstance.LookupOperation("containingProfile");
        }
        
        /// <summary>
        /// The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility and elements with public visibility are made visible.
        ///member-&gt;includes(el)
        ///result = (ownedMember-&gt;includes(el) or
        ///(elementImport-&gt;select(ei|ei.importedElement = VisibilityKind::public)-&gt;collect(importedElement.oclAsType(NamedElement))-&gt;includes(el)) or
        ///(packageImport-&gt;select(visibility = VisibilityKind::public)-&gt;collect(importedPackage.member-&gt;includes(el))-&gt;notEmpty()))
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        /// <param name="el"></param>
        public bool MakesVisible(INamedElement el)
        {
            System.Func<IPackage, INamedElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, INamedElement, bool>>(_makesVisibleOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method makesVisible registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _makesVisibleOperation.Value, el);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _makesVisibleOperation.Value, e));
            bool result = handler.Invoke(this, el);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _makesVisibleOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMakesVisibleOperation()
        {
            return ClassInstance.LookupOperation("makesVisible");
        }
        
        /// <summary>
        /// Derivation for Package::/nestedPackage
        ///result = (packagedElement-&gt;select(oclIsKindOf(Package))-&gt;collect(oclAsType(Package))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackage> GetNestedPackages()
        {
            System.Func<IPackage, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IPackage>>>(_getNestedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNestedPackages registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNestedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNestedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNestedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNestedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getNestedPackages");
        }
        
        /// <summary>
        /// Derivation for Package::/ownedStereotype
        ///result = (packagedElement-&gt;select(oclIsKindOf(Stereotype))-&gt;collect(oclAsType(Stereotype))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IStereotype> GetOwnedStereotypes()
        {
            System.Func<IPackage, ISetExpression<IStereotype>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IStereotype>>>(_getOwnedStereotypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedStereotypes registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedStereotypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedStereotypesOperation.Value, e));
            ISetExpression<IStereotype> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedStereotypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedStereotypesOperation()
        {
            return ClassInstance.LookupOperation("getOwnedStereotypes");
        }
        
        /// <summary>
        /// Derivation for Package::/ownedType
        ///result = (packagedElement-&gt;select(oclIsKindOf(Type))-&gt;collect(oclAsType(Type))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IType> GetOwnedTypes()
        {
            System.Func<IPackage, ISetExpression<NMF.Interop.Uml.IType>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<NMF.Interop.Uml.IType>>>(_getOwnedTypesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedTypes registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedTypesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedTypesOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IType> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedTypesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedTypesOperation()
        {
            return ClassInstance.LookupOperation("getOwnedTypes");
        }
        
        /// <summary>
        /// The query visibleMembers() defines which members of a Package can be accessed outside it.
        ///result = (member-&gt;select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))-&gt;collect(oclAsType(PackageableElement))-&gt;asSet())
        ///&lt;p&gt;From package UML::Packages.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> VisibleMembers()
        {
            System.Func<IPackage, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPackage, ISetExpression<IPackageableElement>>>(_visibleMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method visibleMembers registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _visibleMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _visibleMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _visibleMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveVisibleMembersOperation()
        {
            return ClassInstance.LookupOperation("visibleMembers");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveURIAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("URI")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveNestedPackageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("nestedPackage")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the NestedPackage property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void NestedPackageCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("NestedPackage", e, _nestedPackageReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the NestedPackage property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void NestedPackageCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("NestedPackage", e, _nestedPackageReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedStereotypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("ownedStereotype")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedStereotype property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedStereotypeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedStereotype", e, _ownedStereotypeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedStereotype property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedStereotypeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedStereotype", e, _ownedStereotypeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("ownedType")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedType property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedTypeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedType", e, _ownedTypeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedType property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedTypeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedType", e, _ownedTypeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageMergeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("packageMerge")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackageMerge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageMergeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackageMerge", e, _packageMergeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackageMerge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageMergeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackageMerge", e, _packageMergeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveProfileApplicationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("profileApplication")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ProfileApplication property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ProfileApplicationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ProfileApplication", e, _profileApplicationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ProfileApplication property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ProfileApplicationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ProfileApplication", e, _profileApplicationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveNestingPackageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Package.ClassInstance)).Resolve("nestingPackage")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldNestingPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newNestingPackage = ModelHelper.CastAs<IPackage>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldNestingPackage, newNestingPackage);
            this.OnPropertyChanging("NestingPackage", e, _nestingPackageReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IPackage oldNestingPackage = ModelHelper.CastAs<IPackage>(oldParent);
            IPackage newNestingPackage = ModelHelper.CastAs<IPackage>(newParent);
            if ((oldNestingPackage != null))
            {
                oldNestingPackage.NestedPackage.Remove(this);
            }
            if ((newNestingPackage != null))
            {
                newNestingPackage.NestedPackage.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldNestingPackage, newNestingPackage);
            this.OnPropertyChanged("NestingPackage", e, _nestingPackageReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// All the members of a Namespace are distinguishable within it.
        ///membersAreDistinguishable()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Members_distinguishable(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_members_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method members_distinguishable registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _members_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _members_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _members_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembers_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("members_distinguishable");
        }
        
        /// <summary>
        /// A Namespace cannot have a PackageImport to itself.
        ///packageImport.importedPackage.oclAsType(Namespace)-&gt;excludes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_self(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_selfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_self registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_selfOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_selfOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_selfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_selfOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_self");
        }
        
        /// <summary>
        /// A Namespace cannot have an ElementImport to one of its ownedMembers.
        ///elementImport.importedElement.oclAsType(Element)-&gt;excludesAll(ownedMember)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_ownedMembers(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_ownedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_ownedMembers registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_ownedMembersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_ownedMembersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_ownedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_ownedMembersOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_ownedMembers");
        }
        
        /// <summary>
        /// Creates an import of the specified element into this namespace with the specified visibility.
        /// </summary>
        /// <param name="element">The element to import.</param>
        /// <param name="visibility">The visibility for the new element import.</param>
        public IElementImport CreateElementImport(IPackageableElement element, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport>>(_createElementImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createElementImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createElementImportOperation.Value, element, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createElementImportOperation.Value, e));
            IElementImport result = handler.Invoke(this, element, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createElementImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateElementImportOperation()
        {
            return ClassInstance.LookupOperation("createElementImport");
        }
        
        /// <summary>
        /// Creates an import of the specified package into this namespace with the specified visibility.
        /// </summary>
        /// <param name="package_">The package to import.</param>
        /// <param name="visibility">The visibility for the new package import.</param>
        public IPackageImport CreatePackageImport(IPackage package_, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport>>(_createPackageImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createPackageImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createPackageImportOperation.Value, package_, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createPackageImportOperation.Value, e));
            IPackageImport result = handler.Invoke(this, package_, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createPackageImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreatePackageImportOperation()
        {
            return ClassInstance.LookupOperation("createPackageImport");
        }
        
        /// <summary>
        /// Retrieves the elements imported by this namespace.
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedElements()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedElements registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedElementsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedElementsOperation()
        {
            return ClassInstance.LookupOperation("getImportedElements");
        }
        
        /// <summary>
        /// Retrieves the packages imported by this namespace.
        /// </summary>
        public ISetExpression<IPackage> GetImportedPackages()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>>>(_getImportedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedPackages registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getImportedPackages");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public ISetExpression<INamedElement> GetOwnedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>>>(_getOwnedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedMembers registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedMembersOperation()
        {
            return ClassInstance.LookupOperation("getOwnedMembers");
        }
        
        /// <summary>
        /// The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this Namespace.
        ///result = (imps-&gt;reject(imp1  | imps-&gt;exists(imp2 | not imp1.isDistinguishableFrom(imp2, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ExcludeCollisions(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_excludeCollisionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method excludeCollisions registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _excludeCollisionsOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _excludeCollisionsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _excludeCollisionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveExcludeCollisionsOperation()
        {
            return ClassInstance.LookupOperation("excludeCollisions");
        }
        
        /// <summary>
        /// The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace, taking importing into account. In general a member can have multiple names in a Namespace if it is imported more than once with different aliases.
        ///result = (if self.ownedMember -&gt;includes(element)
        ///then Set{element.name}
        ///else let elementImports : Set(ElementImport) = self.elementImport-&gt;select(ei | ei.importedElement = element) in
        ///  if elementImports-&gt;notEmpty()
        ///  then
        ///     elementImports-&gt;collect(el | el.getName())-&gt;asSet()
        ///  else 
        ///     self.packageImport-&gt;select(pi | pi.importedPackage.visibleMembers().oclAsType(NamedElement)-&gt;includes(element))-&gt; collect(pi | pi.importedPackage.getNamesOfMember(element))-&gt;asSet()
        ///  endif
        ///endif)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="element"></param>
        public ISetExpression<string> GetNamesOfMember(INamedElement element)
        {
            System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>>>(_getNamesOfMemberOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNamesOfMember registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNamesOfMemberOperation.Value, element);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNamesOfMemberOperation.Value, e));
            ISetExpression<string> result = handler.Invoke(this, element);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNamesOfMemberOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNamesOfMemberOperation()
        {
            return ClassInstance.LookupOperation("getNamesOfMember");
        }
        
        /// <summary>
        /// The query importMembers() defines which of a set of PackageableElements are actually imported into the Namespace. This excludes hidden ones, i.e., those which have names that conflict with names of ownedMembers, and it also excludes PackageableElements that would have the indistinguishable names when imported.
        ///result = (self.excludeCollisions(imps)-&gt;select(imp | self.ownedMember-&gt;forAll(mem | imp.isDistinguishableFrom(mem, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ImportMembers(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_importMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method importMembers registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _importMembersOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _importMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _importMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveImportMembersOperation()
        {
            return ClassInstance.LookupOperation("importMembers");
        }
        
        /// <summary>
        /// The importedMember property is derived as the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
        ///result = (self.importMembers(elementImport.importedElement-&gt;asSet()-&gt;union(packageImport.importedPackage-&gt;collect(p | p.visibleMembers()))-&gt;asSet()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedMembersOperation()
        {
            return ClassInstance.LookupOperation("getImportedMembers");
        }
        
        /// <summary>
        /// The Boolean query membersAreDistinguishable() determines whether all of the Namespace&apos;s members are distinguishable within it.
        ///result = (member-&gt;forAll( memb |
        ///   member-&gt;excluding(memb)-&gt;forAll(other |
        ///       memb.isDistinguishableFrom(other, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool MembersAreDistinguishable()
        {
            System.Func<NMF.Interop.Uml.INamespace, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, bool>>(_membersAreDistinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method membersAreDistinguishable registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _membersAreDistinguishableOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _membersAreDistinguishableOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _membersAreDistinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembersAreDistinguishableOperation()
        {
            return ClassInstance.LookupOperation("membersAreDistinguishable");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedRuleReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("ownedRule")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedRule property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedRuleCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedRule", e, _ownedRuleReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedRule property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedRuleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedRule", e, _ownedRuleReference);
        }
        
        /// <summary>
        /// The query isTemplate() returns whether this TemplateableElement is actually a template.
        ///result = (ownedTemplateSignature &lt;&gt; null)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplate()
        {
            System.Func<ITemplateableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, bool>>(_isTemplateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplate registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateOperation()
        {
            return ClassInstance.LookupOperation("isTemplate");
        }
        
        /// <summary>
        /// The query parameterableElements() returns the set of ParameterableElements that may be used as the parameteredElements for a TemplateParameter of this TemplateableElement. By default, this set includes all the ownedElements. Subclasses may override this operation if they choose to restrict the set of ParameterableElements.
        ///result = (self.allOwnedElements()-&gt;select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)-&gt;asSet())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IParameterableElement> ParameterableElements()
        {
            System.Func<ITemplateableElement, ISetExpression<IParameterableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITemplateableElement, ISetExpression<IParameterableElement>>>(_parameterableElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method parameterableElements registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _parameterableElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _parameterableElementsOperation.Value, e));
            ISetExpression<IParameterableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _parameterableElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveParameterableElementsOperation()
        {
            return ClassInstance.LookupOperation("parameterableElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateBindingReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("templateBinding")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TemplateBinding", e, _templateBindingReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TemplateBinding property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TemplateBindingCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TemplateBinding", e, _templateBindingReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedTemplateSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.TemplateableElement.ClassInstance)).Resolve("ownedTemplateSignature")));
        }
        
        /// <summary>
        /// Handles the event that the OwnedTemplateSignature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwnedTemplateSignature(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwnedTemplateSignature))
            {
                this.OwnedTemplateSignature = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int metaclassReferenceIndex = ModelHelper.IndexOfReference(this.MetaclassReference, element);
            if ((metaclassReferenceIndex != -1))
            {
                return ModelHelper.CreatePath("metaclassReference", metaclassReferenceIndex);
            }
            int metamodelReferenceIndex = ModelHelper.IndexOfReference(this.MetamodelReference, element);
            if ((metamodelReferenceIndex != -1))
            {
                return ModelHelper.CreatePath("metamodelReference", metamodelReferenceIndex);
            }
            int nestedPackageIndex = ModelHelper.IndexOfReference(this.NestedPackage, element);
            if ((nestedPackageIndex != -1))
            {
                return ModelHelper.CreatePath("nestedPackage", nestedPackageIndex);
            }
            int ownedStereotypeIndex = ModelHelper.IndexOfReference(this.OwnedStereotype, element);
            if ((ownedStereotypeIndex != -1))
            {
                return ModelHelper.CreatePath("ownedStereotype", ownedStereotypeIndex);
            }
            int ownedTypeIndex = ModelHelper.IndexOfReference(this.OwnedType, element);
            if ((ownedTypeIndex != -1))
            {
                return ModelHelper.CreatePath("ownedType", ownedTypeIndex);
            }
            int packageMergeIndex = ModelHelper.IndexOfReference(this.PackageMerge, element);
            if ((packageMergeIndex != -1))
            {
                return ModelHelper.CreatePath("packageMerge", packageMergeIndex);
            }
            int profileApplicationIndex = ModelHelper.IndexOfReference(this.ProfileApplication, element);
            if ((profileApplicationIndex != -1))
            {
                return ModelHelper.CreatePath("profileApplication", profileApplicationIndex);
            }
            int ownedRuleIndex = ModelHelper.IndexOfReference(this.OwnedRule, element);
            if ((ownedRuleIndex != -1))
            {
                return ModelHelper.CreatePath("ownedRule", ownedRuleIndex);
            }
            int templateBindingIndex = ModelHelper.IndexOfReference(this.TemplateBinding, element);
            if ((templateBindingIndex != -1))
            {
                return ModelHelper.CreatePath("templateBinding", templateBindingIndex);
            }
            if ((element == this.OwnedTemplateSignature))
            {
                return ModelHelper.CreatePath("ownedTemplateSignature");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "METACLASSREFERENCE"))
            {
                if ((index < this.MetaclassReference.Count))
                {
                    return this.MetaclassReference[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "METAMODELREFERENCE"))
            {
                if ((index < this.MetamodelReference.Count))
                {
                    return this.MetamodelReference[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "NESTEDPACKAGE"))
            {
                if ((index < this.NestedPackage.Count))
                {
                    return this.NestedPackage[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDSTEREOTYPE"))
            {
                if ((index < this.OwnedStereotype.Count))
                {
                    return this.OwnedStereotype[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTYPE"))
            {
                if ((index < this.OwnedType.Count))
                {
                    return this.OwnedType[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGEMERGE"))
            {
                if ((index < this.PackageMerge.Count))
                {
                    return this.PackageMerge[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PROFILEAPPLICATION"))
            {
                if ((index < this.ProfileApplication.Count))
                {
                    return this.ProfileApplication[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "NESTINGPACKAGE"))
            {
                return this.NestingPackage;
            }
            if ((reference == "OWNEDRULE"))
            {
                if ((index < this.OwnedRule.Count))
                {
                    return this.OwnedRule[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "TEMPLATEBINDING"))
            {
                if ((index < this.TemplateBinding.Count))
                {
                    return this.TemplateBinding[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return this.OwnedTemplateSignature;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "URI"))
            {
                return this.URI;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "METACLASSREFERENCE"))
            {
                return this._metaclassReference;
            }
            if ((feature == "METAMODELREFERENCE"))
            {
                return this._metamodelReference;
            }
            if ((feature == "NESTEDPACKAGE"))
            {
                return this._nestedPackage;
            }
            if ((feature == "OWNEDSTEREOTYPE"))
            {
                return this._ownedStereotype;
            }
            if ((feature == "OWNEDTYPE"))
            {
                return this._ownedType;
            }
            if ((feature == "PACKAGEMERGE"))
            {
                return this._packageMerge;
            }
            if ((feature == "PROFILEAPPLICATION"))
            {
                return this._profileApplication;
            }
            if ((feature == "OWNEDRULE"))
            {
                return this._ownedRule;
            }
            if ((feature == "TEMPLATEBINDING"))
            {
                return this._templateBinding;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NESTINGPACKAGE"))
            {
                this.NestingPackage = ((IPackage)(value));
                return;
            }
            if ((feature == "OWNEDTEMPLATESIGNATURE"))
            {
                this.OwnedTemplateSignature = ((ITemplateSignature)(value));
                return;
            }
            if ((feature == "URI"))
            {
                this.URI = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "URI"))
            {
                return new URIProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "NESTINGPACKAGE"))
            {
                return new NestingPackageProxy(this);
            }
            if ((reference == "OWNEDTEMPLATESIGNATURE"))
            {
                return new OwnedTemplateSignatureProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._metaclassReference))
            {
                return "metaclassReference";
            }
            if ((container == this._metamodelReference))
            {
                return "metamodelReference";
            }
            if ((container == this._nestedPackage))
            {
                return "nestedPackage";
            }
            if ((container == this._ownedStereotype))
            {
                return "ownedStereotype";
            }
            if ((container == this._ownedType))
            {
                return "ownedType";
            }
            if ((container == this._packageMerge))
            {
                return "packageMerge";
            }
            if ((container == this._profileApplication))
            {
                return "profileApplication";
            }
            if ((container == this._ownedRule))
            {
                return "ownedRule";
            }
            if ((container == this._templateBinding))
            {
                return "templateBinding";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Profile")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Profile class
        /// </summary>
        public class ProfileChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Profile _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ProfileChildrenCollection(Profile parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Profile class
        /// </summary>
        public class ProfileReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Profile _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ProfileReferencedElementsCollection(Profile parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the URI property
        /// </summary>
        private sealed class URIProxy : ModelPropertyChange<IPackage, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public URIProxy(IPackage modelElement) : 
                    base(modelElement, "URI")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.URI;
                }
                set
                {
                    this.ModelElement.URI = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the nestingPackage property
        /// </summary>
        private sealed class NestingPackageProxy : ModelPropertyChange<IPackage, IPackage>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NestingPackageProxy(IPackage modelElement) : 
                    base(modelElement, "nestingPackage")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IPackage Value
            {
                get
                {
                    return this.ModelElement.NestingPackage;
                }
                set
                {
                    this.ModelElement.NestingPackage = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the ownedTemplateSignature property
        /// </summary>
        private sealed class OwnedTemplateSignatureProxy : ModelPropertyChange<ITemplateableElement, ITemplateSignature>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwnedTemplateSignatureProxy(ITemplateableElement modelElement) : 
                    base(modelElement, "ownedTemplateSignature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateSignature Value
            {
                get
                {
                    return this.ModelElement.OwnedTemplateSignature;
                }
                set
                {
                    this.ModelElement.OwnedTemplateSignature = value;
                }
            }
        }
    }
}
