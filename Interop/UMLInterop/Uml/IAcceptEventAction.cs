//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for AcceptEventAction
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(AcceptEventAction))]
    [XmlDefaultImplementationTypeAttribute(typeof(AcceptEventAction))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//AcceptEventAction")]
    public interface IAcceptEventAction : IModelElement, IAction
    {
        
        /// <summary>
        /// Indicates whether there is a single OutputPin for a SignalEvent occurrence, or multiple OutputPins for attribute values of the instance of the Signal associated with a SignalEvent occurrence.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isUnmarshall")]
        [DescriptionAttribute("Indicates whether there is a single OutputPin for a SignalEvent occurrence, or mu" +
            "ltiple OutputPins for attribute values of the instance of the Signal associated " +
            "with a SignalEvent occurrence.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("AcceptEventAction")]
        [XmlElementNameAttribute("isUnmarshall")]
        [XmlAttributeAttribute(true)]
        bool IsUnmarshall
        {
            get;
            set;
        }
        
        /// <summary>
        /// OutputPins holding the values received from an Event occurrence.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("result")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IOutputPin> Result
        {
            get;
        }
        
        /// <summary>
        /// The Triggers specifying the Events of which the AcceptEventAction waits for occurrences.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("trigger")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<ITrigger> Trigger
        {
            get;
        }
        
        /// <summary>
        /// If isUnmarshall=false and any of the triggers are for SignalEvents or TimeEvents, there must be exactly one result OutputPin with multiplicity 1..1.
        ///not isUnmarshall and trigger->exists(event.oclIsKindOf(SignalEvent) or event.oclIsKindOf(TimeEvent)) implies 
        ///	output->size() = 1 and output->first().is(1,1)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool One_output_pin(object diagnostics, object context);
        
        /// <summary>
        /// AcceptEventActions may have no input pins.
        ///input->size() = 0
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool No_input_pins(object diagnostics, object context);
        
        /// <summary>
        /// There are no OutputPins if the trigger events are only ChangeEvents and/or CallEvents when this action is an instance of AcceptEventAction and not an instance of a descendant of AcceptEventAction (such as AcceptCallAction).
        ///(self.oclIsTypeOf(AcceptEventAction) and
        ///   (trigger->forAll(event.oclIsKindOf(ChangeEvent) or  
        ///                             event.oclIsKindOf(CallEvent))))
        ///implies output->size() = 0
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool No_output_pins(object diagnostics, object context);
        
        /// <summary>
        /// If isUnmarshall is true (and this is not an AcceptCallAction), there must be exactly one trigger, which is for a SignalEvent. The number of result output pins must be the same as the number of attributes of the signal. The type and ordering of each result output pin must be the same as the corresponding attribute of the signal. The multiplicity of each result output pin must be compatible with the multiplicity of the corresponding attribute.
        ///isUnmarshall and self.oclIsTypeOf(AcceptEventAction) implies
        ///	trigger->size()=1 and
        ///	trigger->asSequence()->first().event.oclIsKindOf(SignalEvent) and
        ///	let attribute: OrderedSet(Property) = trigger->asSequence()->first().event.oclAsType(SignalEvent).signal.allAttributes() in
        ///	attribute->size()>0 and result->size() = attribute->size() and
        ///	Sequence{1..result->size()}->forAll(i | 
        ///		result->at(i).type = attribute->at(i).type and 
        ///		result->at(i).isOrdered = attribute->at(i).isOrdered and
        ///		result->at(i).includesMultiplicity(attribute->at(i)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Unmarshall_signal_events(object diagnostics, object context);
        
        /// <summary>
        /// If isUnmarshall=false and all the triggers are for SignalEvents, then the type of the single result OutputPin must either be null or all the signals must conform to it.
        ///not isUnmarshall implies 
        ///	result->isEmpty() or
        ///	let type: Type = result->first().type in
        ///	type=null or 
        ///		(trigger->forAll(event.oclIsKindOf(SignalEvent)) and 
        ///		 trigger.event.oclAsType(SignalEvent).signal->forAll(s | s.conformsTo(type)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Conforming_type(object diagnostics, object context);
    }
}

