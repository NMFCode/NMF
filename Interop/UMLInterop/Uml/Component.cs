//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Component represents a modular part of a system that encapsulates its contents and whose manifestation is replaceable within its environment.
    ///<p>From package UML::StructuredClassifiers.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Component")]
    [DebuggerDisplayAttribute("Component {Name}")]
    public partial class Component : Class, NMF.Interop.Uml.IComponent, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _no_nested_classifiersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNo_nested_classifiersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _no_packaged_elementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNo_packaged_elementsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedClassOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedClassOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedEnumerationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedEnumerationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedInterfaceOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedInterfaceOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createOwnedPrimitiveTypeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateOwnedPrimitiveTypeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProvidedsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProvidedsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getRequiredsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetRequiredsOperation);
        
        /// <summary>
        /// The backing field for the IsIndirectlyInstantiated property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isIndirectlyInstantiated = true;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isIndirectlyInstantiatedAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsIndirectlyInstantiatedAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packagedElementReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackagedElementReference);
        
        /// <summary>
        /// The backing field for the PackagedElement property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IPackageableElement> _packagedElement;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _realizationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRealizationReference);
        
        /// <summary>
        /// The backing field for the Realization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ComponentRealizationCollection _realization;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Component()
        {
            this._packagedElement = new ObservableCompositionOrderedSet<IPackageableElement>(this);
            this._packagedElement.CollectionChanging += this.PackagedElementCollectionChanging;
            this._packagedElement.CollectionChanged += this.PackagedElementCollectionChanged;
            this._realization = new ComponentRealizationCollection(this);
            this._realization.CollectionChanging += this.RealizationCollectionChanging;
            this._realization.CollectionChanged += this.RealizationCollectionChanged;
        }
        
        /// <summary>
        /// If true, the Component is defined at design-time, but at run-time (or execution-time) an object specified by the Component does not exist, that is, the Component is instantiated indirectly, through the instantiation of its realizing Classifiers or parts.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DefaultValueAttribute(true)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isIndirectlyInstantiated")]
        [DescriptionAttribute(@"If true, the Component is defined at design-time, but at run-time (or execution-time) an object specified by the Component does not exist, that is, the Component is instantiated indirectly, through the instantiation of its realizing Classifiers or parts.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Component")]
        [XmlElementNameAttribute("isIndirectlyInstantiated")]
        [XmlAttributeAttribute(true)]
        public bool IsIndirectlyInstantiated
        {
            get
            {
                return this._isIndirectlyInstantiated;
            }
            set
            {
                if ((this._isIndirectlyInstantiated != value))
                {
                    bool old = this._isIndirectlyInstantiated;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsIndirectlyInstantiated", e, _isIndirectlyInstantiatedAttribute);
                    this._isIndirectlyInstantiated = value;
                    this.OnPropertyChanged("IsIndirectlyInstantiated", e, _isIndirectlyInstantiatedAttribute);
                }
            }
        }
        
        /// <summary>
        /// The set of PackageableElements that a Component owns. In the namespace of a Component, all model elements that are involved in or related to its definition may be owned or imported explicitly. These may include e.g., Classes, Interfaces, Components, Packages, UseCases, Dependencies (e.g., mappings), and Artifacts.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packagedElement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPackageableElement> PackagedElement
        {
            get
            {
                return this._packagedElement;
            }
        }
        
        /// <summary>
        /// The set of Realizations owned by the Component. Realizations reference the Classifiers of which the Component is an abstraction; i.e., that realize its behavior.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("realization")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("abstraction")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IComponentRealization> Realization
        {
            get
            {
                return this._realization;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ComponentChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ComponentReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Component")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// A Component cannot nest Classifiers.
        ///nestedClassifier->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool No_nested_classifiers(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.IComponent, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, object, object, bool>>(_no_nested_classifiersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method no_nested_classifiers registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _no_nested_classifiersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _no_nested_classifiersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _no_nested_classifiersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNo_nested_classifiersOperation()
        {
            return ClassInstance.LookupOperation("no_nested_classifiers");
        }
        
        /// <summary>
        /// A Component nested in a Class cannot have any packaged elements.
        ///nestingClass <> null implies packagedElement->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool No_packaged_elements(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.IComponent, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, object, object, bool>>(_no_packaged_elementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method no_packaged_elements registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _no_packaged_elementsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _no_packaged_elementsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _no_packaged_elementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNo_packaged_elementsOperation()
        {
            return ClassInstance.LookupOperation("no_packaged_elements");
        }
        
        /// <summary>
        /// Creates a(n) (abstract) class with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new class, or null.</param>
        /// <param name="isAbstract">Whether the new class should be abstract.</param>
        public NMF.Interop.Uml.IClass CreateOwnedClass(string name, bool isAbstract)
        {
            System.Func<NMF.Interop.Uml.IComponent, string, bool, NMF.Interop.Uml.IClass> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, string, bool, NMF.Interop.Uml.IClass>>(_createOwnedClassOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedClass registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedClassOperation.Value, name, isAbstract);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedClassOperation.Value, e));
            NMF.Interop.Uml.IClass result = handler.Invoke(this, name, isAbstract);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedClassOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedClassOperation()
        {
            return ClassInstance.LookupOperation("createOwnedClass");
        }
        
        /// <summary>
        /// Creates a enumeration with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new enumeration, or null.</param>
        public NMF.Interop.Uml.IEnumeration CreateOwnedEnumeration(string name)
        {
            System.Func<NMF.Interop.Uml.IComponent, string, NMF.Interop.Uml.IEnumeration> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, string, NMF.Interop.Uml.IEnumeration>>(_createOwnedEnumerationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedEnumeration registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedEnumerationOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedEnumerationOperation.Value, e));
            NMF.Interop.Uml.IEnumeration result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedEnumerationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedEnumerationOperation()
        {
            return ClassInstance.LookupOperation("createOwnedEnumeration");
        }
        
        /// <summary>
        /// Creates an interface with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new interface, or null.</param>
        public IInterface CreateOwnedInterface(string name)
        {
            System.Func<NMF.Interop.Uml.IComponent, string, IInterface> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, string, IInterface>>(_createOwnedInterfaceOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedInterface registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedInterfaceOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedInterfaceOperation.Value, e));
            IInterface result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedInterfaceOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedInterfaceOperation()
        {
            return ClassInstance.LookupOperation("createOwnedInterface");
        }
        
        /// <summary>
        /// Creates a primitive type with the specified name as a packaged element of this component.
        /// </summary>
        /// <param name="name">The name for the new primitive type, or null.</param>
        public NMF.Interop.Uml.IPrimitiveType CreateOwnedPrimitiveType(string name)
        {
            System.Func<NMF.Interop.Uml.IComponent, string, NMF.Interop.Uml.IPrimitiveType> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, string, NMF.Interop.Uml.IPrimitiveType>>(_createOwnedPrimitiveTypeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createOwnedPrimitiveType registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createOwnedPrimitiveTypeOperation.Value, name);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createOwnedPrimitiveTypeOperation.Value, e));
            NMF.Interop.Uml.IPrimitiveType result = handler.Invoke(this, name);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createOwnedPrimitiveTypeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateOwnedPrimitiveTypeOperation()
        {
            return ClassInstance.LookupOperation("createOwnedPrimitiveType");
        }
        
        /// <summary>
        /// Derivation for Component::/provided
        ///result = (let 	ris : Set(Interface) = allRealizedInterfaces(),
        ///        realizingClassifiers : Set(Classifier) =  self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        ///        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),
        ///        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allRealizedInterfaces())),
        ///        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),
        ///        providedByPorts : Set(Interface) = ports.provided->asSet()
        ///in     ris->union(realizingClassifierInterfaces) ->union(providedByPorts)->asSet())
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        public ISetExpression<IInterface> GetProvideds()
        {
            System.Func<NMF.Interop.Uml.IComponent, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, ISetExpression<IInterface>>>(_getProvidedsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProvideds registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProvidedsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProvidedsOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProvidedsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProvidedsOperation()
        {
            return ClassInstance.LookupOperation("getProvideds");
        }
        
        /// <summary>
        /// Derivation for Component::/required
        ///result = (let 	uis : Set(Interface) = allUsedInterfaces(),
        ///        realizingClassifiers : Set(Classifier) = self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        ///        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),
        ///        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allUsedInterfaces())),
        ///        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),
        ///        usedByPorts : Set(Interface) = ports.required->asSet()
        ///in	    uis->union(realizingClassifierInterfaces)->union(usedByPorts)->asSet()
        ///)
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        public ISetExpression<IInterface> GetRequireds()
        {
            System.Func<NMF.Interop.Uml.IComponent, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.IComponent, ISetExpression<IInterface>>>(_getRequiredsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getRequireds registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getRequiredsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getRequiredsOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getRequiredsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetRequiredsOperation()
        {
            return ClassInstance.LookupOperation("getRequireds");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsIndirectlyInstantiatedAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Component.ClassInstance)).Resolve("isIndirectlyInstantiated")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackagedElementReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Component.ClassInstance)).Resolve("packagedElement")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackagedElement property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackagedElementCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackagedElement", e, _packagedElementReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackagedElement property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackagedElementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackagedElement", e, _packagedElementReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRealizationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Component.ClassInstance)).Resolve("realization")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Realization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Realization", e, _realizationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Realization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Realization", e, _realizationReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int packagedElementIndex = ModelHelper.IndexOfReference(this.PackagedElement, element);
            if ((packagedElementIndex != -1))
            {
                return ModelHelper.CreatePath("packagedElement", packagedElementIndex);
            }
            int realizationIndex = ModelHelper.IndexOfReference(this.Realization, element);
            if ((realizationIndex != -1))
            {
                return ModelHelper.CreatePath("realization", realizationIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "PACKAGEDELEMENT"))
            {
                if ((index < this.PackagedElement.Count))
                {
                    return this.PackagedElement[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "REALIZATION"))
            {
                if ((index < this.Realization.Count))
                {
                    return this.Realization[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISINDIRECTLYINSTANTIATED"))
            {
                return this.IsIndirectlyInstantiated;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "PACKAGEDELEMENT"))
            {
                return this._packagedElement;
            }
            if ((feature == "REALIZATION"))
            {
                return this._realization;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "ISINDIRECTLYINSTANTIATED"))
            {
                this.IsIndirectlyInstantiated = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISINDIRECTLYINSTANTIATED"))
            {
                return Observable.Box(new IsIndirectlyInstantiatedProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._packagedElement))
            {
                return "packagedElement";
            }
            if ((container == this._realization))
            {
                return "realization";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Component")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Component class
        /// </summary>
        public class ComponentChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Component _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ComponentChildrenCollection(Component parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.PackagedElement.Count);
                    count = (count + this._parent.Realization.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.PackagedElement.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Realization.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.PackagedElement.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Realization.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IPackageableElement packagedElementCasted = item.As<IPackageableElement>();
                if ((packagedElementCasted != null))
                {
                    this._parent.PackagedElement.Add(packagedElementCasted);
                }
                IComponentRealization realizationCasted = item.As<IComponentRealization>();
                if ((realizationCasted != null))
                {
                    this._parent.Realization.Add(realizationCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.PackagedElement.Clear();
                this._parent.Realization.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.PackagedElement.Contains(item))
                {
                    return true;
                }
                if (this._parent.Realization.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> packagedElementEnumerator = this._parent.PackagedElement.GetEnumerator();
                try
                {
                    for (
                    ; packagedElementEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = packagedElementEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    packagedElementEnumerator.Dispose();
                }
                IEnumerator<IModelElement> realizationEnumerator = this._parent.Realization.GetEnumerator();
                try
                {
                    for (
                    ; realizationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = realizationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    realizationEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IPackageableElement packageableElementItem = item.As<IPackageableElement>();
                if (((packageableElementItem != null) 
                            && this._parent.PackagedElement.Remove(packageableElementItem)))
                {
                    return true;
                }
                IComponentRealization componentRealizationItem = item.As<IComponentRealization>();
                if (((componentRealizationItem != null) 
                            && this._parent.Realization.Remove(componentRealizationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.PackagedElement).Concat(this._parent.Realization).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Component class
        /// </summary>
        public class ComponentReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Component _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ComponentReferencedElementsCollection(Component parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.PackagedElement.Count);
                    count = (count + this._parent.Realization.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.PackagedElement.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Realization.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.PackagedElement.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Realization.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IPackageableElement packagedElementCasted = item.As<IPackageableElement>();
                if ((packagedElementCasted != null))
                {
                    this._parent.PackagedElement.Add(packagedElementCasted);
                }
                IComponentRealization realizationCasted = item.As<IComponentRealization>();
                if ((realizationCasted != null))
                {
                    this._parent.Realization.Add(realizationCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.PackagedElement.Clear();
                this._parent.Realization.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.PackagedElement.Contains(item))
                {
                    return true;
                }
                if (this._parent.Realization.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> packagedElementEnumerator = this._parent.PackagedElement.GetEnumerator();
                try
                {
                    for (
                    ; packagedElementEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = packagedElementEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    packagedElementEnumerator.Dispose();
                }
                IEnumerator<IModelElement> realizationEnumerator = this._parent.Realization.GetEnumerator();
                try
                {
                    for (
                    ; realizationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = realizationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    realizationEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IPackageableElement packageableElementItem = item.As<IPackageableElement>();
                if (((packageableElementItem != null) 
                            && this._parent.PackagedElement.Remove(packageableElementItem)))
                {
                    return true;
                }
                IComponentRealization componentRealizationItem = item.As<IComponentRealization>();
                if (((componentRealizationItem != null) 
                            && this._parent.Realization.Remove(componentRealizationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.PackagedElement).Concat(this._parent.Realization).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isIndirectlyInstantiated property
        /// </summary>
        private sealed class IsIndirectlyInstantiatedProxy : ModelPropertyChange<NMF.Interop.Uml.IComponent, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsIndirectlyInstantiatedProxy(NMF.Interop.Uml.IComponent modelElement) : 
                    base(modelElement, "isIndirectlyInstantiated")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsIndirectlyInstantiated;
                }
                set
                {
                    this.ModelElement.IsIndirectlyInstantiated = value;
                }
            }
        }
    }
}

