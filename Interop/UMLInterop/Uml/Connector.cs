//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Connector specifies links that enables communication between two or more instances. In contrast to Associations, which specify links between any instance of the associated Classifiers, Connectors specify links between instances playing the connected parts only.
    ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Connector")]
    [DebuggerDisplayAttribute("Connector {Name}")]
    public partial class Connector : Feature, IConnector, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _typesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveTypesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _rolesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRolesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getKindOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetKindOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _contractReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveContractReference);
        
        /// <summary>
        /// The backing field for the Contract property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IBehavior> _contract;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _endReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveEndReference);
        
        /// <summary>
        /// The backing field for the End property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConnectorEnd> _end;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedConnectorReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedConnectorReference);
        
        /// <summary>
        /// The backing field for the RedefinedConnector property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IConnector> _redefinedConnector;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _typeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IAssociation _type;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Connector()
        {
            this._contract = new ObservableAssociationSet<IBehavior>();
            this._contract.CollectionChanging += this.ContractCollectionChanging;
            this._contract.CollectionChanged += this.ContractCollectionChanged;
            this._end = new ObservableCompositionOrderedSet<IConnectorEnd>(this);
            this._end.CollectionChanging += this.EndCollectionChanging;
            this._end.CollectionChanged += this.EndCollectionChanged;
            this._redefinedConnector = new ObservableAssociationSet<IConnector>();
            this._redefinedConnector.CollectionChanging += this.RedefinedConnectorCollectionChanging;
            this._redefinedConnector.CollectionChanged += this.RedefinedConnectorCollectionChanged;
        }
        
        /// <summary>
        /// The set of Behaviors that specify the valid interaction patterns across the Connector.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("contract")]
        [DescriptionAttribute("The set of Behaviors that specify the valid interaction patterns across the Conne" +
            "ctor.\n<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Connector")]
        [XmlElementNameAttribute("contract")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IBehavior> Contract
        {
            get
            {
                return this._contract;
            }
        }
        
        /// <summary>
        /// A Connector has at least two ConnectorEnds, each representing the participation of instances of the Classifiers typing the ConnectableElements attached to the end. The set of ConnectorEnds is ordered.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [LowerBoundAttribute(2)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("end")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConnectorEnd> End
        {
            get
            {
                return this._end;
            }
        }
        
        /// <summary>
        /// A Connector may be redefined when its containing Classifier is specialized. The redefining Connector may have a type that specializes the type of the redefined Connector. The types of the ConnectorEnds of the redefining Connector may specialize the types of the ConnectorEnds of the redefined Connector. The properties of the ConnectorEnds of the redefining Connector may be replaced.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedConnector")]
        [DescriptionAttribute(@"A Connector may be redefined when its containing Classifier is specialized. The redefining Connector may have a type that specializes the type of the redefined Connector. The types of the ConnectorEnds of the redefining Connector may specialize the types of the ConnectorEnds of the redefined Connector. The properties of the ConnectorEnds of the redefining Connector may be replaced.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Connector")]
        [XmlElementNameAttribute("redefinedConnector")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IConnector> RedefinedConnector
        {
            get
            {
                return this._redefinedConnector;
            }
        }
        
        /// <summary>
        /// An optional Association that classifies links corresponding to this Connector.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("type")]
        [DescriptionAttribute("An optional Association that classifies links corresponding to this Connector.\n<p" +
            ">From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Connector")]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(true)]
        public IAssociation Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    IAssociation old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ConnectorChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ConnectorReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Connector")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// The types of the ConnectableElements that the ends of a Connector are attached to must conform to the types of the ends of the Association that types the Connector, if any.
        ///type&lt;&gt;null implies 
        ///  let noOfEnds : Integer = end-&gt;size() in 
        ///  (type.memberEnd-&gt;size() = noOfEnds) and Sequence{1..noOfEnds}-&gt;forAll(i | end-&gt;at(i).role.type.conformsTo(type.memberEnd-&gt;at(i).type))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Types(object diagnostics, object context)
        {
            System.Func<IConnector, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IConnector, object, object, bool>>(_typesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method types registered. Use the method broker to " +
                        "register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _typesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _typesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _typesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveTypesOperation()
        {
            return ClassInstance.LookupOperation("types");
        }
        
        /// <summary>
        /// The ConnectableElements attached as roles to each ConnectorEnd owned by a Connector must be owned or inherited roles of the Classifier that owned the Connector, or they must be Ports of such roles.
        ///structuredClassifier &lt;&gt; null
        ///and
        ///  end-&gt;forAll( e | structuredClassifier.allRoles()-&gt;includes(e.role)
        ///or
        ///  e.role.oclIsKindOf(Port) and structuredClassifier.allRoles()-&gt;includes(e.partWithPort))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Roles(object diagnostics, object context)
        {
            System.Func<IConnector, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IConnector, object, object, bool>>(_rolesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method roles registered. Use the method broker to " +
                        "register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _rolesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _rolesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _rolesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRolesOperation()
        {
            return ClassInstance.LookupOperation("roles");
        }
        
        /// <summary>
        /// Derivation for Connector::/kind : ConnectorKind
        ///result = (if end-&gt;exists(
        ///		role.oclIsKindOf(Port) 
        ///		and partWithPort-&gt;isEmpty()
        ///		and not role.oclAsType(Port).isBehavior)
        ///then ConnectorKind::delegation 
        ///else ConnectorKind::assembly 
        ///endif)
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ConnectorKind GetKind()
        {
            System.Func<IConnector, ConnectorKind> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IConnector, ConnectorKind>>(_getKindOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getKind registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getKindOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getKindOperation.Value, e));
            ConnectorKind result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getKindOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetKindOperation()
        {
            return ClassInstance.LookupOperation("getKind");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveContractReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Connector.ClassInstance)).Resolve("contract")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Contract property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ContractCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Contract", e, _contractReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Contract property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ContractCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Contract", e, _contractReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveEndReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Connector.ClassInstance)).Resolve("end")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the End property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void EndCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("End", e, _endReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the End property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void EndCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("End", e, _endReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedConnectorReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Connector.ClassInstance)).Resolve("redefinedConnector")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedConnector property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedConnectorCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedConnector", e, _redefinedConnectorReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedConnector property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedConnectorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedConnector", e, _redefinedConnectorReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Connector.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int endIndex = ModelHelper.IndexOfReference(this.End, element);
            if ((endIndex != -1))
            {
                return ModelHelper.CreatePath("end", endIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "END"))
            {
                if ((index < this.End.Count))
                {
                    return this.End[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "CONTRACT"))
            {
                return this._contract;
            }
            if ((feature == "END"))
            {
                return this._end;
            }
            if ((feature == "REDEFINEDCONNECTOR"))
            {
                return this._redefinedConnector;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TYPE"))
            {
                this.Type = ((IAssociation)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._end))
            {
                return "end";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Connector")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Connector class
        /// </summary>
        public class ConnectorChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Connector _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ConnectorChildrenCollection(Connector parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.End.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.End.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.End.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IConnectorEnd endCasted = item.As<IConnectorEnd>();
                if ((endCasted != null))
                {
                    this._parent.End.Add(endCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.End.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.End.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> endEnumerator = this._parent.End.GetEnumerator();
                try
                {
                    for (
                    ; endEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = endEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    endEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IConnectorEnd connectorEndItem = item.As<IConnectorEnd>();
                if (((connectorEndItem != null) 
                            && this._parent.End.Remove(connectorEndItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.End).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Connector class
        /// </summary>
        public class ConnectorReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Connector _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ConnectorReferencedElementsCollection(Connector parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Contract.Count);
                    count = (count + this._parent.End.Count);
                    count = (count + this._parent.RedefinedConnector.Count);
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Contract.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.End.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.RedefinedConnector.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Contract.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.End.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.RedefinedConnector.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IBehavior contractCasted = item.As<IBehavior>();
                if ((contractCasted != null))
                {
                    this._parent.Contract.Add(contractCasted);
                }
                IConnectorEnd endCasted = item.As<IConnectorEnd>();
                if ((endCasted != null))
                {
                    this._parent.End.Add(endCasted);
                }
                IConnector redefinedConnectorCasted = item.As<IConnector>();
                if ((redefinedConnectorCasted != null))
                {
                    this._parent.RedefinedConnector.Add(redefinedConnectorCasted);
                }
                if ((this._parent.Type == null))
                {
                    IAssociation typeCasted = item.As<IAssociation>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Contract.Clear();
                this._parent.End.Clear();
                this._parent.RedefinedConnector.Clear();
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Contract.Contains(item))
                {
                    return true;
                }
                if (this._parent.End.Contains(item))
                {
                    return true;
                }
                if (this._parent.RedefinedConnector.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> contractEnumerator = this._parent.Contract.GetEnumerator();
                try
                {
                    for (
                    ; contractEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = contractEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    contractEnumerator.Dispose();
                }
                IEnumerator<IModelElement> endEnumerator = this._parent.End.GetEnumerator();
                try
                {
                    for (
                    ; endEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = endEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    endEnumerator.Dispose();
                }
                IEnumerator<IModelElement> redefinedConnectorEnumerator = this._parent.RedefinedConnector.GetEnumerator();
                try
                {
                    for (
                    ; redefinedConnectorEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = redefinedConnectorEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    redefinedConnectorEnumerator.Dispose();
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IBehavior behaviorItem = item.As<IBehavior>();
                if (((behaviorItem != null) 
                            && this._parent.Contract.Remove(behaviorItem)))
                {
                    return true;
                }
                IConnectorEnd connectorEndItem = item.As<IConnectorEnd>();
                if (((connectorEndItem != null) 
                            && this._parent.End.Remove(connectorEndItem)))
                {
                    return true;
                }
                IConnector connectorItem = item.As<IConnector>();
                if (((connectorItem != null) 
                            && this._parent.RedefinedConnector.Remove(connectorItem)))
                {
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Contract).Concat(this._parent.End).Concat(this._parent.RedefinedConnector).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IConnector, IAssociation>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IConnector modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IAssociation Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
}
