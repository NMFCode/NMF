//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A NamedElement is an Element in a model that may have a name. The name may be given directly and/or via the use of a StringExpression.
    ///<p>From package UML::CommonStructure.</p>
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement")]
    [DebuggerDisplayAttribute("NamedElement {Name}")]
    public abstract partial class NamedElement : Element, INamedElement, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _visibility_needs_ownershipOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveVisibility_needs_ownershipOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _has_qualified_nameOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveHas_qualified_nameOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _has_no_qualified_nameOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveHas_no_qualified_nameOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createDependencyOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateDependencyOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createUsageOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateUsageOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getLabelOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetLabelOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getLabelOperation_ = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetLabelOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNamespaceOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNamespaceOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allNamespacesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllNamespacesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allOwningPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllOwningPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isDistinguishableFromOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsDistinguishableFromOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getQualifiedNameOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetQualifiedNameOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _separatorOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSeparatorOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getClientDependenciesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetClientDependenciesOperation);
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _nameAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Visibility property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private Nullable<VisibilityKind> _visibility;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _visibilityAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveVisibilityAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _nameExpressionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveNameExpressionReference);
        
        /// <summary>
        /// The backing field for the NameExpression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IStringExpression _nameExpression;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// The name of the NamedElement.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DisplayNameAttribute("name")]
        [DescriptionAttribute("The name of the NamedElement.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("NamedElement")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                }
            }
        }
        
        /// <summary>
        /// Determines whether and how the NamedElement is visible outside its owning Namespace.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [DisplayNameAttribute("visibility")]
        [DescriptionAttribute("Determines whether and how the NamedElement is visible outside its owning Namespa" +
            "ce.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("NamedElement")]
        [XmlElementNameAttribute("visibility")]
        [XmlAttributeAttribute(true)]
        public Nullable<VisibilityKind> Visibility
        {
            get
            {
                return this._visibility;
            }
            set
            {
                if ((this._visibility != value))
                {
                    Nullable<VisibilityKind> old = this._visibility;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Visibility", e, _visibilityAttribute);
                    this._visibility = value;
                    this.OnPropertyChanged("Visibility", e, _visibilityAttribute);
                }
            }
        }
        
        /// <summary>
        /// The StringExpression used to define the name of this NamedElement.
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("nameExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IStringExpression NameExpression
        {
            get
            {
                return this._nameExpression;
            }
            set
            {
                if ((this._nameExpression != value))
                {
                    IStringExpression old = this._nameExpression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("NameExpression", e, _nameExpressionReference);
                    this._nameExpression = value;
                    if ((old != null))
                    {
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetNameExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetNameExpression;
                    }
                    this.OnPropertyChanged("NameExpression", e, _nameExpressionReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new NamedElementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new NamedElementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        /// <summary>
        /// If a NamedElement is owned by something other than a Namespace, it does not have a visibility. One that is not owned by anything (and hence must be a Package, as this is the only kind of NamedElement that overrides mustBeOwned()) may have a visibility.
        ///(namespace = null and owner <> null) implies visibility = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Visibility_needs_ownership(object diagnostics, object context)
        {
            System.Func<INamedElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, object, object, bool>>(_visibility_needs_ownershipOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method visibility_needs_ownership registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _visibility_needs_ownershipOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _visibility_needs_ownershipOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _visibility_needs_ownershipOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveVisibility_needs_ownershipOperation()
        {
            return ClassInstance.LookupOperation("visibility_needs_ownership");
        }
        
        /// <summary>
        /// When there is a name, and all of the containing Namespaces have a name, the qualifiedName is constructed from the name of the NamedElement and the names of the containing Namespaces.
        ///(name <> null and allNamespaces()->select(ns | ns.name = null)->isEmpty()) implies
        ///  qualifiedName = allNamespaces()->iterate( ns : Namespace; agg: String = name | ns.name.concat(self.separator()).concat(agg))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Has_qualified_name(object diagnostics, object context)
        {
            System.Func<INamedElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, object, object, bool>>(_has_qualified_nameOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method has_qualified_name registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _has_qualified_nameOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _has_qualified_nameOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _has_qualified_nameOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveHas_qualified_nameOperation()
        {
            return ClassInstance.LookupOperation("has_qualified_name");
        }
        
        /// <summary>
        /// If there is no name, or one of the containing Namespaces has no name, there is no qualifiedName.
        ///name=null or allNamespaces()->select( ns | ns.name=null )->notEmpty() implies qualifiedName = null
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Has_no_qualified_name(object diagnostics, object context)
        {
            System.Func<INamedElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, object, object, bool>>(_has_no_qualified_nameOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method has_no_qualified_name registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _has_no_qualified_nameOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _has_no_qualified_nameOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _has_no_qualified_nameOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveHas_no_qualified_nameOperation()
        {
            return ClassInstance.LookupOperation("has_no_qualified_name");
        }
        
        /// <summary>
        /// Creates a dependency between this named element and the specified supplier, owned by this named element's nearest package.
        /// </summary>
        /// <param name="supplier">The supplier for the new dependency.</param>
        public IDependency CreateDependency(INamedElement supplier)
        {
            System.Func<INamedElement, INamedElement, IDependency> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, INamedElement, IDependency>>(_createDependencyOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createDependency registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createDependencyOperation.Value, supplier);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createDependencyOperation.Value, e));
            IDependency result = handler.Invoke(this, supplier);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createDependencyOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateDependencyOperation()
        {
            return ClassInstance.LookupOperation("createDependency");
        }
        
        /// <summary>
        /// Creates a usage between this named element and the specified supplier, owned by this named element's nearest package.
        /// </summary>
        /// <param name="supplier">The supplier for the new usage.</param>
        public IUsage CreateUsage(INamedElement supplier)
        {
            System.Func<INamedElement, INamedElement, IUsage> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, INamedElement, IUsage>>(_createUsageOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createUsage registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createUsageOperation.Value, supplier);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createUsageOperation.Value, e));
            IUsage result = handler.Invoke(this, supplier);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createUsageOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateUsageOperation()
        {
            return ClassInstance.LookupOperation("createUsage");
        }
        
        /// <summary>
        /// Retrieves a localized label for this named element.
        /// </summary>
        public string GetLabel()
        {
            System.Func<INamedElement, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, string>>(_getLabelOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getLabel registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getLabelOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getLabelOperation.Value, e));
            string result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getLabelOperation.Value, e));
            return result;
        }
        
        /// <summary>
        /// Retrieves a label for this named element, localized if indicated.
        /// </summary>
        /// <param name="localize">Whether to localize the label.</param>
        public string GetLabel(bool localize)
        {
            System.Func<INamedElement, bool, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, bool, string>>(_getLabelOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getLabel registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getLabelOperation.Value, localize);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getLabelOperation.Value, e));
            string result = handler.Invoke(this, localize);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getLabelOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetLabelOperation()
        {
            return ClassInstance.LookupOperation("getLabel");
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetLabelOperation_()
        {
            return ClassInstance.LookupOperation("getLabel");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public NMF.Interop.Uml.INamespace GetNamespace()
        {
            System.Func<INamedElement, NMF.Interop.Uml.INamespace> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, NMF.Interop.Uml.INamespace>>(_getNamespaceOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNamespace registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNamespaceOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNamespaceOperation.Value, e));
            NMF.Interop.Uml.INamespace result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNamespaceOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNamespaceOperation()
        {
            return ClassInstance.LookupOperation("getNamespace");
        }
        
        /// <summary>
        /// The query allNamespaces() gives the sequence of Namespaces in which the NamedElement is nested, working outwards.
        ///result = (
        ///if owner = null
        ///  then OrderedSet{}
        ///else
        ///  let enclosingNamespace : Namespace =
        ///    if owner.oclIsKindOf(TemplateParameter) and owner.oclAsType(TemplateParameter).signature.template.oclIsKindOf(Namespace)
        ///      then owner.oclAsType(TemplateParameter).signature.template.oclAsType(Namespace)
        ///    else
        ///      namespace
        ///    endif
        ///  in enclosingNamespace.allNamespaces()->prepend(enclosingNamespace)
        ///endif)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public IOrderedSetExpression<NMF.Interop.Uml.INamespace> AllNamespaces()
        {
            System.Func<INamedElement, IOrderedSetExpression<NMF.Interop.Uml.INamespace>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, IOrderedSetExpression<NMF.Interop.Uml.INamespace>>>(_allNamespacesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allNamespaces registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allNamespacesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allNamespacesOperation.Value, e));
            IOrderedSetExpression<NMF.Interop.Uml.INamespace> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allNamespacesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllNamespacesOperation()
        {
            return ClassInstance.LookupOperation("allNamespaces");
        }
        
        /// <summary>
        /// The query allOwningPackages() returns the set of all the enclosing Namespaces of this NamedElement, working outwards, that are Packages, up to but not including the first such Namespace that is not a Package.
        ///result = (if namespace.oclIsKindOf(Package)
        ///then
        ///  let owningPackage : Package = namespace.oclAsType(Package) in
        ///    owningPackage->union(owningPackage.allOwningPackages())
        ///else
        ///  null
        ///endif)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public ISetExpression<IPackage> AllOwningPackages()
        {
            System.Func<INamedElement, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, ISetExpression<IPackage>>>(_allOwningPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allOwningPackages registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allOwningPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allOwningPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allOwningPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllOwningPackagesOperation()
        {
            return ClassInstance.LookupOperation("allOwningPackages");
        }
        
        /// <summary>
        /// The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a Namespace. By default, two named elements are distinguishable if (a) they have types neither of which is a kind of the other or (b) they have different names.
        ///result = ((self.oclIsKindOf(n.oclType()) or n.oclIsKindOf(self.oclType())) implies
        ///    ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()
        ///)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        /// <param name="n"></param>
        /// <param name="ns"></param>
        public bool IsDistinguishableFrom(INamedElement n, NMF.Interop.Uml.INamespace ns)
        {
            System.Func<INamedElement, INamedElement, NMF.Interop.Uml.INamespace, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, INamedElement, NMF.Interop.Uml.INamespace, bool>>(_isDistinguishableFromOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isDistinguishableFrom registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isDistinguishableFromOperation.Value, n, ns);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isDistinguishableFromOperation.Value, e));
            bool result = handler.Invoke(this, n, ns);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isDistinguishableFromOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsDistinguishableFromOperation()
        {
            return ClassInstance.LookupOperation("isDistinguishableFrom");
        }
        
        /// <summary>
        /// When a NamedElement has a name, and all of its containing Namespaces have a name, the qualifiedName is constructed from the name of the NamedElement and the names of the containing Namespaces.
        ///result = (if self.name <> null and self.allNamespaces()->select( ns | ns.name=null )->isEmpty()
        ///then 
        ///    self.allNamespaces()->iterate( ns : Namespace; agg: String = self.name | ns.name.concat(self.separator()).concat(agg))
        ///else
        ///   null
        ///endif)
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public string GetQualifiedName()
        {
            System.Func<INamedElement, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, string>>(_getQualifiedNameOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getQualifiedName registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getQualifiedNameOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getQualifiedNameOperation.Value, e));
            string result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getQualifiedNameOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetQualifiedNameOperation()
        {
            return ClassInstance.LookupOperation("getQualifiedName");
        }
        
        /// <summary>
        /// The query separator() gives the string that is used to separate names when constructing a qualifiedName.
        ///result = ('::')
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public string Separator()
        {
            System.Func<INamedElement, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, string>>(_separatorOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method separator registered. Use the method broker" +
                        " to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _separatorOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _separatorOperation.Value, e));
            string result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _separatorOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSeparatorOperation()
        {
            return ClassInstance.LookupOperation("separator");
        }
        
        /// <summary>
        /// result = (Dependency.allInstances()->select(d | d.client->includes(self)))
        ///<p>From package UML::CommonStructure.</p>
        /// </summary>
        public ISetExpression<IDependency> GetClientDependencies()
        {
            System.Func<INamedElement, ISetExpression<IDependency>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<INamedElement, ISetExpression<IDependency>>>(_getClientDependenciesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getClientDependencies registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getClientDependenciesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getClientDependenciesOperation.Value, e));
            ISetExpression<IDependency> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getClientDependenciesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetClientDependenciesOperation()
        {
            return ClassInstance.LookupOperation("getClientDependencies");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveNameAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.NamedElement.ClassInstance)).Resolve("name")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveVisibilityAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.NamedElement.ClassInstance)).Resolve("visibility")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveNameExpressionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.NamedElement.ClassInstance)).Resolve("nameExpression")));
        }
        
        /// <summary>
        /// Handles the event that the NameExpression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetNameExpression(object sender, System.EventArgs eventArgs)
        {
            this.NameExpression = null;
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.NameExpression))
            {
                return ModelHelper.CreatePath("nameExpression");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "NAMEEXPRESSION"))
            {
                return this.NameExpression;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            if ((attribute == "VISIBILITY"))
            {
                return this.Visibility;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NAMEEXPRESSION"))
            {
                this.NameExpression = ((IStringExpression)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            if ((feature == "VISIBILITY"))
            {
                this.Visibility = ((VisibilityKind)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            if ((attribute == "VISIBILITY"))
            {
                return Observable.Box(new VisibilityProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "NAMEEXPRESSION"))
            {
                return new NameExpressionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//NamedElement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the NamedElement class
        /// </summary>
        public class NamedElementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private NamedElement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public NamedElementChildrenCollection(NamedElement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.NameExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.NameExpression == null))
                {
                    IStringExpression nameExpressionCasted = item.As<IStringExpression>();
                    if ((nameExpressionCasted != null))
                    {
                        this._parent.NameExpression = nameExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.NameExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.NameExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.NameExpression != null))
                {
                    array[arrayIndex] = this._parent.NameExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.NameExpression == item))
                {
                    this._parent.NameExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.NameExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the NamedElement class
        /// </summary>
        public class NamedElementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private NamedElement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public NamedElementReferencedElementsCollection(NamedElement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.NameExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.NameExpression == null))
                {
                    IStringExpression nameExpressionCasted = item.As<IStringExpression>();
                    if ((nameExpressionCasted != null))
                    {
                        this._parent.NameExpression = nameExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.NameExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.NameExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.NameExpression != null))
                {
                    array[arrayIndex] = this._parent.NameExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.NameExpression == item))
                {
                    this._parent.NameExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.NameExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<INamedElement, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(INamedElement modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the visibility property
        /// </summary>
        private sealed class VisibilityProxy : ModelPropertyChange<INamedElement, Nullable<VisibilityKind>>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public VisibilityProxy(INamedElement modelElement) : 
                    base(modelElement, "visibility")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override Nullable<VisibilityKind> Value
            {
                get
                {
                    return this.ModelElement.Visibility;
                }
                set
                {
                    this.ModelElement.Visibility = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the nameExpression property
        /// </summary>
        private sealed class NameExpressionProxy : ModelPropertyChange<INamedElement, IStringExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameExpressionProxy(INamedElement modelElement) : 
                    base(modelElement, "nameExpression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IStringExpression Value
            {
                get
                {
                    return this.ModelElement.NameExpression;
                }
                set
                {
                    this.ModelElement.NameExpression = value;
                }
            }
        }
    }
}

