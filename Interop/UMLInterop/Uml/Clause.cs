//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Clause is an Element that represents a single branch of a ConditionalNode, including a test and a body section. The body section is executed only if (but not necessarily if) the test section evaluates to true.
    ///<p>From package UML::Actions.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Clause")]
    public partial class Clause : Element, IClause, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _body_output_pinsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBody_output_pinsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _decider_outputOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDecider_outputOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _test_and_bodyOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveTest_and_bodyOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _bodyReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBodyReference);
        
        /// <summary>
        /// The backing field for the Body property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IExecutableNode> _body;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _bodyOutputReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBodyOutputReference);
        
        /// <summary>
        /// The backing field for the BodyOutput property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationOrderedSet<IOutputPin> _bodyOutput;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _deciderReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDeciderReference);
        
        /// <summary>
        /// The backing field for the Decider property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IOutputPin _decider;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _predecessorClauseReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePredecessorClauseReference);
        
        /// <summary>
        /// The backing field for the PredecessorClause property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClausePredecessorClauseCollection _predecessorClause;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _successorClauseReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSuccessorClauseReference);
        
        /// <summary>
        /// The backing field for the SuccessorClause property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ClauseSuccessorClauseCollection _successorClause;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _testReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTestReference);
        
        /// <summary>
        /// The backing field for the Test property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IExecutableNode> _test;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Clause()
        {
            this._body = new ObservableAssociationSet<IExecutableNode>();
            this._body.CollectionChanging += this.BodyCollectionChanging;
            this._body.CollectionChanged += this.BodyCollectionChanged;
            this._bodyOutput = new ObservableAssociationOrderedSet<IOutputPin>();
            this._bodyOutput.CollectionChanging += this.BodyOutputCollectionChanging;
            this._bodyOutput.CollectionChanged += this.BodyOutputCollectionChanged;
            this._predecessorClause = new ClausePredecessorClauseCollection(this);
            this._predecessorClause.CollectionChanging += this.PredecessorClauseCollectionChanging;
            this._predecessorClause.CollectionChanged += this.PredecessorClauseCollectionChanged;
            this._successorClause = new ClauseSuccessorClauseCollection(this);
            this._successorClause.CollectionChanging += this.SuccessorClauseCollectionChanging;
            this._successorClause.CollectionChanged += this.SuccessorClauseCollectionChanged;
            this._test = new ObservableAssociationSet<IExecutableNode>();
            this._test.CollectionChanging += this.TestCollectionChanging;
            this._test.CollectionChanged += this.TestCollectionChanged;
        }
        
        /// <summary>
        /// The set of ExecutableNodes that are executed if the test evaluates to true and the Clause is chosen over other Clauses within the ConditionalNode that also have tests that evaluate to true.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("body")]
        [DescriptionAttribute("The set of ExecutableNodes that are executed if the test evaluates to true and th" +
            "e Clause is chosen over other Clauses within the ConditionalNode that also have " +
            "tests that evaluate to true.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("Clause")]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IExecutableNode> Body
        {
            get
            {
                return this._body;
            }
        }
        
        /// <summary>
        /// The OutputPins on Actions within the body section whose values are moved to the result OutputPins of the containing ConditionalNode after execution of the body.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("bodyOutput")]
        [DescriptionAttribute("The OutputPins on Actions within the body section whose values are moved to the r" +
            "esult OutputPins of the containing ConditionalNode after execution of the body.\n" +
            "<p>From package UML::Actions.</p>")]
        [CategoryAttribute("Clause")]
        [XmlElementNameAttribute("bodyOutput")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public IOrderedSetExpression<IOutputPin> BodyOutput
        {
            get
            {
                return this._bodyOutput;
            }
        }
        
        /// <summary>
        /// An OutputPin on an Action in the test section whose Boolean value determines the result of the test.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DisplayNameAttribute("decider")]
        [DescriptionAttribute("An OutputPin on an Action in the test section whose Boolean value determines the " +
            "result of the test.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("Clause")]
        [XmlElementNameAttribute("decider")]
        [XmlAttributeAttribute(true)]
        public IOutputPin Decider
        {
            get
            {
                return this._decider;
            }
            set
            {
                if ((this._decider != value))
                {
                    IOutputPin old = this._decider;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Decider", e, _deciderReference);
                    this._decider = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetDecider;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetDecider;
                    }
                    this.OnPropertyChanged("Decider", e, _deciderReference);
                }
            }
        }
        
        /// <summary>
        /// A set of Clauses whose tests must all evaluate to false before this Clause can evaluate its test.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("predecessorClause")]
        [DescriptionAttribute("A set of Clauses whose tests must all evaluate to false before this Clause can ev" +
            "aluate its test.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("Clause")]
        [XmlElementNameAttribute("predecessorClause")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("successorClause")]
        [ConstantAttribute()]
        public ISetExpression<IClause> PredecessorClause
        {
            get
            {
                return this._predecessorClause;
            }
        }
        
        /// <summary>
        /// A set of Clauses that may not evaluate their tests unless the test for this Clause evaluates to false.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("successorClause")]
        [DescriptionAttribute("A set of Clauses that may not evaluate their tests unless the test for this Claus" +
            "e evaluates to false.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("Clause")]
        [XmlElementNameAttribute("successorClause")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("predecessorClause")]
        [ConstantAttribute()]
        public ISetExpression<IClause> SuccessorClause
        {
            get
            {
                return this._successorClause;
            }
        }
        
        /// <summary>
        /// The set of ExecutableNodes that are executed in order to provide a test result for the Clause.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("test")]
        [DescriptionAttribute("The set of ExecutableNodes that are executed in order to provide a test result fo" +
            "r the Clause.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("Clause")]
        [XmlElementNameAttribute("test")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IExecutableNode> Test
        {
            get
            {
                return this._test;
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ClauseReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Clause")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// The bodyOutput Pins are OutputPins on Actions in the body of the Clause.
        ///_'body'.oclAsType(Action).allActions().output->includesAll(bodyOutput)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Body_output_pins(object diagnostics, object context)
        {
            System.Func<IClause, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClause, object, object, bool>>(_body_output_pinsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method body_output_pins registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _body_output_pinsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _body_output_pinsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _body_output_pinsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBody_output_pinsOperation()
        {
            return ClassInstance.LookupOperation("body_output_pins");
        }
        
        /// <summary>
        /// The decider Pin must be on an Action in the test section of the Clause and must be of type Boolean with multiplicity 1..1.
        ///test.oclAsType(Action).allActions().output->includes(decider) and
        ///decider.type = Boolean and
        ///decider.is(1,1)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Decider_output(object diagnostics, object context)
        {
            System.Func<IClause, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClause, object, object, bool>>(_decider_outputOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method decider_output registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _decider_outputOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _decider_outputOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _decider_outputOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDecider_outputOperation()
        {
            return ClassInstance.LookupOperation("decider_output");
        }
        
        /// <summary>
        /// The test and body parts of a ConditionalNode must be disjoint with each other.
        ///test->intersection(_'body')->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Test_and_body(object diagnostics, object context)
        {
            System.Func<IClause, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IClause, object, object, bool>>(_test_and_bodyOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method test_and_body registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _test_and_bodyOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _test_and_bodyOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _test_and_bodyOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveTest_and_bodyOperation()
        {
            return ClassInstance.LookupOperation("test_and_body");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBodyReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Clause.ClassInstance)).Resolve("body")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Body property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Body", e, _bodyReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Body property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Body", e, _bodyReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBodyOutputReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Clause.ClassInstance)).Resolve("bodyOutput")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the BodyOutput property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyOutputCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("BodyOutput", e, _bodyOutputReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the BodyOutput property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyOutputCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("BodyOutput", e, _bodyOutputReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDeciderReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Clause.ClassInstance)).Resolve("decider")));
        }
        
        /// <summary>
        /// Handles the event that the Decider property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDecider(object sender, System.EventArgs eventArgs)
        {
            this.Decider = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePredecessorClauseReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Clause.ClassInstance)).Resolve("predecessorClause")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PredecessorClause property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PredecessorClauseCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PredecessorClause", e, _predecessorClauseReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PredecessorClause property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PredecessorClauseCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PredecessorClause", e, _predecessorClauseReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSuccessorClauseReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Clause.ClassInstance)).Resolve("successorClause")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the SuccessorClause property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SuccessorClauseCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("SuccessorClause", e, _successorClauseReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the SuccessorClause property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SuccessorClauseCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("SuccessorClause", e, _successorClauseReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTestReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Clause.ClassInstance)).Resolve("test")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Test property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TestCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Test", e, _testReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Test property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TestCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Test", e, _testReference);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BODYOUTPUT"))
            {
                if ((index < this.BodyOutput.Count))
                {
                    return this.BodyOutput[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "DECIDER"))
            {
                return this.Decider;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "BODY"))
            {
                return this._body;
            }
            if ((feature == "BODYOUTPUT"))
            {
                return this._bodyOutput;
            }
            if ((feature == "PREDECESSORCLAUSE"))
            {
                return this._predecessorClause;
            }
            if ((feature == "SUCCESSORCLAUSE"))
            {
                return this._successorClause;
            }
            if ((feature == "TEST"))
            {
                return this._test;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "DECIDER"))
            {
                this.Decider = ((IOutputPin)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "DECIDER"))
            {
                return new DeciderProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Clause")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Clause class
        /// </summary>
        public class ClauseReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Clause _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ClauseReferencedElementsCollection(Clause parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Body.Count);
                    count = (count + this._parent.BodyOutput.Count);
                    if ((this._parent.Decider != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.PredecessorClause.Count);
                    count = (count + this._parent.SuccessorClause.Count);
                    count = (count + this._parent.Test.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Body.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BodyOutput.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.PredecessorClause.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.SuccessorClause.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Test.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Body.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BodyOutput.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.PredecessorClause.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.SuccessorClause.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Test.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExecutableNode bodyCasted = item.As<IExecutableNode>();
                if ((bodyCasted != null))
                {
                    this._parent.Body.Add(bodyCasted);
                }
                IOutputPin bodyOutputCasted = item.As<IOutputPin>();
                if ((bodyOutputCasted != null))
                {
                    this._parent.BodyOutput.Add(bodyOutputCasted);
                }
                if ((this._parent.Decider == null))
                {
                    IOutputPin deciderCasted = item.As<IOutputPin>();
                    if ((deciderCasted != null))
                    {
                        this._parent.Decider = deciderCasted;
                        return;
                    }
                }
                IClause predecessorClauseCasted = item.As<IClause>();
                if ((predecessorClauseCasted != null))
                {
                    this._parent.PredecessorClause.Add(predecessorClauseCasted);
                }
                IClause successorClauseCasted = item.As<IClause>();
                if ((successorClauseCasted != null))
                {
                    this._parent.SuccessorClause.Add(successorClauseCasted);
                }
                IExecutableNode testCasted = item.As<IExecutableNode>();
                if ((testCasted != null))
                {
                    this._parent.Test.Add(testCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Body.Clear();
                this._parent.BodyOutput.Clear();
                this._parent.Decider = null;
                this._parent.PredecessorClause.Clear();
                this._parent.SuccessorClause.Clear();
                this._parent.Test.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Body.Contains(item))
                {
                    return true;
                }
                if (this._parent.BodyOutput.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Decider))
                {
                    return true;
                }
                if (this._parent.PredecessorClause.Contains(item))
                {
                    return true;
                }
                if (this._parent.SuccessorClause.Contains(item))
                {
                    return true;
                }
                if (this._parent.Test.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> bodyEnumerator = this._parent.Body.GetEnumerator();
                try
                {
                    for (
                    ; bodyEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = bodyEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    bodyEnumerator.Dispose();
                }
                IEnumerator<IModelElement> bodyOutputEnumerator = this._parent.BodyOutput.GetEnumerator();
                try
                {
                    for (
                    ; bodyOutputEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = bodyOutputEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    bodyOutputEnumerator.Dispose();
                }
                if ((this._parent.Decider != null))
                {
                    array[arrayIndex] = this._parent.Decider;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> predecessorClauseEnumerator = this._parent.PredecessorClause.GetEnumerator();
                try
                {
                    for (
                    ; predecessorClauseEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = predecessorClauseEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    predecessorClauseEnumerator.Dispose();
                }
                IEnumerator<IModelElement> successorClauseEnumerator = this._parent.SuccessorClause.GetEnumerator();
                try
                {
                    for (
                    ; successorClauseEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = successorClauseEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    successorClauseEnumerator.Dispose();
                }
                IEnumerator<IModelElement> testEnumerator = this._parent.Test.GetEnumerator();
                try
                {
                    for (
                    ; testEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = testEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    testEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExecutableNode executableNodeItem = item.As<IExecutableNode>();
                if (((executableNodeItem != null) 
                            && this._parent.Body.Remove(executableNodeItem)))
                {
                    return true;
                }
                IOutputPin outputPinItem = item.As<IOutputPin>();
                if (((outputPinItem != null) 
                            && this._parent.BodyOutput.Remove(outputPinItem)))
                {
                    return true;
                }
                if ((this._parent.Decider == item))
                {
                    this._parent.Decider = null;
                    return true;
                }
                IClause clauseItem = item.As<IClause>();
                if (((clauseItem != null) 
                            && this._parent.PredecessorClause.Remove(clauseItem)))
                {
                    return true;
                }
                if (((clauseItem != null) 
                            && this._parent.SuccessorClause.Remove(clauseItem)))
                {
                    return true;
                }
                if (((executableNodeItem != null) 
                            && this._parent.Test.Remove(executableNodeItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Body).Concat(this._parent.BodyOutput).Concat(this._parent.Decider).Concat(this._parent.PredecessorClause).Concat(this._parent.SuccessorClause).Concat(this._parent.Test).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the decider property
        /// </summary>
        private sealed class DeciderProxy : ModelPropertyChange<IClause, IOutputPin>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DeciderProxy(IClause modelElement) : 
                    base(modelElement, "decider")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IOutputPin Value
            {
                get
                {
                    return this.ModelElement.Decider;
                }
                set
                {
                    this.ModelElement.Decider = value;
                }
            }
        }
    }
}

