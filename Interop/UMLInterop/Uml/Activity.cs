//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// An Activity is the specification of parameterized Behavior as the coordinated sequencing of subordinate units.
    ///&lt;p&gt;From package UML::Activities.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Activity")]
    [DebuggerDisplayAttribute("Activity {Name}")]
    public partial class Activity : Behavior, IActivity, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _maximum_one_parameter_nodeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMaximum_one_parameter_nodeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _maximum_two_parameter_nodesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMaximum_two_parameter_nodesOperation);
        
        /// <summary>
        /// The backing field for the IsReadOnly property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isReadOnly = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isReadOnlyAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsReadOnlyAttribute);
        
        /// <summary>
        /// The backing field for the IsSingleExecution property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isSingleExecution = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isSingleExecutionAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsSingleExecutionAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _edgeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveEdgeReference);
        
        /// <summary>
        /// The backing field for the Edge property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ActivityEdgeCollection _edge;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _variableReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveVariableReference);
        
        /// <summary>
        /// The backing field for the Variable property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ActivityVariableCollection _variable;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _ownedNodeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwnedNodeReference);
        
        /// <summary>
        /// The backing field for the OwnedNode property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IActivityNode> _ownedNode;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _partitionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePartitionReference);
        
        /// <summary>
        /// The backing field for the Partition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IActivityPartition> _partition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _structuredNodeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveStructuredNodeReference);
        
        /// <summary>
        /// The backing field for the StructuredNode property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IStructuredActivityNode> _structuredNode;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Activity()
        {
            this._edge = new ActivityEdgeCollection(this);
            this._edge.CollectionChanging += this.EdgeCollectionChanging;
            this._edge.CollectionChanged += this.EdgeCollectionChanged;
            this._variable = new ActivityVariableCollection(this);
            this._variable.CollectionChanging += this.VariableCollectionChanging;
            this._variable.CollectionChanged += this.VariableCollectionChanged;
            this._ownedNode = new ObservableCompositionOrderedSet<IActivityNode>(this);
            this._ownedNode.CollectionChanging += this.OwnedNodeCollectionChanging;
            this._ownedNode.CollectionChanged += this.OwnedNodeCollectionChanged;
            this._partition = new ObservableCompositionOrderedSet<IActivityPartition>(this);
            this._partition.CollectionChanging += this.PartitionCollectionChanging;
            this._partition.CollectionChanged += this.PartitionCollectionChanged;
            this._structuredNode = new ObservableCompositionOrderedSet<IStructuredActivityNode>(this);
            this._structuredNode.CollectionChanging += this.StructuredNodeCollectionChanging;
            this._structuredNode.CollectionChanged += this.StructuredNodeCollectionChanged;
        }
        
        /// <summary>
        /// If true, this Activity must not make any changes to objects. The default is false (an Activity may make nonlocal changes). (This is an assertion, not an executable property. It may be used by an execution engine to optimize model execution. If the assertion is violated by the Activity, then the model is ill-formed.)
        ///&lt;p&gt;From package UML::Activities.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isReadOnly")]
        [DescriptionAttribute(@"If true, this Activity must not make any changes to objects. The default is false (an Activity may make nonlocal changes). (This is an assertion, not an executable property. It may be used by an execution engine to optimize model execution. If the assertion is violated by the Activity, then the model is ill-formed.)
<p>From package UML::Activities.</p>")]
        [CategoryAttribute("Activity")]
        [XmlElementNameAttribute("isReadOnly")]
        [XmlAttributeAttribute(true)]
        public bool IsReadOnly
        {
            get
            {
                return this._isReadOnly;
            }
            set
            {
                if ((this._isReadOnly != value))
                {
                    bool old = this._isReadOnly;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsReadOnly", e, _isReadOnlyAttribute);
                    this._isReadOnly = value;
                    this.OnPropertyChanged("IsReadOnly", e, _isReadOnlyAttribute);
                }
            }
        }
        
        /// <summary>
        /// If true, all invocations of the Activity are handled by the same execution.
        ///&lt;p&gt;From package UML::Activities.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isSingleExecution")]
        [DescriptionAttribute("If true, all invocations of the Activity are handled by the same execution.\n<p>Fr" +
            "om package UML::Activities.</p>")]
        [CategoryAttribute("Activity")]
        [XmlElementNameAttribute("isSingleExecution")]
        [XmlAttributeAttribute(true)]
        public bool IsSingleExecution
        {
            get
            {
                return this._isSingleExecution;
            }
            set
            {
                if ((this._isSingleExecution != value))
                {
                    bool old = this._isSingleExecution;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsSingleExecution", e, _isSingleExecutionAttribute);
                    this._isSingleExecution = value;
                    this.OnPropertyChanged("IsSingleExecution", e, _isSingleExecutionAttribute);
                }
            }
        }
        
        /// <summary>
        /// ActivityEdges expressing flow between the nodes of the Activity.
        ///&lt;p&gt;From package UML::Activities.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("edge")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("activity")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IActivityEdge> Edge
        {
            get
            {
                return this._edge;
            }
        }
        
        /// <summary>
        /// Top-level Variables defined by the Activity.
        ///&lt;p&gt;From package UML::Activities.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("variable")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("activityScope")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IVariable> Variable
        {
            get
            {
                return this._variable;
            }
        }
        
        /// <summary>
        /// The ownedNode property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("node")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IActivityNode> OwnedNode
        {
            get
            {
                return this._ownedNode;
            }
        }
        
        /// <summary>
        /// Top-level ActivityPartitions in the Activity.
        ///&lt;p&gt;From package UML::Activities.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("partition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IActivityPartition> Partition
        {
            get
            {
                return this._partition;
            }
        }
        
        /// <summary>
        /// Top-level StructuredActivityNodes in the Activity.
        ///&lt;p&gt;From package UML::Activities.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("structuredNode")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IStructuredActivityNode> StructuredNode
        {
            get
            {
                return this._structuredNode;
            }
        }
        
        IListExpression<IActivityGroup> IActivity.OwnedGroup
        {
            get
            {
                return new ActivityOwnedGroupCollection(this);
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ActivityChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ActivityReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Activity")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// A Parameter with direction other than inout must have exactly one ActivityParameterNode in an Activity.
        ///ownedParameter-&gt;forAll(p | 
        ///   p.direction &lt;&gt; ParameterDirectionKind::inout implies node-&gt;select(
        ///       oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p)-&gt;size()= 1)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Maximum_one_parameter_node(object diagnostics, object context)
        {
            System.Func<IActivity, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IActivity, object, object, bool>>(_maximum_one_parameter_nodeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method maximum_one_parameter_node registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _maximum_one_parameter_nodeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _maximum_one_parameter_nodeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _maximum_one_parameter_nodeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMaximum_one_parameter_nodeOperation()
        {
            return ClassInstance.LookupOperation("maximum_one_parameter_node");
        }
        
        /// <summary>
        /// A Parameter with direction inout must have exactly two ActivityParameterNodes in an Activity, at most one with incoming ActivityEdges and at most one with outgoing ActivityEdges.
        ///ownedParameter-&gt;forAll(p | 
        ///p.direction = ParameterDirectionKind::inout implies
        ///let associatedNodes : Set(ActivityNode) = node-&gt;select(
        ///       oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p) in 
        ///  associatedNodes-&gt;size()=2 and
        ///  associatedNodes-&gt;select(incoming-&gt;notEmpty())-&gt;size()&lt;=1 and
        ///  associatedNodes-&gt;select(outgoing-&gt;notEmpty())-&gt;size()&lt;=1
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Maximum_two_parameter_nodes(object diagnostics, object context)
        {
            System.Func<IActivity, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IActivity, object, object, bool>>(_maximum_two_parameter_nodesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method maximum_two_parameter_nodes registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _maximum_two_parameter_nodesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _maximum_two_parameter_nodesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _maximum_two_parameter_nodesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMaximum_two_parameter_nodesOperation()
        {
            return ClassInstance.LookupOperation("maximum_two_parameter_nodes");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsReadOnlyAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Activity.ClassInstance)).Resolve("isReadOnly")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsSingleExecutionAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Activity.ClassInstance)).Resolve("isSingleExecution")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveEdgeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Activity.ClassInstance)).Resolve("edge")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Edge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void EdgeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Edge", e, _edgeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Edge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void EdgeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Edge", e, _edgeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveVariableReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Activity.ClassInstance)).Resolve("variable")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Variable property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void VariableCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Variable", e, _variableReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Variable property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void VariableCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Variable", e, _variableReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwnedNodeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Activity.ClassInstance)).Resolve("ownedNode")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the OwnedNode property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedNodeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("OwnedNode", e, _ownedNodeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the OwnedNode property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void OwnedNodeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("OwnedNode", e, _ownedNodeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePartitionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Activity.ClassInstance)).Resolve("partition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Partition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PartitionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Partition", e, _partitionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Partition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PartitionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Partition", e, _partitionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveStructuredNodeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Activity.ClassInstance)).Resolve("structuredNode")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the StructuredNode property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void StructuredNodeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("StructuredNode", e, _structuredNodeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the StructuredNode property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void StructuredNodeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("StructuredNode", e, _structuredNodeReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int edgeIndex = ModelHelper.IndexOfReference(this.Edge, element);
            if ((edgeIndex != -1))
            {
                return ModelHelper.CreatePath("edge", edgeIndex);
            }
            int variableIndex = ModelHelper.IndexOfReference(this.Variable, element);
            if ((variableIndex != -1))
            {
                return ModelHelper.CreatePath("variable", variableIndex);
            }
            int ownedNodeIndex = ModelHelper.IndexOfReference(this.OwnedNode, element);
            if ((ownedNodeIndex != -1))
            {
                return ModelHelper.CreatePath("ownedNode", ownedNodeIndex);
            }
            int partitionIndex = ModelHelper.IndexOfReference(this.Partition, element);
            if ((partitionIndex != -1))
            {
                return ModelHelper.CreatePath("partition", partitionIndex);
            }
            int structuredNodeIndex = ModelHelper.IndexOfReference(this.StructuredNode, element);
            if ((structuredNodeIndex != -1))
            {
                return ModelHelper.CreatePath("structuredNode", structuredNodeIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "EDGE"))
            {
                if ((index < this.Edge.Count))
                {
                    return this.Edge[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "VARIABLE"))
            {
                if ((index < this.Variable.Count))
                {
                    return this.Variable[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "OWNEDNODE"))
            {
                if ((index < this.OwnedNode.Count))
                {
                    return this.OwnedNode[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PARTITION"))
            {
                if ((index < this.Partition.Count))
                {
                    return this.Partition[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "STRUCTUREDNODE"))
            {
                if ((index < this.StructuredNode.Count))
                {
                    return this.StructuredNode[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISREADONLY"))
            {
                return this.IsReadOnly;
            }
            if ((attribute == "ISSINGLEEXECUTION"))
            {
                return this.IsSingleExecution;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "EDGE"))
            {
                return this._edge;
            }
            if ((feature == "VARIABLE"))
            {
                return this._variable;
            }
            if ((feature == "OWNEDNODE"))
            {
                return this._ownedNode;
            }
            if ((feature == "PARTITION"))
            {
                return this._partition;
            }
            if ((feature == "STRUCTUREDNODE"))
            {
                return this._structuredNode;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "ISREADONLY"))
            {
                this.IsReadOnly = ((bool)(value));
                return;
            }
            if ((feature == "ISSINGLEEXECUTION"))
            {
                this.IsSingleExecution = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISREADONLY"))
            {
                return Observable.Box(new IsReadOnlyProxy(this));
            }
            if ((attribute == "ISSINGLEEXECUTION"))
            {
                return Observable.Box(new IsSingleExecutionProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._edge))
            {
                return "edge";
            }
            if ((container == this._variable))
            {
                return "variable";
            }
            if ((container == this._ownedNode))
            {
                return "ownedNode";
            }
            if ((container == this._partition))
            {
                return "partition";
            }
            if ((container == this._structuredNode))
            {
                return "structuredNode";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Activity")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Activity class
        /// </summary>
        public class ActivityChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Activity _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ActivityChildrenCollection(Activity parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Activity class
        /// </summary>
        public class ActivityReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Activity _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ActivityReferencedElementsCollection(Activity parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isReadOnly property
        /// </summary>
        private sealed class IsReadOnlyProxy : ModelPropertyChange<IActivity, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsReadOnlyProxy(IActivity modelElement) : 
                    base(modelElement, "isReadOnly")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsReadOnly;
                }
                set
                {
                    this.ModelElement.IsReadOnly = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isSingleExecution property
        /// </summary>
        private sealed class IsSingleExecutionProxy : ModelPropertyChange<IActivity, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsSingleExecutionProxy(IActivity modelElement) : 
                    base(modelElement, "isSingleExecution")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsSingleExecution;
                }
                set
                {
                    this.ModelElement.IsSingleExecution = value;
                }
            }
        }
    }
}
