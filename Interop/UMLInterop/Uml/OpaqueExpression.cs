//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// An OpaqueExpression is a ValueSpecification that specifies the computation of a collection of values either in terms of a UML Behavior or based on a textual statement in a language other than UML
    ///<p>From package UML::Values.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//OpaqueExpression")]
    [DebuggerDisplayAttribute("OpaqueExpression {Name}")]
    public partial class OpaqueExpression : ValueSpecification, IOpaqueExpression, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _language_body_sizeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveLanguage_body_sizeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _one_return_result_parameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOne_return_result_parameterOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _only_return_result_parametersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOnly_return_result_parametersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isIntegralOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsIntegralOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isNonNegativeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsNonNegativeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isPositiveOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsPositiveOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getResultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetResultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _valueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveValueOperation);
        
        /// <summary>
        /// The backing field for the Body property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<string> _body;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _bodyAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBodyAttribute);
        
        /// <summary>
        /// The backing field for the Language property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableOrderedSet<string> _language;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _languageAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveLanguageAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _behaviorReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveBehaviorReference);
        
        /// <summary>
        /// The backing field for the Behavior property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _behavior;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public OpaqueExpression()
        {
            this._body = new ObservableList<string>();
            this._body.CollectionChanging += this.BodyCollectionChanging;
            this._body.CollectionChanged += this.BodyCollectionChanged;
            this._language = new ObservableOrderedSet<string>();
            this._language.CollectionChanging += this.LanguageCollectionChanging;
            this._language.CollectionChanged += this.LanguageCollectionChanged;
        }
        
        /// <summary>
        /// A textual definition of the behavior of the OpaqueExpression, possibly in multiple languages.
        ///<p>From package UML::Values.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("body")]
        [DescriptionAttribute("A textual definition of the behavior of the OpaqueExpression, possibly in multipl" +
            "e languages.\n<p>From package UML::Values.</p>")]
        [CategoryAttribute("OpaqueExpression")]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public IListExpression<string> Body
        {
            get
            {
                return this._body;
            }
        }
        
        /// <summary>
        /// Specifies the languages used to express the textual bodies of the OpaqueExpression.  Languages are matched to body Strings by order. The interpretation of the body depends on the languages. If the languages are unspecified, they may be implicit from the expression body or the context.
        ///<p>From package UML::Values.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("language")]
        [DescriptionAttribute(@"Specifies the languages used to express the textual bodies of the OpaqueExpression.  Languages are matched to body Strings by order. The interpretation of the body depends on the languages. If the languages are unspecified, they may be implicit from the expression body or the context.
<p>From package UML::Values.</p>")]
        [CategoryAttribute("OpaqueExpression")]
        [XmlElementNameAttribute("language")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public IOrderedSetExpression<string> Language
        {
            get
            {
                return this._language;
            }
        }
        
        /// <summary>
        /// Specifies the behavior of the OpaqueExpression as a UML Behavior.
        ///<p>From package UML::Values.</p>
        /// </summary>
        [DisplayNameAttribute("behavior")]
        [DescriptionAttribute("Specifies the behavior of the OpaqueExpression as a UML Behavior.\n<p>From package" +
            " UML::Values.</p>")]
        [CategoryAttribute("OpaqueExpression")]
        [XmlElementNameAttribute("behavior")]
        [XmlAttributeAttribute(true)]
        public IBehavior Behavior
        {
            get
            {
                return this._behavior;
            }
            set
            {
                if ((this._behavior != value))
                {
                    IBehavior old = this._behavior;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Behavior", e, _behaviorReference);
                    this._behavior = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetBehavior;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetBehavior;
                    }
                    this.OnPropertyChanged("Behavior", e, _behaviorReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new OpaqueExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//OpaqueExpression")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// If the language attribute is not empty, then the size of the body and language arrays must be the same.
        ///language->notEmpty() implies (_'body'->size() = language->size())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Language_body_size(object diagnostics, object context)
        {
            System.Func<IOpaqueExpression, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, object, object, bool>>(_language_body_sizeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method language_body_size registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _language_body_sizeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _language_body_sizeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _language_body_sizeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveLanguage_body_sizeOperation()
        {
            return ClassInstance.LookupOperation("language_body_size");
        }
        
        /// <summary>
        /// The behavior must have exactly one return result parameter.
        ///behavior <> null implies
        ///   behavior.ownedParameter->select(direction=ParameterDirectionKind::return)->size() = 1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool One_return_result_parameter(object diagnostics, object context)
        {
            System.Func<IOpaqueExpression, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, object, object, bool>>(_one_return_result_parameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method one_return_result_parameter registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _one_return_result_parameterOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _one_return_result_parameterOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _one_return_result_parameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOne_return_result_parameterOperation()
        {
            return ClassInstance.LookupOperation("one_return_result_parameter");
        }
        
        /// <summary>
        /// The behavior may only have return result parameters.
        ///behavior <> null implies behavior.ownedParameter->select(direction<>ParameterDirectionKind::return)->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Only_return_result_parameters(object diagnostics, object context)
        {
            System.Func<IOpaqueExpression, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, object, object, bool>>(_only_return_result_parametersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method only_return_result_parameters registered. U" +
                        "se the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _only_return_result_parametersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _only_return_result_parametersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _only_return_result_parametersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOnly_return_result_parametersOperation()
        {
            return ClassInstance.LookupOperation("only_return_result_parameters");
        }
        
        /// <summary>
        /// The query isIntegral() tells whether an expression is intended to produce an Integer.
        ///result = (false)
        ///<p>From package UML::Values.</p>
        /// </summary>
        public bool IsIntegral()
        {
            System.Func<IOpaqueExpression, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, bool>>(_isIntegralOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isIntegral registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isIntegralOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isIntegralOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isIntegralOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsIntegralOperation()
        {
            return ClassInstance.LookupOperation("isIntegral");
        }
        
        /// <summary>
        /// The query isNonNegative() tells whether an integer expression has a non-negative value.
        ///self.isIntegral()
        ///result = (false)
        ///<p>From package UML::Values.</p>
        /// </summary>
        public bool IsNonNegative()
        {
            System.Func<IOpaqueExpression, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, bool>>(_isNonNegativeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isNonNegative registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isNonNegativeOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isNonNegativeOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isNonNegativeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsNonNegativeOperation()
        {
            return ClassInstance.LookupOperation("isNonNegative");
        }
        
        /// <summary>
        /// The query isPositive() tells whether an integer expression has a positive value.
        ///self.isIntegral()
        ///result = (false)
        ///<p>From package UML::Values.</p>
        /// </summary>
        public bool IsPositive()
        {
            System.Func<IOpaqueExpression, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, bool>>(_isPositiveOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isPositive registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isPositiveOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isPositiveOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isPositiveOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsPositiveOperation()
        {
            return ClassInstance.LookupOperation("isPositive");
        }
        
        /// <summary>
        /// Derivation for OpaqueExpression::/result
        ///result = (if behavior = null then
        ///	null
        ///else
        ///	behavior.ownedParameter->first()
        ///endif)
        ///<p>From package UML::Values.</p>
        /// </summary>
        public NMF.Interop.Uml.IParameter GetResult()
        {
            System.Func<IOpaqueExpression, NMF.Interop.Uml.IParameter> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, NMF.Interop.Uml.IParameter>>(_getResultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getResult registered. Use the method broker" +
                        " to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getResultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getResultOperation.Value, e));
            NMF.Interop.Uml.IParameter result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getResultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetResultOperation()
        {
            return ClassInstance.LookupOperation("getResult");
        }
        
        /// <summary>
        /// The query value() gives an integer value for an expression intended to produce one.
        ///self.isIntegral()
        ///result = (0)
        ///<p>From package UML::Values.</p>
        /// </summary>
        public int Value()
        {
            System.Func<IOpaqueExpression, int> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IOpaqueExpression, int>>(_valueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method value registered. Use the method broker to " +
                        "register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _valueOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _valueOperation.Value, e));
            int result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _valueOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveValueOperation()
        {
            return ClassInstance.LookupOperation("value");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBodyAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.OpaqueExpression.ClassInstance)).Resolve("body")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Body property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Body", e, _bodyAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Body property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void BodyCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Body", e, _bodyAttribute);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveLanguageAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.OpaqueExpression.ClassInstance)).Resolve("language")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Language property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LanguageCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Language", e, _languageAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Language property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LanguageCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Language", e, _languageAttribute);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveBehaviorReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.OpaqueExpression.ClassInstance)).Resolve("behavior")));
        }
        
        /// <summary>
        /// Handles the event that the Behavior property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetBehavior(object sender, System.EventArgs eventArgs)
        {
            this.Behavior = null;
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BEHAVIOR"))
            {
                return this.Behavior;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "BODY"))
            {
                if ((index < this.Body.Count))
                {
                    return this.Body[index];
                }
                else
                {
                    return null;
                }
            }
            if ((attribute == "LANGUAGE"))
            {
                if ((index < this.Language.Count))
                {
                    return this.Language[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "BODY"))
            {
                return this._body;
            }
            if ((feature == "LANGUAGE"))
            {
                return this._language;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BEHAVIOR"))
            {
                this.Behavior = ((IBehavior)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "BEHAVIOR"))
            {
                return new BehaviorProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//OpaqueExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the OpaqueExpression class
        /// </summary>
        public class OpaqueExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private OpaqueExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public OpaqueExpressionReferencedElementsCollection(OpaqueExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Behavior != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Behavior == null))
                {
                    IBehavior behaviorCasted = item.As<IBehavior>();
                    if ((behaviorCasted != null))
                    {
                        this._parent.Behavior = behaviorCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Behavior = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Behavior))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Behavior != null))
                {
                    array[arrayIndex] = this._parent.Behavior;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Behavior == item))
                {
                    this._parent.Behavior = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Behavior).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the behavior property
        /// </summary>
        private sealed class BehaviorProxy : ModelPropertyChange<IOpaqueExpression, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BehaviorProxy(IOpaqueExpression modelElement) : 
                    base(modelElement, "behavior")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.Behavior;
                }
                set
                {
                    this.ModelElement.Behavior = value;
                }
            }
        }
    }
}

