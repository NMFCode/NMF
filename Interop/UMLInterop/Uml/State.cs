//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A State models a situation during which some (usually implicit) invariant condition holds.
    ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//State")]
    [DebuggerDisplayAttribute("State {Name}")]
    public partial class State : RedefinableElement, IState, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _entry_or_exitOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveEntry_or_exitOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _submachine_statesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubmachine_statesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _composite_statesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveComposite_statesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _destinations_or_sources_of_transitionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDestinations_or_sources_of_transitionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _submachine_or_regionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubmachine_or_regionsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _connectionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConnectionReference);
        
        /// <summary>
        /// The backing field for the Connection property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private StateConnectionCollection _connection;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _connectionPointReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConnectionPointReference);
        
        /// <summary>
        /// The backing field for the ConnectionPoint property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private StateConnectionPointCollection _connectionPoint;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _deferrableTriggerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDeferrableTriggerReference);
        
        /// <summary>
        /// The backing field for the DeferrableTrigger property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<ITrigger> _deferrableTrigger;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _doActivityReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDoActivityReference);
        
        /// <summary>
        /// The backing field for the DoActivity property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _doActivity;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _entryReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveEntryReference);
        
        /// <summary>
        /// The backing field for the Entry property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _entry;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _exitReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveExitReference);
        
        /// <summary>
        /// The backing field for the Exit property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _exit;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedStateReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedStateReference);
        
        /// <summary>
        /// The backing field for the RedefinedState property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IState _redefinedState;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _stateInvariantReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveStateInvariantReference);
        
        /// <summary>
        /// The backing field for the StateInvariant property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _stateInvariant;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _submachineReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSubmachineReference);
        
        /// <summary>
        /// The backing field for the Submachine property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IStateMachine _submachine;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _regionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRegionReference);
        
        /// <summary>
        /// The backing field for the Region property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private StateRegionCollection _region;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _members_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembers_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_selfOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_selfOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_import_ownedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_import_ownedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createElementImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreateElementImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _createPackageImportOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCreatePackageImportOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedElementsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedPackagesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedPackagesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOwnedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOwnedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _excludeCollisionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveExcludeCollisionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNamesOfMemberOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNamesOfMemberOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _importMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveImportMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getImportedMembersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetImportedMembersOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _membersAreDistinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMembersAreDistinguishableOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _elementImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveElementImportReference);
        
        /// <summary>
        /// The backing field for the ElementImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespaceElementImportCollection _elementImport;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _packageImportReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrievePackageImportReference);
        
        /// <summary>
        /// The backing field for the PackageImport property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NamespacePackageImportCollection _packageImport;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingStateMachineOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingStateMachineOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getIncomingsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetIncomingsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOutgoingsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOutgoingsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isContainedInStateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsContainedInStateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isContainedInRegionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsContainedInRegionOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _containerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveContainerReference);
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public State()
        {
            this._connection = new StateConnectionCollection(this);
            this._connection.CollectionChanging += this.ConnectionCollectionChanging;
            this._connection.CollectionChanged += this.ConnectionCollectionChanged;
            this._connectionPoint = new StateConnectionPointCollection(this);
            this._connectionPoint.CollectionChanging += this.ConnectionPointCollectionChanging;
            this._connectionPoint.CollectionChanged += this.ConnectionPointCollectionChanged;
            this._deferrableTrigger = new ObservableCompositionOrderedSet<ITrigger>(this);
            this._deferrableTrigger.CollectionChanging += this.DeferrableTriggerCollectionChanging;
            this._deferrableTrigger.CollectionChanged += this.DeferrableTriggerCollectionChanged;
            this._region = new StateRegionCollection(this);
            this._region.CollectionChanging += this.RegionCollectionChanging;
            this._region.CollectionChanged += this.RegionCollectionChanged;
            this._elementImport = new NamespaceElementImportCollection(this);
            this._elementImport.CollectionChanging += this.ElementImportCollectionChanging;
            this._elementImport.CollectionChanged += this.ElementImportCollectionChanged;
            this._packageImport = new NamespacePackageImportCollection(this);
            this._packageImport.CollectionChanging += this.PackageImportCollectionChanging;
            this._packageImport.CollectionChanged += this.PackageImportCollectionChanged;
        }
        
        /// <summary>
        /// The entry and exit connection points used in conjunction with this (submachine) State, i.e., as targets and sources, respectively, in the Region with the submachine State. A connection point reference references the corresponding definition of a connection point Pseudostate in the StateMachine referenced by the submachine State.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("connection")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConnectionPointReference> Connection
        {
            get
            {
                return this._connection;
            }
        }
        
        /// <summary>
        /// The entry and exit Pseudostates of a composite State. These can only be entry or exit Pseudostates, and they must have different names. They can only be defined for composite States.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("connectionPoint")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPseudostate> ConnectionPoint
        {
            get
            {
                return this._connectionPoint;
            }
        }
        
        /// <summary>
        /// A list of Triggers that are candidates to be retained by the StateMachine if they trigger no Transitions out of the State (not consumed). A deferred Trigger is retained until the StateMachine reaches a State configuration where it is no longer deferred.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("deferrableTrigger")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITrigger> DeferrableTrigger
        {
            get
            {
                return this._deferrableTrigger;
            }
        }
        
        /// <summary>
        /// An optional Behavior that is executed while being in the State. The execution starts when this State is entered, and ceases either by itself when done, or when the State is exited, whichever comes first.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("doActivity")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior DoActivity
        {
            get
            {
                return this._doActivity;
            }
            set
            {
                if ((this._doActivity != value))
                {
                    IBehavior old = this._doActivity;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("DoActivity", e, _doActivityReference);
                    this._doActivity = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetDoActivity;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetDoActivity;
                    }
                    this.OnPropertyChanged("DoActivity", e, _doActivityReference);
                }
            }
        }
        
        /// <summary>
        /// An optional Behavior that is executed whenever this State is entered regardless of the Transition taken to reach the State. If defined, entry Behaviors are always executed to completion prior to any internal Behavior or Transitions performed within the State.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("entry")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior Entry
        {
            get
            {
                return this._entry;
            }
            set
            {
                if ((this._entry != value))
                {
                    IBehavior old = this._entry;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Entry", e, _entryReference);
                    this._entry = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetEntry;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetEntry;
                    }
                    this.OnPropertyChanged("Entry", e, _entryReference);
                }
            }
        }
        
        /// <summary>
        /// An optional Behavior that is executed whenever this State is exited regardless of which Transition was taken out of the State. If defined, exit Behaviors are always executed to completion only after all internal and transition Behaviors have completed execution.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("exit")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior Exit
        {
            get
            {
                return this._exit;
            }
            set
            {
                if ((this._exit != value))
                {
                    IBehavior old = this._exit;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Exit", e, _exitReference);
                    this._exit = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetExit;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetExit;
                    }
                    this.OnPropertyChanged("Exit", e, _exitReference);
                }
            }
        }
        
        /// <summary>
        /// The State of which this State is a redefinition.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("redefinedState")]
        [DescriptionAttribute("The State of which this State is a redefinition.\n<p>From package UML::StateMachin" +
            "es.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("redefinedState")]
        [XmlAttributeAttribute(true)]
        public IState RedefinedState
        {
            get
            {
                return this._redefinedState;
            }
            set
            {
                if ((this._redefinedState != value))
                {
                    IState old = this._redefinedState;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("RedefinedState", e, _redefinedStateReference);
                    this._redefinedState = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetRedefinedState;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetRedefinedState;
                    }
                    this.OnPropertyChanged("RedefinedState", e, _redefinedStateReference);
                }
            }
        }
        
        /// <summary>
        /// Specifies conditions that are always true when this State is the current State. In ProtocolStateMachines state invariants are additional conditions to the preconditions of the outgoing Transitions, and to the postcondition of the incoming Transitions.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("stateInvariant")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IConstraint StateInvariant
        {
            get
            {
                return this._stateInvariant;
            }
            set
            {
                if ((this._stateInvariant != value))
                {
                    IConstraint old = this._stateInvariant;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("StateInvariant", e, _stateInvariantReference);
                    this._stateInvariant = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetStateInvariant;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetStateInvariant;
                    }
                    this.OnPropertyChanged("StateInvariant", e, _stateInvariantReference);
                }
            }
        }
        
        /// <summary>
        /// The StateMachine that is to be inserted in place of the (submachine) State.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("submachine")]
        [DescriptionAttribute("The StateMachine that is to be inserted in place of the (submachine) State.\n<p>Fr" +
            "om package UML::StateMachines.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("submachine")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("submachineState")]
        public IStateMachine Submachine
        {
            get
            {
                return this._submachine;
            }
            set
            {
                if ((this._submachine != value))
                {
                    IStateMachine old = this._submachine;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Submachine", e, _submachineReference);
                    this._submachine = value;
                    if ((old != null))
                    {
                        old.SubmachineState.Remove(this);
                        old.Deleted -= this.OnResetSubmachine;
                    }
                    if ((value != null))
                    {
                        value.SubmachineState.Add(this);
                        value.Deleted += this.OnResetSubmachine;
                    }
                    this.OnPropertyChanged("Submachine", e, _submachineReference);
                }
            }
        }
        
        /// <summary>
        /// The Regions owned directly by the State.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("region")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IRegion> Region
        {
            get
            {
                return this._region;
            }
        }
        
        IListExpression<IConstraint> NMF.Interop.Uml.INamespace.OwnedRule
        {
            get
            {
                return new StateOwnedRuleCollection(this);
            }
        }
        
        /// <summary>
        /// References the ElementImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("elementImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IElementImport> ElementImport
        {
            get
            {
                return this._elementImport;
            }
        }
        
        /// <summary>
        /// References the PackageImports owned by the Namespace.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("packageImport")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("importingNamespace")]
        [ConstantAttribute()]
        public IListExpression<IPackageImport> PackageImport
        {
            get
            {
                return this._packageImport;
            }
        }
        
        /// <summary>
        /// The Region that contains this Vertex.
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("container")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("subvertex")]
        public IRegion Container
        {
            get
            {
                return ModelHelper.CastAs<IRegion>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new StateChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new StateReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//State")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Only entry or exit Pseudostates can serve as connection points.
        ///connectionPoint-&gt;forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Entry_or_exit(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_entry_or_exitOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method entry_or_exit registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _entry_or_exitOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _entry_or_exitOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _entry_or_exitOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveEntry_or_exitOperation()
        {
            return ClassInstance.LookupOperation("entry_or_exit");
        }
        
        /// <summary>
        /// Only submachine States can have connection point references.
        ///isSubmachineState implies connection-&gt;notEmpty( )
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Submachine_states(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_submachine_statesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method submachine_states registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _submachine_statesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _submachine_statesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _submachine_statesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubmachine_statesOperation()
        {
            return ClassInstance.LookupOperation("submachine_states");
        }
        
        /// <summary>
        /// Only composite States can have entry or exit Pseudostates defined.
        ///connectionPoint-&gt;notEmpty() implies isComposite
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Composite_states(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_composite_statesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method composite_states registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _composite_statesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _composite_statesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _composite_statesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveComposite_statesOperation()
        {
            return ClassInstance.LookupOperation("composite_states");
        }
        
        /// <summary>
        /// The connection point references used as destinations/sources of Transitions associated with a submachine State must be defined as entry/exit points in the submachine StateMachine.
        ///self.isSubmachineState implies (self.connection-&gt;forAll (cp |
        ///  cp.entry-&gt;forAll (ps | ps.stateMachine = self.submachine) and
        ///  cp.exit-&gt;forAll (ps | ps.stateMachine = self.submachine)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Destinations_or_sources_of_transitions(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_destinations_or_sources_of_transitionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method destinations_or_sources_of_transitions regi" +
                        "stered. Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _destinations_or_sources_of_transitionsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _destinations_or_sources_of_transitionsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _destinations_or_sources_of_transitionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDestinations_or_sources_of_transitionsOperation()
        {
            return ClassInstance.LookupOperation("destinations_or_sources_of_transitions");
        }
        
        /// <summary>
        /// A State is not allowed to have both a submachine and Regions.
        ///isComposite implies not isSubmachineState
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Submachine_or_regions(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_submachine_or_regionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method submachine_or_regions registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _submachine_or_regionsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _submachine_or_regionsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _submachine_or_regionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubmachine_or_regionsOperation()
        {
            return ClassInstance.LookupOperation("submachine_or_regions");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConnectionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("connection")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Connection property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Connection", e, _connectionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Connection property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Connection", e, _connectionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConnectionPointReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("connectionPoint")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ConnectionPoint property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionPointCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ConnectionPoint", e, _connectionPointReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ConnectionPoint property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionPointCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ConnectionPoint", e, _connectionPointReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDeferrableTriggerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("deferrableTrigger")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the DeferrableTrigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void DeferrableTriggerCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("DeferrableTrigger", e, _deferrableTriggerReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the DeferrableTrigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void DeferrableTriggerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("DeferrableTrigger", e, _deferrableTriggerReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDoActivityReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("doActivity")));
        }
        
        /// <summary>
        /// Handles the event that the DoActivity property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDoActivity(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.DoActivity))
            {
                this.DoActivity = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveEntryReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("entry")));
        }
        
        /// <summary>
        /// Handles the event that the Entry property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetEntry(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Entry))
            {
                this.Entry = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveExitReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("exit")));
        }
        
        /// <summary>
        /// Handles the event that the Exit property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetExit(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Exit))
            {
                this.Exit = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedStateReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("redefinedState")));
        }
        
        /// <summary>
        /// Handles the event that the RedefinedState property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRedefinedState(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.RedefinedState))
            {
                this.RedefinedState = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveStateInvariantReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("stateInvariant")));
        }
        
        /// <summary>
        /// Handles the event that the StateInvariant property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetStateInvariant(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.StateInvariant))
            {
                this.StateInvariant = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSubmachineReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("submachine")));
        }
        
        /// <summary>
        /// Handles the event that the Submachine property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSubmachine(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Submachine))
            {
                this.Submachine = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRegionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("region")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Region property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RegionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Region", e, _regionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Region property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RegionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Region", e, _regionReference);
        }
        
        /// <summary>
        /// All the members of a Namespace are distinguishable within it.
        ///membersAreDistinguishable()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Members_distinguishable(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_members_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method members_distinguishable registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _members_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _members_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _members_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembers_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("members_distinguishable");
        }
        
        /// <summary>
        /// A Namespace cannot have a PackageImport to itself.
        ///packageImport.importedPackage.oclAsType(Namespace)-&gt;excludes(self)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_self(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_selfOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_self registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_selfOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_selfOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_selfOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_selfOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_self");
        }
        
        /// <summary>
        /// A Namespace cannot have an ElementImport to one of its ownedMembers.
        ///elementImport.importedElement.oclAsType(Element)-&gt;excludesAll(ownedMember)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_import_ownedMembers(object diagnostics, object context)
        {
            System.Func<NMF.Interop.Uml.INamespace, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, object, object, bool>>(_cannot_import_ownedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_import_ownedMembers registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_import_ownedMembersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_import_ownedMembersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_import_ownedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_import_ownedMembersOperation()
        {
            return ClassInstance.LookupOperation("cannot_import_ownedMembers");
        }
        
        /// <summary>
        /// Creates an import of the specified element into this namespace with the specified visibility.
        /// </summary>
        /// <param name="element">The element to import.</param>
        /// <param name="visibility">The visibility for the new element import.</param>
        public IElementImport CreateElementImport(IPackageableElement element, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackageableElement, VisibilityKind, IElementImport>>(_createElementImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createElementImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createElementImportOperation.Value, element, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createElementImportOperation.Value, e));
            IElementImport result = handler.Invoke(this, element, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createElementImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreateElementImportOperation()
        {
            return ClassInstance.LookupOperation("createElementImport");
        }
        
        /// <summary>
        /// Creates an import of the specified package into this namespace with the specified visibility.
        /// </summary>
        /// <param name="package_">The package to import.</param>
        /// <param name="visibility">The visibility for the new package import.</param>
        public IPackageImport CreatePackageImport(IPackage package_, VisibilityKind visibility)
        {
            System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IPackage, VisibilityKind, IPackageImport>>(_createPackageImportOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method createPackageImport registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _createPackageImportOperation.Value, package_, visibility);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _createPackageImportOperation.Value, e));
            IPackageImport result = handler.Invoke(this, package_, visibility);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _createPackageImportOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCreatePackageImportOperation()
        {
            return ClassInstance.LookupOperation("createPackageImport");
        }
        
        /// <summary>
        /// Retrieves the elements imported by this namespace.
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedElements()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedElements registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedElementsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedElementsOperation()
        {
            return ClassInstance.LookupOperation("getImportedElements");
        }
        
        /// <summary>
        /// Retrieves the packages imported by this namespace.
        /// </summary>
        public ISetExpression<IPackage> GetImportedPackages()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackage>>>(_getImportedPackagesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedPackages registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedPackagesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedPackagesOperation.Value, e));
            ISetExpression<IPackage> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedPackagesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedPackagesOperation()
        {
            return ClassInstance.LookupOperation("getImportedPackages");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public ISetExpression<INamedElement> GetOwnedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<INamedElement>>>(_getOwnedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOwnedMembers registered. Use the method " +
                        "broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOwnedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOwnedMembersOperation.Value, e));
            ISetExpression<INamedElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOwnedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOwnedMembersOperation()
        {
            return ClassInstance.LookupOperation("getOwnedMembers");
        }
        
        /// <summary>
        /// The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this Namespace.
        ///result = (imps-&gt;reject(imp1  | imps-&gt;exists(imp2 | not imp1.isDistinguishableFrom(imp2, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ExcludeCollisions(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_excludeCollisionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method excludeCollisions registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _excludeCollisionsOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _excludeCollisionsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _excludeCollisionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveExcludeCollisionsOperation()
        {
            return ClassInstance.LookupOperation("excludeCollisions");
        }
        
        /// <summary>
        /// The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace, taking importing into account. In general a member can have multiple names in a Namespace if it is imported more than once with different aliases.
        ///result = (if self.ownedMember -&gt;includes(element)
        ///then Set{element.name}
        ///else let elementImports : Set(ElementImport) = self.elementImport-&gt;select(ei | ei.importedElement = element) in
        ///  if elementImports-&gt;notEmpty()
        ///  then
        ///     elementImports-&gt;collect(el | el.getName())-&gt;asSet()
        ///  else 
        ///     self.packageImport-&gt;select(pi | pi.importedPackage.visibleMembers().oclAsType(NamedElement)-&gt;includes(element))-&gt; collect(pi | pi.importedPackage.getNamesOfMember(element))-&gt;asSet()
        ///  endif
        ///endif)
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="element"></param>
        public ISetExpression<string> GetNamesOfMember(INamedElement element)
        {
            System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, INamedElement, ISetExpression<string>>>(_getNamesOfMemberOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getNamesOfMember registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNamesOfMemberOperation.Value, element);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNamesOfMemberOperation.Value, e));
            ISetExpression<string> result = handler.Invoke(this, element);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNamesOfMemberOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNamesOfMemberOperation()
        {
            return ClassInstance.LookupOperation("getNamesOfMember");
        }
        
        /// <summary>
        /// The query importMembers() defines which of a set of PackageableElements are actually imported into the Namespace. This excludes hidden ones, i.e., those which have names that conflict with names of ownedMembers, and it also excludes PackageableElements that would have the indistinguishable names when imported.
        ///result = (self.excludeCollisions(imps)-&gt;select(imp | self.ownedMember-&gt;forAll(mem | imp.isDistinguishableFrom(mem, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="imps"></param>
        public ISetExpression<IPackageableElement> ImportMembers(IEnumerable<IPackageableElement> imps)
        {
            System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, IEnumerable<IPackageableElement>, ISetExpression<IPackageableElement>>>(_importMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method importMembers registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _importMembersOperation.Value, imps);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _importMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this, imps);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _importMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveImportMembersOperation()
        {
            return ClassInstance.LookupOperation("importMembers");
        }
        
        /// <summary>
        /// The importedMember property is derived as the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.
        ///result = (self.importMembers(elementImport.importedElement-&gt;asSet()-&gt;union(packageImport.importedPackage-&gt;collect(p | p.visibleMembers()))-&gt;asSet()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> GetImportedMembers()
        {
            System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, ISetExpression<IPackageableElement>>>(_getImportedMembersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getImportedMembers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getImportedMembersOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getImportedMembersOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getImportedMembersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetImportedMembersOperation()
        {
            return ClassInstance.LookupOperation("getImportedMembers");
        }
        
        /// <summary>
        /// The Boolean query membersAreDistinguishable() determines whether all of the Namespace&apos;s members are distinguishable within it.
        ///result = (member-&gt;forAll( memb |
        ///   member-&gt;excluding(memb)-&gt;forAll(other |
        ///       memb.isDistinguishableFrom(other, self))))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool MembersAreDistinguishable()
        {
            System.Func<NMF.Interop.Uml.INamespace, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<NMF.Interop.Uml.INamespace, bool>>(_membersAreDistinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method membersAreDistinguishable registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _membersAreDistinguishableOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _membersAreDistinguishableOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _membersAreDistinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMembersAreDistinguishableOperation()
        {
            return ClassInstance.LookupOperation("membersAreDistinguishable");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveElementImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("elementImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ElementImport", e, _elementImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ElementImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ElementImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ElementImport", e, _elementImportReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrievePackageImportReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Namespace.ClassInstance)).Resolve("packageImport")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the PackageImport property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void PackageImportCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("PackageImport", e, _packageImportReference);
        }
        
        /// <summary>
        /// The operation containingStateMachine() returns the StateMachine in which this Vertex is defined.
        ///result = (if container &lt;&gt; null
        ///then
        ///-- the container is a region
        ///   container.containingStateMachine()
        ///else 
        ///   if (self.oclIsKindOf(Pseudostate)) and ((self.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint) or (self.oclAsType(Pseudostate).kind = PseudostateKind::exitPoint)) then
        ///      self.oclAsType(Pseudostate).stateMachine
        ///   else 
        ///      if (self.oclIsKindOf(ConnectionPointReference)) then
        ///          self.oclAsType(ConnectionPointReference).state.containingStateMachine() -- no other valid cases possible
        ///      else 
        ///          null
        ///      endif
        ///   endif
        ///endif
        ///)
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        public IStateMachine ContainingStateMachine()
        {
            System.Func<IVertex, IStateMachine> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, IStateMachine>>(_containingStateMachineOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingStateMachine registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingStateMachineOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingStateMachineOperation.Value, e));
            IStateMachine result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingStateMachineOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingStateMachineOperation()
        {
            return ClassInstance.LookupOperation("containingStateMachine");
        }
        
        /// <summary>
        /// Derivation for Vertex::/incoming.
        ///result = (Transition.allInstances()-&gt;select(target=self))
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        public ISetExpression<ITransition> GetIncomings()
        {
            System.Func<IVertex, ISetExpression<ITransition>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, ISetExpression<ITransition>>>(_getIncomingsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getIncomings registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getIncomingsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getIncomingsOperation.Value, e));
            ISetExpression<ITransition> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getIncomingsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetIncomingsOperation()
        {
            return ClassInstance.LookupOperation("getIncomings");
        }
        
        /// <summary>
        /// Derivation for Vertex::/outgoing
        ///result = (Transition.allInstances()-&gt;select(source=self))
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        public ISetExpression<ITransition> GetOutgoings()
        {
            System.Func<IVertex, ISetExpression<ITransition>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, ISetExpression<ITransition>>>(_getOutgoingsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOutgoings registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOutgoingsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOutgoingsOperation.Value, e));
            ISetExpression<ITransition> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOutgoingsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOutgoingsOperation()
        {
            return ClassInstance.LookupOperation("getOutgoings");
        }
        
        /// <summary>
        /// This utility operation returns true if the Vertex is contained in the State s (input argument).
        ///result = (if not s.isComposite() or container-&gt;isEmpty() then
        ///	false
        ///else
        ///	if container.state = s then 
        ///		true
        ///	else
        ///		container.state.isContainedInState(s)
        ///	endif
        ///endif)
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        /// <param name="s"></param>
        public bool IsContainedInState(IState s)
        {
            System.Func<IVertex, IState, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, IState, bool>>(_isContainedInStateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isContainedInState registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isContainedInStateOperation.Value, s);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isContainedInStateOperation.Value, e));
            bool result = handler.Invoke(this, s);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isContainedInStateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsContainedInStateOperation()
        {
            return ClassInstance.LookupOperation("isContainedInState");
        }
        
        /// <summary>
        /// This utility query returns true if the Vertex is contained in the Region r (input argument).
        ///result = (if (container = r) then
        ///	true
        ///else
        ///	if (r.state-&gt;isEmpty()) then
        ///		false
        ///	else
        ///		container.state.isContainedInRegion(r)
        ///	endif
        ///endif)
        ///&lt;p&gt;From package UML::StateMachines.&lt;/p&gt;
        /// </summary>
        /// <param name="r"></param>
        public bool IsContainedInRegion(IRegion r)
        {
            System.Func<IVertex, IRegion, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, IRegion, bool>>(_isContainedInRegionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isContainedInRegion registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isContainedInRegionOperation.Value, r);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isContainedInRegionOperation.Value, e));
            bool result = handler.Invoke(this, r);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isContainedInRegionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsContainedInRegionOperation()
        {
            return ClassInstance.LookupOperation("isContainedInRegion");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveContainerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Vertex.ClassInstance)).Resolve("container")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanging("Container", e, _containerReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            if ((oldContainer != null))
            {
                oldContainer.Subvertex.Remove(this);
            }
            if ((newContainer != null))
            {
                newContainer.Subvertex.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanged("Container", e, _containerReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int connectionIndex = ModelHelper.IndexOfReference(this.Connection, element);
            if ((connectionIndex != -1))
            {
                return ModelHelper.CreatePath("connection", connectionIndex);
            }
            int connectionPointIndex = ModelHelper.IndexOfReference(this.ConnectionPoint, element);
            if ((connectionPointIndex != -1))
            {
                return ModelHelper.CreatePath("connectionPoint", connectionPointIndex);
            }
            int deferrableTriggerIndex = ModelHelper.IndexOfReference(this.DeferrableTrigger, element);
            if ((deferrableTriggerIndex != -1))
            {
                return ModelHelper.CreatePath("deferrableTrigger", deferrableTriggerIndex);
            }
            if ((element == this.DoActivity))
            {
                return ModelHelper.CreatePath("doActivity");
            }
            if ((element == this.Entry))
            {
                return ModelHelper.CreatePath("entry");
            }
            if ((element == this.Exit))
            {
                return ModelHelper.CreatePath("exit");
            }
            if ((element == this.StateInvariant))
            {
                return ModelHelper.CreatePath("stateInvariant");
            }
            int regionIndex = ModelHelper.IndexOfReference(this.Region, element);
            if ((regionIndex != -1))
            {
                return ModelHelper.CreatePath("region", regionIndex);
            }
            int elementImportIndex = ModelHelper.IndexOfReference(this.ElementImport, element);
            if ((elementImportIndex != -1))
            {
                return ModelHelper.CreatePath("elementImport", elementImportIndex);
            }
            int packageImportIndex = ModelHelper.IndexOfReference(this.PackageImport, element);
            if ((packageImportIndex != -1))
            {
                return ModelHelper.CreatePath("packageImport", packageImportIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "CONNECTION"))
            {
                if ((index < this.Connection.Count))
                {
                    return this.Connection[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CONNECTIONPOINT"))
            {
                if ((index < this.ConnectionPoint.Count))
                {
                    return this.ConnectionPoint[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "DEFERRABLETRIGGER"))
            {
                if ((index < this.DeferrableTrigger.Count))
                {
                    return this.DeferrableTrigger[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "DOACTIVITY"))
            {
                return this.DoActivity;
            }
            if ((reference == "ENTRY"))
            {
                return this.Entry;
            }
            if ((reference == "EXIT"))
            {
                return this.Exit;
            }
            if ((reference == "REDEFINEDSTATE"))
            {
                return this.RedefinedState;
            }
            if ((reference == "STATEINVARIANT"))
            {
                return this.StateInvariant;
            }
            if ((reference == "SUBMACHINE"))
            {
                return this.Submachine;
            }
            if ((reference == "REGION"))
            {
                if ((index < this.Region.Count))
                {
                    return this.Region[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "ELEMENTIMPORT"))
            {
                if ((index < this.ElementImport.Count))
                {
                    return this.ElementImport[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "PACKAGEIMPORT"))
            {
                if ((index < this.PackageImport.Count))
                {
                    return this.PackageImport[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CONTAINER"))
            {
                return this.Container;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "CONNECTION"))
            {
                return this._connection;
            }
            if ((feature == "CONNECTIONPOINT"))
            {
                return this._connectionPoint;
            }
            if ((feature == "DEFERRABLETRIGGER"))
            {
                return this._deferrableTrigger;
            }
            if ((feature == "REGION"))
            {
                return this._region;
            }
            if ((feature == "ELEMENTIMPORT"))
            {
                return this._elementImport;
            }
            if ((feature == "PACKAGEIMPORT"))
            {
                return this._packageImport;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "DOACTIVITY"))
            {
                this.DoActivity = ((IBehavior)(value));
                return;
            }
            if ((feature == "ENTRY"))
            {
                this.Entry = ((IBehavior)(value));
                return;
            }
            if ((feature == "EXIT"))
            {
                this.Exit = ((IBehavior)(value));
                return;
            }
            if ((feature == "REDEFINEDSTATE"))
            {
                this.RedefinedState = ((IState)(value));
                return;
            }
            if ((feature == "STATEINVARIANT"))
            {
                this.StateInvariant = ((IConstraint)(value));
                return;
            }
            if ((feature == "SUBMACHINE"))
            {
                this.Submachine = ((IStateMachine)(value));
                return;
            }
            if ((feature == "CONTAINER"))
            {
                this.Container = ((IRegion)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "DOACTIVITY"))
            {
                return new DoActivityProxy(this);
            }
            if ((reference == "ENTRY"))
            {
                return new EntryProxy(this);
            }
            if ((reference == "EXIT"))
            {
                return new ExitProxy(this);
            }
            if ((reference == "REDEFINEDSTATE"))
            {
                return new RedefinedStateProxy(this);
            }
            if ((reference == "STATEINVARIANT"))
            {
                return new StateInvariantProxy(this);
            }
            if ((reference == "SUBMACHINE"))
            {
                return new SubmachineProxy(this);
            }
            if ((reference == "CONTAINER"))
            {
                return new ContainerProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._connection))
            {
                return "connection";
            }
            if ((container == this._connectionPoint))
            {
                return "connectionPoint";
            }
            if ((container == this._deferrableTrigger))
            {
                return "deferrableTrigger";
            }
            if ((container == this._region))
            {
                return "region";
            }
            if ((container == this._elementImport))
            {
                return "elementImport";
            }
            if ((container == this._packageImport))
            {
                return "packageImport";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//State")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the State class
        /// </summary>
        public class StateChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private State _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public StateChildrenCollection(State parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the State class
        /// </summary>
        public class StateReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private State _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public StateReferencedElementsCollection(State parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the doActivity property
        /// </summary>
        private sealed class DoActivityProxy : ModelPropertyChange<IState, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DoActivityProxy(IState modelElement) : 
                    base(modelElement, "doActivity")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.DoActivity;
                }
                set
                {
                    this.ModelElement.DoActivity = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the entry property
        /// </summary>
        private sealed class EntryProxy : ModelPropertyChange<IState, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public EntryProxy(IState modelElement) : 
                    base(modelElement, "entry")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.Entry;
                }
                set
                {
                    this.ModelElement.Entry = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the exit property
        /// </summary>
        private sealed class ExitProxy : ModelPropertyChange<IState, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExitProxy(IState modelElement) : 
                    base(modelElement, "exit")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.Exit;
                }
                set
                {
                    this.ModelElement.Exit = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the redefinedState property
        /// </summary>
        private sealed class RedefinedStateProxy : ModelPropertyChange<IState, IState>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RedefinedStateProxy(IState modelElement) : 
                    base(modelElement, "redefinedState")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IState Value
            {
                get
                {
                    return this.ModelElement.RedefinedState;
                }
                set
                {
                    this.ModelElement.RedefinedState = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the stateInvariant property
        /// </summary>
        private sealed class StateInvariantProxy : ModelPropertyChange<IState, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public StateInvariantProxy(IState modelElement) : 
                    base(modelElement, "stateInvariant")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.StateInvariant;
                }
                set
                {
                    this.ModelElement.StateInvariant = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the submachine property
        /// </summary>
        private sealed class SubmachineProxy : ModelPropertyChange<IState, IStateMachine>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SubmachineProxy(IState modelElement) : 
                    base(modelElement, "submachine")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IStateMachine Value
            {
                get
                {
                    return this.ModelElement.Submachine;
                }
                set
                {
                    this.ModelElement.Submachine = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the container property
        /// </summary>
        private sealed class ContainerProxy : ModelPropertyChange<IVertex, IRegion>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ContainerProxy(IVertex modelElement) : 
                    base(modelElement, "container")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IRegion Value
            {
                get
                {
                    return this.ModelElement.Container;
                }
                set
                {
                    this.ModelElement.Container = value;
                }
            }
        }
    }
}
