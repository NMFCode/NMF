//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A State models a situation during which some (usually implicit) invariant condition holds.
    ///<p>From package UML::StateMachines.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//State")]
    [DebuggerDisplayAttribute("State {Name}")]
    public partial class State : Namespace, IState, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _entry_or_exitOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveEntry_or_exitOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _submachine_statesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubmachine_statesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _composite_statesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveComposite_statesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _destinations_or_sources_of_transitionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDestinations_or_sources_of_transitionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _submachine_or_regionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubmachine_or_regionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompositeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompositeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isOrthogonalOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsOrthogonalOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isSimpleOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsSimpleOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isSubmachineStateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsSubmachineStateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinitionContextOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinitionContextOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _connectionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConnectionReference);
        
        /// <summary>
        /// The backing field for the Connection property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private StateConnectionCollection _connection;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _connectionPointReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConnectionPointReference);
        
        /// <summary>
        /// The backing field for the ConnectionPoint property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private StateConnectionPointCollection _connectionPoint;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _deferrableTriggerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDeferrableTriggerReference);
        
        /// <summary>
        /// The backing field for the DeferrableTrigger property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<ITrigger> _deferrableTrigger;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _doActivityReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDoActivityReference);
        
        /// <summary>
        /// The backing field for the DoActivity property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _doActivity;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _entryReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveEntryReference);
        
        /// <summary>
        /// The backing field for the Entry property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _entry;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _exitReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveExitReference);
        
        /// <summary>
        /// The backing field for the Exit property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _exit;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedStateReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedStateReference);
        
        /// <summary>
        /// The backing field for the RedefinedState property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IState _redefinedState;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _stateInvariantReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveStateInvariantReference);
        
        /// <summary>
        /// The backing field for the StateInvariant property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _stateInvariant;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _submachineReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSubmachineReference);
        
        /// <summary>
        /// The backing field for the Submachine property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IStateMachine _submachine;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _regionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRegionReference);
        
        /// <summary>
        /// The backing field for the Region property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private StateRegionCollection _region;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_consistentOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_consistentOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _non_leaf_redefinitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNon_leaf_redefinitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_context_validOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_context_validOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isConsistentWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsConsistentWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isRedefinitionContextValidOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsRedefinitionContextValidOperation);
        
        /// <summary>
        /// The backing field for the IsLeaf property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isLeaf = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isLeafAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsLeafAttribute);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingStateMachineOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingStateMachineOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getIncomingsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetIncomingsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOutgoingsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOutgoingsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isContainedInStateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsContainedInStateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isContainedInRegionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsContainedInRegionOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _containerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveContainerReference);
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public State()
        {
            this._connection = new StateConnectionCollection(this);
            this._connection.CollectionChanging += this.ConnectionCollectionChanging;
            this._connection.CollectionChanged += this.ConnectionCollectionChanged;
            this._connectionPoint = new StateConnectionPointCollection(this);
            this._connectionPoint.CollectionChanging += this.ConnectionPointCollectionChanging;
            this._connectionPoint.CollectionChanged += this.ConnectionPointCollectionChanged;
            this._deferrableTrigger = new ObservableCompositionOrderedSet<ITrigger>(this);
            this._deferrableTrigger.CollectionChanging += this.DeferrableTriggerCollectionChanging;
            this._deferrableTrigger.CollectionChanged += this.DeferrableTriggerCollectionChanged;
            this._region = new StateRegionCollection(this);
            this._region.CollectionChanging += this.RegionCollectionChanging;
            this._region.CollectionChanged += this.RegionCollectionChanged;
        }
        
        /// <summary>
        /// The entry and exit connection points used in conjunction with this (submachine) State, i.e., as targets and sources, respectively, in the Region with the submachine State. A connection point reference references the corresponding definition of a connection point Pseudostate in the StateMachine referenced by the submachine State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("connection")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConnectionPointReference> Connection
        {
            get
            {
                return this._connection;
            }
        }
        
        /// <summary>
        /// The entry and exit Pseudostates of a composite State. These can only be entry or exit Pseudostates, and they must have different names. They can only be defined for composite States.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("connectionPoint")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IPseudostate> ConnectionPoint
        {
            get
            {
                return this._connectionPoint;
            }
        }
        
        /// <summary>
        /// A list of Triggers that are candidates to be retained by the StateMachine if they trigger no Transitions out of the State (not consumed). A deferred Trigger is retained until the StateMachine reaches a State configuration where it is no longer deferred.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("deferrableTrigger")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITrigger> DeferrableTrigger
        {
            get
            {
                return this._deferrableTrigger;
            }
        }
        
        /// <summary>
        /// An optional Behavior that is executed while being in the State. The execution starts when this State is entered, and ceases either by itself when done, or when the State is exited, whichever comes first.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("doActivity")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior DoActivity
        {
            get
            {
                return this._doActivity;
            }
            set
            {
                if ((this._doActivity != value))
                {
                    IBehavior old = this._doActivity;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("DoActivity", e, _doActivityReference);
                    this._doActivity = value;
                    if ((old != null))
                    {
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetDoActivity;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetDoActivity;
                    }
                    this.OnPropertyChanged("DoActivity", e, _doActivityReference);
                }
            }
        }
        
        /// <summary>
        /// An optional Behavior that is executed whenever this State is entered regardless of the Transition taken to reach the State. If defined, entry Behaviors are always executed to completion prior to any internal Behavior or Transitions performed within the State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("entry")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior Entry
        {
            get
            {
                return this._entry;
            }
            set
            {
                if ((this._entry != value))
                {
                    IBehavior old = this._entry;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Entry", e, _entryReference);
                    this._entry = value;
                    if ((old != null))
                    {
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetEntry;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetEntry;
                    }
                    this.OnPropertyChanged("Entry", e, _entryReference);
                }
            }
        }
        
        /// <summary>
        /// An optional Behavior that is executed whenever this State is exited regardless of which Transition was taken out of the State. If defined, exit Behaviors are always executed to completion only after all internal and transition Behaviors have completed execution.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("exit")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior Exit
        {
            get
            {
                return this._exit;
            }
            set
            {
                if ((this._exit != value))
                {
                    IBehavior old = this._exit;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Exit", e, _exitReference);
                    this._exit = value;
                    if ((old != null))
                    {
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetExit;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetExit;
                    }
                    this.OnPropertyChanged("Exit", e, _exitReference);
                }
            }
        }
        
        /// <summary>
        /// The State of which this State is a redefinition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("redefinedState")]
        [DescriptionAttribute("The State of which this State is a redefinition.\n<p>From package UML::StateMachin" +
            "es.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("redefinedState")]
        [XmlAttributeAttribute(true)]
        public IState RedefinedState
        {
            get
            {
                return this._redefinedState;
            }
            set
            {
                if ((this._redefinedState != value))
                {
                    IState old = this._redefinedState;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("RedefinedState", e, _redefinedStateReference);
                    this._redefinedState = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetRedefinedState;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetRedefinedState;
                    }
                    this.OnPropertyChanged("RedefinedState", e, _redefinedStateReference);
                }
            }
        }
        
        /// <summary>
        /// Specifies conditions that are always true when this State is the current State. In ProtocolStateMachines state invariants are additional conditions to the preconditions of the outgoing Transitions, and to the postcondition of the incoming Transitions.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("stateInvariant")]
        [DescriptionAttribute(@"Specifies conditions that are always true when this State is the current State. In ProtocolStateMachines state invariants are additional conditions to the preconditions of the outgoing Transitions, and to the postcondition of the incoming Transitions.
<p>From package UML::StateMachines.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("stateInvariant")]
        [XmlAttributeAttribute(true)]
        public IConstraint StateInvariant
        {
            get
            {
                return this._stateInvariant;
            }
            set
            {
                if ((this._stateInvariant != value))
                {
                    IConstraint old = this._stateInvariant;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("StateInvariant", e, _stateInvariantReference);
                    this._stateInvariant = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetStateInvariant;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetStateInvariant;
                    }
                    this.OnPropertyChanged("StateInvariant", e, _stateInvariantReference);
                }
            }
        }
        
        /// <summary>
        /// The StateMachine that is to be inserted in place of the (submachine) State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("submachine")]
        [DescriptionAttribute("The StateMachine that is to be inserted in place of the (submachine) State.\n<p>Fr" +
            "om package UML::StateMachines.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("submachine")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("submachineState")]
        public IStateMachine Submachine
        {
            get
            {
                return this._submachine;
            }
            set
            {
                if ((this._submachine != value))
                {
                    IStateMachine old = this._submachine;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Submachine", e, _submachineReference);
                    this._submachine = value;
                    if ((old != null))
                    {
                        old.SubmachineState.Remove(this);
                        old.Deleted -= this.OnResetSubmachine;
                    }
                    if ((value != null))
                    {
                        value.SubmachineState.Add(this);
                        value.Deleted += this.OnResetSubmachine;
                    }
                    this.OnPropertyChanged("Submachine", e, _submachineReference);
                }
            }
        }
        
        /// <summary>
        /// The Regions owned directly by the State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("region")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IRegion> Region
        {
            get
            {
                return this._region;
            }
        }
        
        /// <summary>
        /// Indicates whether it is possible to further redefine a RedefinableElement. If the value is true, then it is not possible to further redefine the RedefinableElement.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isLeaf")]
        [DescriptionAttribute("Indicates whether it is possible to further redefine a RedefinableElement. If the" +
            " value is true, then it is not possible to further redefine the RedefinableEleme" +
            "nt.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("RedefinableElement")]
        [XmlElementNameAttribute("isLeaf")]
        [XmlAttributeAttribute(true)]
        public bool IsLeaf
        {
            get
            {
                return this._isLeaf;
            }
            set
            {
                if ((this._isLeaf != value))
                {
                    bool old = this._isLeaf;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsLeaf", e, _isLeafAttribute);
                    this._isLeaf = value;
                    this.OnPropertyChanged("IsLeaf", e, _isLeafAttribute);
                }
            }
        }
        
        /// <summary>
        /// The Region that contains this Vertex.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("container")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("subvertex")]
        public IRegion Container
        {
            get
            {
                return ModelHelper.CastAs<IRegion>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new StateChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new StateReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//State")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Only entry or exit Pseudostates can serve as connection points.
        ///connectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Entry_or_exit(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_entry_or_exitOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method entry_or_exit registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _entry_or_exitOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _entry_or_exitOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _entry_or_exitOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveEntry_or_exitOperation()
        {
            return ClassInstance.LookupOperation("entry_or_exit");
        }
        
        /// <summary>
        /// Only submachine States can have connection point references.
        ///isSubmachineState implies connection->notEmpty( )
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Submachine_states(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_submachine_statesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method submachine_states registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _submachine_statesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _submachine_statesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _submachine_statesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubmachine_statesOperation()
        {
            return ClassInstance.LookupOperation("submachine_states");
        }
        
        /// <summary>
        /// Only composite States can have entry or exit Pseudostates defined.
        ///connectionPoint->notEmpty() implies isComposite
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Composite_states(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_composite_statesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method composite_states registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _composite_statesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _composite_statesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _composite_statesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveComposite_statesOperation()
        {
            return ClassInstance.LookupOperation("composite_states");
        }
        
        /// <summary>
        /// The connection point references used as destinations/sources of Transitions associated with a submachine State must be defined as entry/exit points in the submachine StateMachine.
        ///self.isSubmachineState implies (self.connection->forAll (cp |
        ///  cp.entry->forAll (ps | ps.stateMachine = self.submachine) and
        ///  cp.exit->forAll (ps | ps.stateMachine = self.submachine)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Destinations_or_sources_of_transitions(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_destinations_or_sources_of_transitionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method destinations_or_sources_of_transitions regi" +
                        "stered. Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _destinations_or_sources_of_transitionsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _destinations_or_sources_of_transitionsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _destinations_or_sources_of_transitionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDestinations_or_sources_of_transitionsOperation()
        {
            return ClassInstance.LookupOperation("destinations_or_sources_of_transitions");
        }
        
        /// <summary>
        /// A State is not allowed to have both a submachine and Regions.
        ///isComposite implies not isSubmachineState
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Submachine_or_regions(object diagnostics, object context)
        {
            System.Func<IState, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, object, object, bool>>(_submachine_or_regionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method submachine_or_regions registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _submachine_or_regionsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _submachine_or_regionsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _submachine_or_regionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubmachine_or_regionsOperation()
        {
            return ClassInstance.LookupOperation("submachine_or_regions");
        }
        
        /// <summary>
        /// A composite State is a State with at least one Region.
        ///result = (region->notEmpty())
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public bool IsComposite()
        {
            System.Func<IState, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, bool>>(_isCompositeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isComposite registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompositeOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompositeOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompositeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompositeOperation()
        {
            return ClassInstance.LookupOperation("isComposite");
        }
        
        /// <summary>
        /// An orthogonal State is a composite state with at least 2 regions.
        ///result = (region->size () > 1)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public bool IsOrthogonal()
        {
            System.Func<IState, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, bool>>(_isOrthogonalOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isOrthogonal registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isOrthogonalOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isOrthogonalOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isOrthogonalOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsOrthogonalOperation()
        {
            return ClassInstance.LookupOperation("isOrthogonal");
        }
        
        /// <summary>
        /// A simple State is a State without any regions.
        ///result = ((region->isEmpty()) and not isSubmachineState())
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public bool IsSimple()
        {
            System.Func<IState, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, bool>>(_isSimpleOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isSimple registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isSimpleOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isSimpleOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isSimpleOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsSimpleOperation()
        {
            return ClassInstance.LookupOperation("isSimple");
        }
        
        /// <summary>
        /// Only submachine State references another StateMachine.
        ///result = (submachine <> null)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public bool IsSubmachineState()
        {
            System.Func<IState, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, bool>>(_isSubmachineStateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isSubmachineState registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isSubmachineStateOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isSubmachineStateOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isSubmachineStateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsSubmachineStateOperation()
        {
            return ClassInstance.LookupOperation("isSubmachineState");
        }
        
        /// <summary>
        /// The redefinition context of a State is the nearest containing StateMachine.
        ///result = (let sm : StateMachine = containingStateMachine() in
        ///if sm._'context' = null or sm.general->notEmpty() then
        ///  sm
        ///else
        ///  sm._'context'
        ///endif)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public IClassifier RedefinitionContext()
        {
            System.Func<IState, IClassifier> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IState, IClassifier>>(_redefinitionContextOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinitionContext registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinitionContextOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinitionContextOperation.Value, e));
            IClassifier result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinitionContextOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinitionContextOperation()
        {
            return ClassInstance.LookupOperation("redefinitionContext");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConnectionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("connection")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Connection property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Connection", e, _connectionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Connection property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Connection", e, _connectionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConnectionPointReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("connectionPoint")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ConnectionPoint property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionPointCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ConnectionPoint", e, _connectionPointReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ConnectionPoint property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConnectionPointCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ConnectionPoint", e, _connectionPointReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDeferrableTriggerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("deferrableTrigger")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the DeferrableTrigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void DeferrableTriggerCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("DeferrableTrigger", e, _deferrableTriggerReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the DeferrableTrigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void DeferrableTriggerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("DeferrableTrigger", e, _deferrableTriggerReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDoActivityReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("doActivity")));
        }
        
        /// <summary>
        /// Handles the event that the DoActivity property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDoActivity(object sender, System.EventArgs eventArgs)
        {
            this.DoActivity = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveEntryReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("entry")));
        }
        
        /// <summary>
        /// Handles the event that the Entry property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetEntry(object sender, System.EventArgs eventArgs)
        {
            this.Entry = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveExitReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("exit")));
        }
        
        /// <summary>
        /// Handles the event that the Exit property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetExit(object sender, System.EventArgs eventArgs)
        {
            this.Exit = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedStateReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("redefinedState")));
        }
        
        /// <summary>
        /// Handles the event that the RedefinedState property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRedefinedState(object sender, System.EventArgs eventArgs)
        {
            this.RedefinedState = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveStateInvariantReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("stateInvariant")));
        }
        
        /// <summary>
        /// Handles the event that the StateInvariant property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetStateInvariant(object sender, System.EventArgs eventArgs)
        {
            this.StateInvariant = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSubmachineReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("submachine")));
        }
        
        /// <summary>
        /// Handles the event that the Submachine property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSubmachine(object sender, System.EventArgs eventArgs)
        {
            this.Submachine = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRegionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.State.ClassInstance)).Resolve("region")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Region property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RegionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Region", e, _regionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Region property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RegionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Region", e, _regionReference);
        }
        
        /// <summary>
        /// A redefining element must be consistent with each redefined element.
        ///redefinedElement->forAll(re | re.isConsistentWith(self))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_consistent(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_consistentOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_consistent registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_consistentOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_consistentOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_consistentOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_consistentOperation()
        {
            return ClassInstance.LookupOperation("redefinition_consistent");
        }
        
        /// <summary>
        /// A RedefinableElement can only redefine non-leaf RedefinableElements.
        ///redefinedElement->forAll(re | not re.isLeaf)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Non_leaf_redefinition(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_non_leaf_redefinitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method non_leaf_redefinition registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _non_leaf_redefinitionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _non_leaf_redefinitionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _non_leaf_redefinitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNon_leaf_redefinitionOperation()
        {
            return ClassInstance.LookupOperation("non_leaf_redefinition");
        }
        
        /// <summary>
        /// At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.
        ///redefinedElement->forAll(re | self.isRedefinitionContextValid(re))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_context_valid(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_context_validOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_context_valid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_context_validOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_context_validOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_context_validOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_context_validOperation()
        {
            return ClassInstance.LookupOperation("redefinition_context_valid");
        }
        
        /// <summary>
        /// The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for subclasses of RedefinableElement to define the consistency conditions.
        ///redefiningElement.isRedefinitionContextValid(self)
        ///result = (false)
        ///<p>From package UML::Classification.</p>
        /// </summary>
        /// <param name="redefiningElement"></param>
        public bool IsConsistentWith(IRedefinableElement redefiningElement)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isConsistentWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isConsistentWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isConsistentWithOperation.Value, redefiningElement);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isConsistentWithOperation.Value, e));
            bool result = handler.Invoke(this, redefiningElement);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isConsistentWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsConsistentWithOperation()
        {
            return ClassInstance.LookupOperation("isConsistentWith");
        }
        
        /// <summary>
        /// The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinition contexts of the specified element.
        ///result = (redefinitionContext->exists(c | c.allParents()->includesAll(redefinedElement.redefinitionContext)))
        ///<p>From package UML::Classification.</p>
        /// </summary>
        /// <param name="redefinedElement"></param>
        public bool IsRedefinitionContextValid(IRedefinableElement redefinedElement)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isRedefinitionContextValidOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isRedefinitionContextValid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isRedefinitionContextValidOperation.Value, redefinedElement);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isRedefinitionContextValidOperation.Value, e));
            bool result = handler.Invoke(this, redefinedElement);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isRedefinitionContextValidOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsRedefinitionContextValidOperation()
        {
            return ClassInstance.LookupOperation("isRedefinitionContextValid");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsLeafAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.RedefinableElement.ClassInstance)).Resolve("isLeaf")));
        }
        
        /// <summary>
        /// The operation containingStateMachine() returns the StateMachine in which this Vertex is defined.
        ///result = (if container <> null
        ///then
        ///-- the container is a region
        ///   container.containingStateMachine()
        ///else 
        ///   if (self.oclIsKindOf(Pseudostate)) and ((self.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint) or (self.oclAsType(Pseudostate).kind = PseudostateKind::exitPoint)) then
        ///      self.oclAsType(Pseudostate).stateMachine
        ///   else 
        ///      if (self.oclIsKindOf(ConnectionPointReference)) then
        ///          self.oclAsType(ConnectionPointReference).state.containingStateMachine() -- no other valid cases possible
        ///      else 
        ///          null
        ///      endif
        ///   endif
        ///endif
        ///)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public IStateMachine ContainingStateMachine()
        {
            System.Func<IVertex, IStateMachine> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, IStateMachine>>(_containingStateMachineOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingStateMachine registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingStateMachineOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingStateMachineOperation.Value, e));
            IStateMachine result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingStateMachineOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingStateMachineOperation()
        {
            return ClassInstance.LookupOperation("containingStateMachine");
        }
        
        /// <summary>
        /// Derivation for Vertex::/incoming.
        ///result = (Transition.allInstances()->select(target=self))
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public ISetExpression<ITransition> GetIncomings()
        {
            System.Func<IVertex, ISetExpression<ITransition>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, ISetExpression<ITransition>>>(_getIncomingsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getIncomings registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getIncomingsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getIncomingsOperation.Value, e));
            ISetExpression<ITransition> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getIncomingsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetIncomingsOperation()
        {
            return ClassInstance.LookupOperation("getIncomings");
        }
        
        /// <summary>
        /// Derivation for Vertex::/outgoing
        ///result = (Transition.allInstances()->select(source=self))
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public ISetExpression<ITransition> GetOutgoings()
        {
            System.Func<IVertex, ISetExpression<ITransition>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, ISetExpression<ITransition>>>(_getOutgoingsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOutgoings registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOutgoingsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOutgoingsOperation.Value, e));
            ISetExpression<ITransition> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOutgoingsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOutgoingsOperation()
        {
            return ClassInstance.LookupOperation("getOutgoings");
        }
        
        /// <summary>
        /// This utility operation returns true if the Vertex is contained in the State s (input argument).
        ///result = (if not s.isComposite() or container->isEmpty() then
        ///	false
        ///else
        ///	if container.state = s then 
        ///		true
        ///	else
        ///		container.state.isContainedInState(s)
        ///	endif
        ///endif)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        /// <param name="s"></param>
        public bool IsContainedInState(IState s)
        {
            System.Func<IVertex, IState, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, IState, bool>>(_isContainedInStateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isContainedInState registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isContainedInStateOperation.Value, s);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isContainedInStateOperation.Value, e));
            bool result = handler.Invoke(this, s);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isContainedInStateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsContainedInStateOperation()
        {
            return ClassInstance.LookupOperation("isContainedInState");
        }
        
        /// <summary>
        /// This utility query returns true if the Vertex is contained in the Region r (input argument).
        ///result = (if (container = r) then
        ///	true
        ///else
        ///	if (r.state->isEmpty()) then
        ///		false
        ///	else
        ///		container.state.isContainedInRegion(r)
        ///	endif
        ///endif)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        /// <param name="r"></param>
        public bool IsContainedInRegion(IRegion r)
        {
            System.Func<IVertex, IRegion, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IVertex, IRegion, bool>>(_isContainedInRegionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isContainedInRegion registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isContainedInRegionOperation.Value, r);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isContainedInRegionOperation.Value, e));
            bool result = handler.Invoke(this, r);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isContainedInRegionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsContainedInRegionOperation()
        {
            return ClassInstance.LookupOperation("isContainedInRegion");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveContainerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Vertex.ClassInstance)).Resolve("container")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanging("Container", e, _containerReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            if ((oldContainer != null))
            {
                oldContainer.Subvertex.Remove(this);
            }
            if ((newContainer != null))
            {
                newContainer.Subvertex.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanged("Container", e, _containerReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int connectionIndex = ModelHelper.IndexOfReference(this.Connection, element);
            if ((connectionIndex != -1))
            {
                return ModelHelper.CreatePath("connection", connectionIndex);
            }
            int connectionPointIndex = ModelHelper.IndexOfReference(this.ConnectionPoint, element);
            if ((connectionPointIndex != -1))
            {
                return ModelHelper.CreatePath("connectionPoint", connectionPointIndex);
            }
            int deferrableTriggerIndex = ModelHelper.IndexOfReference(this.DeferrableTrigger, element);
            if ((deferrableTriggerIndex != -1))
            {
                return ModelHelper.CreatePath("deferrableTrigger", deferrableTriggerIndex);
            }
            if ((element == this.DoActivity))
            {
                return ModelHelper.CreatePath("doActivity");
            }
            if ((element == this.Entry))
            {
                return ModelHelper.CreatePath("entry");
            }
            if ((element == this.Exit))
            {
                return ModelHelper.CreatePath("exit");
            }
            int regionIndex = ModelHelper.IndexOfReference(this.Region, element);
            if ((regionIndex != -1))
            {
                return ModelHelper.CreatePath("region", regionIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "CONNECTION"))
            {
                if ((index < this.Connection.Count))
                {
                    return this.Connection[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CONNECTIONPOINT"))
            {
                if ((index < this.ConnectionPoint.Count))
                {
                    return this.ConnectionPoint[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "DEFERRABLETRIGGER"))
            {
                if ((index < this.DeferrableTrigger.Count))
                {
                    return this.DeferrableTrigger[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "DOACTIVITY"))
            {
                return this.DoActivity;
            }
            if ((reference == "ENTRY"))
            {
                return this.Entry;
            }
            if ((reference == "EXIT"))
            {
                return this.Exit;
            }
            if ((reference == "REDEFINEDSTATE"))
            {
                return this.RedefinedState;
            }
            if ((reference == "STATEINVARIANT"))
            {
                return this.StateInvariant;
            }
            if ((reference == "SUBMACHINE"))
            {
                return this.Submachine;
            }
            if ((reference == "REGION"))
            {
                if ((index < this.Region.Count))
                {
                    return this.Region[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CONTAINER"))
            {
                return this.Container;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISLEAF"))
            {
                return this.IsLeaf;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "CONNECTION"))
            {
                return this._connection;
            }
            if ((feature == "CONNECTIONPOINT"))
            {
                return this._connectionPoint;
            }
            if ((feature == "DEFERRABLETRIGGER"))
            {
                return this._deferrableTrigger;
            }
            if ((feature == "REGION"))
            {
                return this._region;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "DOACTIVITY"))
            {
                this.DoActivity = ((IBehavior)(value));
                return;
            }
            if ((feature == "ENTRY"))
            {
                this.Entry = ((IBehavior)(value));
                return;
            }
            if ((feature == "EXIT"))
            {
                this.Exit = ((IBehavior)(value));
                return;
            }
            if ((feature == "REDEFINEDSTATE"))
            {
                this.RedefinedState = ((IState)(value));
                return;
            }
            if ((feature == "STATEINVARIANT"))
            {
                this.StateInvariant = ((IConstraint)(value));
                return;
            }
            if ((feature == "SUBMACHINE"))
            {
                this.Submachine = ((IStateMachine)(value));
                return;
            }
            if ((feature == "CONTAINER"))
            {
                this.Container = ((IRegion)(value));
                return;
            }
            if ((feature == "ISLEAF"))
            {
                this.IsLeaf = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISLEAF"))
            {
                return Observable.Box(new IsLeafProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "DOACTIVITY"))
            {
                return new DoActivityProxy(this);
            }
            if ((reference == "ENTRY"))
            {
                return new EntryProxy(this);
            }
            if ((reference == "EXIT"))
            {
                return new ExitProxy(this);
            }
            if ((reference == "REDEFINEDSTATE"))
            {
                return new RedefinedStateProxy(this);
            }
            if ((reference == "STATEINVARIANT"))
            {
                return new StateInvariantProxy(this);
            }
            if ((reference == "SUBMACHINE"))
            {
                return new SubmachineProxy(this);
            }
            if ((reference == "CONTAINER"))
            {
                return new ContainerProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._connection))
            {
                return "connection";
            }
            if ((container == this._connectionPoint))
            {
                return "connectionPoint";
            }
            if ((container == this._deferrableTrigger))
            {
                return "deferrableTrigger";
            }
            if ((container == this._region))
            {
                return "region";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//State")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the State class
        /// </summary>
        public class StateChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private State _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public StateChildrenCollection(State parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Connection.Count);
                    count = (count + this._parent.ConnectionPoint.Count);
                    count = (count + this._parent.DeferrableTrigger.Count);
                    if ((this._parent.DoActivity != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Entry != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Exit != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Region.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Connection.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.ConnectionPoint.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.DeferrableTrigger.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Region.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Connection.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.ConnectionPoint.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.DeferrableTrigger.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Region.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IConnectionPointReference connectionCasted = item.As<IConnectionPointReference>();
                if ((connectionCasted != null))
                {
                    this._parent.Connection.Add(connectionCasted);
                }
                IPseudostate connectionPointCasted = item.As<IPseudostate>();
                if ((connectionPointCasted != null))
                {
                    this._parent.ConnectionPoint.Add(connectionPointCasted);
                }
                ITrigger deferrableTriggerCasted = item.As<ITrigger>();
                if ((deferrableTriggerCasted != null))
                {
                    this._parent.DeferrableTrigger.Add(deferrableTriggerCasted);
                }
                if ((this._parent.DoActivity == null))
                {
                    IBehavior doActivityCasted = item.As<IBehavior>();
                    if ((doActivityCasted != null))
                    {
                        this._parent.DoActivity = doActivityCasted;
                        return;
                    }
                }
                if ((this._parent.Entry == null))
                {
                    IBehavior entryCasted = item.As<IBehavior>();
                    if ((entryCasted != null))
                    {
                        this._parent.Entry = entryCasted;
                        return;
                    }
                }
                if ((this._parent.Exit == null))
                {
                    IBehavior exitCasted = item.As<IBehavior>();
                    if ((exitCasted != null))
                    {
                        this._parent.Exit = exitCasted;
                        return;
                    }
                }
                IRegion regionCasted = item.As<IRegion>();
                if ((regionCasted != null))
                {
                    this._parent.Region.Add(regionCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Connection.Clear();
                this._parent.ConnectionPoint.Clear();
                this._parent.DeferrableTrigger.Clear();
                this._parent.DoActivity = null;
                this._parent.Entry = null;
                this._parent.Exit = null;
                this._parent.Region.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Connection.Contains(item))
                {
                    return true;
                }
                if (this._parent.ConnectionPoint.Contains(item))
                {
                    return true;
                }
                if (this._parent.DeferrableTrigger.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.DoActivity))
                {
                    return true;
                }
                if ((item == this._parent.Entry))
                {
                    return true;
                }
                if ((item == this._parent.Exit))
                {
                    return true;
                }
                if (this._parent.Region.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> connectionEnumerator = this._parent.Connection.GetEnumerator();
                try
                {
                    for (
                    ; connectionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = connectionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    connectionEnumerator.Dispose();
                }
                IEnumerator<IModelElement> connectionPointEnumerator = this._parent.ConnectionPoint.GetEnumerator();
                try
                {
                    for (
                    ; connectionPointEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = connectionPointEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    connectionPointEnumerator.Dispose();
                }
                IEnumerator<IModelElement> deferrableTriggerEnumerator = this._parent.DeferrableTrigger.GetEnumerator();
                try
                {
                    for (
                    ; deferrableTriggerEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = deferrableTriggerEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    deferrableTriggerEnumerator.Dispose();
                }
                if ((this._parent.DoActivity != null))
                {
                    array[arrayIndex] = this._parent.DoActivity;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Entry != null))
                {
                    array[arrayIndex] = this._parent.Entry;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Exit != null))
                {
                    array[arrayIndex] = this._parent.Exit;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> regionEnumerator = this._parent.Region.GetEnumerator();
                try
                {
                    for (
                    ; regionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = regionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    regionEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IConnectionPointReference connectionPointReferenceItem = item.As<IConnectionPointReference>();
                if (((connectionPointReferenceItem != null) 
                            && this._parent.Connection.Remove(connectionPointReferenceItem)))
                {
                    return true;
                }
                IPseudostate pseudostateItem = item.As<IPseudostate>();
                if (((pseudostateItem != null) 
                            && this._parent.ConnectionPoint.Remove(pseudostateItem)))
                {
                    return true;
                }
                ITrigger triggerItem = item.As<ITrigger>();
                if (((triggerItem != null) 
                            && this._parent.DeferrableTrigger.Remove(triggerItem)))
                {
                    return true;
                }
                if ((this._parent.DoActivity == item))
                {
                    this._parent.DoActivity = null;
                    return true;
                }
                if ((this._parent.Entry == item))
                {
                    this._parent.Entry = null;
                    return true;
                }
                if ((this._parent.Exit == item))
                {
                    this._parent.Exit = null;
                    return true;
                }
                IRegion regionItem = item.As<IRegion>();
                if (((regionItem != null) 
                            && this._parent.Region.Remove(regionItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Connection).Concat(this._parent.ConnectionPoint).Concat(this._parent.DeferrableTrigger).Concat(this._parent.DoActivity).Concat(this._parent.Entry).Concat(this._parent.Exit).Concat(this._parent.Region).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the State class
        /// </summary>
        public class StateReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private State _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public StateReferencedElementsCollection(State parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Connection.Count);
                    count = (count + this._parent.ConnectionPoint.Count);
                    count = (count + this._parent.DeferrableTrigger.Count);
                    if ((this._parent.DoActivity != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Entry != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Exit != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.RedefinedState != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.StateInvariant != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Submachine != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Region.Count);
                    if ((this._parent.Container != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Connection.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.ConnectionPoint.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.DeferrableTrigger.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Region.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Connection.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.ConnectionPoint.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.DeferrableTrigger.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Region.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IConnectionPointReference connectionCasted = item.As<IConnectionPointReference>();
                if ((connectionCasted != null))
                {
                    this._parent.Connection.Add(connectionCasted);
                }
                IPseudostate connectionPointCasted = item.As<IPseudostate>();
                if ((connectionPointCasted != null))
                {
                    this._parent.ConnectionPoint.Add(connectionPointCasted);
                }
                ITrigger deferrableTriggerCasted = item.As<ITrigger>();
                if ((deferrableTriggerCasted != null))
                {
                    this._parent.DeferrableTrigger.Add(deferrableTriggerCasted);
                }
                if ((this._parent.DoActivity == null))
                {
                    IBehavior doActivityCasted = item.As<IBehavior>();
                    if ((doActivityCasted != null))
                    {
                        this._parent.DoActivity = doActivityCasted;
                        return;
                    }
                }
                if ((this._parent.Entry == null))
                {
                    IBehavior entryCasted = item.As<IBehavior>();
                    if ((entryCasted != null))
                    {
                        this._parent.Entry = entryCasted;
                        return;
                    }
                }
                if ((this._parent.Exit == null))
                {
                    IBehavior exitCasted = item.As<IBehavior>();
                    if ((exitCasted != null))
                    {
                        this._parent.Exit = exitCasted;
                        return;
                    }
                }
                if ((this._parent.RedefinedState == null))
                {
                    IState redefinedStateCasted = item.As<IState>();
                    if ((redefinedStateCasted != null))
                    {
                        this._parent.RedefinedState = redefinedStateCasted;
                        return;
                    }
                }
                if ((this._parent.StateInvariant == null))
                {
                    IConstraint stateInvariantCasted = item.As<IConstraint>();
                    if ((stateInvariantCasted != null))
                    {
                        this._parent.StateInvariant = stateInvariantCasted;
                        return;
                    }
                }
                if ((this._parent.Submachine == null))
                {
                    IStateMachine submachineCasted = item.As<IStateMachine>();
                    if ((submachineCasted != null))
                    {
                        this._parent.Submachine = submachineCasted;
                        return;
                    }
                }
                IRegion regionCasted = item.As<IRegion>();
                if ((regionCasted != null))
                {
                    this._parent.Region.Add(regionCasted);
                }
                if ((this._parent.Container == null))
                {
                    IRegion containerCasted = item.As<IRegion>();
                    if ((containerCasted != null))
                    {
                        this._parent.Container = containerCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Connection.Clear();
                this._parent.ConnectionPoint.Clear();
                this._parent.DeferrableTrigger.Clear();
                this._parent.DoActivity = null;
                this._parent.Entry = null;
                this._parent.Exit = null;
                this._parent.RedefinedState = null;
                this._parent.StateInvariant = null;
                this._parent.Submachine = null;
                this._parent.Region.Clear();
                this._parent.Container = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Connection.Contains(item))
                {
                    return true;
                }
                if (this._parent.ConnectionPoint.Contains(item))
                {
                    return true;
                }
                if (this._parent.DeferrableTrigger.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.DoActivity))
                {
                    return true;
                }
                if ((item == this._parent.Entry))
                {
                    return true;
                }
                if ((item == this._parent.Exit))
                {
                    return true;
                }
                if ((item == this._parent.RedefinedState))
                {
                    return true;
                }
                if ((item == this._parent.StateInvariant))
                {
                    return true;
                }
                if ((item == this._parent.Submachine))
                {
                    return true;
                }
                if (this._parent.Region.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Container))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> connectionEnumerator = this._parent.Connection.GetEnumerator();
                try
                {
                    for (
                    ; connectionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = connectionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    connectionEnumerator.Dispose();
                }
                IEnumerator<IModelElement> connectionPointEnumerator = this._parent.ConnectionPoint.GetEnumerator();
                try
                {
                    for (
                    ; connectionPointEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = connectionPointEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    connectionPointEnumerator.Dispose();
                }
                IEnumerator<IModelElement> deferrableTriggerEnumerator = this._parent.DeferrableTrigger.GetEnumerator();
                try
                {
                    for (
                    ; deferrableTriggerEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = deferrableTriggerEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    deferrableTriggerEnumerator.Dispose();
                }
                if ((this._parent.DoActivity != null))
                {
                    array[arrayIndex] = this._parent.DoActivity;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Entry != null))
                {
                    array[arrayIndex] = this._parent.Entry;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Exit != null))
                {
                    array[arrayIndex] = this._parent.Exit;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.RedefinedState != null))
                {
                    array[arrayIndex] = this._parent.RedefinedState;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.StateInvariant != null))
                {
                    array[arrayIndex] = this._parent.StateInvariant;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Submachine != null))
                {
                    array[arrayIndex] = this._parent.Submachine;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> regionEnumerator = this._parent.Region.GetEnumerator();
                try
                {
                    for (
                    ; regionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = regionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    regionEnumerator.Dispose();
                }
                if ((this._parent.Container != null))
                {
                    array[arrayIndex] = this._parent.Container;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IConnectionPointReference connectionPointReferenceItem = item.As<IConnectionPointReference>();
                if (((connectionPointReferenceItem != null) 
                            && this._parent.Connection.Remove(connectionPointReferenceItem)))
                {
                    return true;
                }
                IPseudostate pseudostateItem = item.As<IPseudostate>();
                if (((pseudostateItem != null) 
                            && this._parent.ConnectionPoint.Remove(pseudostateItem)))
                {
                    return true;
                }
                ITrigger triggerItem = item.As<ITrigger>();
                if (((triggerItem != null) 
                            && this._parent.DeferrableTrigger.Remove(triggerItem)))
                {
                    return true;
                }
                if ((this._parent.DoActivity == item))
                {
                    this._parent.DoActivity = null;
                    return true;
                }
                if ((this._parent.Entry == item))
                {
                    this._parent.Entry = null;
                    return true;
                }
                if ((this._parent.Exit == item))
                {
                    this._parent.Exit = null;
                    return true;
                }
                if ((this._parent.RedefinedState == item))
                {
                    this._parent.RedefinedState = null;
                    return true;
                }
                if ((this._parent.StateInvariant == item))
                {
                    this._parent.StateInvariant = null;
                    return true;
                }
                if ((this._parent.Submachine == item))
                {
                    this._parent.Submachine = null;
                    return true;
                }
                IRegion regionItem = item.As<IRegion>();
                if (((regionItem != null) 
                            && this._parent.Region.Remove(regionItem)))
                {
                    return true;
                }
                if ((this._parent.Container == item))
                {
                    this._parent.Container = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Connection).Concat(this._parent.ConnectionPoint).Concat(this._parent.DeferrableTrigger).Concat(this._parent.DoActivity).Concat(this._parent.Entry).Concat(this._parent.Exit).Concat(this._parent.RedefinedState).Concat(this._parent.StateInvariant).Concat(this._parent.Submachine).Concat(this._parent.Region).Concat(this._parent.Container).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the doActivity property
        /// </summary>
        private sealed class DoActivityProxy : ModelPropertyChange<IState, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DoActivityProxy(IState modelElement) : 
                    base(modelElement, "doActivity")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.DoActivity;
                }
                set
                {
                    this.ModelElement.DoActivity = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the entry property
        /// </summary>
        private sealed class EntryProxy : ModelPropertyChange<IState, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public EntryProxy(IState modelElement) : 
                    base(modelElement, "entry")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.Entry;
                }
                set
                {
                    this.ModelElement.Entry = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the exit property
        /// </summary>
        private sealed class ExitProxy : ModelPropertyChange<IState, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExitProxy(IState modelElement) : 
                    base(modelElement, "exit")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.Exit;
                }
                set
                {
                    this.ModelElement.Exit = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the redefinedState property
        /// </summary>
        private sealed class RedefinedStateProxy : ModelPropertyChange<IState, IState>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RedefinedStateProxy(IState modelElement) : 
                    base(modelElement, "redefinedState")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IState Value
            {
                get
                {
                    return this.ModelElement.RedefinedState;
                }
                set
                {
                    this.ModelElement.RedefinedState = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the stateInvariant property
        /// </summary>
        private sealed class StateInvariantProxy : ModelPropertyChange<IState, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public StateInvariantProxy(IState modelElement) : 
                    base(modelElement, "stateInvariant")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.StateInvariant;
                }
                set
                {
                    this.ModelElement.StateInvariant = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the submachine property
        /// </summary>
        private sealed class SubmachineProxy : ModelPropertyChange<IState, IStateMachine>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SubmachineProxy(IState modelElement) : 
                    base(modelElement, "submachine")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IStateMachine Value
            {
                get
                {
                    return this.ModelElement.Submachine;
                }
                set
                {
                    this.ModelElement.Submachine = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isLeaf property
        /// </summary>
        private sealed class IsLeafProxy : ModelPropertyChange<IRedefinableElement, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsLeafProxy(IRedefinableElement modelElement) : 
                    base(modelElement, "isLeaf")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsLeaf;
                }
                set
                {
                    this.ModelElement.IsLeaf = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the container property
        /// </summary>
        private sealed class ContainerProxy : ModelPropertyChange<IVertex, IRegion>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ContainerProxy(IVertex modelElement) : 
                    base(modelElement, "container")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IRegion Value
            {
                get
                {
                    return this.ModelElement.Container;
                }
                set
                {
                    this.ModelElement.Container = value;
                }
            }
        }
    }
}

