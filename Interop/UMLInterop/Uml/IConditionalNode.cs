//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for ConditionalNode
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ConditionalNode))]
    [XmlDefaultImplementationTypeAttribute(typeof(ConditionalNode))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//ConditionalNode")]
    public interface IConditionalNode : IModelElement, IStructuredActivityNode
    {
        
        /// <summary>
        /// If true, the modeler asserts that the test for at least one Clause of the ConditionalNode will succeed.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isAssured")]
        [DescriptionAttribute("If true, the modeler asserts that the test for at least one Clause of the Conditi" +
            "onalNode will succeed.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("ConditionalNode")]
        [XmlElementNameAttribute("isAssured")]
        [XmlAttributeAttribute(true)]
        bool IsAssured
        {
            get;
            set;
        }
        
        /// <summary>
        /// If true, the modeler asserts that the test for at most one Clause of the ConditionalNode will succeed.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDeterminate")]
        [DescriptionAttribute("If true, the modeler asserts that the test for at most one Clause of the Conditio" +
            "nalNode will succeed.\n<p>From package UML::Actions.</p>")]
        [CategoryAttribute("ConditionalNode")]
        [XmlElementNameAttribute("isDeterminate")]
        [XmlAttributeAttribute(true)]
        bool IsDeterminate
        {
            get;
            set;
        }
        
        /// <summary>
        /// The set of Clauses composing the ConditionalNode.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("clause")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IClause> Clause
        {
            get;
        }
        
        /// <summary>
        /// The OutputPins that onto which are moved values from the bodyOutputs of the Clause selected for execution.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("result")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<IOutputPin> Result
        {
            get;
        }
        
        /// <summary>
        /// The result OutputPins have no incoming edges.
        ///result.incoming->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Result_no_incoming(object diagnostics, object context);
        
        /// <summary>
        /// A ConditionalNode has no InputPins.
        ///input->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool No_input_pins(object diagnostics, object context);
        
        /// <summary>
        /// No ExecutableNode in the ConditionNode may appear in the test or body part of more than one clause of a ConditionalNode.
        ///node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->forAll(n | 
        ///	self.clause->select(test->union(_'body')->includes(n))->size()=1)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool One_clause_with_executable_node(object diagnostics, object context);
        
        /// <summary>
        /// Each clause of a ConditionalNode must have the same number of bodyOutput pins as the ConditionalNode has result OutputPins, and each clause bodyOutput Pin must be compatible with the corresponding result OutputPin (by positional order) in type, multiplicity, ordering, and uniqueness.
        ///clause->forAll(
        ///	bodyOutput->size()=self.result->size() and
        ///	Sequence{1..self.result->size()}->forAll(i |
        ///		bodyOutput->at(i).type.conformsTo(result->at(i).type) and
        ///		bodyOutput->at(i).isOrdered = result->at(i).isOrdered and
        ///		bodyOutput->at(i).isUnique = result->at(i).isUnique and
        ///		bodyOutput->at(i).compatibleWith(result->at(i))))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Matching_output_pins(object diagnostics, object context);
        
        /// <summary>
        /// The union of the ExecutableNodes in the test and body parts of all clauses must be the same as the subset of nodes contained in the ConditionalNode (considered as a StructuredActivityNode) that are ExecutableNodes.
        ///clause.test->union(clause._'body') = node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Executable_nodes(object diagnostics, object context);
        
        /// <summary>
        /// No two clauses within a ConditionalNode may be predecessorClauses of each other, either directly or indirectly.
        ///clause->closure(predecessorClause)->intersection(clause)->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Clause_no_predecessor(object diagnostics, object context);
    }
}

