//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Gate is a MessageEnd which serves as a connection point for relating a Message which has a MessageEnd (sendEvent / receiveEvent) outside an InteractionFragment with another Message which has a MessageEnd (receiveEvent / sendEvent)  inside that InteractionFragment.
    ///<p>From package UML::Interactions.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Gate")]
    [DebuggerDisplayAttribute("Gate {Name}")]
    public partial class Gate : MessageEnd, IGate, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _actual_gate_matchedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveActual_gate_matchedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inside_cf_matchedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInside_cf_matchedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _outside_cf_matchedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOutside_cf_matchedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _formal_gate_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveFormal_gate_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _actual_gate_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveActual_gate_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _outside_cf_gate_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOutside_cf_gate_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _inside_cf_gate_distinguishableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInside_cf_gate_distinguishableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isOutsideCFOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsOutsideCFOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isInsideCFOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsInsideCFOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isActualOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsActualOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isFormalOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsFormalOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getNameOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetNameOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _matchesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMatchesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOperandOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOperandOperation);
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Gate")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// If this Gate is an actualGate, it must have exactly one matching formalGate within the referred Interaction.
        ///interactionUse->notEmpty() implies interactionUse.refersTo.formalGate->select(matches(self))->size()=1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Actual_gate_matched(object diagnostics, object context)
        {
            System.Func<IGate, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, object, object, bool>>(_actual_gate_matchedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method actual_gate_matched registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _actual_gate_matchedOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _actual_gate_matchedOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _actual_gate_matchedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveActual_gate_matchedOperation()
        {
            return ClassInstance.LookupOperation("actual_gate_matched");
        }
        
        /// <summary>
        /// If this Gate is inside a CombinedFragment, it must have exactly one matching Gate which is outside of that CombinedFragment.
        ///isInsideCF() implies combinedFragment.cfragmentGate->select(isOutsideCF() and matches(self))->size()=1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Inside_cf_matched(object diagnostics, object context)
        {
            System.Func<IGate, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, object, object, bool>>(_inside_cf_matchedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inside_cf_matched registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inside_cf_matchedOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inside_cf_matchedOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inside_cf_matchedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInside_cf_matchedOperation()
        {
            return ClassInstance.LookupOperation("inside_cf_matched");
        }
        
        /// <summary>
        /// If this Gate is outside an 'alt' CombinedFragment,  for every InteractionOperator inside that CombinedFragment there must be exactly one matching Gate inside the CombindedFragment with its opposing end enclosed by that InteractionOperator. If this Gate is outside CombinedFragment with operator other than 'alt',   there must be exactly one matching Gate inside that CombinedFragment.
        ///isOutsideCF() implies
        /// if self.combinedFragment.interactionOperator->asOrderedSet()->first() = InteractionOperatorKind::alt
        /// then self.combinedFragment.operand->forAll(op : InteractionOperand |
        /// self.combinedFragment.cfragmentGate->select(isInsideCF() and 
        /// oppositeEnd().enclosingFragment()->includes(self.combinedFragment) and matches(self))->size()=1)
        /// else  self.combinedFragment.cfragmentGate->select(isInsideCF() and matches(self))->size()=1
        /// endif
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Outside_cf_matched(object diagnostics, object context)
        {
            System.Func<IGate, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, object, object, bool>>(_outside_cf_matchedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method outside_cf_matched registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _outside_cf_matchedOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _outside_cf_matchedOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _outside_cf_matchedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOutside_cf_matchedOperation()
        {
            return ClassInstance.LookupOperation("outside_cf_matched");
        }
        
        /// <summary>
        /// isFormal() implies that no other formalGate of the parent Interaction returns the same getName() as returned for self
        ///isFormal() implies interaction.formalGate->select(getName() = self.getName())->size()=1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Formal_gate_distinguishable(object diagnostics, object context)
        {
            System.Func<IGate, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, object, object, bool>>(_formal_gate_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method formal_gate_distinguishable registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _formal_gate_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _formal_gate_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _formal_gate_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveFormal_gate_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("formal_gate_distinguishable");
        }
        
        /// <summary>
        /// isActual() implies that no other actualGate of the parent InteractionUse returns the same getName() as returned for self
        ///isActual() implies interactionUse.actualGate->select(getName() = self.getName())->size()=1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Actual_gate_distinguishable(object diagnostics, object context)
        {
            System.Func<IGate, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, object, object, bool>>(_actual_gate_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method actual_gate_distinguishable registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _actual_gate_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _actual_gate_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _actual_gate_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveActual_gate_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("actual_gate_distinguishable");
        }
        
        /// <summary>
        /// isOutsideCF() implies that no other outside cfragmentGate of the parent CombinedFragment returns the same getName() as returned for self
        ///isOutsideCF() implies combinedFragment.cfragmentGate->select(getName() = self.getName())->size()=1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Outside_cf_gate_distinguishable(object diagnostics, object context)
        {
            System.Func<IGate, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, object, object, bool>>(_outside_cf_gate_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method outside_cf_gate_distinguishable registered." +
                        " Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _outside_cf_gate_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _outside_cf_gate_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _outside_cf_gate_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOutside_cf_gate_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("outside_cf_gate_distinguishable");
        }
        
        /// <summary>
        /// isInsideCF() implies that no other inside cfragmentGate attached to a message with its other end in the same InteractionOperator as self, returns the same getName() as returned for self
        ///isInsideCF() implies
        ///let selfOperand : InteractionOperand = self.getOperand() in
        ///  combinedFragment.cfragmentGate->select(isInsideCF() and getName() = self.getName())->select(getOperand() = selfOperand)->size()=1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Inside_cf_gate_distinguishable(object diagnostics, object context)
        {
            System.Func<IGate, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, object, object, bool>>(_inside_cf_gate_distinguishableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method inside_cf_gate_distinguishable registered. " +
                        "Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _inside_cf_gate_distinguishableOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _inside_cf_gate_distinguishableOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _inside_cf_gate_distinguishableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInside_cf_gate_distinguishableOperation()
        {
            return ClassInstance.LookupOperation("inside_cf_gate_distinguishable");
        }
        
        /// <summary>
        /// This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if present)  is outside of the same CombinedFragment.
        ///result = (self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
        ///let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
        ///if oppEnd.oclIsKindOf(MessageOccurrenceSpecification) 
        ///then let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)
        ///in  self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
        ///     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
        ///     oppMOS.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
        ///     union(oppMOS.enclosingOperand.oclAsType(InteractionFragment)->asSet())
        ///else let oppGate : Gate = oppEnd.oclAsType(Gate) 
        ///in self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
        ///     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =
        ///     oppGate.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->
        ///     union(oppGate.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet())
        ///endif)
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        public bool IsOutsideCF()
        {
            System.Func<IGate, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, bool>>(_isOutsideCFOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isOutsideCF registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isOutsideCFOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isOutsideCFOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isOutsideCFOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsOutsideCFOperation()
        {
            return ClassInstance.LookupOperation("isOutsideCF");
        }
        
        /// <summary>
        /// This query returns true if this Gate is attached to the boundary of a CombinedFragment, and its other end (if present) is inside of an InteractionOperator of the same CombinedFragment.
        ///result = (self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies
        ///let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
        ///if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
        ///then let oppMOS : MessageOccurrenceSpecification
        ///= oppEnd.oclAsType(MessageOccurrenceSpecification)
        ///in combinedFragment = oppMOS.enclosingOperand.combinedFragment
        ///else let oppGate : Gate = oppEnd.oclAsType(Gate)
        ///in combinedFragment = oppGate.combinedFragment.enclosingOperand.combinedFragment
        ///endif)
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        public bool IsInsideCF()
        {
            System.Func<IGate, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, bool>>(_isInsideCFOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isInsideCF registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isInsideCFOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isInsideCFOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isInsideCFOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsInsideCFOperation()
        {
            return ClassInstance.LookupOperation("isInsideCF");
        }
        
        /// <summary>
        /// This query returns true value if this Gate is an actualGate of an InteractionUse.
        ///result = (interactionUse->notEmpty())
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        public bool IsActual()
        {
            System.Func<IGate, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, bool>>(_isActualOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isActual registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isActualOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isActualOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isActualOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsActualOperation()
        {
            return ClassInstance.LookupOperation("isActual");
        }
        
        /// <summary>
        /// This query returns true if this Gate is a formalGate of an Interaction.
        ///result = (interaction->notEmpty())
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        public bool IsFormal()
        {
            System.Func<IGate, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, bool>>(_isFormalOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isFormal registered. Use the method broker " +
                        "to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isFormalOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isFormalOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isFormalOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsFormalOperation()
        {
            return ClassInstance.LookupOperation("isFormal");
        }
        
        /// <summary>
        /// This query returns the name of the gate, either the explicit name (.name) or the constructed name ('out_" or 'in_' concatenated in front of .message.name) if the explicit name is not present.
        ///result = (if name->notEmpty() then name->asOrderedSet()->first()
        ///else  if isActual() or isOutsideCF() 
        ///  then if isSend() 
        ///    then 'out_'.concat(self.message.name->asOrderedSet()->first())
        ///    else 'in_'.concat(self.message.name->asOrderedSet()->first())
        ///    endif
        ///  else if isSend()
        ///    then 'in_'.concat(self.message.name->asOrderedSet()->first())
        ///    else 'out_'.concat(self.message.name->asOrderedSet()->first())
        ///    endif
        ///  endif
        ///endif)
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        public string GetName()
        {
            System.Func<IGate, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, string>>(_getNameOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getName registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getNameOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getNameOperation.Value, e));
            string result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getNameOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetNameOperation()
        {
            return ClassInstance.LookupOperation("getName");
        }
        
        /// <summary>
        /// This query returns true if the name of this Gate matches the name of the in parameter Gate, and the messages for the two Gates correspond. The Message for one Gate (say A) corresponds to the Message for another Gate (say B) if (A and B have the same name value) and (if A is a sendEvent then B is a receiveEvent) and (if A is a receiveEvent then B is a sendEvent) and (A and B have the same messageSort value) and (A and B have the same signature value).
        ///result = (self.getName() = gateToMatch.getName() and 
        ///self.message.messageSort = gateToMatch.message.messageSort and
        ///self.message.name = gateToMatch.message.name and
        ///self.message.sendEvent->includes(self) implies gateToMatch.message.receiveEvent->includes(gateToMatch)  and
        ///self.message.receiveEvent->includes(self) implies gateToMatch.message.sendEvent->includes(gateToMatch) and
        ///self.message.signature = gateToMatch.message.signature)
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        /// <param name="gateToMatch"></param>
        public bool Matches(IGate gateToMatch)
        {
            System.Func<IGate, IGate, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, IGate, bool>>(_matchesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method matches registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _matchesOperation.Value, gateToMatch);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _matchesOperation.Value, e));
            bool result = handler.Invoke(this, gateToMatch);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _matchesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMatchesOperation()
        {
            return ClassInstance.LookupOperation("matches");
        }
        
        /// <summary>
        /// If the Gate is an inside Combined Fragment Gate, this operation returns the InteractionOperand that the opposite end of this Gate is included within.
        ///result = (if isInsideCF() then
        ///  let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in
        ///    if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)
        ///    then let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)
        ///        in oppMOS.enclosingOperand->asOrderedSet()->first()
        ///    else let oppGate : Gate = oppEnd.oclAsType(Gate)
        ///        in oppGate.combinedFragment.enclosingOperand->asOrderedSet()->first()
        ///    endif
        ///  else null
        ///endif)
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        public IInteractionOperand GetOperand()
        {
            System.Func<IGate, IInteractionOperand> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IGate, IInteractionOperand>>(_getOperandOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOperand registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOperandOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOperandOperation.Value, e));
            IInteractionOperand result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOperandOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOperandOperation()
        {
            return ClassInstance.LookupOperation("getOperand");
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Gate")));
            }
            return _classInstance;
        }
    }
}

