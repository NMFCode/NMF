//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Port is a property of an EncapsulatedClassifier that specifies a distinct interaction point between that EncapsulatedClassifier and its environment or between the (behavior of the) EncapsulatedClassifier and its internal parts. Ports are connected to Properties of the EncapsulatedClassifier by Connectors through which requests can be made to invoke BehavioralFeatures. A Port may specify the services an EncapsulatedClassifier provides (offers) to its environment as well as the services that an EncapsulatedClassifier expects (requires) of its environment.  A Port may have an associated ProtocolStateMachine.
    ///<p>From package UML::StructuredClassifiers.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Port")]
    [DebuggerDisplayAttribute("Port {Name}")]
    public partial class Port : Property, IPort, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _port_aggregationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrievePort_aggregationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _default_valueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDefault_valueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _encapsulated_ownerOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveEncapsulated_ownerOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProvidedsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProvidedsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getRequiredsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetRequiredsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _basicProvidedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBasicProvidedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _basicRequiredOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBasicRequiredOperation);
        
        /// <summary>
        /// The backing field for the IsBehavior property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isBehavior = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isBehaviorAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsBehaviorAttribute);
        
        /// <summary>
        /// The backing field for the IsConjugated property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isConjugated = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isConjugatedAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsConjugatedAttribute);
        
        /// <summary>
        /// The backing field for the IsService property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isService = true;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isServiceAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsServiceAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _protocolReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveProtocolReference);
        
        /// <summary>
        /// The backing field for the Protocol property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IProtocolStateMachine _protocol;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedPortReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedPortReference);
        
        /// <summary>
        /// The backing field for the RedefinedPort property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IPort> _redefinedPort;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Port()
        {
            this._redefinedPort = new ObservableAssociationSet<IPort>();
            this._redefinedPort.CollectionChanging += this.RedefinedPortCollectionChanging;
            this._redefinedPort.CollectionChanged += this.RedefinedPortCollectionChanged;
        }
        
        /// <summary>
        /// Specifies whether requests arriving at this Port are sent to the classifier behavior of this EncapsulatedClassifier. Such a Port is referred to as a behavior Port. Any invocation of a BehavioralFeature targeted at a behavior Port will be handled by the instance of the owning EncapsulatedClassifier itself, rather than by any instances that it may contain.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isBehavior")]
        [DescriptionAttribute(@"Specifies whether requests arriving at this Port are sent to the classifier behavior of this EncapsulatedClassifier. Such a Port is referred to as a behavior Port. Any invocation of a BehavioralFeature targeted at a behavior Port will be handled by the instance of the owning EncapsulatedClassifier itself, rather than by any instances that it may contain.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("isBehavior")]
        [XmlAttributeAttribute(true)]
        public bool IsBehavior
        {
            get
            {
                return this._isBehavior;
            }
            set
            {
                if ((this._isBehavior != value))
                {
                    bool old = this._isBehavior;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsBehavior", e, _isBehaviorAttribute);
                    this._isBehavior = value;
                    this.OnPropertyChanged("IsBehavior", e, _isBehaviorAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies the way that the provided and required Interfaces are derived from the Port’s Type.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isConjugated")]
        [DescriptionAttribute("Specifies the way that the provided and required Interfaces are derived from the " +
            "Port’s Type.\n<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("isConjugated")]
        [XmlAttributeAttribute(true)]
        public bool IsConjugated
        {
            get
            {
                return this._isConjugated;
            }
            set
            {
                if ((this._isConjugated != value))
                {
                    bool old = this._isConjugated;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsConjugated", e, _isConjugatedAttribute);
                    this._isConjugated = value;
                    this.OnPropertyChanged("IsConjugated", e, _isConjugatedAttribute);
                }
            }
        }
        
        /// <summary>
        /// If true, indicates that this Port is used to provide the published functionality of an EncapsulatedClassifier.  If false, this Port is used to implement the EncapsulatedClassifier but is not part of the essential externally-visible functionality of the EncapsulatedClassifier and can, therefore, be altered or deleted along with the internal implementation of the EncapsulatedClassifier and other properties that are considered part of its implementation.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DefaultValueAttribute(true)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isService")]
        [DescriptionAttribute(@"If true, indicates that this Port is used to provide the published functionality of an EncapsulatedClassifier.  If false, this Port is used to implement the EncapsulatedClassifier but is not part of the essential externally-visible functionality of the EncapsulatedClassifier and can, therefore, be altered or deleted along with the internal implementation of the EncapsulatedClassifier and other properties that are considered part of its implementation.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("isService")]
        [XmlAttributeAttribute(true)]
        public bool IsService
        {
            get
            {
                return this._isService;
            }
            set
            {
                if ((this._isService != value))
                {
                    bool old = this._isService;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsService", e, _isServiceAttribute);
                    this._isService = value;
                    this.OnPropertyChanged("IsService", e, _isServiceAttribute);
                }
            }
        }
        
        /// <summary>
        /// An optional ProtocolStateMachine which describes valid interactions at this interaction point.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DisplayNameAttribute("protocol")]
        [DescriptionAttribute("An optional ProtocolStateMachine which describes valid interactions at this inter" +
            "action point.\n<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("protocol")]
        [XmlAttributeAttribute(true)]
        public IProtocolStateMachine Protocol
        {
            get
            {
                return this._protocol;
            }
            set
            {
                if ((this._protocol != value))
                {
                    IProtocolStateMachine old = this._protocol;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Protocol", e, _protocolReference);
                    this._protocol = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetProtocol;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetProtocol;
                    }
                    this.OnPropertyChanged("Protocol", e, _protocolReference);
                }
            }
        }
        
        /// <summary>
        /// A Port may be redefined when its containing EncapsulatedClassifier is specialized. The redefining Port may have additional Interfaces to those that are associated with the redefined Port or it may replace an Interface by one of its subtypes.
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedPort")]
        [DescriptionAttribute(@"A Port may be redefined when its containing EncapsulatedClassifier is specialized. The redefining Port may have additional Interfaces to those that are associated with the redefined Port or it may replace an Interface by one of its subtypes.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("redefinedPort")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IPort> RedefinedPort
        {
            get
            {
                return this._redefinedPort;
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new PortReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Port")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Port.aggregation must be composite.
        ///aggregation = AggregationKind::composite
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Port_aggregation(object diagnostics, object context)
        {
            System.Func<IPort, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, object, object, bool>>(_port_aggregationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method port_aggregation registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _port_aggregationOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _port_aggregationOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _port_aggregationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrievePort_aggregationOperation()
        {
            return ClassInstance.LookupOperation("port_aggregation");
        }
        
        /// <summary>
        /// A defaultValue for port cannot be specified when the type of the Port is an Interface.
        ///type.oclIsKindOf(Interface) implies defaultValue->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Default_value(object diagnostics, object context)
        {
            System.Func<IPort, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, object, object, bool>>(_default_valueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method default_value registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _default_valueOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _default_valueOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _default_valueOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDefault_valueOperation()
        {
            return ClassInstance.LookupOperation("default_value");
        }
        
        /// <summary>
        /// All Ports are owned by an EncapsulatedClassifier.
        ///owner = encapsulatedClassifier
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Encapsulated_owner(object diagnostics, object context)
        {
            System.Func<IPort, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, object, object, bool>>(_encapsulated_ownerOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method encapsulated_owner registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _encapsulated_ownerOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _encapsulated_ownerOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _encapsulated_ownerOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveEncapsulated_ownerOperation()
        {
            return ClassInstance.LookupOperation("encapsulated_owner");
        }
        
        /// <summary>
        /// Derivation for Port::/provided
        ///result = (if isConjugated then basicRequired() else basicProvided() endif)
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        public ISetExpression<IInterface> GetProvideds()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_getProvidedsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProvideds registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProvidedsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProvidedsOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProvidedsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProvidedsOperation()
        {
            return ClassInstance.LookupOperation("getProvideds");
        }
        
        /// <summary>
        /// Derivation for Port::/required
        ///result = (if isConjugated then basicProvided() else basicRequired() endif)
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        public ISetExpression<IInterface> GetRequireds()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_getRequiredsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getRequireds registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getRequiredsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getRequiredsOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getRequiredsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetRequiredsOperation()
        {
            return ClassInstance.LookupOperation("getRequireds");
        }
        
        /// <summary>
        /// The union of the sets of Interfaces realized by the type of the Port and its supertypes, or directly the type of the Port if the Port is typed by an Interface.
        ///result = (if type.oclIsKindOf(Interface) 
        ///then type.oclAsType(Interface)->asSet() 
        ///else type.oclAsType(Classifier).allRealizedInterfaces() 
        ///endif)
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        public ISetExpression<IInterface> BasicProvided()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_basicProvidedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method basicProvided registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _basicProvidedOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _basicProvidedOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _basicProvidedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBasicProvidedOperation()
        {
            return ClassInstance.LookupOperation("basicProvided");
        }
        
        /// <summary>
        /// The union of the sets of Interfaces used by the type of the Port and its supertypes.
        ///result = ( type.oclAsType(Classifier).allUsedInterfaces() )
        ///<p>From package UML::StructuredClassifiers.</p>
        /// </summary>
        public ISetExpression<IInterface> BasicRequired()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_basicRequiredOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method basicRequired registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _basicRequiredOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _basicRequiredOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _basicRequiredOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBasicRequiredOperation()
        {
            return ClassInstance.LookupOperation("basicRequired");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsBehaviorAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("isBehavior")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsConjugatedAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("isConjugated")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsServiceAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("isService")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveProtocolReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("protocol")));
        }
        
        /// <summary>
        /// Handles the event that the Protocol property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetProtocol(object sender, System.EventArgs eventArgs)
        {
            this.Protocol = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedPortReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("redefinedPort")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedPort property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedPortCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedPort", e, _redefinedPortReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedPort property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedPortCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedPort", e, _redefinedPortReference);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "PROTOCOL"))
            {
                return this.Protocol;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISBEHAVIOR"))
            {
                return this.IsBehavior;
            }
            if ((attribute == "ISCONJUGATED"))
            {
                return this.IsConjugated;
            }
            if ((attribute == "ISSERVICE"))
            {
                return this.IsService;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "REDEFINEDPORT"))
            {
                return this._redefinedPort;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "PROTOCOL"))
            {
                this.Protocol = ((IProtocolStateMachine)(value));
                return;
            }
            if ((feature == "ISBEHAVIOR"))
            {
                this.IsBehavior = ((bool)(value));
                return;
            }
            if ((feature == "ISCONJUGATED"))
            {
                this.IsConjugated = ((bool)(value));
                return;
            }
            if ((feature == "ISSERVICE"))
            {
                this.IsService = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISBEHAVIOR"))
            {
                return Observable.Box(new IsBehaviorProxy(this));
            }
            if ((attribute == "ISCONJUGATED"))
            {
                return Observable.Box(new IsConjugatedProxy(this));
            }
            if ((attribute == "ISSERVICE"))
            {
                return Observable.Box(new IsServiceProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "PROTOCOL"))
            {
                return new ProtocolProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Port")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Port class
        /// </summary>
        public class PortReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Port _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public PortReferencedElementsCollection(Port parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Protocol != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.RedefinedPort.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.RedefinedPort.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.RedefinedPort.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Protocol == null))
                {
                    IProtocolStateMachine protocolCasted = item.As<IProtocolStateMachine>();
                    if ((protocolCasted != null))
                    {
                        this._parent.Protocol = protocolCasted;
                        return;
                    }
                }
                IPort redefinedPortCasted = item.As<IPort>();
                if ((redefinedPortCasted != null))
                {
                    this._parent.RedefinedPort.Add(redefinedPortCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Protocol = null;
                this._parent.RedefinedPort.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Protocol))
                {
                    return true;
                }
                if (this._parent.RedefinedPort.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Protocol != null))
                {
                    array[arrayIndex] = this._parent.Protocol;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> redefinedPortEnumerator = this._parent.RedefinedPort.GetEnumerator();
                try
                {
                    for (
                    ; redefinedPortEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = redefinedPortEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    redefinedPortEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Protocol == item))
                {
                    this._parent.Protocol = null;
                    return true;
                }
                IPort portItem = item.As<IPort>();
                if (((portItem != null) 
                            && this._parent.RedefinedPort.Remove(portItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Protocol).Concat(this._parent.RedefinedPort).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isBehavior property
        /// </summary>
        private sealed class IsBehaviorProxy : ModelPropertyChange<IPort, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsBehaviorProxy(IPort modelElement) : 
                    base(modelElement, "isBehavior")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsBehavior;
                }
                set
                {
                    this.ModelElement.IsBehavior = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isConjugated property
        /// </summary>
        private sealed class IsConjugatedProxy : ModelPropertyChange<IPort, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsConjugatedProxy(IPort modelElement) : 
                    base(modelElement, "isConjugated")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsConjugated;
                }
                set
                {
                    this.ModelElement.IsConjugated = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isService property
        /// </summary>
        private sealed class IsServiceProxy : ModelPropertyChange<IPort, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsServiceProxy(IPort modelElement) : 
                    base(modelElement, "isService")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsService;
                }
                set
                {
                    this.ModelElement.IsService = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the protocol property
        /// </summary>
        private sealed class ProtocolProxy : ModelPropertyChange<IPort, IProtocolStateMachine>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ProtocolProxy(IPort modelElement) : 
                    base(modelElement, "protocol")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IProtocolStateMachine Value
            {
                get
                {
                    return this.ModelElement.Protocol;
                }
                set
                {
                    this.ModelElement.Protocol = value;
                }
            }
        }
    }
}

