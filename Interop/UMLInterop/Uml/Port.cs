//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Port is a property of an EncapsulatedClassifier that specifies a distinct interaction point between that EncapsulatedClassifier and its environment or between the (behavior of the) EncapsulatedClassifier and its internal parts. Ports are connected to Properties of the EncapsulatedClassifier by Connectors through which requests can be made to invoke BehavioralFeatures. A Port may specify the services an EncapsulatedClassifier provides (offers) to its environment as well as the services that an EncapsulatedClassifier expects (requires) of its environment.  A Port may have an associated ProtocolStateMachine.
    ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Port")]
    [DebuggerDisplayAttribute("Port {Name}")]
    public partial class Port : StructuralFeature, IPort, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _port_aggregationOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrievePort_aggregationOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _default_valueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDefault_valueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _encapsulated_ownerOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveEncapsulated_ownerOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getProvidedsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetProvidedsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getRequiredsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetRequiredsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _basicProvidedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBasicProvidedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _basicRequiredOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBasicRequiredOperation);
        
        /// <summary>
        /// The backing field for the IsBehavior property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isBehavior = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isBehaviorAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsBehaviorAttribute);
        
        /// <summary>
        /// The backing field for the IsConjugated property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isConjugated = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isConjugatedAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsConjugatedAttribute);
        
        /// <summary>
        /// The backing field for the IsService property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isService = true;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isServiceAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsServiceAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _protocolReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveProtocolReference);
        
        /// <summary>
        /// The backing field for the Protocol property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IProtocolStateMachine _protocol;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedPortReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedPortReference);
        
        /// <summary>
        /// The backing field for the RedefinedPort property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IPort> _redefinedPort;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _subsetting_context_conformsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubsetting_context_conformsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _derived_union_is_read_onlyOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDerived_union_is_read_onlyOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _multiplicity_of_compositeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMultiplicity_of_compositeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefined_property_inheritedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefined_property_inheritedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _subsetting_rulesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubsetting_rulesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _binding_to_attributeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveBinding_to_attributeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _derived_union_is_derivedOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDerived_union_is_derivedOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _deployment_targetOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveDeployment_targetOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _subsetted_property_namesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubsetted_property_namesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _type_of_opposite_endOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveType_of_opposite_endOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _qualified_is_association_endOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveQualified_is_association_endOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getDefaultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetDefaultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOtherEndOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOtherEndOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isSetDefaultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsSetDefaultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setBooleanDefaultValueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetBooleanDefaultValueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setDefaultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetDefaultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setIntegerDefaultValueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetIntegerDefaultValueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setIsCompositeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetIsCompositeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setIsNavigableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetIsNavigableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setNullDefaultValueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetNullDefaultValueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setOppositeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetOppositeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setRealDefaultValueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetRealDefaultValueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setStringDefaultValueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetStringDefaultValueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _setUnlimitedNaturalDefaultValueOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSetUnlimitedNaturalDefaultValueOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _unsetDefaultOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveUnsetDefaultOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isAttributeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsAttributeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isNavigableOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsNavigableOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getOppositeOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetOppositeOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _subsettingContextOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSubsettingContextOperation);
        
        /// <summary>
        /// The backing field for the Aggregation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private AggregationKind _aggregation = AggregationKind.None;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _aggregationAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveAggregationAttribute);
        
        /// <summary>
        /// The backing field for the IsDerived property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isDerived = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isDerivedAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsDerivedAttribute);
        
        /// <summary>
        /// The backing field for the IsDerivedUnion property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isDerivedUnion = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isDerivedUnionAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsDerivedUnionAttribute);
        
        /// <summary>
        /// The backing field for the IsID property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isID = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isIDAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsIDAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _datatypeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDatatypeReference);
        
        /// <summary>
        /// The backing field for the Datatype property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NMF.Interop.Uml.IDataType _datatype;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _interfaceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveInterfaceReference);
        
        /// <summary>
        /// The backing field for the Interface property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IInterface _interface;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _associationEndReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveAssociationEndReference);
        
        /// <summary>
        /// The backing field for the AssociationEnd property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IProperty _associationEnd;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _qualifierReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveQualifierReference);
        
        /// <summary>
        /// The backing field for the Qualifier property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PropertyQualifierCollection _qualifier;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _classReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveClassReference);
        
        /// <summary>
        /// The backing field for the Class property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private NMF.Interop.Uml.IClass _class;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _defaultValueReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDefaultValueReference);
        
        /// <summary>
        /// The backing field for the DefaultValue property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IValueSpecification _defaultValue;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningAssociationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningAssociationReference);
        
        /// <summary>
        /// The backing field for the OwningAssociation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IAssociation _owningAssociation;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _subsettedPropertyReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSubsettedPropertyReference);
        
        /// <summary>
        /// The backing field for the SubsettedProperty property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IProperty> _subsettedProperty;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getEndsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetEndsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isCompatibleWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsCompatibleWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isTemplateParameterOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsTemplateParameterOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _owningTemplateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveOwningTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the OwningTemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _owningTemplateParameter;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _templateParameterReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTemplateParameterReference);
        
        /// <summary>
        /// The backing field for the TemplateParameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITemplateParameter _templateParameter;
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getDeployedElementsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetDeployedElementsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _deploymentReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveDeploymentReference);
        
        /// <summary>
        /// The backing field for the Deployment property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private DeploymentTargetDeploymentCollection _deployment;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Port()
        {
            this._redefinedPort = new ObservableAssociationSet<IPort>();
            this._redefinedPort.CollectionChanging += this.RedefinedPortCollectionChanging;
            this._redefinedPort.CollectionChanged += this.RedefinedPortCollectionChanged;
            this._qualifier = new PropertyQualifierCollection(this);
            this._qualifier.CollectionChanging += this.QualifierCollectionChanging;
            this._qualifier.CollectionChanged += this.QualifierCollectionChanged;
            this._subsettedProperty = new ObservableAssociationSet<IProperty>();
            this._subsettedProperty.CollectionChanging += this.SubsettedPropertyCollectionChanging;
            this._subsettedProperty.CollectionChanged += this.SubsettedPropertyCollectionChanged;
            this._deployment = new DeploymentTargetDeploymentCollection(this);
            this._deployment.CollectionChanging += this.DeploymentCollectionChanging;
            this._deployment.CollectionChanged += this.DeploymentCollectionChanged;
        }
        
        /// <summary>
        /// Specifies whether requests arriving at this Port are sent to the classifier behavior of this EncapsulatedClassifier. Such a Port is referred to as a behavior Port. Any invocation of a BehavioralFeature targeted at a behavior Port will be handled by the instance of the owning EncapsulatedClassifier itself, rather than by any instances that it may contain.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isBehavior")]
        [DescriptionAttribute(@"Specifies whether requests arriving at this Port are sent to the classifier behavior of this EncapsulatedClassifier. Such a Port is referred to as a behavior Port. Any invocation of a BehavioralFeature targeted at a behavior Port will be handled by the instance of the owning EncapsulatedClassifier itself, rather than by any instances that it may contain.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("isBehavior")]
        [XmlAttributeAttribute(true)]
        public bool IsBehavior
        {
            get
            {
                return this._isBehavior;
            }
            set
            {
                if ((this._isBehavior != value))
                {
                    bool old = this._isBehavior;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsBehavior", e, _isBehaviorAttribute);
                    this._isBehavior = value;
                    this.OnPropertyChanged("IsBehavior", e, _isBehaviorAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies the way that the provided and required Interfaces are derived from the Port’s Type.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isConjugated")]
        [DescriptionAttribute("Specifies the way that the provided and required Interfaces are derived from the " +
            "Port’s Type.\n<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("isConjugated")]
        [XmlAttributeAttribute(true)]
        public bool IsConjugated
        {
            get
            {
                return this._isConjugated;
            }
            set
            {
                if ((this._isConjugated != value))
                {
                    bool old = this._isConjugated;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsConjugated", e, _isConjugatedAttribute);
                    this._isConjugated = value;
                    this.OnPropertyChanged("IsConjugated", e, _isConjugatedAttribute);
                }
            }
        }
        
        /// <summary>
        /// If true, indicates that this Port is used to provide the published functionality of an EncapsulatedClassifier.  If false, this Port is used to implement the EncapsulatedClassifier but is not part of the essential externally-visible functionality of the EncapsulatedClassifier and can, therefore, be altered or deleted along with the internal implementation of the EncapsulatedClassifier and other properties that are considered part of its implementation.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(true)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isService")]
        [DescriptionAttribute(@"If true, indicates that this Port is used to provide the published functionality of an EncapsulatedClassifier.  If false, this Port is used to implement the EncapsulatedClassifier but is not part of the essential externally-visible functionality of the EncapsulatedClassifier and can, therefore, be altered or deleted along with the internal implementation of the EncapsulatedClassifier and other properties that are considered part of its implementation.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("isService")]
        [XmlAttributeAttribute(true)]
        public bool IsService
        {
            get
            {
                return this._isService;
            }
            set
            {
                if ((this._isService != value))
                {
                    bool old = this._isService;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsService", e, _isServiceAttribute);
                    this._isService = value;
                    this.OnPropertyChanged("IsService", e, _isServiceAttribute);
                }
            }
        }
        
        /// <summary>
        /// An optional ProtocolStateMachine which describes valid interactions at this interaction point.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("protocol")]
        [DescriptionAttribute("An optional ProtocolStateMachine which describes valid interactions at this inter" +
            "action point.\n<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("protocol")]
        [XmlAttributeAttribute(true)]
        public IProtocolStateMachine Protocol
        {
            get
            {
                return this._protocol;
            }
            set
            {
                if ((this._protocol != value))
                {
                    IProtocolStateMachine old = this._protocol;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Protocol", e, _protocolReference);
                    this._protocol = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetProtocol;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetProtocol;
                    }
                    this.OnPropertyChanged("Protocol", e, _protocolReference);
                }
            }
        }
        
        /// <summary>
        /// A Port may be redefined when its containing EncapsulatedClassifier is specialized. The redefining Port may have additional Interfaces to those that are associated with the redefined Port or it may replace an Interface by one of its subtypes.
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("redefinedPort")]
        [DescriptionAttribute(@"A Port may be redefined when its containing EncapsulatedClassifier is specialized. The redefining Port may have additional Interfaces to those that are associated with the redefined Port or it may replace an Interface by one of its subtypes.
<p>From package UML::StructuredClassifiers.</p>")]
        [CategoryAttribute("Port")]
        [XmlElementNameAttribute("redefinedPort")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IPort> RedefinedPort
        {
            get
            {
                return this._redefinedPort;
            }
        }
        
        ICollectionExpression<IProperty> IProperty.RedefinedProperty
        {
            get
            {
                return new PortRedefinedPropertyCollection(this);
            }
        }
        
        /// <summary>
        /// Specifies the kind of aggregation that applies to the Property.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(AggregationKind.None)]
        [DisplayNameAttribute("aggregation")]
        [DescriptionAttribute("Specifies the kind of aggregation that applies to the Property.\n<p>From package U" +
            "ML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("aggregation")]
        [XmlAttributeAttribute(true)]
        public AggregationKind Aggregation
        {
            get
            {
                return this._aggregation;
            }
            set
            {
                if ((this._aggregation != value))
                {
                    AggregationKind old = this._aggregation;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Aggregation", e, _aggregationAttribute);
                    this._aggregation = value;
                    this.OnPropertyChanged("Aggregation", e, _aggregationAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies whether the Property is derived, i.e., whether its value or values can be computed from other information.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerived")]
        [DescriptionAttribute("Specifies whether the Property is derived, i.e., whether its value or values can " +
            "be computed from other information.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerived")]
        [XmlAttributeAttribute(true)]
        public bool IsDerived
        {
            get
            {
                return this._isDerived;
            }
            set
            {
                if ((this._isDerived != value))
                {
                    bool old = this._isDerived;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsDerived", e, _isDerivedAttribute);
                    this._isDerived = value;
                    this.OnPropertyChanged("IsDerived", e, _isDerivedAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies whether the property is derived as the union of all of the Properties that are constrained to subset it.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isDerivedUnion")]
        [DescriptionAttribute("Specifies whether the property is derived as the union of all of the Properties t" +
            "hat are constrained to subset it.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isDerivedUnion")]
        [XmlAttributeAttribute(true)]
        public bool IsDerivedUnion
        {
            get
            {
                return this._isDerivedUnion;
            }
            set
            {
                if ((this._isDerivedUnion != value))
                {
                    bool old = this._isDerivedUnion;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsDerivedUnion", e, _isDerivedUnionAttribute);
                    this._isDerivedUnion = value;
                    this.OnPropertyChanged("IsDerivedUnion", e, _isDerivedUnionAttribute);
                }
            }
        }
        
        /// <summary>
        /// True indicates this property can be used to uniquely identify an instance of the containing Class.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isID")]
        [DescriptionAttribute("True indicates this property can be used to uniquely identify an instance of the " +
            "containing Class.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("isID")]
        [XmlAttributeAttribute(true)]
        public bool IsID
        {
            get
            {
                return this._isID;
            }
            set
            {
                if ((this._isID != value))
                {
                    bool old = this._isID;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsID", e, _isIDAttribute);
                    this._isID = value;
                    this.OnPropertyChanged("IsID", e, _isIDAttribute);
                }
            }
        }
        
        /// <summary>
        /// The DataType that owns this Property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("datatype")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedAttribute")]
        public NMF.Interop.Uml.IDataType Datatype
        {
            get
            {
                return this._datatype;
            }
            set
            {
                if ((this._datatype != value))
                {
                    NMF.Interop.Uml.IDataType old = this._datatype;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Datatype", e, _datatypeReference);
                    this._datatype = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedAttribute.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedAttribute.Add(this);
                    }
                    this.OnPropertyChanged("Datatype", e, _datatypeReference);
                }
            }
        }
        
        /// <summary>
        /// The Interface that owns this Property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("interface")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("ownedAttribute")]
        public IInterface Interface
        {
            get
            {
                return this._interface;
            }
            set
            {
                if ((this._interface != value))
                {
                    IInterface old = this._interface;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Interface", e, _interfaceReference);
                    this._interface = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.OwnedAttribute.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.OwnedAttribute.Add(this);
                    }
                    this.OnPropertyChanged("Interface", e, _interfaceReference);
                }
            }
        }
        
        /// <summary>
        /// Designates the optional association end that owns a qualifier attribute.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("associationEnd")]
        [XmlAttributeAttribute(true)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlOppositeAttribute("qualifier")]
        public IProperty AssociationEnd
        {
            get
            {
                return this._associationEnd;
            }
            set
            {
                if ((this._associationEnd != value))
                {
                    IProperty old = this._associationEnd;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("AssociationEnd", e, _associationEndReference);
                    this._associationEnd = value;
                    this.Parent = value;
                    if ((old != null))
                    {
                        old.Qualifier.Remove(this);
                    }
                    if ((value != null))
                    {
                        value.Qualifier.Add(this);
                    }
                    this.OnPropertyChanged("AssociationEnd", e, _associationEndReference);
                }
            }
        }
        
        /// <summary>
        /// An optional list of ordered qualifier attributes for the end.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("qualifier")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("associationEnd")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IProperty> Qualifier
        {
            get
            {
                return this._qualifier;
            }
        }
        
        /// <summary>
        /// The Class that owns this Property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("class")]
        [DescriptionAttribute("The Class that owns this Property, if any.\n<p>From package UML::Classification.</" +
            "p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("class")]
        [XmlAttributeAttribute(true)]
        public NMF.Interop.Uml.IClass Class
        {
            get
            {
                return this._class;
            }
            set
            {
                if ((this._class != value))
                {
                    NMF.Interop.Uml.IClass old = this._class;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Class", e, _classReference);
                    this._class = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetClass;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetClass;
                    }
                    this.OnPropertyChanged("Class", e, _classReference);
                }
            }
        }
        
        /// <summary>
        /// A ValueSpecification that is evaluated to give a default value for the Property when an instance of the owning Classifier is instantiated.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("defaultValue")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IValueSpecification DefaultValue
        {
            get
            {
                return this._defaultValue;
            }
            set
            {
                if ((this._defaultValue != value))
                {
                    IValueSpecification old = this._defaultValue;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("DefaultValue", e, _defaultValueReference);
                    this._defaultValue = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetDefaultValue;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetDefaultValue;
                    }
                    this.OnPropertyChanged("DefaultValue", e, _defaultValueReference);
                }
            }
        }
        
        /// <summary>
        /// The owning association of this property, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("owningAssociation")]
        [DescriptionAttribute("The owning association of this property, if any.\n<p>From package UML::Classificat" +
            "ion.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("owningAssociation")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedEnd")]
        public IAssociation OwningAssociation
        {
            get
            {
                return this._owningAssociation;
            }
            set
            {
                if ((this._owningAssociation != value))
                {
                    IAssociation old = this._owningAssociation;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwningAssociation", e, _owningAssociationReference);
                    this._owningAssociation = value;
                    if ((old != null))
                    {
                        old.OwnedEnd.Remove(this);
                        old.Deleted -= this.OnResetOwningAssociation;
                    }
                    if ((value != null))
                    {
                        if ((value.OwnedEnd.Contains(this) != true))
                        {
                            value.OwnedEnd.Add(this);
                        }
                        value.Deleted += this.OnResetOwningAssociation;
                    }
                    this.OnPropertyChanged("OwningAssociation", e, _owningAssociationReference);
                }
            }
        }
        
        /// <summary>
        /// The properties of which this Property is constrained to be a subset, if any.
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("subsettedProperty")]
        [DescriptionAttribute("The properties of which this Property is constrained to be a subset, if any.\n<p>F" +
            "rom package UML::Classification.</p>")]
        [CategoryAttribute("Property")]
        [XmlElementNameAttribute("subsettedProperty")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IProperty> SubsettedProperty
        {
            get
            {
                return this._subsettedProperty;
            }
        }
        
        IAssociation IProperty.Association
        {
            get
            {
                IProperty _this = this;
                return _this.OwningAssociation;
            }
            set
            {
                IProperty _this = this;
                _this.OwningAssociation = value;
            }
        }
        
        /// <summary>
        /// The formal TemplateParameter that owns this ParameterableElement.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("owningTemplateParameter")]
        [DescriptionAttribute("The formal TemplateParameter that owns this ParameterableElement.\n<p>From package" +
            " UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("owningTemplateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("ownedParameteredElement")]
        public ITemplateParameter OwningTemplateParameter
        {
            get
            {
                return this._owningTemplateParameter;
            }
            set
            {
                if ((this._owningTemplateParameter != value))
                {
                    ITemplateParameter old = this._owningTemplateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("OwningTemplateParameter", e, _owningTemplateParameterReference);
                    this._owningTemplateParameter = value;
                    if ((old != null))
                    {
                        old.OwnedParameteredElement = null;
                        old.Deleted -= this.OnResetOwningTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.OwnedParameteredElement = this;
                        value.Deleted += this.OnResetOwningTemplateParameter;
                    }
                    this.OnPropertyChanged("OwningTemplateParameter", e, _owningTemplateParameterReference);
                }
            }
        }
        
        /// <summary>
        /// The TemplateParameter that exposes this ParameterableElement as a formal parameter.
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        [DisplayNameAttribute("templateParameter")]
        [DescriptionAttribute("The TemplateParameter that exposes this ParameterableElement as a formal paramete" +
            "r.\n<p>From package UML::CommonStructure.</p>")]
        [CategoryAttribute("ParameterableElement")]
        [XmlElementNameAttribute("templateParameter")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("parameteredElement")]
        public ITemplateParameter TemplateParameter
        {
            get
            {
                return this._templateParameter;
            }
            set
            {
                if ((this._templateParameter != value))
                {
                    ITemplateParameter old = this._templateParameter;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TemplateParameter", e, _templateParameterReference);
                    this._templateParameter = value;
                    if ((old != null))
                    {
                        old.ParameteredElement = null;
                        old.Deleted -= this.OnResetTemplateParameter;
                    }
                    if ((value != null))
                    {
                        value.ParameteredElement = this;
                        value.Deleted += this.OnResetTemplateParameter;
                    }
                    this.OnPropertyChanged("TemplateParameter", e, _templateParameterReference);
                }
            }
        }
        
        ITemplateParameter IParameterableElement.TemplateParameter
        {
            get
            {
                IParameterableElement _this = this;
                return _this.OwningTemplateParameter;
            }
            set
            {
                IParameterableElement _this = this;
                _this.OwningTemplateParameter = value;
            }
        }
        
        /// <summary>
        /// The set of Deployments for a DeploymentTarget.
        ///&lt;p&gt;From package UML::Deployments.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("deployment")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("location")]
        [ConstantAttribute()]
        public IOrderedSetExpression<IDeployment> Deployment
        {
            get
            {
                return this._deployment;
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new PortReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Port")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Port.aggregation must be composite.
        ///aggregation = AggregationKind::composite
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Port_aggregation(object diagnostics, object context)
        {
            System.Func<IPort, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, object, object, bool>>(_port_aggregationOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method port_aggregation registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _port_aggregationOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _port_aggregationOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _port_aggregationOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrievePort_aggregationOperation()
        {
            return ClassInstance.LookupOperation("port_aggregation");
        }
        
        /// <summary>
        /// A defaultValue for port cannot be specified when the type of the Port is an Interface.
        ///type.oclIsKindOf(Interface) implies defaultValue-&gt;isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Default_value(object diagnostics, object context)
        {
            System.Func<IPort, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, object, object, bool>>(_default_valueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method default_value registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _default_valueOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _default_valueOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _default_valueOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDefault_valueOperation()
        {
            return ClassInstance.LookupOperation("default_value");
        }
        
        /// <summary>
        /// All Ports are owned by an EncapsulatedClassifier.
        ///owner = encapsulatedClassifier
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Encapsulated_owner(object diagnostics, object context)
        {
            System.Func<IPort, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, object, object, bool>>(_encapsulated_ownerOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method encapsulated_owner registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _encapsulated_ownerOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _encapsulated_ownerOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _encapsulated_ownerOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveEncapsulated_ownerOperation()
        {
            return ClassInstance.LookupOperation("encapsulated_owner");
        }
        
        /// <summary>
        /// Derivation for Port::/provided
        ///result = (if isConjugated then basicRequired() else basicProvided() endif)
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> GetProvideds()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_getProvidedsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getProvideds registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getProvidedsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getProvidedsOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getProvidedsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetProvidedsOperation()
        {
            return ClassInstance.LookupOperation("getProvideds");
        }
        
        /// <summary>
        /// Derivation for Port::/required
        ///result = (if isConjugated then basicProvided() else basicRequired() endif)
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> GetRequireds()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_getRequiredsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getRequireds registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getRequiredsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getRequiredsOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getRequiredsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetRequiredsOperation()
        {
            return ClassInstance.LookupOperation("getRequireds");
        }
        
        /// <summary>
        /// The union of the sets of Interfaces realized by the type of the Port and its supertypes, or directly the type of the Port if the Port is typed by an Interface.
        ///result = (if type.oclIsKindOf(Interface) 
        ///then type.oclAsType(Interface)-&gt;asSet() 
        ///else type.oclAsType(Classifier).allRealizedInterfaces() 
        ///endif)
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> BasicProvided()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_basicProvidedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method basicProvided registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _basicProvidedOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _basicProvidedOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _basicProvidedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBasicProvidedOperation()
        {
            return ClassInstance.LookupOperation("basicProvided");
        }
        
        /// <summary>
        /// The union of the sets of Interfaces used by the type of the Port and its supertypes.
        ///result = ( type.oclAsType(Classifier).allUsedInterfaces() )
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IInterface> BasicRequired()
        {
            System.Func<IPort, ISetExpression<IInterface>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IPort, ISetExpression<IInterface>>>(_basicRequiredOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method basicRequired registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _basicRequiredOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _basicRequiredOperation.Value, e));
            ISetExpression<IInterface> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _basicRequiredOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBasicRequiredOperation()
        {
            return ClassInstance.LookupOperation("basicRequired");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsBehaviorAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("isBehavior")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsConjugatedAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("isConjugated")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsServiceAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("isService")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveProtocolReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("protocol")));
        }
        
        /// <summary>
        /// Handles the event that the Protocol property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetProtocol(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Protocol))
            {
                this.Protocol = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedPortReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Port.ClassInstance)).Resolve("redefinedPort")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RedefinedPort property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedPortCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RedefinedPort", e, _redefinedPortReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RedefinedPort property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RedefinedPortCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RedefinedPort", e, _redefinedPortReference);
        }
        
        /// <summary>
        /// Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.
        ///subsettedProperty-&gt;notEmpty() implies
        ///  (subsettingContext()-&gt;notEmpty() and subsettingContext()-&gt;forAll (sc |
        ///    subsettedProperty-&gt;forAll(sp |
        ///      sp.subsettingContext()-&gt;exists(c | sc.conformsTo(c)))))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Subsetting_context_conforms(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_subsetting_context_conformsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method subsetting_context_conforms registered. Use" +
                        " the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _subsetting_context_conformsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _subsetting_context_conformsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _subsetting_context_conformsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubsetting_context_conformsOperation()
        {
            return ClassInstance.LookupOperation("subsetting_context_conforms");
        }
        
        /// <summary>
        /// A derived union is read only.
        ///isDerivedUnion implies isReadOnly
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Derived_union_is_read_only(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_derived_union_is_read_onlyOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method derived_union_is_read_only registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _derived_union_is_read_onlyOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _derived_union_is_read_onlyOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _derived_union_is_read_onlyOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDerived_union_is_read_onlyOperation()
        {
            return ClassInstance.LookupOperation("derived_union_is_read_only");
        }
        
        /// <summary>
        /// A multiplicity on the composing end of a composite aggregation must not have an upper bound greater than 1.
        ///isComposite and association &lt;&gt; null implies opposite.upperBound() &lt;= 1
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Multiplicity_of_composite(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_multiplicity_of_compositeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method multiplicity_of_composite registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _multiplicity_of_compositeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _multiplicity_of_compositeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _multiplicity_of_compositeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMultiplicity_of_compositeOperation()
        {
            return ClassInstance.LookupOperation("multiplicity_of_composite");
        }
        
        /// <summary>
        /// A redefined Property must be inherited from a more general Classifier.
        ///(redefinedProperty-&gt;notEmpty()) implies
        ///  (redefinitionContext-&gt;notEmpty() and
        ///      redefinedProperty-&gt;forAll(rp|
        ///        ((redefinitionContext-&gt;collect(fc|
        ///          fc.allParents()))-&gt;asSet())-&gt;collect(c| c.allFeatures())-&gt;asSet()-&gt;includes(rp)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefined_property_inherited(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_redefined_property_inheritedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefined_property_inherited registered. Us" +
                        "e the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefined_property_inheritedOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefined_property_inheritedOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefined_property_inheritedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefined_property_inheritedOperation()
        {
            return ClassInstance.LookupOperation("redefined_property_inherited");
        }
        
        /// <summary>
        /// A subsetting Property may strengthen the type of the subsetted Property, and its upper bound may be less.
        ///subsettedProperty-&gt;forAll(sp |
        ///  self.type.conformsTo(sp.type) and
        ///    ((self.upperBound()-&gt;notEmpty() and sp.upperBound()-&gt;notEmpty()) implies
        ///      self.upperBound() &lt;= sp.upperBound() ))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Subsetting_rules(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_subsetting_rulesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method subsetting_rules registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _subsetting_rulesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _subsetting_rulesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _subsetting_rulesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubsetting_rulesOperation()
        {
            return ClassInstance.LookupOperation("subsetting_rules");
        }
        
        /// <summary>
        /// A binding of a PropertyTemplateParameter representing an attribute must be to an attribute.
        ///(self.isAttribute()
        ///and (templateParameterSubstitution-&gt;notEmpty())
        ///implies (templateParameterSubstitution-&gt;forAll(ts |
        ///    ts.formal.oclIsKindOf(Property)
        ///    and ts.formal.oclAsType(Property).isAttribute())))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Binding_to_attribute(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_binding_to_attributeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method binding_to_attribute registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _binding_to_attributeOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _binding_to_attributeOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _binding_to_attributeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveBinding_to_attributeOperation()
        {
            return ClassInstance.LookupOperation("binding_to_attribute");
        }
        
        /// <summary>
        /// A derived union is derived.
        ///isDerivedUnion implies isDerived
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Derived_union_is_derived(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_derived_union_is_derivedOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method derived_union_is_derived registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _derived_union_is_derivedOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _derived_union_is_derivedOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _derived_union_is_derivedOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDerived_union_is_derivedOperation()
        {
            return ClassInstance.LookupOperation("derived_union_is_derived");
        }
        
        /// <summary>
        /// A Property can be a DeploymentTarget if it is a kind of Node and functions as a part in the internal structure of an encompassing Node.
        ///deployment-&gt;notEmpty() implies owner.oclIsKindOf(Node) and Node.allInstances()-&gt;exists(n | n.part-&gt;exists(p | p = self))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Deployment_target(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_deployment_targetOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method deployment_target registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _deployment_targetOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _deployment_targetOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _deployment_targetOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveDeployment_targetOperation()
        {
            return ClassInstance.LookupOperation("deployment_target");
        }
        
        /// <summary>
        /// A Property may not subset a Property with the same name.
        ///subsettedProperty-&gt;forAll(sp | sp.name &lt;&gt; name)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Subsetted_property_names(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_subsetted_property_namesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method subsetted_property_names registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _subsetted_property_namesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _subsetted_property_namesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _subsetted_property_namesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubsetted_property_namesOperation()
        {
            return ClassInstance.LookupOperation("subsetted_property_names");
        }
        
        /// <summary>
        /// If a Property is a classifier-owned end of a binary Association, its owner must be the type of the opposite end.
        ///(opposite-&gt;notEmpty() and owningAssociation-&gt;isEmpty()) implies classifier = opposite.type
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Type_of_opposite_end(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_type_of_opposite_endOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method type_of_opposite_end registered. Use the me" +
                        "thod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _type_of_opposite_endOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _type_of_opposite_endOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _type_of_opposite_endOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveType_of_opposite_endOperation()
        {
            return ClassInstance.LookupOperation("type_of_opposite_end");
        }
        
        /// <summary>
        /// All qualified Properties must be Association ends
        ///qualifier-&gt;notEmpty() implies association-&gt;notEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Qualified_is_association_end(object diagnostics, object context)
        {
            System.Func<IProperty, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, object, object, bool>>(_qualified_is_association_endOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method qualified_is_association_end registered. Us" +
                        "e the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _qualified_is_association_endOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _qualified_is_association_endOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _qualified_is_association_endOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveQualified_is_association_endOperation()
        {
            return ClassInstance.LookupOperation("qualified_is_association_end");
        }
        
        /// <summary>
        /// Retrieves a string representation of the default value for this property.
        /// </summary>
        public string GetDefault()
        {
            System.Func<IProperty, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, string>>(_getDefaultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getDefault registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getDefaultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getDefaultOperation.Value, e));
            string result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getDefaultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetDefaultOperation()
        {
            return ClassInstance.LookupOperation("getDefault");
        }
        
        /// <summary>
        /// Retrieves the other end of the (binary) association in which this property is a member end.
        /// </summary>
        public IProperty GetOtherEnd()
        {
            System.Func<IProperty, IProperty> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, IProperty>>(_getOtherEndOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOtherEnd registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOtherEndOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOtherEndOperation.Value, e));
            IProperty result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOtherEndOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOtherEndOperation()
        {
            return ClassInstance.LookupOperation("getOtherEnd");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public bool IsSetDefault()
        {
            System.Func<IProperty, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, bool>>(_isSetDefaultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isSetDefault registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isSetDefaultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isSetDefaultOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isSetDefaultOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsSetDefaultOperation()
        {
            return ClassInstance.LookupOperation("isSetDefault");
        }
        
        /// <summary>
        /// Sets the default value for this property to the specified Boolean value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        public void SetBooleanDefaultValue(bool value)
        {
            System.Action<IProperty, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, bool>>(_setBooleanDefaultValueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setBooleanDefaultValue registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setBooleanDefaultValueOperation.Value, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setBooleanDefaultValueOperation.Value, e));
            handler.Invoke(this, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setBooleanDefaultValueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetBooleanDefaultValueOperation()
        {
            return ClassInstance.LookupOperation("setBooleanDefaultValue");
        }
        
        /// <summary>
        /// Sets the default value for this property based on the specified string representation.
        /// </summary>
        /// <param name="newDefault">A string repesentation of the new default value.</param>
        public void SetDefault(string newDefault)
        {
            System.Action<IProperty, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, string>>(_setDefaultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setDefault registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setDefaultOperation.Value, newDefault);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setDefaultOperation.Value, e));
            handler.Invoke(this, newDefault);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setDefaultOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetDefaultOperation()
        {
            return ClassInstance.LookupOperation("setDefault");
        }
        
        /// <summary>
        /// Sets the default value for this property to the specified integer value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        public void SetIntegerDefaultValue(int value)
        {
            System.Action<IProperty, int> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, int>>(_setIntegerDefaultValueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setIntegerDefaultValue registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setIntegerDefaultValueOperation.Value, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setIntegerDefaultValueOperation.Value, e));
            handler.Invoke(this, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setIntegerDefaultValueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetIntegerDefaultValueOperation()
        {
            return ClassInstance.LookupOperation("setIntegerDefaultValue");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newIsComposite"></param>
        public void SetIsComposite(bool newIsComposite)
        {
            System.Action<IProperty, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, bool>>(_setIsCompositeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setIsComposite registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setIsCompositeOperation.Value, newIsComposite);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setIsCompositeOperation.Value, e));
            handler.Invoke(this, newIsComposite);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setIsCompositeOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetIsCompositeOperation()
        {
            return ClassInstance.LookupOperation("setIsComposite");
        }
        
        /// <summary>
        /// Sets the navigability of this property as indicated.
        /// </summary>
        /// <param name="isNavigable">The new navigability.</param>
        public void SetIsNavigable(bool isNavigable)
        {
            System.Action<IProperty, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, bool>>(_setIsNavigableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setIsNavigable registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setIsNavigableOperation.Value, isNavigable);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setIsNavigableOperation.Value, e));
            handler.Invoke(this, isNavigable);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setIsNavigableOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetIsNavigableOperation()
        {
            return ClassInstance.LookupOperation("setIsNavigable");
        }
        
        /// <summary>
        /// Sets the default value for this property to the null value.
        /// </summary>
        public void SetNullDefaultValue()
        {
            System.Action<IProperty> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty>>(_setNullDefaultValueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setNullDefaultValue registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setNullDefaultValueOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setNullDefaultValueOperation.Value, e));
            handler.Invoke(this);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setNullDefaultValueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetNullDefaultValueOperation()
        {
            return ClassInstance.LookupOperation("setNullDefaultValue");
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="newOpposite"></param>
        public void SetOpposite(IProperty newOpposite)
        {
            System.Action<IProperty, IProperty> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, IProperty>>(_setOppositeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setOpposite registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setOppositeOperation.Value, newOpposite);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setOppositeOperation.Value, e));
            handler.Invoke(this, newOpposite);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setOppositeOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetOppositeOperation()
        {
            return ClassInstance.LookupOperation("setOpposite");
        }
        
        /// <summary>
        /// Sets the default value for this property to the specified real value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        public void SetRealDefaultValue(double value)
        {
            System.Action<IProperty, double> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, double>>(_setRealDefaultValueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setRealDefaultValue registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setRealDefaultValueOperation.Value, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setRealDefaultValueOperation.Value, e));
            handler.Invoke(this, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setRealDefaultValueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetRealDefaultValueOperation()
        {
            return ClassInstance.LookupOperation("setRealDefaultValue");
        }
        
        /// <summary>
        /// Sets the default value for this property to the specified string value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        public void SetStringDefaultValue(string value)
        {
            System.Action<IProperty, string> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, string>>(_setStringDefaultValueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setStringDefaultValue registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setStringDefaultValueOperation.Value, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setStringDefaultValueOperation.Value, e));
            handler.Invoke(this, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setStringDefaultValueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetStringDefaultValueOperation()
        {
            return ClassInstance.LookupOperation("setStringDefaultValue");
        }
        
        /// <summary>
        /// Sets the default value for this property to the specified unlimited natural value.
        /// </summary>
        /// <param name="value">The new default value.</param>
        public void SetUnlimitedNaturalDefaultValue(object value)
        {
            System.Action<IProperty, object> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty, object>>(_setUnlimitedNaturalDefaultValueOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method setUnlimitedNaturalDefaultValue registered." +
                        " Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _setUnlimitedNaturalDefaultValueOperation.Value, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _setUnlimitedNaturalDefaultValueOperation.Value, e));
            handler.Invoke(this, value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _setUnlimitedNaturalDefaultValueOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSetUnlimitedNaturalDefaultValueOperation()
        {
            return ClassInstance.LookupOperation("setUnlimitedNaturalDefaultValue");
        }
        
        /// <summary>
        /// 
        /// </summary>
        public void UnsetDefault()
        {
            System.Action<IProperty> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Action<IProperty>>(_unsetDefaultOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method unsetDefault registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _unsetDefaultOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _unsetDefaultOperation.Value, e));
            handler.Invoke(this);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _unsetDefaultOperation.Value, e));
        }
        
        private static NMF.Models.Meta.IOperation RetrieveUnsetDefaultOperation()
        {
            return ClassInstance.LookupOperation("unsetDefault");
        }
        
        /// <summary>
        /// The query isAttribute() is true if the Property is defined as an attribute of some Classifier.
        ///result = (not classifier-&gt;isEmpty())
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public bool IsAttribute()
        {
            System.Func<IProperty, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, bool>>(_isAttributeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isAttribute registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isAttributeOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isAttributeOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isAttributeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsAttributeOperation()
        {
            return ClassInstance.LookupOperation("isAttribute");
        }
        
        /// <summary>
        /// The query isNavigable() indicates whether it is possible to navigate across the property.
        ///result = (not classifier-&gt;isEmpty() or association.navigableOwnedEnd-&gt;includes(self))
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public bool IsNavigable()
        {
            System.Func<IProperty, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, bool>>(_isNavigableOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isNavigable registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isNavigableOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isNavigableOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isNavigableOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsNavigableOperation()
        {
            return ClassInstance.LookupOperation("isNavigable");
        }
        
        /// <summary>
        /// If this property is a memberEnd of a binary association, then opposite gives the other end.
        ///result = (if association &lt;&gt; null and association.memberEnd-&gt;size() = 2
        ///then
        ///    association.memberEnd-&gt;any(e | e &lt;&gt; self)
        ///else
        ///    null
        ///endif)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public IProperty GetOpposite()
        {
            System.Func<IProperty, IProperty> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, IProperty>>(_getOppositeOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getOpposite registered. Use the method brok" +
                        "er to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getOppositeOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getOppositeOperation.Value, e));
            IProperty result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getOppositeOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetOppositeOperation()
        {
            return ClassInstance.LookupOperation("getOpposite");
        }
        
        /// <summary>
        /// The query subsettingContext() gives the context for subsetting a Property. It consists, in the case of an attribute, of the corresponding Classifier, and in the case of an association end, all of the Classifiers at the other ends.
        ///result = (if association &lt;&gt; null
        ///then association.memberEnd-&gt;excluding(self)-&gt;collect(type)-&gt;asSet()
        ///else 
        ///  if classifier&lt;&gt;null
        ///  then classifier-&gt;asSet()
        ///  else Set{} 
        ///  endif
        ///endif)
        ///&lt;p&gt;From package UML::Classification.&lt;/p&gt;
        /// </summary>
        public ISetExpression<NMF.Interop.Uml.IType> SubsettingContext()
        {
            System.Func<IProperty, ISetExpression<NMF.Interop.Uml.IType>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IProperty, ISetExpression<NMF.Interop.Uml.IType>>>(_subsettingContextOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method subsettingContext registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _subsettingContextOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _subsettingContextOperation.Value, e));
            ISetExpression<NMF.Interop.Uml.IType> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _subsettingContextOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSubsettingContextOperation()
        {
            return ClassInstance.LookupOperation("subsettingContext");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveAggregationAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("aggregation")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsDerivedAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("isDerived")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsDerivedUnionAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("isDerivedUnion")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsIDAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("isID")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDatatypeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("datatype")));
        }
        
        /// <summary>
        /// Handles the event that the Datatype property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDatatype(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Datatype))
            {
                this.Datatype = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveInterfaceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("interface")));
        }
        
        /// <summary>
        /// Handles the event that the Interface property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetInterface(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Interface))
            {
                this.Interface = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveAssociationEndReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("associationEnd")));
        }
        
        /// <summary>
        /// Handles the event that the AssociationEnd property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetAssociationEnd(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.AssociationEnd))
            {
                this.AssociationEnd = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveQualifierReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("qualifier")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Qualifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void QualifierCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Qualifier", e, _qualifierReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Qualifier property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void QualifierCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Qualifier", e, _qualifierReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveClassReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("class")));
        }
        
        /// <summary>
        /// Handles the event that the Class property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetClass(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.Class))
            {
                this.Class = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDefaultValueReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("defaultValue")));
        }
        
        /// <summary>
        /// Handles the event that the DefaultValue property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDefaultValue(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.DefaultValue))
            {
                this.DefaultValue = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningAssociationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("owningAssociation")));
        }
        
        /// <summary>
        /// Handles the event that the OwningAssociation property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwningAssociation(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwningAssociation))
            {
                this.OwningAssociation = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSubsettedPropertyReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Property.ClassInstance)).Resolve("subsettedProperty")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the SubsettedProperty property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SubsettedPropertyCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("SubsettedProperty", e, _subsettedPropertyReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the SubsettedProperty property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void SubsettedPropertyCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("SubsettedProperty", e, _subsettedPropertyReference);
        }
        
        /// <summary>
        /// Derivation for ConnectableElement::/end : ConnectorEnd
        ///result = (ConnectorEnd.allInstances()-&gt;select(role = self))
        ///&lt;p&gt;From package UML::StructuredClassifiers.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IConnectorEnd> GetEnds()
        {
            System.Func<IConnectableElement, ISetExpression<IConnectorEnd>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IConnectableElement, ISetExpression<IConnectorEnd>>>(_getEndsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getEnds registered. Use the method broker t" +
                        "o register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getEndsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getEndsOperation.Value, e));
            ISetExpression<IConnectorEnd> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getEndsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetEndsOperation()
        {
            return ClassInstance.LookupOperation("getEnds");
        }
        
        /// <summary>
        /// The query isCompatibleWith() determines if this ParameterableElement is compatible with the specified ParameterableElement. By default, this ParameterableElement is compatible with another ParameterableElement p if the kind of this ParameterableElement is the same as or a subtype of the kind of p. Subclasses of ParameterableElement should override this operation to specify different compatibility constraints.
        ///result = (self.oclIsKindOf(p.oclType()))
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        /// <param name="p"></param>
        public bool IsCompatibleWith(IParameterableElement p)
        {
            System.Func<IParameterableElement, IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, IParameterableElement, bool>>(_isCompatibleWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isCompatibleWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isCompatibleWithOperation.Value, p);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isCompatibleWithOperation.Value, e));
            bool result = handler.Invoke(this, p);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isCompatibleWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsCompatibleWithOperation()
        {
            return ClassInstance.LookupOperation("isCompatibleWith");
        }
        
        /// <summary>
        /// The query isTemplateParameter() determines if this ParameterableElement is exposed as a formal TemplateParameter.
        ///result = (templateParameter-&gt;notEmpty())
        ///&lt;p&gt;From package UML::CommonStructure.&lt;/p&gt;
        /// </summary>
        public bool IsTemplateParameter()
        {
            System.Func<IParameterableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IParameterableElement, bool>>(_isTemplateParameterOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isTemplateParameter registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isTemplateParameterOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isTemplateParameterOperation.Value, e));
            bool result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isTemplateParameterOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsTemplateParameterOperation()
        {
            return ClassInstance.LookupOperation("isTemplateParameter");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveOwningTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("owningTemplateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the OwningTemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetOwningTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.OwningTemplateParameter))
            {
                this.OwningTemplateParameter = null;
            }
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTemplateParameterReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.ParameterableElement.ClassInstance)).Resolve("templateParameter")));
        }
        
        /// <summary>
        /// Handles the event that the TemplateParameter property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTemplateParameter(object sender, System.EventArgs eventArgs)
        {
            if ((sender == this.TemplateParameter))
            {
                this.TemplateParameter = null;
            }
        }
        
        /// <summary>
        /// Derivation for DeploymentTarget::/deployedElement
        ///result = (deployment.deployedArtifact-&gt;select(oclIsKindOf(Artifact))-&gt;collect(oclAsType(Artifact).manifestation)-&gt;collect(utilizedElement)-&gt;asSet())
        ///&lt;p&gt;From package UML::Deployments.&lt;/p&gt;
        /// </summary>
        public ISetExpression<IPackageableElement> GetDeployedElements()
        {
            System.Func<IDeploymentTarget, ISetExpression<IPackageableElement>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IDeploymentTarget, ISetExpression<IPackageableElement>>>(_getDeployedElementsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getDeployedElements registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getDeployedElementsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getDeployedElementsOperation.Value, e));
            ISetExpression<IPackageableElement> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getDeployedElementsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetDeployedElementsOperation()
        {
            return ClassInstance.LookupOperation("getDeployedElements");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveDeploymentReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.DeploymentTarget.ClassInstance)).Resolve("deployment")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Deployment property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void DeploymentCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Deployment", e, _deploymentReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Deployment property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void DeploymentCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Deployment", e, _deploymentReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int qualifierIndex = ModelHelper.IndexOfReference(this.Qualifier, element);
            if ((qualifierIndex != -1))
            {
                return ModelHelper.CreatePath("qualifier", qualifierIndex);
            }
            if ((element == this.DefaultValue))
            {
                return ModelHelper.CreatePath("defaultValue");
            }
            int deploymentIndex = ModelHelper.IndexOfReference(this.Deployment, element);
            if ((deploymentIndex != -1))
            {
                return ModelHelper.CreatePath("deployment", deploymentIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "PROTOCOL"))
            {
                return this.Protocol;
            }
            if ((reference == "DATATYPE"))
            {
                return this.Datatype;
            }
            if ((reference == "INTERFACE"))
            {
                return this.Interface;
            }
            if ((reference == "ASSOCIATIONEND"))
            {
                return this.AssociationEnd;
            }
            if ((reference == "QUALIFIER"))
            {
                if ((index < this.Qualifier.Count))
                {
                    return this.Qualifier[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CLASS"))
            {
                return this.Class;
            }
            if ((reference == "DEFAULTVALUE"))
            {
                return this.DefaultValue;
            }
            if ((reference == "OWNINGASSOCIATION"))
            {
                return this.OwningAssociation;
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return this.OwningTemplateParameter;
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return this.TemplateParameter;
            }
            if ((reference == "DEPLOYMENT"))
            {
                if ((index < this.Deployment.Count))
                {
                    return this.Deployment[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISBEHAVIOR"))
            {
                return this.IsBehavior;
            }
            if ((attribute == "ISCONJUGATED"))
            {
                return this.IsConjugated;
            }
            if ((attribute == "ISSERVICE"))
            {
                return this.IsService;
            }
            if ((attribute == "AGGREGATION"))
            {
                return this.Aggregation;
            }
            if ((attribute == "ISDERIVED"))
            {
                return this.IsDerived;
            }
            if ((attribute == "ISDERIVEDUNION"))
            {
                return this.IsDerivedUnion;
            }
            if ((attribute == "ISID"))
            {
                return this.IsID;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "REDEFINEDPORT"))
            {
                return this._redefinedPort;
            }
            if ((feature == "QUALIFIER"))
            {
                return this._qualifier;
            }
            if ((feature == "SUBSETTEDPROPERTY"))
            {
                return this._subsettedProperty;
            }
            if ((feature == "DEPLOYMENT"))
            {
                return this._deployment;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "PROTOCOL"))
            {
                this.Protocol = ((IProtocolStateMachine)(value));
                return;
            }
            if ((feature == "DATATYPE"))
            {
                this.Datatype = ((NMF.Interop.Uml.IDataType)(value));
                return;
            }
            if ((feature == "INTERFACE"))
            {
                this.Interface = ((IInterface)(value));
                return;
            }
            if ((feature == "ASSOCIATIONEND"))
            {
                this.AssociationEnd = ((IProperty)(value));
                return;
            }
            if ((feature == "CLASS"))
            {
                this.Class = ((NMF.Interop.Uml.IClass)(value));
                return;
            }
            if ((feature == "DEFAULTVALUE"))
            {
                this.DefaultValue = ((IValueSpecification)(value));
                return;
            }
            if ((feature == "OWNINGASSOCIATION"))
            {
                this.OwningAssociation = ((IAssociation)(value));
                return;
            }
            if ((feature == "OWNINGTEMPLATEPARAMETER"))
            {
                this.OwningTemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "TEMPLATEPARAMETER"))
            {
                this.TemplateParameter = ((ITemplateParameter)(value));
                return;
            }
            if ((feature == "ISBEHAVIOR"))
            {
                this.IsBehavior = ((bool)(value));
                return;
            }
            if ((feature == "ISCONJUGATED"))
            {
                this.IsConjugated = ((bool)(value));
                return;
            }
            if ((feature == "ISSERVICE"))
            {
                this.IsService = ((bool)(value));
                return;
            }
            if ((feature == "AGGREGATION"))
            {
                this.Aggregation = ((AggregationKind)(value));
                return;
            }
            if ((feature == "ISDERIVED"))
            {
                this.IsDerived = ((bool)(value));
                return;
            }
            if ((feature == "ISDERIVEDUNION"))
            {
                this.IsDerivedUnion = ((bool)(value));
                return;
            }
            if ((feature == "ISID"))
            {
                this.IsID = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISBEHAVIOR"))
            {
                return Observable.Box(new IsBehaviorProxy(this));
            }
            if ((attribute == "ISCONJUGATED"))
            {
                return Observable.Box(new IsConjugatedProxy(this));
            }
            if ((attribute == "ISSERVICE"))
            {
                return Observable.Box(new IsServiceProxy(this));
            }
            if ((attribute == "AGGREGATION"))
            {
                return Observable.Box(new AggregationProxy(this));
            }
            if ((attribute == "ISDERIVED"))
            {
                return Observable.Box(new IsDerivedProxy(this));
            }
            if ((attribute == "ISDERIVEDUNION"))
            {
                return Observable.Box(new IsDerivedUnionProxy(this));
            }
            if ((attribute == "ISID"))
            {
                return Observable.Box(new IsIDProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "PROTOCOL"))
            {
                return new ProtocolProxy(this);
            }
            if ((reference == "DATATYPE"))
            {
                return new DatatypeProxy(this);
            }
            if ((reference == "INTERFACE"))
            {
                return new InterfaceProxy(this);
            }
            if ((reference == "ASSOCIATIONEND"))
            {
                return new AssociationEndProxy(this);
            }
            if ((reference == "CLASS"))
            {
                return new ClassProxy(this);
            }
            if ((reference == "DEFAULTVALUE"))
            {
                return new DefaultValueProxy(this);
            }
            if ((reference == "OWNINGASSOCIATION"))
            {
                return new OwningAssociationProxy(this);
            }
            if ((reference == "OWNINGTEMPLATEPARAMETER"))
            {
                return new OwningTemplateParameterProxy(this);
            }
            if ((reference == "TEMPLATEPARAMETER"))
            {
                return new TemplateParameterProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._qualifier))
            {
                return "qualifier";
            }
            if ((container == this._deployment))
            {
                return "deployment";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Port")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Port class
        /// </summary>
        public class PortReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Port _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public PortReferencedElementsCollection(Port parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isBehavior property
        /// </summary>
        private sealed class IsBehaviorProxy : ModelPropertyChange<IPort, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsBehaviorProxy(IPort modelElement) : 
                    base(modelElement, "isBehavior")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsBehavior;
                }
                set
                {
                    this.ModelElement.IsBehavior = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isConjugated property
        /// </summary>
        private sealed class IsConjugatedProxy : ModelPropertyChange<IPort, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsConjugatedProxy(IPort modelElement) : 
                    base(modelElement, "isConjugated")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsConjugated;
                }
                set
                {
                    this.ModelElement.IsConjugated = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isService property
        /// </summary>
        private sealed class IsServiceProxy : ModelPropertyChange<IPort, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsServiceProxy(IPort modelElement) : 
                    base(modelElement, "isService")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsService;
                }
                set
                {
                    this.ModelElement.IsService = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the protocol property
        /// </summary>
        private sealed class ProtocolProxy : ModelPropertyChange<IPort, IProtocolStateMachine>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ProtocolProxy(IPort modelElement) : 
                    base(modelElement, "protocol")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IProtocolStateMachine Value
            {
                get
                {
                    return this.ModelElement.Protocol;
                }
                set
                {
                    this.ModelElement.Protocol = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the aggregation property
        /// </summary>
        private sealed class AggregationProxy : ModelPropertyChange<IProperty, AggregationKind>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public AggregationProxy(IProperty modelElement) : 
                    base(modelElement, "aggregation")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override AggregationKind Value
            {
                get
                {
                    return this.ModelElement.Aggregation;
                }
                set
                {
                    this.ModelElement.Aggregation = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isDerived property
        /// </summary>
        private sealed class IsDerivedProxy : ModelPropertyChange<IProperty, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsDerivedProxy(IProperty modelElement) : 
                    base(modelElement, "isDerived")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsDerived;
                }
                set
                {
                    this.ModelElement.IsDerived = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isDerivedUnion property
        /// </summary>
        private sealed class IsDerivedUnionProxy : ModelPropertyChange<IProperty, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsDerivedUnionProxy(IProperty modelElement) : 
                    base(modelElement, "isDerivedUnion")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsDerivedUnion;
                }
                set
                {
                    this.ModelElement.IsDerivedUnion = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isID property
        /// </summary>
        private sealed class IsIDProxy : ModelPropertyChange<IProperty, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsIDProxy(IProperty modelElement) : 
                    base(modelElement, "isID")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsID;
                }
                set
                {
                    this.ModelElement.IsID = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the datatype property
        /// </summary>
        private sealed class DatatypeProxy : ModelPropertyChange<IProperty, NMF.Interop.Uml.IDataType>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DatatypeProxy(IProperty modelElement) : 
                    base(modelElement, "datatype")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override NMF.Interop.Uml.IDataType Value
            {
                get
                {
                    return this.ModelElement.Datatype;
                }
                set
                {
                    this.ModelElement.Datatype = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the interface property
        /// </summary>
        private sealed class InterfaceProxy : ModelPropertyChange<IProperty, IInterface>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public InterfaceProxy(IProperty modelElement) : 
                    base(modelElement, "interface")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IInterface Value
            {
                get
                {
                    return this.ModelElement.Interface;
                }
                set
                {
                    this.ModelElement.Interface = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the associationEnd property
        /// </summary>
        private sealed class AssociationEndProxy : ModelPropertyChange<IProperty, IProperty>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public AssociationEndProxy(IProperty modelElement) : 
                    base(modelElement, "associationEnd")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IProperty Value
            {
                get
                {
                    return this.ModelElement.AssociationEnd;
                }
                set
                {
                    this.ModelElement.AssociationEnd = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the class property
        /// </summary>
        private sealed class ClassProxy : ModelPropertyChange<IProperty, NMF.Interop.Uml.IClass>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ClassProxy(IProperty modelElement) : 
                    base(modelElement, "class")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override NMF.Interop.Uml.IClass Value
            {
                get
                {
                    return this.ModelElement.Class;
                }
                set
                {
                    this.ModelElement.Class = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the defaultValue property
        /// </summary>
        private sealed class DefaultValueProxy : ModelPropertyChange<IProperty, IValueSpecification>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DefaultValueProxy(IProperty modelElement) : 
                    base(modelElement, "defaultValue")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IValueSpecification Value
            {
                get
                {
                    return this.ModelElement.DefaultValue;
                }
                set
                {
                    this.ModelElement.DefaultValue = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningAssociation property
        /// </summary>
        private sealed class OwningAssociationProxy : ModelPropertyChange<IProperty, IAssociation>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningAssociationProxy(IProperty modelElement) : 
                    base(modelElement, "owningAssociation")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IAssociation Value
            {
                get
                {
                    return this.ModelElement.OwningAssociation;
                }
                set
                {
                    this.ModelElement.OwningAssociation = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the association property
        /// </summary>
        private sealed class AssociationProxy : ModelPropertyChange<IProperty, IAssociation>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public AssociationProxy(IProperty modelElement) : 
                    base(modelElement, "association")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IAssociation Value
            {
                get
                {
                    return this.ModelElement.Association;
                }
                set
                {
                    this.ModelElement.Association = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the owningTemplateParameter property
        /// </summary>
        private sealed class OwningTemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OwningTemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "owningTemplateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.OwningTemplateParameter;
                }
                set
                {
                    this.ModelElement.OwningTemplateParameter = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the templateParameter property
        /// </summary>
        private sealed class TemplateParameterProxy : ModelPropertyChange<IParameterableElement, ITemplateParameter>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TemplateParameterProxy(IParameterableElement modelElement) : 
                    base(modelElement, "templateParameter")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITemplateParameter Value
            {
                get
                {
                    return this.ModelElement.TemplateParameter;
                }
                set
                {
                    this.ModelElement.TemplateParameter = value;
                }
            }
        }
    }
}
