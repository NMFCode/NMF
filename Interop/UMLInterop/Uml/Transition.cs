//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Transition represents an arc between exactly one source Vertex and exactly one Target vertex (the source and targets may be the same Vertex). It may form part of a compound transition, which takes the StateMachine from one steady State configuration to another, representing the full response of the StateMachine to an occurrence of an Event that triggered it.
    ///<p>From package UML::StateMachines.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Transition")]
    [DebuggerDisplayAttribute("Transition {Name}")]
    public partial class Transition : Namespace, ITransition, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _state_is_externalOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveState_is_externalOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _join_segment_guardsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveJoin_segment_guardsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _state_is_internalOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveState_is_internalOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _outgoing_pseudostatesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOutgoing_pseudostatesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _join_segment_stateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveJoin_segment_stateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _fork_segment_stateOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveFork_segment_stateOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _state_is_localOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveState_is_localOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _initial_transitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveInitial_transitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _fork_segment_guardsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveFork_segment_guardsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingStateMachineOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingStateMachineOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinitionContextOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinitionContextOperation);
        
        /// <summary>
        /// The backing field for the Kind property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private TransitionKind _kind = TransitionKind.External;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _kindAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveKindAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _effectReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveEffectReference);
        
        /// <summary>
        /// The backing field for the Effect property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBehavior _effect;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _guardReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveGuardReference);
        
        /// <summary>
        /// The backing field for the Guard property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _guard;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _redefinedTransitionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRedefinedTransitionReference);
        
        /// <summary>
        /// The backing field for the RedefinedTransition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITransition _redefinedTransition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _sourceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSourceReference);
        
        /// <summary>
        /// The backing field for the Source property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IVertex _source;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _targetReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTargetReference);
        
        /// <summary>
        /// The backing field for the Target property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IVertex _target;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _triggerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveTriggerReference);
        
        /// <summary>
        /// The backing field for the Trigger property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<ITrigger> _trigger;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _containerReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveContainerReference);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_consistentOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_consistentOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _non_leaf_redefinitionOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveNon_leaf_redefinitionOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _redefinition_context_validOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveRedefinition_context_validOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isConsistentWithOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsConsistentWithOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _isRedefinitionContextValidOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveIsRedefinitionContextValidOperation);
        
        /// <summary>
        /// The backing field for the IsLeaf property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isLeaf = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isLeafAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsLeafAttribute);
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Transition()
        {
            this._trigger = new ObservableCompositionOrderedSet<ITrigger>(this);
            this._trigger.CollectionChanging += this.TriggerCollectionChanging;
            this._trigger.CollectionChanged += this.TriggerCollectionChanged;
        }
        
        /// <summary>
        /// Indicates the precise type of the Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DefaultValueAttribute(TransitionKind.External)]
        [DisplayNameAttribute("kind")]
        [DescriptionAttribute("Indicates the precise type of the Transition.\n<p>From package UML::StateMachines." +
            "</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("kind")]
        [XmlAttributeAttribute(true)]
        public TransitionKind Kind
        {
            get
            {
                return this._kind;
            }
            set
            {
                if ((this._kind != value))
                {
                    TransitionKind old = this._kind;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Kind", e, _kindAttribute);
                    this._kind = value;
                    this.OnPropertyChanged("Kind", e, _kindAttribute);
                }
            }
        }
        
        /// <summary>
        /// Specifies an optional behavior to be performed when the Transition fires.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("effect")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBehavior Effect
        {
            get
            {
                return this._effect;
            }
            set
            {
                if ((this._effect != value))
                {
                    IBehavior old = this._effect;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Effect", e, _effectReference);
                    this._effect = value;
                    if ((old != null))
                    {
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetEffect;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetEffect;
                    }
                    this.OnPropertyChanged("Effect", e, _effectReference);
                }
            }
        }
        
        /// <summary>
        /// A guard is a Constraint that provides a fine-grained control over the firing of the Transition. The guard is evaluated when an Event occurrence is dispatched by the StateMachine. If the guard is true at that time, the Transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. Guard expressions with side effects are ill formed.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("guard")]
        [DescriptionAttribute(@"A guard is a Constraint that provides a fine-grained control over the firing of the Transition. The guard is evaluated when an Event occurrence is dispatched by the StateMachine. If the guard is true at that time, the Transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. Guard expressions with side effects are ill formed.
<p>From package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("guard")]
        [XmlAttributeAttribute(true)]
        public IConstraint Guard
        {
            get
            {
                return this._guard;
            }
            set
            {
                if ((this._guard != value))
                {
                    IConstraint old = this._guard;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Guard", e, _guardReference);
                    this._guard = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetGuard;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetGuard;
                    }
                    this.OnPropertyChanged("Guard", e, _guardReference);
                }
            }
        }
        
        /// <summary>
        /// The Transition that is redefined by this Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("redefinedTransition")]
        [DescriptionAttribute("The Transition that is redefined by this Transition.\n<p>From package UML::StateMa" +
            "chines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("redefinedTransition")]
        [XmlAttributeAttribute(true)]
        public ITransition RedefinedTransition
        {
            get
            {
                return this._redefinedTransition;
            }
            set
            {
                if ((this._redefinedTransition != value))
                {
                    ITransition old = this._redefinedTransition;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("RedefinedTransition", e, _redefinedTransitionReference);
                    this._redefinedTransition = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetRedefinedTransition;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetRedefinedTransition;
                    }
                    this.OnPropertyChanged("RedefinedTransition", e, _redefinedTransitionReference);
                }
            }
        }
        
        /// <summary>
        /// Designates the originating Vertex (State or Pseudostate) of the Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("source")]
        [DescriptionAttribute("Designates the originating Vertex (State or Pseudostate) of the Transition.\n<p>Fr" +
            "om package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("source")]
        [XmlAttributeAttribute(true)]
        public IVertex Source
        {
            get
            {
                return this._source;
            }
            set
            {
                if ((this._source != value))
                {
                    IVertex old = this._source;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Source", e, _sourceReference);
                    this._source = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetSource;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetSource;
                    }
                    this.OnPropertyChanged("Source", e, _sourceReference);
                }
            }
        }
        
        /// <summary>
        /// Designates the target Vertex that is reached when the Transition is taken.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("target")]
        [DescriptionAttribute("Designates the target Vertex that is reached when the Transition is taken.\n<p>Fro" +
            "m package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(true)]
        public IVertex Target
        {
            get
            {
                return this._target;
            }
            set
            {
                if ((this._target != value))
                {
                    IVertex old = this._target;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Target", e, _targetReference);
                    this._target = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetTarget;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetTarget;
                    }
                    this.OnPropertyChanged("Target", e, _targetReference);
                }
            }
        }
        
        /// <summary>
        /// Specifies the Triggers that may fire the transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("trigger")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<ITrigger> Trigger
        {
            get
            {
                return this._trigger;
            }
        }
        
        /// <summary>
        /// Designates the Region that owns this Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("container")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("transition")]
        public IRegion Container
        {
            get
            {
                return ModelHelper.CastAs<IRegion>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// Indicates whether it is possible to further redefine a RedefinableElement. If the value is true, then it is not possible to further redefine the RedefinableElement.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isLeaf")]
        [DescriptionAttribute("Indicates whether it is possible to further redefine a RedefinableElement. If the" +
            " value is true, then it is not possible to further redefine the RedefinableEleme" +
            "nt.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("RedefinableElement")]
        [XmlElementNameAttribute("isLeaf")]
        [XmlAttributeAttribute(true)]
        public bool IsLeaf
        {
            get
            {
                return this._isLeaf;
            }
            set
            {
                if ((this._isLeaf != value))
                {
                    bool old = this._isLeaf;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsLeaf", e, _isLeafAttribute);
                    this._isLeaf = value;
                    this.OnPropertyChanged("IsLeaf", e, _isLeafAttribute);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new TransitionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new TransitionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Transition")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// A Transition with kind external can source any Vertex except entry points.
        ///(kind = TransitionKind::external) implies
        ///	not (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool State_is_external(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_state_is_externalOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method state_is_external registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _state_is_externalOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _state_is_externalOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _state_is_externalOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveState_is_externalOperation()
        {
            return ClassInstance.LookupOperation("state_is_external");
        }
        
        /// <summary>
        /// A join segment must not have Guards or Triggers.
        ///(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (guard = null and trigger->isEmpty())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Join_segment_guards(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_join_segment_guardsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method join_segment_guards registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _join_segment_guardsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _join_segment_guardsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _join_segment_guardsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveJoin_segment_guardsOperation()
        {
            return ClassInstance.LookupOperation("join_segment_guards");
        }
        
        /// <summary>
        /// A Transition with kind internal must have a State as its source, and its source and target must be equal.
        ///(kind = TransitionKind::internal) implies
        ///		(source.oclIsKindOf (State) and source = target)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool State_is_internal(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_state_is_internalOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method state_is_internal registered. Use the metho" +
                        "d broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _state_is_internalOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _state_is_internalOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _state_is_internalOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveState_is_internalOperation()
        {
            return ClassInstance.LookupOperation("state_is_internal");
        }
        
        /// <summary>
        /// Transitions outgoing Pseudostates may not have a Trigger.
        ///source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind <> PseudostateKind::initial) implies trigger->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Outgoing_pseudostates(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_outgoing_pseudostatesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method outgoing_pseudostates registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _outgoing_pseudostatesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _outgoing_pseudostatesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _outgoing_pseudostatesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOutgoing_pseudostatesOperation()
        {
            return ClassInstance.LookupOperation("outgoing_pseudostates");
        }
        
        /// <summary>
        /// A join segment must always originate from a State.
        ///(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (source.oclIsKindOf(State))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Join_segment_state(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_join_segment_stateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method join_segment_state registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _join_segment_stateOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _join_segment_stateOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _join_segment_stateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveJoin_segment_stateOperation()
        {
            return ClassInstance.LookupOperation("join_segment_state");
        }
        
        /// <summary>
        /// A fork segment must always target a State.
        ///(source.oclIsKindOf(Pseudostate) and  source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (target.oclIsKindOf(State))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Fork_segment_state(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_fork_segment_stateOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method fork_segment_state registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _fork_segment_stateOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _fork_segment_stateOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _fork_segment_stateOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveFork_segment_stateOperation()
        {
            return ClassInstance.LookupOperation("fork_segment_state");
        }
        
        /// <summary>
        /// A Transition with kind local must have a composite State or an entry point as its source.
        ///(kind = TransitionKind::local) implies
        ///		((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or
        ///		(source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool State_is_local(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_state_is_localOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method state_is_local registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _state_is_localOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _state_is_localOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _state_is_localOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveState_is_localOperation()
        {
            return ClassInstance.LookupOperation("state_is_local");
        }
        
        /// <summary>
        /// An initial Transition at the topmost level Region of a StateMachine that has no Trigger.
        ///(source.oclIsKindOf(Pseudostate) and container.stateMachine->notEmpty()) implies
        ///	trigger->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Initial_transition(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_initial_transitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method initial_transition registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _initial_transitionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _initial_transitionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _initial_transitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveInitial_transitionOperation()
        {
            return ClassInstance.LookupOperation("initial_transition");
        }
        
        /// <summary>
        /// A fork segment must not have Guards or Triggers.
        ///(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (guard = null and trigger->isEmpty())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Fork_segment_guards(object diagnostics, object context)
        {
            System.Func<ITransition, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, object, object, bool>>(_fork_segment_guardsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method fork_segment_guards registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _fork_segment_guardsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _fork_segment_guardsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _fork_segment_guardsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveFork_segment_guardsOperation()
        {
            return ClassInstance.LookupOperation("fork_segment_guards");
        }
        
        /// <summary>
        /// The query containingStateMachine() returns the StateMachine that contains the Transition either directly or transitively.
        ///result = (container.containingStateMachine())
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public IStateMachine ContainingStateMachine()
        {
            System.Func<ITransition, IStateMachine> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, IStateMachine>>(_containingStateMachineOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingStateMachine registered. Use the " +
                        "method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingStateMachineOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingStateMachineOperation.Value, e));
            IStateMachine result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingStateMachineOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingStateMachineOperation()
        {
            return ClassInstance.LookupOperation("containingStateMachine");
        }
        
        /// <summary>
        /// The redefinition context of a Transition is the nearest containing StateMachine.
        ///result = (let sm : StateMachine = containingStateMachine() in
        ///if sm._'context' = null or sm.general->notEmpty() then
        ///  sm
        ///else
        ///  sm._'context'
        ///endif)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        public IClassifier RedefinitionContext()
        {
            System.Func<ITransition, IClassifier> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<ITransition, IClassifier>>(_redefinitionContextOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinitionContext registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinitionContextOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinitionContextOperation.Value, e));
            IClassifier result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinitionContextOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinitionContextOperation()
        {
            return ClassInstance.LookupOperation("redefinitionContext");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveKindAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("kind")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveEffectReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("effect")));
        }
        
        /// <summary>
        /// Handles the event that the Effect property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetEffect(object sender, System.EventArgs eventArgs)
        {
            this.Effect = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveGuardReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("guard")));
        }
        
        /// <summary>
        /// Handles the event that the Guard property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetGuard(object sender, System.EventArgs eventArgs)
        {
            this.Guard = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRedefinedTransitionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("redefinedTransition")));
        }
        
        /// <summary>
        /// Handles the event that the RedefinedTransition property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRedefinedTransition(object sender, System.EventArgs eventArgs)
        {
            this.RedefinedTransition = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSourceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("source")));
        }
        
        /// <summary>
        /// Handles the event that the Source property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSource(object sender, System.EventArgs eventArgs)
        {
            this.Source = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTargetReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("target")));
        }
        
        /// <summary>
        /// Handles the event that the Target property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTarget(object sender, System.EventArgs eventArgs)
        {
            this.Target = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveTriggerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("trigger")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Trigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TriggerCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Trigger", e, _triggerReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Trigger property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TriggerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Trigger", e, _triggerReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveContainerReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Transition.ClassInstance)).Resolve("container")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanging("Container", e, _containerReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IRegion oldContainer = ModelHelper.CastAs<IRegion>(oldParent);
            IRegion newContainer = ModelHelper.CastAs<IRegion>(newParent);
            if ((oldContainer != null))
            {
                oldContainer.Transition.Remove(this);
            }
            if ((newContainer != null))
            {
                newContainer.Transition.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldContainer, newContainer);
            this.OnPropertyChanged("Container", e, _containerReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// A redefining element must be consistent with each redefined element.
        ///redefinedElement->forAll(re | re.isConsistentWith(self))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_consistent(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_consistentOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_consistent registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_consistentOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_consistentOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_consistentOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_consistentOperation()
        {
            return ClassInstance.LookupOperation("redefinition_consistent");
        }
        
        /// <summary>
        /// A RedefinableElement can only redefine non-leaf RedefinableElements.
        ///redefinedElement->forAll(re | not re.isLeaf)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Non_leaf_redefinition(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_non_leaf_redefinitionOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method non_leaf_redefinition registered. Use the m" +
                        "ethod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _non_leaf_redefinitionOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _non_leaf_redefinitionOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _non_leaf_redefinitionOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveNon_leaf_redefinitionOperation()
        {
            return ClassInstance.LookupOperation("non_leaf_redefinition");
        }
        
        /// <summary>
        /// At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.
        ///redefinedElement->forAll(re | self.isRedefinitionContextValid(re))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Redefinition_context_valid(object diagnostics, object context)
        {
            System.Func<IRedefinableElement, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, object, object, bool>>(_redefinition_context_validOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method redefinition_context_valid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _redefinition_context_validOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _redefinition_context_validOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _redefinition_context_validOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveRedefinition_context_validOperation()
        {
            return ClassInstance.LookupOperation("redefinition_context_valid");
        }
        
        /// <summary>
        /// The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for subclasses of RedefinableElement to define the consistency conditions.
        ///redefiningElement.isRedefinitionContextValid(self)
        ///result = (false)
        ///<p>From package UML::Classification.</p>
        /// </summary>
        /// <param name="redefiningElement"></param>
        public bool IsConsistentWith(IRedefinableElement redefiningElement)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isConsistentWithOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isConsistentWith registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isConsistentWithOperation.Value, redefiningElement);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isConsistentWithOperation.Value, e));
            bool result = handler.Invoke(this, redefiningElement);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isConsistentWithOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsConsistentWithOperation()
        {
            return ClassInstance.LookupOperation("isConsistentWith");
        }
        
        /// <summary>
        /// The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinition contexts of the specified element.
        ///result = (redefinitionContext->exists(c | c.allParents()->includesAll(redefinedElement.redefinitionContext)))
        ///<p>From package UML::Classification.</p>
        /// </summary>
        /// <param name="redefinedElement"></param>
        public bool IsRedefinitionContextValid(IRedefinableElement redefinedElement)
        {
            System.Func<IRedefinableElement, IRedefinableElement, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IRedefinableElement, IRedefinableElement, bool>>(_isRedefinitionContextValidOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method isRedefinitionContextValid registered. Use " +
                        "the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _isRedefinitionContextValidOperation.Value, redefinedElement);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _isRedefinitionContextValidOperation.Value, e));
            bool result = handler.Invoke(this, redefinedElement);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _isRedefinitionContextValidOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveIsRedefinitionContextValidOperation()
        {
            return ClassInstance.LookupOperation("isRedefinitionContextValid");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsLeafAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.RedefinableElement.ClassInstance)).Resolve("isLeaf")));
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Effect))
            {
                return ModelHelper.CreatePath("effect");
            }
            int triggerIndex = ModelHelper.IndexOfReference(this.Trigger, element);
            if ((triggerIndex != -1))
            {
                return ModelHelper.CreatePath("trigger", triggerIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "EFFECT"))
            {
                return this.Effect;
            }
            if ((reference == "GUARD"))
            {
                return this.Guard;
            }
            if ((reference == "REDEFINEDTRANSITION"))
            {
                return this.RedefinedTransition;
            }
            if ((reference == "SOURCE"))
            {
                return this.Source;
            }
            if ((reference == "TARGET"))
            {
                return this.Target;
            }
            if ((reference == "TRIGGER"))
            {
                if ((index < this.Trigger.Count))
                {
                    return this.Trigger[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CONTAINER"))
            {
                return this.Container;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "KIND"))
            {
                return this.Kind;
            }
            if ((attribute == "ISLEAF"))
            {
                return this.IsLeaf;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "TRIGGER"))
            {
                return this._trigger;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "EFFECT"))
            {
                this.Effect = ((IBehavior)(value));
                return;
            }
            if ((feature == "GUARD"))
            {
                this.Guard = ((IConstraint)(value));
                return;
            }
            if ((feature == "REDEFINEDTRANSITION"))
            {
                this.RedefinedTransition = ((ITransition)(value));
                return;
            }
            if ((feature == "SOURCE"))
            {
                this.Source = ((IVertex)(value));
                return;
            }
            if ((feature == "TARGET"))
            {
                this.Target = ((IVertex)(value));
                return;
            }
            if ((feature == "CONTAINER"))
            {
                this.Container = ((IRegion)(value));
                return;
            }
            if ((feature == "KIND"))
            {
                this.Kind = ((TransitionKind)(value));
                return;
            }
            if ((feature == "ISLEAF"))
            {
                this.IsLeaf = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "KIND"))
            {
                return Observable.Box(new KindProxy(this));
            }
            if ((attribute == "ISLEAF"))
            {
                return Observable.Box(new IsLeafProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "EFFECT"))
            {
                return new EffectProxy(this);
            }
            if ((reference == "GUARD"))
            {
                return new GuardProxy(this);
            }
            if ((reference == "REDEFINEDTRANSITION"))
            {
                return new RedefinedTransitionProxy(this);
            }
            if ((reference == "SOURCE"))
            {
                return new SourceProxy(this);
            }
            if ((reference == "TARGET"))
            {
                return new TargetProxy(this);
            }
            if ((reference == "CONTAINER"))
            {
                return new ContainerProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._trigger))
            {
                return "trigger";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Transition")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Transition class
        /// </summary>
        public class TransitionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Transition _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TransitionChildrenCollection(Transition parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Effect != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Trigger.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Trigger.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Trigger.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Effect == null))
                {
                    IBehavior effectCasted = item.As<IBehavior>();
                    if ((effectCasted != null))
                    {
                        this._parent.Effect = effectCasted;
                        return;
                    }
                }
                ITrigger triggerCasted = item.As<ITrigger>();
                if ((triggerCasted != null))
                {
                    this._parent.Trigger.Add(triggerCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Effect = null;
                this._parent.Trigger.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Effect))
                {
                    return true;
                }
                if (this._parent.Trigger.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Effect != null))
                {
                    array[arrayIndex] = this._parent.Effect;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> triggerEnumerator = this._parent.Trigger.GetEnumerator();
                try
                {
                    for (
                    ; triggerEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = triggerEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    triggerEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Effect == item))
                {
                    this._parent.Effect = null;
                    return true;
                }
                ITrigger triggerItem = item.As<ITrigger>();
                if (((triggerItem != null) 
                            && this._parent.Trigger.Remove(triggerItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Effect).Concat(this._parent.Trigger).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Transition class
        /// </summary>
        public class TransitionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Transition _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TransitionReferencedElementsCollection(Transition parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Effect != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Guard != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.RedefinedTransition != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Source != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Target != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Trigger.Count);
                    if ((this._parent.Container != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Trigger.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Trigger.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Effect == null))
                {
                    IBehavior effectCasted = item.As<IBehavior>();
                    if ((effectCasted != null))
                    {
                        this._parent.Effect = effectCasted;
                        return;
                    }
                }
                if ((this._parent.Guard == null))
                {
                    IConstraint guardCasted = item.As<IConstraint>();
                    if ((guardCasted != null))
                    {
                        this._parent.Guard = guardCasted;
                        return;
                    }
                }
                if ((this._parent.RedefinedTransition == null))
                {
                    ITransition redefinedTransitionCasted = item.As<ITransition>();
                    if ((redefinedTransitionCasted != null))
                    {
                        this._parent.RedefinedTransition = redefinedTransitionCasted;
                        return;
                    }
                }
                if ((this._parent.Source == null))
                {
                    IVertex sourceCasted = item.As<IVertex>();
                    if ((sourceCasted != null))
                    {
                        this._parent.Source = sourceCasted;
                        return;
                    }
                }
                if ((this._parent.Target == null))
                {
                    IVertex targetCasted = item.As<IVertex>();
                    if ((targetCasted != null))
                    {
                        this._parent.Target = targetCasted;
                        return;
                    }
                }
                ITrigger triggerCasted = item.As<ITrigger>();
                if ((triggerCasted != null))
                {
                    this._parent.Trigger.Add(triggerCasted);
                }
                if ((this._parent.Container == null))
                {
                    IRegion containerCasted = item.As<IRegion>();
                    if ((containerCasted != null))
                    {
                        this._parent.Container = containerCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Effect = null;
                this._parent.Guard = null;
                this._parent.RedefinedTransition = null;
                this._parent.Source = null;
                this._parent.Target = null;
                this._parent.Trigger.Clear();
                this._parent.Container = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Effect))
                {
                    return true;
                }
                if ((item == this._parent.Guard))
                {
                    return true;
                }
                if ((item == this._parent.RedefinedTransition))
                {
                    return true;
                }
                if ((item == this._parent.Source))
                {
                    return true;
                }
                if ((item == this._parent.Target))
                {
                    return true;
                }
                if (this._parent.Trigger.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Container))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Effect != null))
                {
                    array[arrayIndex] = this._parent.Effect;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Guard != null))
                {
                    array[arrayIndex] = this._parent.Guard;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.RedefinedTransition != null))
                {
                    array[arrayIndex] = this._parent.RedefinedTransition;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Source != null))
                {
                    array[arrayIndex] = this._parent.Source;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Target != null))
                {
                    array[arrayIndex] = this._parent.Target;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> triggerEnumerator = this._parent.Trigger.GetEnumerator();
                try
                {
                    for (
                    ; triggerEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = triggerEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    triggerEnumerator.Dispose();
                }
                if ((this._parent.Container != null))
                {
                    array[arrayIndex] = this._parent.Container;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Effect == item))
                {
                    this._parent.Effect = null;
                    return true;
                }
                if ((this._parent.Guard == item))
                {
                    this._parent.Guard = null;
                    return true;
                }
                if ((this._parent.RedefinedTransition == item))
                {
                    this._parent.RedefinedTransition = null;
                    return true;
                }
                if ((this._parent.Source == item))
                {
                    this._parent.Source = null;
                    return true;
                }
                if ((this._parent.Target == item))
                {
                    this._parent.Target = null;
                    return true;
                }
                ITrigger triggerItem = item.As<ITrigger>();
                if (((triggerItem != null) 
                            && this._parent.Trigger.Remove(triggerItem)))
                {
                    return true;
                }
                if ((this._parent.Container == item))
                {
                    this._parent.Container = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Effect).Concat(this._parent.Guard).Concat(this._parent.RedefinedTransition).Concat(this._parent.Source).Concat(this._parent.Target).Concat(this._parent.Trigger).Concat(this._parent.Container).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the kind property
        /// </summary>
        private sealed class KindProxy : ModelPropertyChange<ITransition, TransitionKind>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public KindProxy(ITransition modelElement) : 
                    base(modelElement, "kind")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override TransitionKind Value
            {
                get
                {
                    return this.ModelElement.Kind;
                }
                set
                {
                    this.ModelElement.Kind = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the effect property
        /// </summary>
        private sealed class EffectProxy : ModelPropertyChange<ITransition, IBehavior>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public EffectProxy(ITransition modelElement) : 
                    base(modelElement, "effect")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBehavior Value
            {
                get
                {
                    return this.ModelElement.Effect;
                }
                set
                {
                    this.ModelElement.Effect = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the guard property
        /// </summary>
        private sealed class GuardProxy : ModelPropertyChange<ITransition, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public GuardProxy(ITransition modelElement) : 
                    base(modelElement, "guard")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.Guard;
                }
                set
                {
                    this.ModelElement.Guard = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the redefinedTransition property
        /// </summary>
        private sealed class RedefinedTransitionProxy : ModelPropertyChange<ITransition, ITransition>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RedefinedTransitionProxy(ITransition modelElement) : 
                    base(modelElement, "redefinedTransition")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITransition Value
            {
                get
                {
                    return this.ModelElement.RedefinedTransition;
                }
                set
                {
                    this.ModelElement.RedefinedTransition = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the source property
        /// </summary>
        private sealed class SourceProxy : ModelPropertyChange<ITransition, IVertex>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SourceProxy(ITransition modelElement) : 
                    base(modelElement, "source")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IVertex Value
            {
                get
                {
                    return this.ModelElement.Source;
                }
                set
                {
                    this.ModelElement.Source = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the target property
        /// </summary>
        private sealed class TargetProxy : ModelPropertyChange<ITransition, IVertex>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TargetProxy(ITransition modelElement) : 
                    base(modelElement, "target")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IVertex Value
            {
                get
                {
                    return this.ModelElement.Target;
                }
                set
                {
                    this.ModelElement.Target = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the container property
        /// </summary>
        private sealed class ContainerProxy : ModelPropertyChange<ITransition, IRegion>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ContainerProxy(ITransition modelElement) : 
                    base(modelElement, "container")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IRegion Value
            {
                get
                {
                    return this.ModelElement.Container;
                }
                set
                {
                    this.ModelElement.Container = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isLeaf property
        /// </summary>
        private sealed class IsLeafProxy : ModelPropertyChange<IRedefinableElement, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsLeafProxy(IRedefinableElement modelElement) : 
                    base(modelElement, "isLeaf")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsLeaf;
                }
                set
                {
                    this.ModelElement.IsLeaf = value;
                }
            }
        }
    }
}

