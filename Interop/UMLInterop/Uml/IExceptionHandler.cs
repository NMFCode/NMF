//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for ExceptionHandler
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ExceptionHandler))]
    [XmlDefaultImplementationTypeAttribute(typeof(ExceptionHandler))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//ExceptionHandler")]
    public interface IExceptionHandler : IModelElement, IElement
    {
        
        /// <summary>
        /// An ObjectNode within the handlerBody. When the ExceptionHandler catches an exception, the exception token is placed on this ObjectNode, causing the handlerBody to execute.
        ///<p>From package UML::Activities.</p>
        /// </summary>
        [DisplayNameAttribute("exceptionInput")]
        [DescriptionAttribute("An ObjectNode within the handlerBody. When the ExceptionHandler catches an except" +
            "ion, the exception token is placed on this ObjectNode, causing the handlerBody t" +
            "o execute.\n<p>From package UML::Activities.</p>")]
        [CategoryAttribute("ExceptionHandler")]
        [XmlElementNameAttribute("exceptionInput")]
        [XmlAttributeAttribute(true)]
        IObjectNode ExceptionInput
        {
            get;
            set;
        }
        
        /// <summary>
        /// The Classifiers whose instances the ExceptionHandler catches as exceptions. If an exception occurs whose type is any exceptionType, the ExceptionHandler catches the exception and executes the handlerBody.
        ///<p>From package UML::Activities.</p>
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("exceptionType")]
        [DescriptionAttribute("The Classifiers whose instances the ExceptionHandler catches as exceptions. If an" +
            " exception occurs whose type is any exceptionType, the ExceptionHandler catches " +
            "the exception and executes the handlerBody.\n<p>From package UML::Activities.</p>" +
            "")]
        [CategoryAttribute("ExceptionHandler")]
        [XmlElementNameAttribute("exceptionType")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IClassifier> ExceptionType
        {
            get;
        }
        
        /// <summary>
        /// An ExecutableNode that is executed if the ExceptionHandler catches an exception.
        ///<p>From package UML::Activities.</p>
        /// </summary>
        [DisplayNameAttribute("handlerBody")]
        [DescriptionAttribute("An ExecutableNode that is executed if the ExceptionHandler catches an exception.\n" +
            "<p>From package UML::Activities.</p>")]
        [CategoryAttribute("ExceptionHandler")]
        [XmlElementNameAttribute("handlerBody")]
        [XmlAttributeAttribute(true)]
        IExecutableNode HandlerBody
        {
            get;
            set;
        }
        
        /// <summary>
        /// The ExecutableNode protected by the ExceptionHandler. If an exception propagates out of the protectedNode and has a type matching one of the exceptionTypes, then it is caught by this ExceptionHandler.
        ///<p>From package UML::Activities.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("protectedNode")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("handler")]
        IExecutableNode ProtectedNode
        {
            get;
            set;
        }
        
        /// <summary>
        /// The handlerBody has no incoming or outgoing ActivityEdges and the exceptionInput has no incoming ActivityEdges.
        ///handlerBody.incoming->isEmpty() and handlerBody.outgoing->isEmpty() and exceptionInput.incoming->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Handler_body_edges(object diagnostics, object context);
        
        /// <summary>
        /// If the protectedNode is an Action with OutputPins, then the handlerBody must also be an Action with the same number of OutputPins, which are compatible in type, ordering, and multiplicity to those of the protectedNode.
        ///(protectedNode.oclIsKindOf(Action) and protectedNode.oclAsType(Action).output->notEmpty()) implies
        ///(
        ///  handlerBody.oclIsKindOf(Action) and 
        ///  let protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output,
        ///        handlerBodyOutput : OrderedSet(OutputPin) =  handlerBody.oclAsType(Action).output in
        ///    protectedNodeOutput->size() = handlerBodyOutput->size() and
        ///    Sequence{1..protectedNodeOutput->size()}->forAll(i |
        ///    	handlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and
        ///    	handlerBodyOutput->at(i).isOrdered=protectedNodeOutput->at(i).isOrdered and
        ///    	handlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i)))
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Output_pins(object diagnostics, object context);
        
        /// <summary>
        /// The handlerBody is an Action with one InputPin, and that InputPin is the same as the exceptionInput.
        ///handlerBody.oclIsKindOf(Action) and
        ///let inputs: OrderedSet(InputPin) = handlerBody.oclAsType(Action).input in
        ///inputs->size()=1 and inputs->first()=exceptionInput
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool One_input(object diagnostics, object context);
        
        /// <summary>
        /// An ActivityEdge that has a source within the handlerBody of an ExceptionHandler must have its target in the handlerBody also, and vice versa.
        ///let nodes:Set(ActivityNode) = handlerBody.oclAsType(Action).allOwnedNodes() in
        ///nodes.outgoing->forAll(nodes->includes(target)) and
        ///nodes.incoming->forAll(nodes->includes(source))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Edge_source_target(object diagnostics, object context);
        
        /// <summary>
        /// The handlerBody must have the same owner as the protectedNode.
        ///handlerBody.owner=protectedNode.owner
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Handler_body_owner(object diagnostics, object context);
        
        /// <summary>
        /// The exceptionInput must either have no type or every exceptionType must conform to the exceptionInput type.
        ///exceptionInput.type=null or 
        ///exceptionType->forAll(conformsTo(exceptionInput.type.oclAsType(Classifier)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Exception_input_type(object diagnostics, object context);
    }
}

