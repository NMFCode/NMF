//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for Transition
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Transition))]
    [XmlDefaultImplementationTypeAttribute(typeof(Transition))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Transition")]
    public interface ITransition : IModelElement, IRedefinableElement, NMF.Interop.Uml.INamespace
    {
        
        /// <summary>
        /// Indicates the precise type of the Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DefaultValueAttribute(TransitionKind.External)]
        [DisplayNameAttribute("kind")]
        [DescriptionAttribute("Indicates the precise type of the Transition.\n<p>From package UML::StateMachines." +
            "</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("kind")]
        [XmlAttributeAttribute(true)]
        TransitionKind Kind
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies an optional behavior to be performed when the Transition fires.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("effect")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBehavior Effect
        {
            get;
            set;
        }
        
        /// <summary>
        /// A guard is a Constraint that provides a fine-grained control over the firing of the Transition. The guard is evaluated when an Event occurrence is dispatched by the StateMachine. If the guard is true at that time, the Transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. Guard expressions with side effects are ill formed.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("guard")]
        [DescriptionAttribute(@"A guard is a Constraint that provides a fine-grained control over the firing of the Transition. The guard is evaluated when an Event occurrence is dispatched by the StateMachine. If the guard is true at that time, the Transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. Guard expressions with side effects are ill formed.
<p>From package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("guard")]
        [XmlAttributeAttribute(true)]
        IConstraint Guard
        {
            get;
            set;
        }
        
        /// <summary>
        /// The Transition that is redefined by this Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("redefinedTransition")]
        [DescriptionAttribute("The Transition that is redefined by this Transition.\n<p>From package UML::StateMa" +
            "chines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("redefinedTransition")]
        [XmlAttributeAttribute(true)]
        ITransition RedefinedTransition
        {
            get;
            set;
        }
        
        /// <summary>
        /// Designates the originating Vertex (State or Pseudostate) of the Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("source")]
        [DescriptionAttribute("Designates the originating Vertex (State or Pseudostate) of the Transition.\n<p>Fr" +
            "om package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("source")]
        [XmlAttributeAttribute(true)]
        IVertex Source
        {
            get;
            set;
        }
        
        /// <summary>
        /// Designates the target Vertex that is reached when the Transition is taken.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("target")]
        [DescriptionAttribute("Designates the target Vertex that is reached when the Transition is taken.\n<p>Fro" +
            "m package UML::StateMachines.</p>")]
        [CategoryAttribute("Transition")]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(true)]
        IVertex Target
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies the Triggers that may fire the transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("trigger")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<ITrigger> Trigger
        {
            get;
        }
        
        /// <summary>
        /// Designates the Region that owns this Transition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("container")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("transition")]
        IRegion Container
        {
            get;
            set;
        }
        
        /// <summary>
        /// A Transition with kind external can source any Vertex except entry points.
        ///(kind = TransitionKind::external) implies
        ///	not (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool State_is_external(object diagnostics, object context);
        
        /// <summary>
        /// A join segment must not have Guards or Triggers.
        ///(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (guard = null and trigger->isEmpty())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Join_segment_guards(object diagnostics, object context);
        
        /// <summary>
        /// A Transition with kind internal must have a State as its source, and its source and target must be equal.
        ///(kind = TransitionKind::internal) implies
        ///		(source.oclIsKindOf (State) and source = target)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool State_is_internal(object diagnostics, object context);
        
        /// <summary>
        /// Transitions outgoing Pseudostates may not have a Trigger.
        ///source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind <> PseudostateKind::initial) implies trigger->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Outgoing_pseudostates(object diagnostics, object context);
        
        /// <summary>
        /// A join segment must always originate from a State.
        ///(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (source.oclIsKindOf(State))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Join_segment_state(object diagnostics, object context);
        
        /// <summary>
        /// A fork segment must always target a State.
        ///(source.oclIsKindOf(Pseudostate) and  source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (target.oclIsKindOf(State))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Fork_segment_state(object diagnostics, object context);
        
        /// <summary>
        /// A Transition with kind local must have a composite State or an entry point as its source.
        ///(kind = TransitionKind::local) implies
        ///		((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or
        ///		(source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool State_is_local(object diagnostics, object context);
        
        /// <summary>
        /// An initial Transition at the topmost level Region of a StateMachine that has no Trigger.
        ///(source.oclIsKindOf(Pseudostate) and container.stateMachine->notEmpty()) implies
        ///	trigger->isEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Initial_transition(object diagnostics, object context);
        
        /// <summary>
        /// A fork segment must not have Guards or Triggers.
        ///(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (guard = null and trigger->isEmpty())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Fork_segment_guards(object diagnostics, object context);
        
        /// <summary>
        /// The query containingStateMachine() returns the StateMachine that contains the Transition either directly or transitively.
        ///result = (container.containingStateMachine())
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        IStateMachine ContainingStateMachine();
        
        /// <summary>
        /// The redefinition context of a Transition is the nearest containing StateMachine.
        ///result = (let sm : StateMachine = containingStateMachine() in
        ///if sm._'context' = null or sm.general->notEmpty() then
        ///  sm
        ///else
        ///  sm._'context'
        ///endif)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        IClassifier RedefinitionContext();
    }
}

