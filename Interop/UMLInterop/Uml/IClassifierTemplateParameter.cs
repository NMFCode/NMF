//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for ClassifierTemplateParameter
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ClassifierTemplateParameter))]
    [XmlDefaultImplementationTypeAttribute(typeof(ClassifierTemplateParameter))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//ClassifierTemplateParameter")]
    public interface IClassifierTemplateParameter : IModelElement, ITemplateParameter
    {
        
        /// <summary>
        /// Constrains the required relationship between an actual parameter and the parameteredElement for this formal parameter.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DefaultValueAttribute(true)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("allowSubstitutable")]
        [DescriptionAttribute("Constrains the required relationship between an actual parameter and the paramete" +
            "redElement for this formal parameter.\n<p>From package UML::Classification.</p>")]
        [CategoryAttribute("ClassifierTemplateParameter")]
        [XmlElementNameAttribute("allowSubstitutable")]
        [XmlAttributeAttribute(true)]
        bool AllowSubstitutable
        {
            get;
            set;
        }
        
        /// <summary>
        /// The classifiers that constrain the argument that can be used for the parameter. If the allowSubstitutable attribute is true, then any Classifier that is compatible with this constraining Classifier can be substituted; otherwise, it must be either this Classifier or one of its specializations. If this property is empty, there are no constraints on the Classifier that can be used as an argument.
        ///<p>From package UML::Classification.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("constrainingClassifier")]
        [DescriptionAttribute(@"The classifiers that constrain the argument that can be used for the parameter. If the allowSubstitutable attribute is true, then any Classifier that is compatible with this constraining Classifier can be substituted; otherwise, it must be either this Classifier or one of its specializations. If this property is empty, there are no constraints on the Classifier that can be used as an argument.
<p>From package UML::Classification.</p>")]
        [CategoryAttribute("ClassifierTemplateParameter")]
        [XmlElementNameAttribute("constrainingClassifier")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ISetExpression<IClassifier> ConstrainingClassifier
        {
            get;
        }
        
        /// <summary>
        /// If allowSubstitutable is true, then there must be a constrainingClassifier.
        ///allowSubstitutable implies constrainingClassifier->notEmpty()
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Has_constraining_classifier(object diagnostics, object context);
        
        /// <summary>
        /// The parameteredElement has no direct features, and if constrainedElement is empty it has no generalizations.
        ///parameteredElement.feature->isEmpty() and (constrainingClassifier->isEmpty() implies  parameteredElement.allParents()->isEmpty())
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Parametered_element_no_features(object diagnostics, object context);
        
        /// <summary>
        /// If the parameteredElement is not abstract, then the Classifier used as an argument shall not be abstract.
        ///(not parameteredElement.isAbstract) implies templateParameterSubstitution.actual->forAll(a | not a.oclAsType(Classifier).isAbstract)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Matching_abstract(object diagnostics, object context);
        
        /// <summary>
        /// The argument to a ClassifierTemplateParameter is a Classifier.
        /// templateParameterSubstitution.actual->forAll(a | a.oclIsKindOf(Classifier))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Actual_is_classifier(object diagnostics, object context);
        
        /// <summary>
        /// If there are any constrainingClassifiers, then every argument must be the same as or a specialization of them, or if allowSubstitutable is true, then it can also be substitutable.
        ///templateParameterSubstitution.actual->forAll( a |
        ///  let arg : Classifier = a.oclAsType(Classifier) in
        ///    constrainingClassifier->forAll(
        ///      cc |  
        ///         arg = cc or arg.conformsTo(cc) or (allowSubstitutable and arg.isSubstitutableFor(cc))
        ///      )
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Constraining_classifiers_constrain_args(object diagnostics, object context);
        
        /// <summary>
        /// If there are any constrainingClassifiers, then the parameteredElement must be the same as or a specialization of them, or if allowSubstitutable is true, then it can also be substitutable.
        ///constrainingClassifier->forAll(
        ///     cc |  parameteredElement = cc or parameteredElement.conformsTo(cc) or (allowSubstitutable and parameteredElement.isSubstitutableFor(cc))
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Constraining_classifiers_constrain_parametered_element(object diagnostics, object context);
    }
}

