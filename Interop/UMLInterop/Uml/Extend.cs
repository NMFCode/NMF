//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A relationship from an extending UseCase to an extended UseCase that specifies how and when the behavior defined in the extending UseCase can be inserted into the behavior defined in the extended UseCase.
    ///<p>From package UML::UseCases.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Extend")]
    [DebuggerDisplayAttribute("Extend {Name}")]
    public partial class Extend : NamedElement, IExtend, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _extension_pointsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveExtension_pointsOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _conditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConditionReference);
        
        /// <summary>
        /// The backing field for the Condition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConstraint _condition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _extendedCaseReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveExtendedCaseReference);
        
        /// <summary>
        /// The backing field for the ExtendedCase property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IUseCase _extendedCase;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _extensionLocationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveExtensionLocationReference);
        
        /// <summary>
        /// The backing field for the ExtensionLocation property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationOrderedSet<IExtensionPoint> _extensionLocation;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _extensionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveExtensionReference);
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Extend()
        {
            this._extensionLocation = new ObservableAssociationOrderedSet<IExtensionPoint>();
            this._extensionLocation.CollectionChanging += this.ExtensionLocationCollectionChanging;
            this._extensionLocation.CollectionChanged += this.ExtensionLocationCollectionChanged;
        }
        
        /// <summary>
        /// References the condition that must hold when the first ExtensionPoint is reached for the extension to take place. If no constraint is associated with the Extend relationship, the extension is unconditional.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("condition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IConstraint Condition
        {
            get
            {
                return this._condition;
            }
            set
            {
                if ((this._condition != value))
                {
                    IConstraint old = this._condition;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Condition", e, _conditionReference);
                    this._condition = value;
                    if ((old != null))
                    {
                        old.Parent = null;
                        old.ParentChanged -= this.OnResetCondition;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetCondition;
                    }
                    this.OnPropertyChanged("Condition", e, _conditionReference);
                }
            }
        }
        
        /// <summary>
        /// The UseCase that is being extended.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [DisplayNameAttribute("extendedCase")]
        [DescriptionAttribute("The UseCase that is being extended.\n<p>From package UML::UseCases.</p>")]
        [CategoryAttribute("Extend")]
        [XmlElementNameAttribute("extendedCase")]
        [XmlAttributeAttribute(true)]
        public IUseCase ExtendedCase
        {
            get
            {
                return this._extendedCase;
            }
            set
            {
                if ((this._extendedCase != value))
                {
                    IUseCase old = this._extendedCase;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ExtendedCase", e, _extendedCaseReference);
                    this._extendedCase = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetExtendedCase;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetExtendedCase;
                    }
                    this.OnPropertyChanged("ExtendedCase", e, _extendedCaseReference);
                }
            }
        }
        
        /// <summary>
        /// An ordered list of ExtensionPoints belonging to the extended UseCase, specifying where the respective behavioral fragments of the extending UseCase are to be inserted. The first fragment in the extending UseCase is associated with the first extension point in the list, the second fragment with the second point, and so on. Note that, in most practical cases, the extending UseCase has just a single behavior fragment, so that the list of ExtensionPoints is trivial.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("extensionLocation")]
        [DescriptionAttribute(@"An ordered list of ExtensionPoints belonging to the extended UseCase, specifying where the respective behavioral fragments of the extending UseCase are to be inserted. The first fragment in the extending UseCase is associated with the first extension point in the list, the second fragment with the second point, and so on. Note that, in most practical cases, the extending UseCase has just a single behavior fragment, so that the list of ExtensionPoints is trivial.
<p>From package UML::UseCases.</p>")]
        [CategoryAttribute("Extend")]
        [XmlElementNameAttribute("extensionLocation")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public IOrderedSetExpression<IExtensionPoint> ExtensionLocation
        {
            get
            {
                return this._extensionLocation;
            }
        }
        
        /// <summary>
        /// The UseCase that represents the extension and owns the Extend relationship.
        ///<p>From package UML::UseCases.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("extension")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("extend")]
        public IUseCase Extension
        {
            get
            {
                return ModelHelper.CastAs<IUseCase>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ExtendChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ExtendReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Extend")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// The ExtensionPoints referenced by the Extend relationship must belong to the UseCase that is being extended.
        ///extensionLocation->forAll (xp | extendedCase.extensionPoint->includes(xp))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Extension_points(object diagnostics, object context)
        {
            System.Func<IExtend, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IExtend, object, object, bool>>(_extension_pointsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method extension_points registered. Use the method" +
                        " broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _extension_pointsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _extension_pointsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _extension_pointsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveExtension_pointsOperation()
        {
            return ClassInstance.LookupOperation("extension_points");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Extend.ClassInstance)).Resolve("condition")));
        }
        
        /// <summary>
        /// Handles the event that the Condition property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetCondition(object sender, System.EventArgs eventArgs)
        {
            this.Condition = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveExtendedCaseReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Extend.ClassInstance)).Resolve("extendedCase")));
        }
        
        /// <summary>
        /// Handles the event that the ExtendedCase property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetExtendedCase(object sender, System.EventArgs eventArgs)
        {
            this.ExtendedCase = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveExtensionLocationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Extend.ClassInstance)).Resolve("extensionLocation")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the ExtensionLocation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ExtensionLocationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("ExtensionLocation", e, _extensionLocationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the ExtensionLocation property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ExtensionLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("ExtensionLocation", e, _extensionLocationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveExtensionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Extend.ClassInstance)).Resolve("extension")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IUseCase oldExtension = ModelHelper.CastAs<IUseCase>(oldParent);
            IUseCase newExtension = ModelHelper.CastAs<IUseCase>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldExtension, newExtension);
            this.OnPropertyChanging("Extension", e, _extensionReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IUseCase oldExtension = ModelHelper.CastAs<IUseCase>(oldParent);
            IUseCase newExtension = ModelHelper.CastAs<IUseCase>(newParent);
            if ((oldExtension != null))
            {
                oldExtension.Extend.Remove(this);
            }
            if ((newExtension != null))
            {
                newExtension.Extend.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldExtension, newExtension);
            this.OnPropertyChanged("Extension", e, _extensionReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Condition))
            {
                return ModelHelper.CreatePath("condition");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "CONDITION"))
            {
                return this.Condition;
            }
            if ((reference == "EXTENDEDCASE"))
            {
                return this.ExtendedCase;
            }
            if ((reference == "EXTENSIONLOCATION"))
            {
                if ((index < this.ExtensionLocation.Count))
                {
                    return this.ExtensionLocation[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "EXTENSION"))
            {
                return this.Extension;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "EXTENSIONLOCATION"))
            {
                return this._extensionLocation;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "CONDITION"))
            {
                this.Condition = ((IConstraint)(value));
                return;
            }
            if ((feature == "EXTENDEDCASE"))
            {
                this.ExtendedCase = ((IUseCase)(value));
                return;
            }
            if ((feature == "EXTENSION"))
            {
                this.Extension = ((IUseCase)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "CONDITION"))
            {
                return new ConditionProxy(this);
            }
            if ((reference == "EXTENDEDCASE"))
            {
                return new ExtendedCaseProxy(this);
            }
            if ((reference == "EXTENSION"))
            {
                return new ExtensionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Extend")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Extend class
        /// </summary>
        public class ExtendChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Extend _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ExtendChildrenCollection(Extend parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Condition != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Condition == null))
                {
                    IConstraint conditionCasted = item.As<IConstraint>();
                    if ((conditionCasted != null))
                    {
                        this._parent.Condition = conditionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Condition = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Condition))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Condition != null))
                {
                    array[arrayIndex] = this._parent.Condition;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Condition == item))
                {
                    this._parent.Condition = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Condition).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Extend class
        /// </summary>
        public class ExtendReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Extend _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ExtendReferencedElementsCollection(Extend parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Condition != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.ExtendedCase != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.ExtensionLocation.Count);
                    if ((this._parent.Extension != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.ExtensionLocation.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.ExtensionLocation.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Condition == null))
                {
                    IConstraint conditionCasted = item.As<IConstraint>();
                    if ((conditionCasted != null))
                    {
                        this._parent.Condition = conditionCasted;
                        return;
                    }
                }
                if ((this._parent.ExtendedCase == null))
                {
                    IUseCase extendedCaseCasted = item.As<IUseCase>();
                    if ((extendedCaseCasted != null))
                    {
                        this._parent.ExtendedCase = extendedCaseCasted;
                        return;
                    }
                }
                IExtensionPoint extensionLocationCasted = item.As<IExtensionPoint>();
                if ((extensionLocationCasted != null))
                {
                    this._parent.ExtensionLocation.Add(extensionLocationCasted);
                }
                if ((this._parent.Extension == null))
                {
                    IUseCase extensionCasted = item.As<IUseCase>();
                    if ((extensionCasted != null))
                    {
                        this._parent.Extension = extensionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Condition = null;
                this._parent.ExtendedCase = null;
                this._parent.ExtensionLocation.Clear();
                this._parent.Extension = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Condition))
                {
                    return true;
                }
                if ((item == this._parent.ExtendedCase))
                {
                    return true;
                }
                if (this._parent.ExtensionLocation.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Extension))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Condition != null))
                {
                    array[arrayIndex] = this._parent.Condition;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.ExtendedCase != null))
                {
                    array[arrayIndex] = this._parent.ExtendedCase;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> extensionLocationEnumerator = this._parent.ExtensionLocation.GetEnumerator();
                try
                {
                    for (
                    ; extensionLocationEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = extensionLocationEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    extensionLocationEnumerator.Dispose();
                }
                if ((this._parent.Extension != null))
                {
                    array[arrayIndex] = this._parent.Extension;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Condition == item))
                {
                    this._parent.Condition = null;
                    return true;
                }
                if ((this._parent.ExtendedCase == item))
                {
                    this._parent.ExtendedCase = null;
                    return true;
                }
                IExtensionPoint extensionPointItem = item.As<IExtensionPoint>();
                if (((extensionPointItem != null) 
                            && this._parent.ExtensionLocation.Remove(extensionPointItem)))
                {
                    return true;
                }
                if ((this._parent.Extension == item))
                {
                    this._parent.Extension = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Condition).Concat(this._parent.ExtendedCase).Concat(this._parent.ExtensionLocation).Concat(this._parent.Extension).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the condition property
        /// </summary>
        private sealed class ConditionProxy : ModelPropertyChange<IExtend, IConstraint>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ConditionProxy(IExtend modelElement) : 
                    base(modelElement, "condition")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConstraint Value
            {
                get
                {
                    return this.ModelElement.Condition;
                }
                set
                {
                    this.ModelElement.Condition = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the extendedCase property
        /// </summary>
        private sealed class ExtendedCaseProxy : ModelPropertyChange<IExtend, IUseCase>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExtendedCaseProxy(IExtend modelElement) : 
                    base(modelElement, "extendedCase")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IUseCase Value
            {
                get
                {
                    return this.ModelElement.ExtendedCase;
                }
                set
                {
                    this.ModelElement.ExtendedCase = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the extension property
        /// </summary>
        private sealed class ExtensionProxy : ModelPropertyChange<IExtend, IUseCase>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExtensionProxy(IExtend modelElement) : 
                    base(modelElement, "extension")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IUseCase Value
            {
                get
                {
                    return this.ModelElement.Extension;
                }
                set
                {
                    this.ModelElement.Extension = value;
                }
            }
        }
    }
}

