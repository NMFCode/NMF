//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// An Action is the fundamental unit of executable functionality. The execution of an Action represents some transformation or processing in the modeled system. Actions provide the ExecutableNodes within Activities and may also be used within Interactions.
    ///<p>From package UML::Actions.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Action")]
    [DebuggerDisplayAttribute("Action {Name}")]
    public abstract partial class Action : ExecutableNode, IAction, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getContextOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetContextOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allActionsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllActionsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _allOwnedNodesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveAllOwnedNodesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _containingBehaviorOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveContainingBehaviorOperation);
        
        /// <summary>
        /// The backing field for the IsLocallyReentrant property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private bool _isLocallyReentrant = false;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _isLocallyReentrantAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveIsLocallyReentrantAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _localPostconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveLocalPostconditionReference);
        
        /// <summary>
        /// The backing field for the LocalPostcondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConstraint> _localPostcondition;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _localPreconditionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveLocalPreconditionReference);
        
        /// <summary>
        /// The backing field for the LocalPrecondition property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IConstraint> _localPrecondition;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Action()
        {
            this._localPostcondition = new ObservableCompositionOrderedSet<IConstraint>(this);
            this._localPostcondition.CollectionChanging += this.LocalPostconditionCollectionChanging;
            this._localPostcondition.CollectionChanged += this.LocalPostconditionCollectionChanged;
            this._localPrecondition = new ObservableCompositionOrderedSet<IConstraint>(this);
            this._localPrecondition.CollectionChanging += this.LocalPreconditionCollectionChanging;
            this._localPrecondition.CollectionChanged += this.LocalPreconditionCollectionChanged;
        }
        
        /// <summary>
        /// If true, the Action can begin a new, concurrent execution, even if there is already another execution of the Action ongoing. If false, the Action cannot begin a new execution until any previous execution has completed.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DefaultValueAttribute(false)]
        [TypeConverterAttribute(typeof(LowercaseBooleanConverter))]
        [DisplayNameAttribute("isLocallyReentrant")]
        [DescriptionAttribute("If true, the Action can begin a new, concurrent execution, even if there is alrea" +
            "dy another execution of the Action ongoing. If false, the Action cannot begin a " +
            "new execution until any previous execution has completed.\n<p>From package UML::A" +
            "ctions.</p>")]
        [CategoryAttribute("Action")]
        [XmlElementNameAttribute("isLocallyReentrant")]
        [XmlAttributeAttribute(true)]
        public bool IsLocallyReentrant
        {
            get
            {
                return this._isLocallyReentrant;
            }
            set
            {
                if ((this._isLocallyReentrant != value))
                {
                    bool old = this._isLocallyReentrant;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsLocallyReentrant", e, _isLocallyReentrantAttribute);
                    this._isLocallyReentrant = value;
                    this.OnPropertyChanged("IsLocallyReentrant", e, _isLocallyReentrantAttribute);
                }
            }
        }
        
        /// <summary>
        /// A Constraint that must be satisfied when execution of the Action is completed.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("localPostcondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConstraint> LocalPostcondition
        {
            get
            {
                return this._localPostcondition;
            }
        }
        
        /// <summary>
        /// A Constraint that must be satisfied when execution of the Action is started.
        ///<p>From package UML::Actions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("localPrecondition")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IConstraint> LocalPrecondition
        {
            get
            {
                return this._localPrecondition;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ActionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ActionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Action")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// The derivation for the context property.
        ///result = (let behavior: Behavior = self.containingBehavior() in
        ///if behavior=null then null
        ///else if behavior._'context' = null then behavior
        ///else behavior._'context'
        ///endif
        ///endif)
        ///<p>From package UML::Actions.</p>
        /// </summary>
        public IClassifier GetContext()
        {
            System.Func<IAction, IClassifier> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IAction, IClassifier>>(_getContextOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getContext registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getContextOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getContextOperation.Value, e));
            IClassifier result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getContextOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetContextOperation()
        {
            return ClassInstance.LookupOperation("getContext");
        }
        
        /// <summary>
        /// Return this Action and all Actions contained directly or indirectly in it. By default only the Action itself is returned, but the operation is overridden for StructuredActivityNodes.
        ///result = (self->asSet())
        ///<p>From package UML::Actions.</p>
        /// </summary>
        public ISetExpression<IAction> AllActions()
        {
            System.Func<IAction, ISetExpression<IAction>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IAction, ISetExpression<IAction>>>(_allActionsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allActions registered. Use the method broke" +
                        "r to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allActionsOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allActionsOperation.Value, e));
            ISetExpression<IAction> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allActionsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllActionsOperation()
        {
            return ClassInstance.LookupOperation("allActions");
        }
        
        /// <summary>
        /// Returns all the ActivityNodes directly or indirectly owned by this Action. This includes at least all the Pins of the Action.
        ///result = (input.oclAsType(Pin)->asSet()->union(output->asSet()))
        ///<p>From package UML::Actions.</p>
        /// </summary>
        public ISetExpression<IActivityNode> AllOwnedNodes()
        {
            System.Func<IAction, ISetExpression<IActivityNode>> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IAction, ISetExpression<IActivityNode>>>(_allOwnedNodesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method allOwnedNodes registered. Use the method br" +
                        "oker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _allOwnedNodesOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _allOwnedNodesOperation.Value, e));
            ISetExpression<IActivityNode> result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _allOwnedNodesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveAllOwnedNodesOperation()
        {
            return ClassInstance.LookupOperation("allOwnedNodes");
        }
        
        /// <summary>
        /// result = (if inStructuredNode<>null then inStructuredNode.containingBehavior() 
        ///else if activity<>null then activity
        ///else interaction 
        ///endif
        ///endif
        ///)
        ///<p>From package UML::Actions.</p>
        /// </summary>
        public IBehavior ContainingBehavior()
        {
            System.Func<IAction, IBehavior> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IAction, IBehavior>>(_containingBehaviorOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method containingBehavior registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _containingBehaviorOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _containingBehaviorOperation.Value, e));
            IBehavior result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _containingBehaviorOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveContainingBehaviorOperation()
        {
            return ClassInstance.LookupOperation("containingBehavior");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveIsLocallyReentrantAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Action.ClassInstance)).Resolve("isLocallyReentrant")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveLocalPostconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Action.ClassInstance)).Resolve("localPostcondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the LocalPostcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LocalPostconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("LocalPostcondition", e, _localPostconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the LocalPostcondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LocalPostconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("LocalPostcondition", e, _localPostconditionReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveLocalPreconditionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Action.ClassInstance)).Resolve("localPrecondition")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the LocalPrecondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LocalPreconditionCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("LocalPrecondition", e, _localPreconditionReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the LocalPrecondition property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void LocalPreconditionCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("LocalPrecondition", e, _localPreconditionReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int localPostconditionIndex = ModelHelper.IndexOfReference(this.LocalPostcondition, element);
            if ((localPostconditionIndex != -1))
            {
                return ModelHelper.CreatePath("localPostcondition", localPostconditionIndex);
            }
            int localPreconditionIndex = ModelHelper.IndexOfReference(this.LocalPrecondition, element);
            if ((localPreconditionIndex != -1))
            {
                return ModelHelper.CreatePath("localPrecondition", localPreconditionIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "LOCALPOSTCONDITION"))
            {
                if ((index < this.LocalPostcondition.Count))
                {
                    return this.LocalPostcondition[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "LOCALPRECONDITION"))
            {
                if ((index < this.LocalPrecondition.Count))
                {
                    return this.LocalPrecondition[index];
                }
                else
                {
                    return null;
                }
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISLOCALLYREENTRANT"))
            {
                return this.IsLocallyReentrant;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "LOCALPOSTCONDITION"))
            {
                return this._localPostcondition;
            }
            if ((feature == "LOCALPRECONDITION"))
            {
                return this._localPrecondition;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "ISLOCALLYREENTRANT"))
            {
                this.IsLocallyReentrant = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISLOCALLYREENTRANT"))
            {
                return Observable.Box(new IsLocallyReentrantProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._localPostcondition))
            {
                return "localPostcondition";
            }
            if ((container == this._localPrecondition))
            {
                return "localPrecondition";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Action")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Action class
        /// </summary>
        public class ActionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Action _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ActionChildrenCollection(Action parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.LocalPostcondition.Count);
                    count = (count + this._parent.LocalPrecondition.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.LocalPostcondition.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.LocalPrecondition.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.LocalPostcondition.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.LocalPrecondition.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IConstraint localPostconditionCasted = item.As<IConstraint>();
                if ((localPostconditionCasted != null))
                {
                    this._parent.LocalPostcondition.Add(localPostconditionCasted);
                }
                IConstraint localPreconditionCasted = item.As<IConstraint>();
                if ((localPreconditionCasted != null))
                {
                    this._parent.LocalPrecondition.Add(localPreconditionCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.LocalPostcondition.Clear();
                this._parent.LocalPrecondition.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.LocalPostcondition.Contains(item))
                {
                    return true;
                }
                if (this._parent.LocalPrecondition.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> localPostconditionEnumerator = this._parent.LocalPostcondition.GetEnumerator();
                try
                {
                    for (
                    ; localPostconditionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = localPostconditionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    localPostconditionEnumerator.Dispose();
                }
                IEnumerator<IModelElement> localPreconditionEnumerator = this._parent.LocalPrecondition.GetEnumerator();
                try
                {
                    for (
                    ; localPreconditionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = localPreconditionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    localPreconditionEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IConstraint constraintItem = item.As<IConstraint>();
                if (((constraintItem != null) 
                            && this._parent.LocalPostcondition.Remove(constraintItem)))
                {
                    return true;
                }
                if (((constraintItem != null) 
                            && this._parent.LocalPrecondition.Remove(constraintItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.LocalPostcondition).Concat(this._parent.LocalPrecondition).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Action class
        /// </summary>
        public class ActionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Action _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ActionReferencedElementsCollection(Action parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.LocalPostcondition.Count);
                    count = (count + this._parent.LocalPrecondition.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.LocalPostcondition.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.LocalPrecondition.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.LocalPostcondition.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.LocalPrecondition.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IConstraint localPostconditionCasted = item.As<IConstraint>();
                if ((localPostconditionCasted != null))
                {
                    this._parent.LocalPostcondition.Add(localPostconditionCasted);
                }
                IConstraint localPreconditionCasted = item.As<IConstraint>();
                if ((localPreconditionCasted != null))
                {
                    this._parent.LocalPrecondition.Add(localPreconditionCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.LocalPostcondition.Clear();
                this._parent.LocalPrecondition.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.LocalPostcondition.Contains(item))
                {
                    return true;
                }
                if (this._parent.LocalPrecondition.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> localPostconditionEnumerator = this._parent.LocalPostcondition.GetEnumerator();
                try
                {
                    for (
                    ; localPostconditionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = localPostconditionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    localPostconditionEnumerator.Dispose();
                }
                IEnumerator<IModelElement> localPreconditionEnumerator = this._parent.LocalPrecondition.GetEnumerator();
                try
                {
                    for (
                    ; localPreconditionEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = localPreconditionEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    localPreconditionEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IConstraint constraintItem = item.As<IConstraint>();
                if (((constraintItem != null) 
                            && this._parent.LocalPostcondition.Remove(constraintItem)))
                {
                    return true;
                }
                if (((constraintItem != null) 
                            && this._parent.LocalPrecondition.Remove(constraintItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.LocalPostcondition).Concat(this._parent.LocalPrecondition).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isLocallyReentrant property
        /// </summary>
        private sealed class IsLocallyReentrantProxy : ModelPropertyChange<IAction, bool>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsLocallyReentrantProxy(IAction modelElement) : 
                    base(modelElement, "isLocallyReentrant")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override bool Value
            {
                get
                {
                    return this.ModelElement.IsLocallyReentrant;
                }
                set
                {
                    this.ModelElement.IsLocallyReentrant = value;
                }
            }
        }
    }
}

