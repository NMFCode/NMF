//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.26
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;


namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// InformationFlows describe circulation of information through a system in a general manner. They do not specify the nature of the information, mechanisms by which it is conveyed, sequences of exchange or any control conditions. During more detailed modeling, representation and realization links may be added to specify which model elements implement an InformationFlow and to show how information is conveyed.  InformationFlows require some kind of “information channel” for unidirectional transmission of information items from sources to targets.  They specify the information channel’s realizations, if any, and identify the information that flows along them.  Information moving along the information channel may be represented by abstract InformationItems and by concrete Classifiers.
    ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//InformationFlow")]
    [DebuggerDisplayAttribute("InformationFlow {Name}")]
    public partial class InformationFlow : PackageableElement, IInformationFlow, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _must_conformOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveMust_conformOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _sources_and_targets_kindOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSources_and_targets_kindOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _convey_classifiersOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveConvey_classifiersOperation);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _conveyedReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConveyedReference);
        
        /// <summary>
        /// The backing field for the Conveyed property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IClassifier> _conveyed;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _informationSourceReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveInformationSourceReference);
        
        /// <summary>
        /// The backing field for the InformationSource property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<INamedElement> _informationSource;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _informationTargetReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveInformationTargetReference);
        
        /// <summary>
        /// The backing field for the InformationTarget property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<INamedElement> _informationTarget;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _realizationReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRealizationReference);
        
        /// <summary>
        /// The backing field for the Realization property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IRelationship> _realization;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _realizingActivityEdgeReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRealizingActivityEdgeReference);
        
        /// <summary>
        /// The backing field for the RealizingActivityEdge property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IActivityEdge> _realizingActivityEdge;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _realizingConnectorReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRealizingConnectorReference);
        
        /// <summary>
        /// The backing field for the RealizingConnector property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IConnector> _realizingConnector;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _realizingMessageReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveRealizingMessageReference);
        
        /// <summary>
        /// The backing field for the RealizingMessage property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableAssociationSet<IMessage> _realizingMessage;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public InformationFlow()
        {
            this._conveyed = new ObservableAssociationSet<IClassifier>();
            this._conveyed.CollectionChanging += this.ConveyedCollectionChanging;
            this._conveyed.CollectionChanged += this.ConveyedCollectionChanged;
            this._informationSource = new ObservableAssociationSet<INamedElement>();
            this._informationSource.CollectionChanging += this.InformationSourceCollectionChanging;
            this._informationSource.CollectionChanged += this.InformationSourceCollectionChanged;
            this._informationTarget = new ObservableAssociationSet<INamedElement>();
            this._informationTarget.CollectionChanging += this.InformationTargetCollectionChanging;
            this._informationTarget.CollectionChanged += this.InformationTargetCollectionChanged;
            this._realization = new ObservableAssociationSet<IRelationship>();
            this._realization.CollectionChanging += this.RealizationCollectionChanging;
            this._realization.CollectionChanged += this.RealizationCollectionChanged;
            this._realizingActivityEdge = new ObservableAssociationSet<IActivityEdge>();
            this._realizingActivityEdge.CollectionChanging += this.RealizingActivityEdgeCollectionChanging;
            this._realizingActivityEdge.CollectionChanged += this.RealizingActivityEdgeCollectionChanged;
            this._realizingConnector = new ObservableAssociationSet<IConnector>();
            this._realizingConnector.CollectionChanging += this.RealizingConnectorCollectionChanging;
            this._realizingConnector.CollectionChanged += this.RealizingConnectorCollectionChanged;
            this._realizingMessage = new ObservableAssociationSet<IMessage>();
            this._realizingMessage.CollectionChanging += this.RealizingMessageCollectionChanging;
            this._realizingMessage.CollectionChanged += this.RealizingMessageCollectionChanged;
        }
        
        /// <summary>
        /// Specifies the information items that may circulate on this information flow.
        ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("conveyed")]
        [DescriptionAttribute("Specifies the information items that may circulate on this information flow.\n<p>F" +
            "rom package UML::InformationFlows.</p>")]
        [CategoryAttribute("InformationFlow")]
        [XmlElementNameAttribute("conveyed")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IClassifier> Conveyed
        {
            get
            {
                return this._conveyed;
            }
        }
        
        /// <summary>
        /// Defines from which source the conveyed InformationItems are initiated.
        ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("informationSource")]
        [DescriptionAttribute("Defines from which source the conveyed InformationItems are initiated.\n<p>From pa" +
            "ckage UML::InformationFlows.</p>")]
        [CategoryAttribute("InformationFlow")]
        [XmlElementNameAttribute("informationSource")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<INamedElement> InformationSource
        {
            get
            {
                return this._informationSource;
            }
        }
        
        /// <summary>
        /// Defines to which target the conveyed InformationItems are directed.
        ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
        /// </summary>
        [LowerBoundAttribute(1)]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("informationTarget")]
        [DescriptionAttribute("Defines to which target the conveyed InformationItems are directed.\n<p>From packa" +
            "ge UML::InformationFlows.</p>")]
        [CategoryAttribute("InformationFlow")]
        [XmlElementNameAttribute("informationTarget")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<INamedElement> InformationTarget
        {
            get
            {
                return this._informationTarget;
            }
        }
        
        /// <summary>
        /// Determines which Relationship will realize the specified flow.
        ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("realization")]
        [DescriptionAttribute("Determines which Relationship will realize the specified flow.\n<p>From package UM" +
            "L::InformationFlows.</p>")]
        [CategoryAttribute("InformationFlow")]
        [XmlElementNameAttribute("realization")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IRelationship> Realization
        {
            get
            {
                return this._realization;
            }
        }
        
        /// <summary>
        /// Determines which ActivityEdges will realize the specified flow.
        ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("realizingActivityEdge")]
        [DescriptionAttribute("Determines which ActivityEdges will realize the specified flow.\n<p>From package U" +
            "ML::InformationFlows.</p>")]
        [CategoryAttribute("InformationFlow")]
        [XmlElementNameAttribute("realizingActivityEdge")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IActivityEdge> RealizingActivityEdge
        {
            get
            {
                return this._realizingActivityEdge;
            }
        }
        
        /// <summary>
        /// Determines which Connectors will realize the specified flow.
        ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("realizingConnector")]
        [DescriptionAttribute("Determines which Connectors will realize the specified flow.\n<p>From package UML:" +
            ":InformationFlows.</p>")]
        [CategoryAttribute("InformationFlow")]
        [XmlElementNameAttribute("realizingConnector")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IConnector> RealizingConnector
        {
            get
            {
                return this._realizingConnector;
            }
        }
        
        /// <summary>
        /// Determines which Messages will realize the specified flow.
        ///&lt;p&gt;From package UML::InformationFlows.&lt;/p&gt;
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("realizingMessage")]
        [DescriptionAttribute("Determines which Messages will realize the specified flow.\n<p>From package UML::I" +
            "nformationFlows.</p>")]
        [CategoryAttribute("InformationFlow")]
        [XmlElementNameAttribute("realizingMessage")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ISetExpression<IMessage> RealizingMessage
        {
            get
            {
                return this._realizingMessage;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new InformationFlowChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new InformationFlowReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//InformationFlow")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// The sources and targets of the information flow must conform to the sources and targets or conversely the targets and sources of the realization relationships.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Must_conform(object diagnostics, object context)
        {
            System.Func<IInformationFlow, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IInformationFlow, object, object, bool>>(_must_conformOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method must_conform registered. Use the method bro" +
                        "ker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _must_conformOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _must_conformOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _must_conformOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveMust_conformOperation()
        {
            return ClassInstance.LookupOperation("must_conform");
        }
        
        /// <summary>
        /// The sources and targets of the information flow can only be one of the following kind: Actor, Node, UseCase, Artifact, Class, Component, Port, Property, Interface, Package, ActivityNode, ActivityPartition,
        ///Behavior and InstanceSpecification except when its classifier is a relationship (i.e. it represents a link).
        ///(self.informationSource-&gt;forAll( sis |
        ///  oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or 
        ///  oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or 
        ///  oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or 
        ///  (oclIsKindOf(InstanceSpecification) and not sis.oclAsType(InstanceSpecification).classifier-&gt;exists(oclIsKindOf(Relationship))))) 
        ///
        ///and
        ///
        ///(self.informationTarget-&gt;forAll( sit | 
        ///  oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or 
        ///  oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or 
        ///  oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or 
        ///(oclIsKindOf(InstanceSpecification) and not sit.oclAsType(InstanceSpecification).classifier-&gt;exists(oclIsKindOf(Relationship)))))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Sources_and_targets_kind(object diagnostics, object context)
        {
            System.Func<IInformationFlow, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IInformationFlow, object, object, bool>>(_sources_and_targets_kindOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method sources_and_targets_kind registered. Use th" +
                        "e method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _sources_and_targets_kindOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _sources_and_targets_kindOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _sources_and_targets_kindOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSources_and_targets_kindOperation()
        {
            return ClassInstance.LookupOperation("sources_and_targets_kind");
        }
        
        /// <summary>
        /// An information flow can only convey classifiers that are allowed to represent an information item.
        ///self.conveyed-&gt;forAll(oclIsKindOf(Class) or oclIsKindOf(Interface)
        ///  or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Convey_classifiers(object diagnostics, object context)
        {
            System.Func<IInformationFlow, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IInformationFlow, object, object, bool>>(_convey_classifiersOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method convey_classifiers registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _convey_classifiersOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _convey_classifiersOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _convey_classifiersOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveConvey_classifiersOperation()
        {
            return ClassInstance.LookupOperation("convey_classifiers");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConveyedReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.InformationFlow.ClassInstance)).Resolve("conveyed")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Conveyed property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConveyedCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Conveyed", e, _conveyedReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Conveyed property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConveyedCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Conveyed", e, _conveyedReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveInformationSourceReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.InformationFlow.ClassInstance)).Resolve("informationSource")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the InformationSource property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void InformationSourceCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("InformationSource", e, _informationSourceReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the InformationSource property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void InformationSourceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("InformationSource", e, _informationSourceReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveInformationTargetReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.InformationFlow.ClassInstance)).Resolve("informationTarget")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the InformationTarget property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void InformationTargetCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("InformationTarget", e, _informationTargetReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the InformationTarget property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void InformationTargetCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("InformationTarget", e, _informationTargetReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRealizationReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.InformationFlow.ClassInstance)).Resolve("realization")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Realization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizationCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Realization", e, _realizationReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Realization property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Realization", e, _realizationReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRealizingActivityEdgeReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.InformationFlow.ClassInstance)).Resolve("realizingActivityEdge")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RealizingActivityEdge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizingActivityEdgeCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RealizingActivityEdge", e, _realizingActivityEdgeReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RealizingActivityEdge property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizingActivityEdgeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RealizingActivityEdge", e, _realizingActivityEdgeReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRealizingConnectorReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.InformationFlow.ClassInstance)).Resolve("realizingConnector")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RealizingConnector property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizingConnectorCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RealizingConnector", e, _realizingConnectorReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RealizingConnector property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizingConnectorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RealizingConnector", e, _realizingConnectorReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveRealizingMessageReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.InformationFlow.ClassInstance)).Resolve("realizingMessage")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the RealizingMessage property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizingMessageCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("RealizingMessage", e, _realizingMessageReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the RealizingMessage property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void RealizingMessageCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("RealizingMessage", e, _realizingMessageReference);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "CONVEYED"))
            {
                return this._conveyed;
            }
            if ((feature == "INFORMATIONSOURCE"))
            {
                return this._informationSource;
            }
            if ((feature == "INFORMATIONTARGET"))
            {
                return this._informationTarget;
            }
            if ((feature == "REALIZATION"))
            {
                return this._realization;
            }
            if ((feature == "REALIZINGACTIVITYEDGE"))
            {
                return this._realizingActivityEdge;
            }
            if ((feature == "REALIZINGCONNECTOR"))
            {
                return this._realizingConnector;
            }
            if ((feature == "REALIZINGMESSAGE"))
            {
                return this._realizingMessage;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//InformationFlow")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the InformationFlow class
        /// </summary>
        public class InformationFlowChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private InformationFlow _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public InformationFlowChildrenCollection(InformationFlow parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the InformationFlow class
        /// </summary>
        public class InformationFlowReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private InformationFlow _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public InformationFlowReferencedElementsCollection(InformationFlow parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().GetEnumerator();
            }
        }
    }
}
