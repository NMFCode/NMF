//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// A Message defines a particular communication between Lifelines of an Interaction.
    ///<p>From package UML::Interactions.</p>
    /// </summary>
    [XmlNamespaceAttribute("http://www.eclipse.org/uml2/5.0.0/UML")]
    [XmlNamespacePrefixAttribute("uml")]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//Message")]
    [DebuggerDisplayAttribute("Message {Name}")]
    public partial class Message : NamedElement, IMessage, IModelElement
    {
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _sending_receiving_message_eventOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSending_receiving_message_eventOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _argumentsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveArgumentsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _cannot_cross_boundariesOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveCannot_cross_boundariesOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _signature_is_signalOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSignature_is_signalOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _occurrence_specificationsOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveOccurrence_specificationsOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _signature_refer_toOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSignature_refer_toOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _signature_is_operation_requestOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSignature_is_operation_requestOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _signature_is_operation_replyOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveSignature_is_operation_replyOperation);
        
        private static System.Lazy<NMF.Models.Meta.IOperation> _getMessageKindOperation = new System.Lazy<NMF.Models.Meta.IOperation>(RetrieveGetMessageKindOperation);
        
        /// <summary>
        /// The backing field for the MessageSort property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private MessageSort _messageSort = MessageSort.SynchCall;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _messageSortAttribute = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveMessageSortAttribute);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _argumentReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveArgumentReference);
        
        /// <summary>
        /// The backing field for the Argument property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionOrderedSet<IValueSpecification> _argument;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _connectorReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveConnectorReference);
        
        /// <summary>
        /// The backing field for the Connector property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IConnector _connector;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _interactionReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveInteractionReference);
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _receiveEventReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveReceiveEventReference);
        
        /// <summary>
        /// The backing field for the ReceiveEvent property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IMessageEnd _receiveEvent;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _sendEventReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSendEventReference);
        
        /// <summary>
        /// The backing field for the SendEvent property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IMessageEnd _sendEvent;
        
        private static Lazy<NMF.Models.Meta.ITypedElement> _signatureReference = new Lazy<NMF.Models.Meta.ITypedElement>(RetrieveSignatureReference);
        
        /// <summary>
        /// The backing field for the Signature property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private INamedElement _signature;
        
        private static NMF.Models.Meta.IClass _classInstance;
        
        public Message()
        {
            this._argument = new ObservableCompositionOrderedSet<IValueSpecification>(this);
            this._argument.CollectionChanging += this.ArgumentCollectionChanging;
            this._argument.CollectionChanged += this.ArgumentCollectionChanged;
        }
        
        /// <summary>
        /// The sort of communication reflected by the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DefaultValueAttribute(MessageSort.SynchCall)]
        [DisplayNameAttribute("messageSort")]
        [DescriptionAttribute("The sort of communication reflected by the Message.\n<p>From package UML::Interact" +
            "ions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("messageSort")]
        [XmlAttributeAttribute(true)]
        public MessageSort MessageSort
        {
            get
            {
                return this._messageSort;
            }
            set
            {
                if ((this._messageSort != value))
                {
                    MessageSort old = this._messageSort;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("MessageSort", e, _messageSortAttribute);
                    this._messageSort = value;
                    this.OnPropertyChanged("MessageSort", e, _messageSortAttribute);
                }
            }
        }
        
        /// <summary>
        /// The arguments of the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("argument")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public IOrderedSetExpression<IValueSpecification> Argument
        {
            get
            {
                return this._argument;
            }
        }
        
        /// <summary>
        /// The Connector on which this Message is sent.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("connector")]
        [DescriptionAttribute("The Connector on which this Message is sent.\n<p>From package UML::Interactions.</" +
            "p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("connector")]
        [XmlAttributeAttribute(true)]
        public IConnector Connector
        {
            get
            {
                return this._connector;
            }
            set
            {
                if ((this._connector != value))
                {
                    IConnector old = this._connector;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Connector", e, _connectorReference);
                    this._connector = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetConnector;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetConnector;
                    }
                    this.OnPropertyChanged("Connector", e, _connectorReference);
                }
            }
        }
        
        /// <summary>
        /// The enclosing Interaction owning the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("interaction")]
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden)]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("message")]
        public IInteraction Interaction
        {
            get
            {
                return ModelHelper.CastAs<IInteraction>(this.Parent);
            }
            set
            {
                this.Parent = value;
            }
        }
        
        /// <summary>
        /// References the Receiving of the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("receiveEvent")]
        [DescriptionAttribute("References the Receiving of the Message.\n<p>From package UML::Interactions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("receiveEvent")]
        [XmlAttributeAttribute(true)]
        public IMessageEnd ReceiveEvent
        {
            get
            {
                return this._receiveEvent;
            }
            set
            {
                if ((this._receiveEvent != value))
                {
                    IMessageEnd old = this._receiveEvent;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ReceiveEvent", e, _receiveEventReference);
                    this._receiveEvent = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetReceiveEvent;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetReceiveEvent;
                    }
                    this.OnPropertyChanged("ReceiveEvent", e, _receiveEventReference);
                }
            }
        }
        
        /// <summary>
        /// References the Sending of the Message.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("sendEvent")]
        [DescriptionAttribute("References the Sending of the Message.\n<p>From package UML::Interactions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("sendEvent")]
        [XmlAttributeAttribute(true)]
        public IMessageEnd SendEvent
        {
            get
            {
                return this._sendEvent;
            }
            set
            {
                if ((this._sendEvent != value))
                {
                    IMessageEnd old = this._sendEvent;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("SendEvent", e, _sendEventReference);
                    this._sendEvent = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetSendEvent;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetSendEvent;
                    }
                    this.OnPropertyChanged("SendEvent", e, _sendEventReference);
                }
            }
        }
        
        /// <summary>
        /// The signature of the Message is the specification of its content. It refers either an Operation or a Signal.
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        [DisplayNameAttribute("signature")]
        [DescriptionAttribute("The signature of the Message is the specification of its content. It refers eithe" +
            "r an Operation or a Signal.\n<p>From package UML::Interactions.</p>")]
        [CategoryAttribute("Message")]
        [XmlElementNameAttribute("signature")]
        [XmlAttributeAttribute(true)]
        public INamedElement Signature
        {
            get
            {
                return this._signature;
            }
            set
            {
                if ((this._signature != value))
                {
                    INamedElement old = this._signature;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Signature", e, _signatureReference);
                    this._signature = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetSignature;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetSignature;
                    }
                    this.OnPropertyChanged("Signature", e, _signatureReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new MessageChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new MessageReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static NMF.Models.Meta.IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Message")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// If the sendEvent and the receiveEvent of the same Message are on the same Lifeline, the sendEvent must be ordered before the receiveEvent.
        ///receiveEvent.oclIsKindOf(MessageOccurrenceSpecification)
        ///implies
        ///let f :  Lifeline = sendEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered in
        ///f = receiveEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered  implies
        ///f.events->indexOf(sendEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() ) < 
        ///f.events->indexOf(receiveEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() )
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Sending_receiving_message_event(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_sending_receiving_message_eventOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method sending_receiving_message_event registered." +
                        " Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _sending_receiving_message_eventOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _sending_receiving_message_eventOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _sending_receiving_message_eventOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSending_receiving_message_eventOperation()
        {
            return ClassInstance.LookupOperation("sending_receiving_message_event");
        }
        
        /// <summary>
        /// Arguments of a Message must only be: i) attributes of the sending lifeline, ii) constants, iii) symbolic values (which are wildcard values representing any legal value), iv) explicit parameters of the enclosing Interaction, v) attributes of the class owning the Interaction.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Arguments(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_argumentsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method arguments registered. Use the method broker" +
                        " to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _argumentsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _argumentsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _argumentsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveArgumentsOperation()
        {
            return ClassInstance.LookupOperation("arguments");
        }
        
        /// <summary>
        /// Messages cannot cross boundaries of CombinedFragments or their operands.  This is true if and only if both MessageEnds are enclosed within the same InteractionFragment (i.e., an InteractionOperand or an Interaction).
        ///sendEvent->notEmpty() and receiveEvent->notEmpty() implies
        ///let sendEnclosingFrag : Set(InteractionFragment) = 
        ///sendEvent->asOrderedSet()->first().enclosingFragment()
        ///in 
        ///let receiveEnclosingFrag : Set(InteractionFragment) = 
        ///receiveEvent->asOrderedSet()->first().enclosingFragment()
        ///in  sendEnclosingFrag = receiveEnclosingFrag
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Cannot_cross_boundaries(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_cannot_cross_boundariesOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method cannot_cross_boundaries registered. Use the" +
                        " method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _cannot_cross_boundariesOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _cannot_cross_boundariesOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _cannot_cross_boundariesOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveCannot_cross_boundariesOperation()
        {
            return ClassInstance.LookupOperation("cannot_cross_boundaries");
        }
        
        /// <summary>
        /// In the case when the Message signature is a Signal, the arguments of the Message must correspond to the attributes of the Signal. A Message Argument corresponds to a Signal Attribute if the Argument is of the same Class or a specialization of that of the Attribute.
        ///(messageSort = MessageSort::asynchSignal ) and signature.oclIsKindOf(Signal) implies
        ///   let signalAttributes : OrderedSet(Property) = signature.oclAsType(Signal).inheritedMember()->
        ///             select(n:NamedElement | n.oclIsTypeOf(Property))->collect(oclAsType(Property))->asOrderedSet()
        ///   in signalAttributes->size() = self.argument->size()
        ///   and self.argument->forAll( o: ValueSpecification |
        ///          not (o.oclIsKindOf(Expression)
        ///          and o.oclAsType(Expression).symbol->size()=0
        ///          and o.oclAsType(Expression).operand->isEmpty() ) implies
        ///              let p : Property = signalAttributes->at(self.argument->indexOf(o))
        ///              in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Signature_is_signal(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_signature_is_signalOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method signature_is_signal registered. Use the met" +
                        "hod broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _signature_is_signalOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _signature_is_signalOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _signature_is_signalOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSignature_is_signalOperation()
        {
            return ClassInstance.LookupOperation("signature_is_signal");
        }
        
        /// <summary>
        /// If the MessageEnds are both OccurrenceSpecifications, then the connector must go between the Parts represented by the Lifelines of the two MessageEnds.
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Occurrence_specifications(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_occurrence_specificationsOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method occurrence_specifications registered. Use t" +
                        "he method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _occurrence_specificationsOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _occurrence_specificationsOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _occurrence_specificationsOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveOccurrence_specificationsOperation()
        {
            return ClassInstance.LookupOperation("occurrence_specifications");
        }
        
        /// <summary>
        /// The signature must either refer an Operation (in which case messageSort is either synchCall or asynchCall or reply) or a Signal (in which case messageSort is asynchSignal). The name of the NamedElement referenced by signature must be the same as that of the Message.
        ///signature->notEmpty() implies 
        ///((signature.oclIsKindOf(Operation) and 
        ///(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or messageSort = MessageSort::reply) 
        ///) or (signature.oclIsKindOf(Signal)  and messageSort = MessageSort::asynchSignal )
        /// ) and name = signature.name
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Signature_refer_to(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_signature_refer_toOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method signature_refer_to registered. Use the meth" +
                        "od broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _signature_refer_toOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _signature_refer_toOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _signature_refer_toOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSignature_refer_toOperation()
        {
            return ClassInstance.LookupOperation("signature_refer_to");
        }
        
        /// <summary>
        /// In the case when a Message with messageSort synchCall or asynchCall has a non empty Operation signature, the arguments of the Message must correspond to the in and inout parameters of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.
        ///(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall) and signature.oclIsKindOf(Operation)  implies 
        /// let requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
        /// select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::_'in'  )
        ///in requestParms->size() = self.argument->size() and
        ///self.argument->forAll( o: ValueSpecification | 
        ///not (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and o.oclAsType(Expression).operand->isEmpty() ) implies 
        ///let p : Parameter = requestParms->at(self.argument->indexOf(o)) in
        ///o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Signature_is_operation_request(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_signature_is_operation_requestOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method signature_is_operation_request registered. " +
                        "Use the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _signature_is_operation_requestOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _signature_is_operation_requestOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _signature_is_operation_requestOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSignature_is_operation_requestOperation()
        {
            return ClassInstance.LookupOperation("signature_is_operation_request");
        }
        
        /// <summary>
        /// In the case when a Message with messageSort reply has a non empty Operation signature, the arguments of the Message must correspond to the out, inout, and return parameters of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of that of the Parameter.
        ///(messageSort = MessageSort::reply) and signature.oclIsKindOf(Operation) implies 
        /// let replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->
        ///select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::return)
        ///in replyParms->size() = self.argument->size() and
        ///self.argument->forAll( o: ValueSpecification | o.oclIsKindOf(Expression) and let e : Expression = o.oclAsType(Expression) in
        ///e.operand->notEmpty()  implies 
        ///let p : Parameter = replyParms->at(self.argument->indexOf(o)) in
        ///e.operand->asSequence()->first().type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))
        ///)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        public bool Signature_is_operation_reply(object diagnostics, object context)
        {
            System.Func<IMessage, object, object, bool> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, object, object, bool>>(_signature_is_operation_replyOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method signature_is_operation_reply registered. Us" +
                        "e the method broker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _signature_is_operation_replyOperation.Value, diagnostics, context);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _signature_is_operation_replyOperation.Value, e));
            bool result = handler.Invoke(this, diagnostics, context);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _signature_is_operation_replyOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveSignature_is_operation_replyOperation()
        {
            return ClassInstance.LookupOperation("signature_is_operation_reply");
        }
        
        /// <summary>
        /// This query returns the MessageKind value for this Message.
        ///result = (messageKind)
        ///<p>From package UML::Interactions.</p>
        /// </summary>
        public MessageKind GetMessageKind()
        {
            System.Func<IMessage, MessageKind> handler = OperationBroker.Instance.GetRegisteredDelegate<System.Func<IMessage, MessageKind>>(_getMessageKindOperation);
            if ((handler != null))
            {
            }
            else
            {
                throw new System.InvalidOperationException("There is no implementation for method getMessageKind registered. Use the method b" +
                        "roker to register a method implementation.");
            }
            OperationCallEventArgs e = new OperationCallEventArgs(this, _getMessageKindOperation.Value);
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalling(this, _getMessageKindOperation.Value, e));
            MessageKind result = handler.Invoke(this);
            e.Result = result;
            this.OnBubbledChange(BubbledChangeEventArgs.OperationCalled(this, _getMessageKindOperation.Value, e));
            return result;
        }
        
        private static NMF.Models.Meta.IOperation RetrieveGetMessageKindOperation()
        {
            return ClassInstance.LookupOperation("getMessageKind");
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveMessageSortAttribute()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Message.ClassInstance)).Resolve("messageSort")));
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveArgumentReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Message.ClassInstance)).Resolve("argument")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Argument property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Argument", e, _argumentReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Argument property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Argument", e, _argumentReference);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveConnectorReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Message.ClassInstance)).Resolve("connector")));
        }
        
        /// <summary>
        /// Handles the event that the Connector property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetConnector(object sender, System.EventArgs eventArgs)
        {
            this.Connector = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveInteractionReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Message.ClassInstance)).Resolve("interaction")));
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element is about to change
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanging(IModelElement newParent, IModelElement oldParent)
        {
            IInteraction oldInteraction = ModelHelper.CastAs<IInteraction>(oldParent);
            IInteraction newInteraction = ModelHelper.CastAs<IInteraction>(newParent);
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldInteraction, newInteraction);
            this.OnPropertyChanging("Interaction", e, _interactionReference);
        }
        
        /// <summary>
        /// Gets called when the parent model element of the current model element changes
        /// </summary>
        /// <param name="oldParent">The old parent model element</param>
        /// <param name="newParent">The new parent model element</param>
        protected override void OnParentChanged(IModelElement newParent, IModelElement oldParent)
        {
            IInteraction oldInteraction = ModelHelper.CastAs<IInteraction>(oldParent);
            IInteraction newInteraction = ModelHelper.CastAs<IInteraction>(newParent);
            if ((oldInteraction != null))
            {
                oldInteraction.Message.Remove(this);
            }
            if ((newInteraction != null))
            {
                newInteraction.Message.Add(this);
            }
            ValueChangedEventArgs e = new ValueChangedEventArgs(oldInteraction, newInteraction);
            this.OnPropertyChanged("Interaction", e, _interactionReference);
            base.OnParentChanged(newParent, oldParent);
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveReceiveEventReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Message.ClassInstance)).Resolve("receiveEvent")));
        }
        
        /// <summary>
        /// Handles the event that the ReceiveEvent property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetReceiveEvent(object sender, System.EventArgs eventArgs)
        {
            this.ReceiveEvent = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSendEventReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Message.ClassInstance)).Resolve("sendEvent")));
        }
        
        /// <summary>
        /// Handles the event that the SendEvent property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSendEvent(object sender, System.EventArgs eventArgs)
        {
            this.SendEvent = null;
        }
        
        private static NMF.Models.Meta.ITypedElement RetrieveSignatureReference()
        {
            return ((NMF.Models.Meta.ITypedElement)(((ModelElement)(NMF.Interop.Uml.Message.ClassInstance)).Resolve("signature")));
        }
        
        /// <summary>
        /// Handles the event that the Signature property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSignature(object sender, System.EventArgs eventArgs)
        {
            this.Signature = null;
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            int argumentIndex = ModelHelper.IndexOfReference(this.Argument, element);
            if ((argumentIndex != -1))
            {
                return ModelHelper.CreatePath("argument", argumentIndex);
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "ARGUMENT"))
            {
                if ((index < this.Argument.Count))
                {
                    return this.Argument[index];
                }
                else
                {
                    return null;
                }
            }
            if ((reference == "CONNECTOR"))
            {
                return this.Connector;
            }
            if ((reference == "INTERACTION"))
            {
                return this.Interaction;
            }
            if ((reference == "RECEIVEEVENT"))
            {
                return this.ReceiveEvent;
            }
            if ((reference == "SENDEVENT"))
            {
                return this.SendEvent;
            }
            if ((reference == "SIGNATURE"))
            {
                return this.Signature;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "MESSAGESORT"))
            {
                return this.MessageSort;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ARGUMENT"))
            {
                return this._argument;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "CONNECTOR"))
            {
                this.Connector = ((IConnector)(value));
                return;
            }
            if ((feature == "INTERACTION"))
            {
                this.Interaction = ((IInteraction)(value));
                return;
            }
            if ((feature == "RECEIVEEVENT"))
            {
                this.ReceiveEvent = ((IMessageEnd)(value));
                return;
            }
            if ((feature == "SENDEVENT"))
            {
                this.SendEvent = ((IMessageEnd)(value));
                return;
            }
            if ((feature == "SIGNATURE"))
            {
                this.Signature = ((INamedElement)(value));
                return;
            }
            if ((feature == "MESSAGESORT"))
            {
                this.MessageSort = ((MessageSort)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "MESSAGESORT"))
            {
                return Observable.Box(new MessageSortProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "CONNECTOR"))
            {
                return new ConnectorProxy(this);
            }
            if ((reference == "INTERACTION"))
            {
                return new InteractionProxy(this);
            }
            if ((reference == "RECEIVEEVENT"))
            {
                return new ReceiveEventProxy(this);
            }
            if ((reference == "SENDEVENT"))
            {
                return new SendEventProxy(this);
            }
            if ((reference == "SIGNATURE"))
            {
                return new SignatureProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._argument))
            {
                return "argument";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override NMF.Models.Meta.IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((NMF.Models.Meta.IClass)(MetaRepository.Instance.Resolve("http://www.eclipse.org/uml2/5.0.0/UML#//Message")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Message class
        /// </summary>
        public class MessageChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Message _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public MessageChildrenCollection(Message parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Argument.Count);
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Argument.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Argument.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IValueSpecification argumentCasted = item.As<IValueSpecification>();
                if ((argumentCasted != null))
                {
                    this._parent.Argument.Add(argumentCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Argument.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Argument.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentEnumerator = this._parent.Argument.GetEnumerator();
                try
                {
                    for (
                    ; argumentEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IValueSpecification valueSpecificationItem = item.As<IValueSpecification>();
                if (((valueSpecificationItem != null) 
                            && this._parent.Argument.Remove(valueSpecificationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Argument).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Message class
        /// </summary>
        public class MessageReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Message _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public MessageReferencedElementsCollection(Message parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Argument.Count);
                    if ((this._parent.Connector != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Interaction != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.ReceiveEvent != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.SendEvent != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Signature != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            protected override void AttachCore()
            {
                this._parent.Argument.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            protected override void DetachCore()
            {
                this._parent.Argument.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IValueSpecification argumentCasted = item.As<IValueSpecification>();
                if ((argumentCasted != null))
                {
                    this._parent.Argument.Add(argumentCasted);
                }
                if ((this._parent.Connector == null))
                {
                    IConnector connectorCasted = item.As<IConnector>();
                    if ((connectorCasted != null))
                    {
                        this._parent.Connector = connectorCasted;
                        return;
                    }
                }
                if ((this._parent.Interaction == null))
                {
                    IInteraction interactionCasted = item.As<IInteraction>();
                    if ((interactionCasted != null))
                    {
                        this._parent.Interaction = interactionCasted;
                        return;
                    }
                }
                if ((this._parent.ReceiveEvent == null))
                {
                    IMessageEnd receiveEventCasted = item.As<IMessageEnd>();
                    if ((receiveEventCasted != null))
                    {
                        this._parent.ReceiveEvent = receiveEventCasted;
                        return;
                    }
                }
                if ((this._parent.SendEvent == null))
                {
                    IMessageEnd sendEventCasted = item.As<IMessageEnd>();
                    if ((sendEventCasted != null))
                    {
                        this._parent.SendEvent = sendEventCasted;
                        return;
                    }
                }
                if ((this._parent.Signature == null))
                {
                    INamedElement signatureCasted = item.As<INamedElement>();
                    if ((signatureCasted != null))
                    {
                        this._parent.Signature = signatureCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Argument.Clear();
                this._parent.Connector = null;
                this._parent.Interaction = null;
                this._parent.ReceiveEvent = null;
                this._parent.SendEvent = null;
                this._parent.Signature = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Argument.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Connector))
                {
                    return true;
                }
                if ((item == this._parent.Interaction))
                {
                    return true;
                }
                if ((item == this._parent.ReceiveEvent))
                {
                    return true;
                }
                if ((item == this._parent.SendEvent))
                {
                    return true;
                }
                if ((item == this._parent.Signature))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentEnumerator = this._parent.Argument.GetEnumerator();
                try
                {
                    for (
                    ; argumentEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentEnumerator.Dispose();
                }
                if ((this._parent.Connector != null))
                {
                    array[arrayIndex] = this._parent.Connector;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Interaction != null))
                {
                    array[arrayIndex] = this._parent.Interaction;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.ReceiveEvent != null))
                {
                    array[arrayIndex] = this._parent.ReceiveEvent;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.SendEvent != null))
                {
                    array[arrayIndex] = this._parent.SendEvent;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Signature != null))
                {
                    array[arrayIndex] = this._parent.Signature;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IValueSpecification valueSpecificationItem = item.As<IValueSpecification>();
                if (((valueSpecificationItem != null) 
                            && this._parent.Argument.Remove(valueSpecificationItem)))
                {
                    return true;
                }
                if ((this._parent.Connector == item))
                {
                    this._parent.Connector = null;
                    return true;
                }
                if ((this._parent.Interaction == item))
                {
                    this._parent.Interaction = null;
                    return true;
                }
                if ((this._parent.ReceiveEvent == item))
                {
                    this._parent.ReceiveEvent = null;
                    return true;
                }
                if ((this._parent.SendEvent == item))
                {
                    this._parent.SendEvent = null;
                    return true;
                }
                if ((this._parent.Signature == item))
                {
                    this._parent.Signature = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Argument).Concat(this._parent.Connector).Concat(this._parent.Interaction).Concat(this._parent.ReceiveEvent).Concat(this._parent.SendEvent).Concat(this._parent.Signature).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the messageSort property
        /// </summary>
        private sealed class MessageSortProxy : ModelPropertyChange<IMessage, MessageSort>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public MessageSortProxy(IMessage modelElement) : 
                    base(modelElement, "messageSort")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override MessageSort Value
            {
                get
                {
                    return this.ModelElement.MessageSort;
                }
                set
                {
                    this.ModelElement.MessageSort = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the connector property
        /// </summary>
        private sealed class ConnectorProxy : ModelPropertyChange<IMessage, IConnector>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ConnectorProxy(IMessage modelElement) : 
                    base(modelElement, "connector")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IConnector Value
            {
                get
                {
                    return this.ModelElement.Connector;
                }
                set
                {
                    this.ModelElement.Connector = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the interaction property
        /// </summary>
        private sealed class InteractionProxy : ModelPropertyChange<IMessage, IInteraction>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public InteractionProxy(IMessage modelElement) : 
                    base(modelElement, "interaction")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IInteraction Value
            {
                get
                {
                    return this.ModelElement.Interaction;
                }
                set
                {
                    this.ModelElement.Interaction = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the receiveEvent property
        /// </summary>
        private sealed class ReceiveEventProxy : ModelPropertyChange<IMessage, IMessageEnd>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ReceiveEventProxy(IMessage modelElement) : 
                    base(modelElement, "receiveEvent")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IMessageEnd Value
            {
                get
                {
                    return this.ModelElement.ReceiveEvent;
                }
                set
                {
                    this.ModelElement.ReceiveEvent = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the sendEvent property
        /// </summary>
        private sealed class SendEventProxy : ModelPropertyChange<IMessage, IMessageEnd>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SendEventProxy(IMessage modelElement) : 
                    base(modelElement, "sendEvent")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IMessageEnd Value
            {
                get
                {
                    return this.ModelElement.SendEvent;
                }
                set
                {
                    this.ModelElement.SendEvent = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the signature property
        /// </summary>
        private sealed class SignatureProxy : ModelPropertyChange<IMessage, INamedElement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SignatureProxy(IMessage modelElement) : 
                    base(modelElement, "signature")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override INamedElement Value
            {
                get
                {
                    return this.ModelElement.Signature;
                }
                set
                {
                    this.ModelElement.Signature = value;
                }
            }
        }
    }
}

