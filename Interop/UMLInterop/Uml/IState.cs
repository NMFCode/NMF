//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:6.0.25
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.Collections.Generic;
using NMF.Collections.ObjectModel;
using NMF.Expressions;
using NMF.Expressions.Linq;
using NMF.Interop.Ecore;
using NMF.Models;
using NMF.Models.Collections;
using NMF.Models.Expressions;
using NMF.Models.Meta;
using NMF.Models.Repository;
using NMF.Serialization;
using NMF.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;

namespace NMF.Interop.Uml
{
    
    
    /// <summary>
    /// The public interface for State
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(State))]
    [XmlDefaultImplementationTypeAttribute(typeof(State))]
    [ModelRepresentationClassAttribute("http://www.eclipse.org/uml2/5.0.0/UML#//State")]
    public interface IState : IModelElement, IVertex, IRedefinableElement, NMF.Interop.Uml.INamespace
    {
        
        /// <summary>
        /// The entry and exit connection points used in conjunction with this (submachine) State, i.e., as targets and sources, respectively, in the Region with the submachine State. A connection point reference references the corresponding definition of a connection point Pseudostate in the StateMachine referenced by the submachine State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("connection")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        IOrderedSetExpression<IConnectionPointReference> Connection
        {
            get;
        }
        
        /// <summary>
        /// The entry and exit Pseudostates of a composite State. These can only be entry or exit Pseudostates, and they must have different names. They can only be defined for composite States.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("connectionPoint")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        IOrderedSetExpression<IPseudostate> ConnectionPoint
        {
            get;
        }
        
        /// <summary>
        /// A list of Triggers that are candidates to be retained by the StateMachine if they trigger no Transitions out of the State (not consumed). A deferred Trigger is retained until the StateMachine reaches a State configuration where it is no longer deferred.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("deferrableTrigger")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        IOrderedSetExpression<ITrigger> DeferrableTrigger
        {
            get;
        }
        
        /// <summary>
        /// An optional Behavior that is executed while being in the State. The execution starts when this State is entered, and ceases either by itself when done, or when the State is exited, whichever comes first.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("doActivity")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBehavior DoActivity
        {
            get;
            set;
        }
        
        /// <summary>
        /// An optional Behavior that is executed whenever this State is entered regardless of the Transition taken to reach the State. If defined, entry Behaviors are always executed to completion prior to any internal Behavior or Transitions performed within the State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("entry")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBehavior Entry
        {
            get;
            set;
        }
        
        /// <summary>
        /// An optional Behavior that is executed whenever this State is exited regardless of which Transition was taken out of the State. If defined, exit Behaviors are always executed to completion only after all internal and transition Behaviors have completed execution.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("exit")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBehavior Exit
        {
            get;
            set;
        }
        
        /// <summary>
        /// The State of which this State is a redefinition.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("redefinedState")]
        [DescriptionAttribute("The State of which this State is a redefinition.\n<p>From package UML::StateMachin" +
            "es.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("redefinedState")]
        [XmlAttributeAttribute(true)]
        IState RedefinedState
        {
            get;
            set;
        }
        
        /// <summary>
        /// Specifies conditions that are always true when this State is the current State. In ProtocolStateMachines state invariants are additional conditions to the preconditions of the outgoing Transitions, and to the postcondition of the incoming Transitions.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("stateInvariant")]
        [DescriptionAttribute(@"Specifies conditions that are always true when this State is the current State. In ProtocolStateMachines state invariants are additional conditions to the preconditions of the outgoing Transitions, and to the postcondition of the incoming Transitions.
<p>From package UML::StateMachines.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("stateInvariant")]
        [XmlAttributeAttribute(true)]
        IConstraint StateInvariant
        {
            get;
            set;
        }
        
        /// <summary>
        /// The StateMachine that is to be inserted in place of the (submachine) State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DisplayNameAttribute("submachine")]
        [DescriptionAttribute("The StateMachine that is to be inserted in place of the (submachine) State.\n<p>Fr" +
            "om package UML::StateMachines.</p>")]
        [CategoryAttribute("State")]
        [XmlElementNameAttribute("submachine")]
        [XmlAttributeAttribute(true)]
        [XmlOppositeAttribute("submachineState")]
        IStateMachine Submachine
        {
            get;
            set;
        }
        
        /// <summary>
        /// The Regions owned directly by the State.
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("region")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [XmlOppositeAttribute("state")]
        [ConstantAttribute()]
        IOrderedSetExpression<IRegion> Region
        {
            get;
        }
        
        /// <summary>
        /// Only entry or exit Pseudostates can serve as connection points.
        ///connectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Entry_or_exit(object diagnostics, object context);
        
        /// <summary>
        /// Only submachine States can have connection point references.
        ///isSubmachineState implies connection->notEmpty( )
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Submachine_states(object diagnostics, object context);
        
        /// <summary>
        /// Only composite States can have entry or exit Pseudostates defined.
        ///connectionPoint->notEmpty() implies isComposite
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Composite_states(object diagnostics, object context);
        
        /// <summary>
        /// The connection point references used as destinations/sources of Transitions associated with a submachine State must be defined as entry/exit points in the submachine StateMachine.
        ///self.isSubmachineState implies (self.connection->forAll (cp |
        ///  cp.entry->forAll (ps | ps.stateMachine = self.submachine) and
        ///  cp.exit->forAll (ps | ps.stateMachine = self.submachine)))
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Destinations_or_sources_of_transitions(object diagnostics, object context);
        
        /// <summary>
        /// A State is not allowed to have both a submachine and Regions.
        ///isComposite implies not isSubmachineState
        /// </summary>
        /// <param name="diagnostics">The chain of diagnostics to which problems are to be appended.</param>
        /// <param name="context">The cache of context-specific information.</param>
        bool Submachine_or_regions(object diagnostics, object context);
        
        /// <summary>
        /// A composite State is a State with at least one Region.
        ///result = (region->notEmpty())
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        bool IsComposite();
        
        /// <summary>
        /// An orthogonal State is a composite state with at least 2 regions.
        ///result = (region->size () > 1)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        bool IsOrthogonal();
        
        /// <summary>
        /// A simple State is a State without any regions.
        ///result = ((region->isEmpty()) and not isSubmachineState())
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        bool IsSimple();
        
        /// <summary>
        /// Only submachine State references another StateMachine.
        ///result = (submachine <> null)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        bool IsSubmachineState();
        
        /// <summary>
        /// The redefinition context of a State is the nearest containing StateMachine.
        ///result = (let sm : StateMachine = containingStateMachine() in
        ///if sm._'context' = null or sm.general->notEmpty() then
        ///  sm
        ///else
        ///  sm._'context'
        ///endif)
        ///<p>From package UML::StateMachines.</p>
        /// </summary>
        IClassifier RedefinitionContext();
    }
}

