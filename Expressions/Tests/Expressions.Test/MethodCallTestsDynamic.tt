<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="TestGenerationSettings.t4" once="true"#>
using System;
using System.Collections.Generic;
using NMF.Expressions.Linq;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace NMF.Expressions.Test
{ 
    [TestClass]
    public class MethodCallTestsDynamic
    {        

        public class Helper
        {
<#
    for(int i=1;i<=maxNumParameter;i++)
    {
#>
            
            private static readonly ObservingFunc<<#= Interpolate("Dummy<string>", ", ", i, 0) #>, string> combineFunc<#= i #> = new ObservingFunc<<#= Interpolate("Dummy<string>", ", ", i, 0) #>, string>((<#= Interpolate("d{0}", ", ", i, 0) #>) => <#= Interpolate("d{0}.Item", " + \", \" + ", i, 0) #>);

            [LensPut(typeof(Helper), "PutCombine")]
            [ObservableProxy(typeof(Helper), "CombineProxy")]
            public static string Combine(<#= Interpolate("Dummy<string> arg{0}", ", ", i, 0) #>)
            {
                return combineFunc<#= i #>.Evaluate(<#= Interpolate("arg{0}", ", ", i, 0) #>);
            }
            
            public string CombineInstace(<#= Interpolate("Dummy<string> arg{0}", ", ", i, 0) #>)
            {
                return combineFunc<#= i #>.Evaluate(<#= Interpolate("arg{0}", ", ", i, 0) #>);
            }

            public static INotifyValue<string> CombineProxy(<#= Interpolate("Dummy<string> arg{0}", ", ", i, 0) #>)
            {
                return combineFunc<#= i #>.Observe(<#= Interpolate("arg{0}", ", ", i, 0) #>);
            }     

            public static void PutCombine(<#= Interpolate("Dummy<string> arg{0}", ", ", i, 0) #>, string value)
            {
                var splittedValue = value.Split(new char[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                
<# 
        for(int j=1;j<=i;j++)
        {
#>
                arg<#= j #>.Item = splittedValue[<#= j - 1 #>].ToString();
<#
        }
#>
            }
<#
    }
#>
        }
<#
    for(int i=1;i<=maxNumParameter;i++)
    {
#>
        #region New tests with <#= i #> parameters
<#
        foreach(var isObservable in new[] { false , true })
        {
            foreach(var isStatic in new[] { false, true })
            {
#> 
        [TestMethod]
        public void MethodCall_<#= isObservable?"":"No" #>ObservableTarget_<#= isStatic?"Static":"Instance" #><#= i #>()
        {
            var update = false;
            var dummy = new NotifyCollection<<#= isObservable?"Observable":"" #>Dummy<string>>();
            
            for(int j = 1; j<= <#= i #>; j++)
            {
                dummy.Add( new <#= isObservable?"Observable":"" #>Dummy<string>() { Item = j.ToString() } );
            }

            var test = Observable.Expression<string>(() => <#= isStatic?"Helper.Combine":"(new Helper()).CombineInstace" #>(<#= Interpolate("dummy[{0}]", ", ", i, -1) #>));
<#
            if(isObservable)
            {
#>
            test.ValueChanged += (o, e) =>
            {
                update = true;
                Assert.AreEqual("<#= GenerateTestString( i, 0, 0 ) #>", e.OldValue);
                Assert.AreEqual("<#= GenerateTestString( i, 0, 1 ) #>", e.NewValue);
            };
<#
            }
            else
            {
#>
            test.ValueChanged += (o, e) => update = true;
<#
}
#>
            Assert.AreEqual("<#= GenerateTestString( i, 0, 0 ) #>", test.Value);
            Assert.IsFalse(update);

            dummy[<#= i - 1 #>].Item = "<#= i + 1 #>";

            Assert.Is<#= isObservable?"True":"False" #>(update);
<#
            if(isObservable)
            {
#>
            Assert.AreEqual("<#= GenerateTestString( i, 0, 1 ) #>", test.Value);
<#
            }
#>
        }
<#
            }
        }
#>


        #endregion

<#
    }
#>
    }
}
<#+
    public string Interpolate(string str, string separator, int i, int offset){
        return String.Join(separator,Enumerable.Range(1, i).Select(x => String.Format(str, x + offset)));
    }

    public string GenerateTestString(int length, int offset, int lastOffset)
    {
        var list = Enumerable.Range(1, length).ToList();
        list[length-1] += lastOffset;
        return String.Join(", ", list.Select(x => (x + offset).ToString()));
    }    
#>