grammar AnyText (anytext)
root Grammar

imports https://github.com/NMFCode/NMF/AnyText

Grammar: 'grammar' Name=ID ('(' LanguageId=ID ')')? <nl> 'root' StartRule=[ClassRule] <nl> <nl>
Imports+=MetamodelImport* <nl>
Rules+=Rule<nl>+;

MetamodelImport: 'imports' (Prefix=ID 'from')? File=Uri <nl>;
Rule: ClassRule | DataRule | FragmentRule | ParanthesisRule | EnumRule;
ClassRule: InheritanceRule | ModelRule;

InheritanceRule: Name=ID RuleTypeFragment ':' <nl> <ind> Subtypes+=[ClassRule] ('|' Subtypes+=[ClassRule])+ <nsp> ';' <unind> <nl> <nl>;
ModelRule: Name=ID RuleTypeFragment ':' <nl> <ind> Expression=ParserExpression <nsp> ';' <unind> <nl> <nl>;
DataRule: 'terminal' Name=ID RuleTypeFragment ':' <nl> <ind> Regex=Regex ('surround' 'with' SurroundCharacter=Char)? ('escape' EscapeRules+=EscapeRule (',' EscapeRules+=EscapeRule)*)? <nsp> ';'<unind> <nl> <nl>;
EscapeRule: Character=Char 'as' Escape=Keyword;
FragmentRule: 'fragment' Name=ID 'processes' (Prefix=ID <nsp> '.'<nsp>)?  TypeName=ID ':' <nl> <ind> Expression=ParserExpression <nsp> ';'<unind> <nl> <nl>;
ParanthesisRule: 'parantheses' Name=ID ':' <nl> <ind> OpeningParanthesis=KeywordExpression InnerRule=[ClassRule] ClosingParanthesis=KeywordExpression <nsp> ';'<unind> <nl> <nl>;
EnumRule: 'enum' Name=ID RuleTypeFragment ':' <nl> <ind> (Literals+=LiteralRule)+ <nsp> ';'<unind> <nl> <nl>;
LiteralRule: Literal=ID '=>' Keyword=Keyword <nl>;

fragment RuleTypeFragment processes Rule: ('returns' (Prefix=ID <nsp> '.'<nsp>)? TypeName=ID)? <nsp>;
fragment FormattingInstructionFragment processes ParserExpression: (FormattingInstructions+=FormattingInstruction)*;
enum FormattingInstruction: 
  Newline => '<nl>'
  Indent => '<ind>'
  Unindent => '<unind>'
  AvoidSpace => '<nsp>'
  ForbidSpace => '<!nsp>';

ParserExpression: ChoiceExpression | SequenceExpression | ConjunctiveParserExpression;
ConjunctiveParserExpression returns ParserExpression: PlusExpression | StarExpression | MaybeExpression | BasicParserExpression;
BasicParserExpression returns ParserExpression: NegativeLookaheadExpression | KeywordExpression | ReferenceExpression | AssignExpression | AddAssignExpression | ExistsAssignExpression | RuleExpression | ParanthesisExpression;

parantheses ParanthesisExpression: '(' ParserExpression ')';
SequenceExpression: InnerExpressions+=ConjunctiveParserExpression (InnerExpressions+=ConjunctiveParserExpression)+;
PlusExpression: Inner=BasicParserExpression <nsp> '+' FormattingInstructionFragment;
StarExpression: Inner=BasicParserExpression <nsp> '*' FormattingInstructionFragment;
MaybeExpression: Inner=BasicParserExpression <nsp> '?' FormattingInstructionFragment;

KeywordExpression: Keyword=Keyword FormattingInstructionFragment;

ChoiceExpression: (Alternatives+=ConjunctiveParserExpression '|')+ Alternatives+=ConjunctiveParserExpression;

AssignExpression: Feature=ID <nsp> '=' <nsp> Assigned=BasicParserExpression FormattingInstructionFragment;
AddAssignExpression: Feature=ID <nsp> '+=' <nsp> Assigned=BasicParserExpression FormattingInstructionFragment;
ExistsAssignExpression: Feature=ID <nsp> '?=' <nsp> Assigned=BasicParserExpression FormattingInstructionFragment;
NegativeLookaheadExpression: '!' Inner=BasicParserExpression;
RuleExpression: Rule=[Rule] FormattingInstructionFragment !'=' !'+=' !'?=' ;
ReferenceExpression: '[' <nsp> ReferencedRule=[Rule] <nsp> ']';

terminal ID: /[a-zA-Z]\w*/;
terminal Keyword: /(\\\\|\\'|[^'\\])+/ surround with ' escape \ as '\\\\', ' as '\\\'';
terminal Regex: /(\\\/|[^\/])*/ surround with / escape / as '\\/';
terminal Uri: /.+/;
terminal Char: /\S/;