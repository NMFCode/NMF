<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NMF.Transformations</name>
    </assembly>
    <members>
        <member name="T:NMF.Transformations.Linq.TransformationComputationWrapper`2">
            <summary>
            Wraps computations from the type TIn to the type TOut
            </summary>
            <typeparam name="TIn">The input type for the wrapped computation</typeparam>
            <typeparam name="TOut">The output type for the wrapped computations</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`2.#ctor(NMF.Transformations.Core.Computation)">
            <summary>
            Wraps the given computation into a typed wrapping structure
            </summary>
            <param name="inner">The computation that is to be wrapped</param>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationComputationWrapper`2.Input">
            <summary>
            Gets the input of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationComputationWrapper`2.Output">
            <summary>
            Gets the output of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationComputationWrapper`2.Computation">
            <summary>
            Gets the underlying computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`2.Equals(NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1})">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="other">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`2.Equals(System.Object)">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="obj">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`2.GetHashCode">
            <summary>
            Gets a hash code representation of the current value
            </summary>
            <returns>A hash code representation of the value represented by the current instance</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`2.op_Equality(NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1},NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>True, if both wrappers represent the same computation, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`2.op_Inequality(NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1},NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as not equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>False, if both wrappers represent the same computation, otherwise true</returns>
        </member>
        <member name="T:NMF.Transformations.Linq.TransformationComputationWrapper`3">
            <summary>
            Wraps computations from the type TIn to the type TOut
            </summary>
            <typeparam name="TIn1">The first input type for the wrapped computation</typeparam>
            <typeparam name="TIn2">The second input type for the wrapped computation</typeparam>
            <typeparam name="TOut">The output type for the wrapped computations</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`3.#ctor(NMF.Transformations.Core.Computation)">
            <summary>
            Wraps the given computation into a typed wrapping structure
            </summary>
            <param name="inner">The computation that is to be wrapped</param>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationComputationWrapper`3.Input1">
            <summary>
            Gets the first input of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationComputationWrapper`3.Input2">
            <summary>
            Gets the second input of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationComputationWrapper`3.Output">
            <summary>
            Gets the output of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationComputationWrapper`3.Computation">
            <summary>
            Gets the underlying computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`3.Equals(NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1,`2})">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="other">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`3.Equals(System.Object)">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="obj">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`3.GetHashCode">
            <summary>
            Gets a hash code representation of the current value
            </summary>
            <returns>A hash code representation of the value represented by the current instance</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`3.op_Equality(NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1,`2},NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1,`2})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>True, if both wrappers represent the same computation, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationComputationWrapper`3.op_Inequality(NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1,`2},NMF.Transformations.Linq.TransformationComputationWrapper{`0,`1,`2})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as not equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>False, if both wrappers represent the same computation, otherwise true</returns>
        </member>
        <member name="T:NMF.Transformations.Linq.InPlaceComputationWrapper`1">
            <summary>
            Wraps computations from the type TIn to the type TOut
            </summary>
            <typeparam name="TIn">The input type for the wrapped computation</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`1.#ctor(NMF.Transformations.Core.Computation)">
            <summary>
            Wraps the given computation into a typed wrapping structure
            </summary>
            <param name="inner">The computation that is to be wrapped</param>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceComputationWrapper`1.Input">
            <summary>
            Gets the input of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceComputationWrapper`1.Computation">
            <summary>
            Gets the underlying computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`1.Equals(NMF.Transformations.Linq.InPlaceComputationWrapper{`0})">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="other">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`1.Equals(System.Object)">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="obj">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`1.GetHashCode">
            <summary>
            Gets a hash code representation of the current value
            </summary>
            <returns>A hash code representation of the value represented by the current instance</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`1.op_Equality(NMF.Transformations.Linq.InPlaceComputationWrapper{`0},NMF.Transformations.Linq.InPlaceComputationWrapper{`0})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>True, if both wrappers represent the same computation, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`1.op_Inequality(NMF.Transformations.Linq.InPlaceComputationWrapper{`0},NMF.Transformations.Linq.InPlaceComputationWrapper{`0})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as not equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>False, if both wrappers represent the same computation, otherwise true</returns>
        </member>
        <member name="T:NMF.Transformations.Linq.InPlaceComputationWrapper`2">
            <summary>
            Wraps computations from the type TIn to the type TOut
            </summary>
            <typeparam name="TIn1">The first input type for the wrapped computation</typeparam>
            <typeparam name="TIn2">The second input type for the wrapped computation</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`2.#ctor(NMF.Transformations.Core.Computation)">
            <summary>
            Wraps the given computation into a typed wrapping structure
            </summary>
            <param name="inner">The computation that is to be wrapped</param>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceComputationWrapper`2.Input1">
            <summary>
            Gets the first input of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceComputationWrapper`2.Input2">
            <summary>
            Gets the second input of the represented computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceComputationWrapper`2.Computation">
            <summary>
            Gets the underlying computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`2.Equals(NMF.Transformations.Linq.InPlaceComputationWrapper{`0,`1})">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="other">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`2.Equals(System.Object)">
            <summary>
            Gets a value indicating whether the current transformation computation wrapper and the provided instance should be treated as equal
            </summary>
            <param name="obj">The other instance</param>
            <returns>True, if the current object represents the same value as the given parameter, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`2.GetHashCode">
            <summary>
            Gets a hash code representation of the current value
            </summary>
            <returns>A hash code representation of the value represented by the current instance</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`2.op_Equality(NMF.Transformations.Linq.InPlaceComputationWrapper{`0,`1},NMF.Transformations.Linq.InPlaceComputationWrapper{`0,`1})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>True, if both wrappers represent the same computation, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceComputationWrapper`2.op_Inequality(NMF.Transformations.Linq.InPlaceComputationWrapper{`0,`1},NMF.Transformations.Linq.InPlaceComputationWrapper{`0,`1})">
            <summary>
            Gets a value indicating whether the two instances of the transformationwrapper should be as not equal
            </summary>
            <param name="left">The first computation wrapper</param>
            <param name="right">The second computation wrapper</param>
            <returns>False, if both wrappers represent the same computation, otherwise true</returns>
        </member>
        <member name="T:NMF.Transformations.Linq.IncrementalExtensions">
            <summary>
            This class contains the extension methods necessary for the NMF Transformations relational extensions
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Boolean,System.Func{NMF.Transformations.Linq.TransformationComputationWrapper{``0,``1,``2},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <typeparam name="TOutput">The output type of the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},NMF.Transformations.Core.ITransformationContext,System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="context">The context in which the rule is used as source of computations</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``1(NMF.Transformations.InPlaceTransformationRuleBase{``0},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput">The type of the input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean)">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.ToComputationSource``2(NMF.Transformations.InPlaceTransformationRuleBase{``0,``1},System.Boolean,System.Func{NMF.Transformations.Linq.InPlaceComputationWrapper{``0,``1},System.Boolean})">
            <summary>
            Creates a new computation source from a transformation rule
            </summary>
            <typeparam name="TInput1">The type of the first input arguments for the transformation rule</typeparam>
            <typeparam name="TInput2">The type of the second input arguments for the transformation rule</typeparam>
            <param name="rule">The rule that should be taken as a source of computation objects</param>
            <param name="allowNull">A boolean value indicating whether null values should be allowed</param>
            <param name="filter">A method or lambda expression to filter the computation objects</param>
            <returns>A source of computations that can further be dealt with</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.Where``1(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Filters the given monad instance with the given filter operator
            </summary>
            <typeparam name="T">The inner type of the monad instance</typeparam>
            <param name="items">The monad instance that should be filtered</param>
            <param name="filter">The filter that should be applied to the monad</param>
            <returns>A filtered monad instance</returns>
            <remarks>Please see the documentation of the Where extension method and its use with the LINQ-syntax for more details</remarks>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.Select``2(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Binds the Monad IRelationalSource to child items
            </summary>
            <typeparam name="T1">The inner type of the input monad instance</typeparam>
            <typeparam name="T2">The inner type of the result monad instance</typeparam>
            <param name="items">The monad instance whose child items should be selected</param>
            <param name="selector">A method that selects the result items from a source item</param>
            <returns>A monad instance of the result type that is based on the source monad instance</returns>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.SelectMany``2(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}})">
            <summary>
            Binds the Monad IRelationalSource to child items
            </summary>
            <typeparam name="T1">The inner type of the outer monad instance</typeparam>
            <typeparam name="T2">The inner type of the inner monad instance</typeparam>
            <param name="items">The monad instance which children are to be selected</param>
            <param name="selector">A method that selects the output</param>
            <returns>A monad instance with items selected by the given selector function</returns>
            <remarks>Please see the documentation of the SelectMany extension method and its use with the LINQ-syntax for more details</remarks>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalExtensions.SelectMany``3(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{``0}},System.Linq.Expressions.Expression{System.Func{``0,System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{``1}}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Binds the Monad IRelationalSource to child items
            </summary>
            <typeparam name="T1">The inner type of the outer monad instance</typeparam>
            <typeparam name="T2">The inner type of the inner monad instance</typeparam>
            <typeparam name="T3">The inner type of the return monad</typeparam>
            <param name="items">The monad instance which children are to be selected</param>
            <param name="func">The operator that should be applied in the bind function</param>
            <param name="selector">A method that selects the output</param>
            <returns>A monad instance with items selected by the given selector function</returns>
            <remarks>Please see the documentation of the SelectMany extension method and its use with the LINQ-syntax for more details</remarks>
        </member>
        <member name="T:NMF.Transformations.Linq.IncrementalPattern`1">
            <summary>
            Represents a relational pattern for a transformation rule with one input argument
            </summary>
            <typeparam name="TIn">The input type of the targeted transformation rule</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalPattern`1.#ctor(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{`0}})">
            <summary>
            Creates a new relational pattern with the given pattern constructor
            </summary>
            <param name="sourceCreator">A method that creates a relational source for a given transformation context</param>
        </member>
        <member name="P:NMF.Transformations.Linq.IncrementalPattern`1.SourceCreator">
            <summary>
            Gets the pattern constructor function that is used to build up relational patterns
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalPattern`1.CreatePattern(NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a pattern context for the given transformation context
            </summary>
            <param name="context">The transformation context the pattern should be created for</param>
            <returns></returns>
        </member>
        <member name="P:NMF.Transformations.Linq.IncrementalPattern`1.TargetRule">
            <summary>
            The transformation rule, the pattern should be applied to
            </summary>
        </member>
        <member name="T:NMF.Transformations.Linq.IncrementalPattern`2">
            <summary>
            Represents a relational pattern for a transformation rule with one input argument
            </summary>
            <typeparam name="TIn1">The first input type of the targeted transformation rule</typeparam>
            <typeparam name="TIn2">The second input type of the targeted transformation rule</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalPattern`2.#ctor(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Creates a new relational pattern with the given pattern constructor
            </summary>
            <param name="sourceCreator">A method that creates a relational source for a given transformation context</param>
        </member>
        <member name="P:NMF.Transformations.Linq.IncrementalPattern`2.TargetRule">
            <summary>
            The transformation rule, the pattern should be applied to
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.IncrementalPattern`2.SourceCreator">
            <summary>
            Gets the pattern constructor function that is used to build up relational patterns
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.IncrementalPattern`2.CreatePattern(NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a pattern context for the given transformation context
            </summary>
            <param name="context">The transformation context the pattern should be created for</param>
            <returns></returns>
        </member>
        <member name="T:NMF.Transformations.Linq.RelationalPatternContext`1">
            <summary>
            This class represents the pattern context for a relational pattern applied to a transformation rule with one input argument
            </summary>
            <typeparam name="TIn">The type of the input argument of the parented transformation rule</typeparam>
        </member>
        <member name="T:NMF.Transformations.Linq.RelationalPatternContext`2">
            <summary>
            This class represents the pattern context for a relational pattern applied to a transformation rule with two input arguments
            </summary>
            <typeparam name="TIn1">The type of the first input argument of the parented transformation rule</typeparam>
            <typeparam name="TIn2">The type of the second input argument of the parented transformation rule</typeparam>
        </member>
        <member name="T:NMF.Transformations.Linq.StaticPattern`1">
            <summary>
            Denotes a static pattern used as input for a transformation rule
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NMF.Transformations.Linq.StaticPattern`1.TargetRule">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.StaticPattern`1.Selector">
            <summary>
            Gets the function to select inputs for the target rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.StaticPattern`1.#ctor(System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Creates a new static pattern to fire transformation rule executions
            </summary>
            <param name="selector">A function that selects the inputs for the transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.Linq.StaticPattern`1.CreatePattern(NMF.Transformations.Core.ITransformationContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.Transformations.Linq.StaticPattern`2">
            <summary>
            Denotes a static pattern used to generate inputs for transformation rules
            </summary>
            <typeparam name="T1">The first argument type of the transformation rule</typeparam>
            <typeparam name="T2">The second argument tyoe of the transformation rule</typeparam>
        </member>
        <member name="P:NMF.Transformations.Linq.StaticPattern`2.TargetRule">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.StaticPattern`2.Selector">
            <summary>
            The function to select the input elements of the target transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.StaticPattern`2.#ctor(System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Creates a new instance
            </summary>
            <param name="selector">The function to select the input elements of the target transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.Linq.StaticPattern`2.CreatePattern(NMF.Transformations.Core.ITransformationContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.Transformations.Linq.TransformationRuleSource`2">
            <summary>
            Represents the usage of a transformation rule with one input argument in a relational pattern
            </summary>
            <typeparam name="TIn">The type of the transformation rule input argument</typeparam>
            <typeparam name="TOut">The transformation rule output type</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`2.#ctor(NMF.Transformations.TransformationRuleBase{`0,`1},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new TransformationRuleSource instance for the given transformation rule in the given context
            </summary>
            <param name="rule">The transformation rule that should be used as source</param>
            <param name="context">The context in which the computations should be used by the current instance</param>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`2.TransformationRule">
            <summary>
            Gets the transformation rule this transformation rule source is responsible for
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`2.Context">
            <summary>
            Gets the context in which the transformation rule source is active
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`2.Filter">
            <summary>
            Gets or sets the filter to be used to filter computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`2.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Receives a new computation from the computation rule
            </summary>
            <param name="computation">The computation that is received</param>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`2.ExecuteBefore">
            <summary>
            Gets or sets a value indicating whether the computation object should be forwarded before or after the dependencies are resolved
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`2.Dispose">
            <summary>
            Clears dependencies
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`2.Dispose(System.Boolean)">
            <summary>
            Clears dependencies
            </summary>
            <param name="disposing">A value indicating whether Dispose was called</param>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`2.AddNullItem">
            <summary>
            Adds a null instance to the received computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`2.GetEnumerator">
            <summary>
            Gets an enumerator that enumerates the collected computations so far
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`2.Successors">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`2.Dependencies">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`2.ExecutionMetaData">
            <inheritdoc />
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`2.Notify(System.Collections.Generic.IList{NMF.Expressions.INotificationResult})">
            <inheritdoc />
        </member>
        <member name="E:NMF.Transformations.Linq.TransformationRuleSource`2.CollectionChanged">
            <summary>
            Gets fired when new elements appear in the trace
            </summary>
        </member>
        <member name="T:NMF.Transformations.Linq.TransformationRuleSource`3">
            <summary>
            Represents the usage of a transformation rule with two input arguments in a relational pattern
            </summary>
            <typeparam name="TIn1">The type of the first transformation rule input argument</typeparam>
            <typeparam name="TIn2">The type of the second transformation rule input argument</typeparam>
            <typeparam name="TOut">The transformation rule output type</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`3.#ctor(NMF.Transformations.TransformationRuleBase{`0,`1,`2},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new TransformationRuleSource instance for the given transformation rule in the given context
            </summary>
            <param name="rule">The transformation rule that should be used as source</param>
            <param name="context">The context in which the computations should be used by the current instance</param>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`3.TransformationRule">
            <summary>
            Gets the transformation rule this transformation rule source is responsible for
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`3.Context">
            <summary>
            Gets the context in which the transformation rule source is active
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`3.Filter">
            <summary>
            Gets or sets the filter to be used to filter computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`3.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Receives a new computation from the computation rule
            </summary>
            <param name="computation">The computation that is received</param>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`3.ExecuteBefore">
            <summary>
            Gets or sets a value indicating whether the computation object should be forwarded before or after the dependencies are resolved
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`3.Dispose">
            <summary>
            Clears dependencies
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`3.Dispose(System.Boolean)">
            <summary>
            Clears dependencies
            </summary>
            <param name="disposing">A value indicating whether Dispose was called</param>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`3.AddNullItem">
            <summary>
            Adds a null instance to the received computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`3.GetEnumerator">
            <summary>
            Gets an enumerator that enumerates the collected computations so far
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`3.Successors">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`3.Dependencies">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.TransformationRuleSource`3.ExecutionMetaData">
            <inheritdoc />
        </member>
        <member name="M:NMF.Transformations.Linq.TransformationRuleSource`3.Notify(System.Collections.Generic.IList{NMF.Expressions.INotificationResult})">
            <inheritdoc />
        </member>
        <member name="E:NMF.Transformations.Linq.TransformationRuleSource`3.CollectionChanged">
            <summary>
            Gets fired when new elements appear in the trace
            </summary>
        </member>
        <member name="T:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1">
            <summary>
            Represents the usage of a transformation rule with one input argument in a relational pattern
            </summary>
            <typeparam name="TIn">The type of the transformation rule input argument</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.#ctor(NMF.Transformations.InPlaceTransformationRuleBase{`0},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new TransformationRuleSource instance for the given transformation rule in the given context
            </summary>
            <param name="rule">The transformation rule that should be used as source</param>
            <param name="context">The context in which the computations should be used by the current instance</param>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.TransformationRule">
            <summary>
            Gets the transformation rule this transformation rule source is responsible for
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.Context">
            <summary>
            Gets the context in which the transformation rule source is active
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.Filter">
            <summary>
            Gets or sets the filter to be used to filter computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Receives a new computation from the computation rule
            </summary>
            <param name="computation">The computation that is received</param>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.ExecuteBefore">
            <summary>
            Gets or sets a value indicating whether the computation object should be forwarded before or after the dependencies are resolved
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.Dispose">
            <summary>
            Clears dependencies
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.Dispose(System.Boolean)">
            <summary>
            Clears dependencies
            </summary>
            <param name="disposing">A value indicating whether Dispose was called</param>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.AddNullItem">
            <summary>
            Adds a null instance to the received computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.GetEnumerator">
            <summary>
            Gets an enumerator that enumerates the collected computations so far
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.Successors">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.Dependencies">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.ExecutionMetaData">
            <inheritdoc />
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.Notify(System.Collections.Generic.IList{NMF.Expressions.INotificationResult})">
            <inheritdoc />
        </member>
        <member name="E:NMF.Transformations.Linq.InPlaceTransformationRuleSource`1.CollectionChanged">
            <summary>
            Gets fired when new elements appear in the trace
            </summary>
        </member>
        <member name="T:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2">
            <summary>
            Represents the usage of a transformation rule with two input arguments in a relational pattern
            </summary>
            <typeparam name="TIn1">The type of the first transformation rule input argument</typeparam>
            <typeparam name="TIn2">The type of the second transformation rule input argument</typeparam>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.#ctor(NMF.Transformations.InPlaceTransformationRuleBase{`0,`1},NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new TransformationRuleSource instance for the given transformation rule in the given context
            </summary>
            <param name="rule">The transformation rule that should be used as source</param>
            <param name="context">The context in which the computations should be used by the current instance</param>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.TransformationRule">
            <summary>
            Gets the transformation rule this transformation rule source is responsible for
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.Context">
            <summary>
            Gets the context in which the transformation rule source is active
            </summary>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.Filter">
            <summary>
            Gets or sets the filter to be used to filter computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Receives a new computation from the computation rule
            </summary>
            <param name="computation">The computation that is received</param>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.ExecuteBefore">
            <summary>
            Gets or sets a value indicating whether the computation object should be forwarded before or after the dependencies are resolved
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.Dispose">
            <summary>
            Clears dependencies
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.Dispose(System.Boolean)">
            <summary>
            Clears dependencies
            </summary>
            <param name="disposing">A value indicating whether Dispose was called</param>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.AddNullItem">
            <summary>
            Adds a null instance to the received computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.GetEnumerator">
            <summary>
            Gets an enumerator that enumerates the collected computations so far
            </summary>
            <returns>An enumerator</returns>
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.Successors">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.Dependencies">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.ExecutionMetaData">
            <inheritdoc />
        </member>
        <member name="M:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.Notify(System.Collections.Generic.IList{NMF.Expressions.INotificationResult})">
            <inheritdoc />
        </member>
        <member name="E:NMF.Transformations.Linq.InPlaceTransformationRuleSource`2.CollectionChanged">
            <summary>
            Gets fired when new elements appear in the trace
            </summary>
        </member>
        <member name="T:NMF.Transformations.AbstractTransformationRule`2">
            <summary>
            Defines a transformation rule with a single input argument that is abstract, i.e. it cannot create an output
            This means that there must exist transformation rules that are marked instantiating for this rule. 
            </summary>
            <typeparam name="TIn">The type of the input argument for this transformation rule</typeparam>
            <typeparam name="TOut">The type of output, that is generated in an instantiating rule</typeparam>
        </member>
        <member name="M:NMF.Transformations.AbstractTransformationRule`2.CreateOutput(`0,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates the output of this transformation rule
            </summary>
            <param name="input">The input argument for this computation</param>
            <param name="context">The context in which the output is required</param>
            <returns>The output for this transformation</returns>
            <remarks>Creation of transformation rule outputs is not supported for abstract transformation rules and thus, calling this method will result in an InvalidOperationException</remarks>
        </member>
        <member name="T:NMF.Transformations.AbstractTransformationRule`3">
            <summary>
            Defines a transformation rule with two input arguments that is abstract, i.e. it cannot create an output
            This means that there must exist transformation rules that are marked instantiating for this rule. 
            </summary>
            <typeparam name="TIn1">The type of the first input argument for this transformation rule</typeparam>
            <typeparam name="TIn2">The type of the second input argument for this transformation rule</typeparam>
            <typeparam name="TOut">The type of output, that is generated in an instantiating rule</typeparam>
        </member>
        <member name="M:NMF.Transformations.AbstractTransformationRule`3.CreateOutput(`0,`1,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates the output of this transformation rule
            </summary>
            <param name="input1">The first input argument for this computation</param>
            <param name="input2">The second input argument for this computation</param>
            <param name="context">The context in which the output is required</param>
            <returns>The output for this transformation</returns>
            <remarks>Creation of transformation rule outputs is not supported for abstract transformation rules and thus, calling this method will result in an InvalidOperationException</remarks>
        </member>
        <member name="T:NMF.Transformations.ChangePropagationMode">
            <summary>
            Denotes the change propagation mode
            </summary>
        </member>
        <member name="F:NMF.Transformations.ChangePropagationMode.None">
            <summary>
            No change propagation is performed
            </summary>
        </member>
        <member name="F:NMF.Transformations.ChangePropagationMode.OneWay">
            <summary>
            Change propagation is performed from the source to the target model
            </summary>
        </member>
        <member name="F:NMF.Transformations.ChangePropagationMode.TwoWay">
            <summary>
            Changes are propagated in both directions
            </summary>
        </member>
        <member name="T:NMF.Transformations.ComputationBase`1">
            <summary>
            Represents a computation that transforms a single input
            </summary>
            <typeparam name="TIn">The type of the input</typeparam>
        </member>
        <member name="M:NMF.Transformations.ComputationBase`1.#ctor(NMF.Transformations.GeneralTransformationRule{`0},NMF.Transformations.Core.IComputationContext,`0)">
            <summary>
            Creates a new computation within the given transformation context for the given input
            </summary>
            <param name="transformationRule">The transformation rule that was used to transform the input</param>
            <param name="context">The context of this transformation</param>
            <param name="input">The input for this transformation</param>
        </member>
        <member name="M:NMF.Transformations.ComputationBase`1.GetInput(System.Int32)">
            <summary>
            Gets the input argument for this computation with the given index
            </summary>
            <param name="index">The index of the input parameter</param>
            <returns>The input parameter at the ith position</returns>
        </member>
        <member name="P:NMF.Transformations.ComputationBase`1.TransformationRule">
            <summary>
            Gets the transformation rule, which has been used to compute this computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.ComputationBase`1.Input">
            <summary>
            Gets the input argument for this computation
            </summary>
        </member>
        <member name="T:NMF.Transformations.ComputationBase`2">
            <summary>
            Represents a computation that transforms two inputs
            </summary>
            <typeparam name="TIn1">The type of the first input</typeparam>
            <typeparam name="TIn2">The type of the second input</typeparam>
        </member>
        <member name="M:NMF.Transformations.ComputationBase`2.#ctor(NMF.Transformations.GeneralTransformationRule{`0,`1},NMF.Transformations.Core.IComputationContext,`0,`1)">
            <summary>
            Creates a new computation within the given transformation context for the given input
            </summary>
            <param name="transformationRule">The transformation rule that was used to transform the input</param>
            <param name="context">The context of this transformation</param>
            <param name="input1">The first input for this transformation</param>
            <param name="input2">The second input for this transformation</param>
        </member>
        <member name="M:NMF.Transformations.ComputationBase`2.GetInput(System.Int32)">
            <summary>
            Gets the input argument for this computation with the given index
            </summary>
            <param name="index">The index of the input parameter</param>
            <returns>The input parameter at the ith position</returns>
        </member>
        <member name="P:NMF.Transformations.ComputationBase`2.TransformationRule">
            <summary>
            Gets the transformation rule, which has been used to compute this computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.ComputationBase`2.Input1">
            <summary>
            Gets the first input argument for this computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.ComputationBase`2.Input2">
            <summary>
            Gets the second input argument for this computation
            </summary>
        </member>
        <member name="T:NMF.Transformations.ComputationBase">
            <summary>
            Represents a computation that transforms arbitrary many inputs
            </summary>
        </member>
        <member name="M:NMF.Transformations.ComputationBase.#ctor(NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.IComputationContext,System.Object[])">
            <summary>
            Creates a new computation within the given transformation context for the given input
            </summary>
            <param name="transformationRule">The transformation rule that was used to transform the input</param>
            <param name="context">The context of this transformation</param>
            <param name="inputs">The input for this transformation</param>
        </member>
        <member name="M:NMF.Transformations.ComputationBase.GetInput(System.Int32)">
            <summary>
            Gets the input argument for this computation with the given index
            </summary>
            <param name="index">The index of the input parameter</param>
            <returns>The input parameter at the ith position</returns>
        </member>
        <member name="P:NMF.Transformations.ComputationBase.Input">
            <summary>
            Gets the inputs of this computation
            </summary>
        </member>
        <member name="T:NMF.Transformations.GeneralTransformationRule`1">
            <summary>
            Defines a transformation rule of a transformation that has one input argument
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.MarkInstantiatingFor(NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{`0})">
            <summary>
            Marks the current transformation rule instantiating for the specified rule
            </summary>
            <param name="filter">The filter that should filter the inputs where this transformation rule is marked instantiating</param>
            <param name="rule">The transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Rule``1">
            <summary>
            Gets the first rule within the rules associated transformation that has the given rule type
            </summary>
            <typeparam name="TRule">The type of the transformation rule that is looked for</typeparam>
            <returns>The first transformation rule within the associated transformation or null, if there is none.</returns>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.WithPattern(NMF.Transformations.ITransformationRulePattern{`0})">
            <summary>
            Registers the given pattern for the current transformation rule
            </summary>
            <param name="pattern">The pattern that should be applied based on the current transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.WithPattern(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{`0}})">
            <summary>
            Registers the given incremental pattern for the current transformation rule
            </summary>
            <param name="patternCreator">The relation pattern that should be applied on the current transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.WithPattern(System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Registers the given static pattern for the current transformation rule
            </summary>
            <param name="patternCreator">The relation pattern that should be applied on the current transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireByType``1">
            <summary>
            Requires all transformation rules that transform items with the input type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireByType``1(System.Func{`0,``0})">
            <summary>
            Requires all transformation rules that transform items with the input type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireByType``2(System.Func{`0,``0},System.Func{`0,``1})">
            <summary>
            Requires all transformation rules that transform items with the input type
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Require``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,``0})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Require``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,``0},System.Func{`0,``1})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireManyByType``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireManyByType``2(System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Require(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,System.Object[]})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that returns the input of the required transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Require``1(NMF.Transformations.GeneralTransformationRule{``0},System.Predicate{`0})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="filter">A filter that filters the input arguments that need the specified requirement</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Require``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,``0},System.Predicate{`0})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="filter">A filter that filters the input arguments that need the specified requirement</param>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Require``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,``0},System.Func{`0,``1},System.Predicate{`0})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="filter">A filter that filters the input arguments that need the specified requirement</param>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireMany(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,System.Collections.Generic.IEnumerable{System.Object[]}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the input arguments for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireMany``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.RequireMany``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Call(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,System.Object[]})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the input for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallMany(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,System.Collections.Generic.IEnumerable{System.Object[]}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the input for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallByType``1(System.Func{`0,``0})">
            <summary>
            Calls all transformation rules that transform items with the input type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallByType``2(System.Func{`0,``0},System.Func{`0,``1})">
            <summary>
            Calls all transformation rules that transform items with the input type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Call``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,``0})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Call``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,``0},System.Func{`0,``1})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Call``1(NMF.Transformations.GeneralTransformationRule{``0},System.Predicate{`0})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="filter">A filter that filters the input arguments that need the specified requirement</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Call``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,``0},System.Predicate{`0})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="filter">A filter that filters the input arguments that need the specified requirement</param>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.Call``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,``0},System.Func{`0,``1},System.Predicate{`0})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="filter">A filter that filters the input arguments that need the specified requirement</param>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallManyByType``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Calls all transformation rules that transform S to T with all of the specified objects after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallManyByType``2(System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Calls all transformation rules that transform S to T with all of the specified objects after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallMany``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallMany``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="P:NMF.Transformations.GeneralTransformationRule`1.InputType">
            <summary>
            Gets the type signature of the input arguments of this transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``1(System.Func{``0,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``2(System.Func{``0,``1,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``1(System.Func{``0,`0},System.Predicate{``0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``2(System.Func{``0,``1,`0},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,`0},System.Predicate{``0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,`0},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``1(System.Func{``0,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whole collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``1(System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Predicate{``0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Predicate{``0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``2(System.Func{``0,``1,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``3(System.Func{``0,``1,``2,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``2(System.Func{``0,``1,`0},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``3(System.Func{``0,``1,``2,`0},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,`0},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,`0},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whole collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``3(System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``3(System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEachOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the input type is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the rule parameter is passed a null instance.</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.TraceInput``1(System.Func{`0,``0})">
            <summary>
            Creates a trace entry for every computation of the current rule for the computation input
            </summary>
            <typeparam name="TKey">The type that should be used as key for the trace entry</typeparam>
            <param name="traceSelector">A method that returns the trace key for the input of a computation</param>
            <returns>A trace group that can be used as a key for the trace functionality</returns>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.TraceInput``1(NMF.Transformations.TraceEntryGroup{``0,`0},System.Func{`0,``0})">
            <summary>
            Creates a trace entry for every computation of the current rule for the computation input
            </summary>
            <typeparam name="TKey">The type that should be used as key for the trace entry</typeparam>
            <param name="traceSelector">A method that returns the trace key for the input of a computation</param>
            <param name="traceKey">A trace group used as a key for the trace functionality</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.SelectArrays``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},NMF.Transformations.Core.Computation)">
            <summary>
            This method is a helper function that converts the given selector of tuples to a selector of object[]
            </summary>
            <param name="selector">The source selector that selects the output of dependant transformation rules as typed tuples</param>
            <param name="computation">The inputs for the selector</param>
            <returns>A collection of inputs for other transformation rules</returns>
            <remarks>This method is used as helper function for DependMany.</remarks>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.SelectArraysT2``2(System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},NMF.Transformations.Core.Computation)">
            <summary>
            This method is a helper function that converts the given selector of tuples to a selector of object[]
            </summary>
            <param name="selector">The source selector that selects the output of dependant transformation rules as typed tuples</param>
            <param name="computation">The inputs for the selector</param>
            <returns>A collection of inputs for other transformation rules</returns>
            <remarks>This method is used as helper function for DependMany.</remarks>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,`0},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallFor(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,`0},System.Predicate{NMF.Transformations.Core.Computation},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method to filter the objects where the reversed dependency is applicable</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,System.Collections.Generic.IEnumerable{`0}},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.CallForEach(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,System.Collections.Generic.IEnumerable{`0}},System.Predicate{NMF.Transformations.Core.Computation},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`1.ToString">
            <summary>
            Gets the name of the transformation rule
            </summary>
            <returns>The name of the transformation rule</returns>
        </member>
        <member name="T:NMF.Transformations.GeneralTransformationRule`2">
            <summary>
            Defines a transformation rule of a transformation that has one input argument
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.MarkInstantiatingFor(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,`1,System.Boolean})">
            <summary>
            Marks the current transformation rule instantiating for the specified rule
            </summary>
            <param name="filter">The filter that should filter the inputs where this transformation rule is marked instantiating</param>
            <param name="rule">The transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Rule``1">
            <summary>
            Gets the first rule within the rules associated transformation that has the given rule type
            </summary>
            <typeparam name="TRule">The type of the transformation rule that is looked for</typeparam>
            <returns>The first transformation rule within the associated transformation or null, if there is none.</returns>
        </member>
        <member name="P:NMF.Transformations.GeneralTransformationRule`2.InputType">
            <summary>
            Gets the type signature of the input arguments of this transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.WithPattern(NMF.Transformations.ITransformationRulePattern{`0,`1})">
            <summary>
            Registers the given pattern for the current transformation rule
            </summary>
            <param name="pattern">The pattern that should be applied based on the current transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.WithPattern(System.Func{NMF.Transformations.Core.ITransformationContext,NMF.Expressions.INotifyEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Registers the given incremental pattern for the current transformation rule
            </summary>
            <param name="patternCreator">The relation pattern that should be applied on the current transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.WithPattern(System.Func{NMF.Transformations.Core.ITransformationContext,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Registers the given incremental pattern for the current transformation rule
            </summary>
            <param name="patternCreator">The relation pattern that should be applied on the current transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireByType``2">
            <summary>
            Requires all transformation rules that transform items from S1 and S2 to T
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireByType``2(System.Func{`0,`1,``0},System.Func{`0,`1,``1})">
            <summary>
            Requires all transformation rules that transform items from S1, S2 to T
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The first input argument type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector1 parameter</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector2 parameter</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireByType``1(System.Func{`0,`1,``0})">
            <summary>
            Requires all transformation rules that transform items from S1, S2 to T
            </summary>
            <typeparam name="TRequiredInput">The first input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Require(NMF.Transformations.GeneralTransformationRule{`0,`1},System.Func{`0,`1,System.Boolean})">
            <summary>
            Requires the given transformation rule with the same input types and a filter
            </summary>
            <param name="rule">The transformation rule</param>
            <param name="filter">The filter method</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Require``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,``0},System.Func{`0,`1,``1})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector1 parameter</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector2 parameter</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Require``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,``0})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The first input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Require(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,`1,System.Object[]})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireManyByType``2(System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Requires all transformation rules that transform S1, S2 to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireManyByType``1(System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Requires all transformation rules that transform S1, S2 to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput">The first input argument type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireMany``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireMany``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput">The first input argument type of the dependent transformations</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallByType``2">
            <summary>
            Calls the transformation rules that match the given input types with the same inputs
            </summary>
            <typeparam name="TRequiredInput1">The first input type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input type of the dependent transformation rule</typeparam>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Call``2(NMF.Transformations.GeneralTransformationRule{``0,``1})">
            <summary>
            Calls the given transformation rule with the same inputs
            </summary>
            <typeparam name="TRequiredInput1">The first input type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input type of the dependent transformation rule</typeparam>
            <param name="rule">The transformation rule that needs to be called</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallByType``2(System.Func{`0,`1,``0},System.Func{`0,`1,``1})">
            <summary>
            Calls the transformation rules that match the given input type signature
            </summary>
            <typeparam name="TRequiredInput1">The first input type of the dependent transformation rules</typeparam>
            <typeparam name="TRequiredInput2">The second input type of the dependent transformation rules</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector1 parameter</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector2 parameter</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallByType``1(System.Func{`0,`1,``0})">
            <summary>
            Calls all transformation rules that match the given input type signature
            </summary>
            <typeparam name="TRequiredInput">The type of the input argument of dependent transformation rules</typeparam>
            <param name="selector">A method that selects the input arguzment for the dependent transformation rules</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Call``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,``0},System.Func{`0,`1,``1})">
            <summary>
            Calls the given transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The type of the first input argument of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The type of the second input argument of the dependent transformation rule</typeparam>
            <param name="rule">The transformation rule that needs to be called</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector1 parameter</exception>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown when a null reference is passed to the selector2 parameter</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Call(NMF.Transformations.GeneralTransformationRule{`0,`1},System.Func{`0,`1,System.Boolean})">
            <summary>
            Requires the given transformation rule with the same input types and a filter
            </summary>
            <param name="rule">The transformation rule</param>
            <param name="filter">The filter method</param>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Call``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,``0})">
            <summary>
            Calls the given transformation rule
            </summary>
            <typeparam name="TRequiredInput">The type of the dependent transformation rules input argument</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the input parameter for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallManyByType``2(System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Calls the transformation rules that match the given input type signature multiple times
            </summary>
            <typeparam name="TRequiredInput1">The type of the first input parameter of the dependent transformation rules</typeparam>
            <typeparam name="TRequiredInput2">The type of the second input parameter of the dependent transformation rules</typeparam>
            <param name="selector">A method that selects the input parameters for the dependent transformation rules</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallManyByType``1(System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Calls the transformation rules that match the given input type signature multiple times
            </summary>
            <typeparam name="TRequiredInput">The type of the input parameter of the dependent transformation rules</typeparam>
            <param name="selector">A method that selects the input parameter for the dependent transformation rules</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallMany``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Calls the given transformation rule multiple times
            </summary>
            <typeparam name="TRequiredInput1">The type of the first input parameter of the dependent transformation rules</typeparam>
            <typeparam name="TRequiredInput2">The type of the second input parameter of the dependent transformation rules</typeparam>
            <param name="selector">A method that selects the input parameters for the dependent transformation rules</param>
            <param name="rule">The transformation rule that needs to be called</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallMany``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Calls the given transformation rule multiple times
            </summary>
            <typeparam name="TRequiredInput">The type of the input parameter of the dependent transformation rules</typeparam>
            <param name="selector">A method that selects the input parameter for the dependent transformation rules</param>
            <param name="rule">The transformation rule that needs to be called</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``2(System.Func{``0,``1,`0},System.Func{``0,``1,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``2(System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method that filters the objects where the dependency should be applied</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,`0},System.Func{``0,``1,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method to filter the objects where the reversed dependency is applicable</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``1(System.Func{``0,`0},System.Func{``0,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``1(System.Func{``0,`0},System.Func{``0,`1},System.Func{``0,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method that filters the objects where the dependency should be applied</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,`0},System.Func{``0,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,`0},System.Func{``0,`1},System.Func{``0,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method to filter the objects where the reversed dependency is applicable</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``3(System.Func{``0,``1,``2,`0},System.Func{``0,``1,``2,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``3(System.Func{``0,``1,``2,`0},System.Func{``0,``1,``2,`1},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method that filters the objects where the dependency should be applied</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,`0},System.Func{``0,``1,``2,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,`0},System.Func{``0,``1,``2,`1},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method to filter the objects where the reversed dependency is applicable</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``2(System.Func{``0,``1,`0},System.Func{``0,``1,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``2(System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method that filters the objects where the dependency should be applied</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,`0},System.Func{``0,``1,`1})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input type of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector1">A method that selects the first input parameter for the current transformation rule</param>
            <param name="selector2">A method that selects the second input parameter for the current transformation rule</param>
            <param name="filter">A method to filter the objects where the reversed dependency is applicable</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector1 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector2 parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``1(System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``1(System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``3(System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``3(System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,``2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,``2,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput1">The first input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredInput2">The second input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``2(System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEachOutputSensitive``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,System.Boolean})">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <typeparam name="TRequiredInput">The input type parameter of the transformation rule acting as trigger</typeparam>
            <typeparam name="TRequiredOutput">The output type parameter of the transformation rule acting as trigger</typeparam>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,System.Tuple{`0,`1}},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallFor(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,System.Tuple{`0,`1}},System.Predicate{NMF.Transformations.Core.Computation},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver objects are transformed with the given transformation rule
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method to filter the objects where the reversed dependency is applicable</param>
            <param name="rule">The transformation rule that act as trigger for the current transformation rule</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallForEach(NMF.Transformations.Core.GeneralTransformationRule,System.Func{NMF.Transformations.Core.Computation,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Predicate{NMF.Transformations.Core.Computation},System.Boolean)">
            <summary>
            Specify that the current transformation rule is called whenenver the given types are transformed multiple times
            </summary>
            <param name="selector">A method that selects the input parameters for the current transformation rule</param>
            <param name="filter">A method that filters the inputs of the transformation rule acting as trigger</param>
            <param name="rule">The transformation rule acting as trigger for the current transformation rule</param>
            <param name="needOutput">True, if the call must be made after the output of the trigger rule is created, otherwise false</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.RequireMany(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Object[]}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the inputs for the dependent computations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.Call(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,`1,System.Object[]})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the input for the dependent computations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.CallMany(NMF.Transformations.Core.GeneralTransformationRule,System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Object[]}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <param name="selector">A method that selects the inputs for the dependent computations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the selector parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.GeneralTransformationRule`2.ToString">
            <summary>
            Gets the name of the transformation rule
            </summary>
            <returns>The name of the transformation rule</returns>
        </member>
        <member name="T:NMF.Transformations.InPlaceComputation`1">
            <summary>
            Represents an in-place computation 
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
        </member>
        <member name="M:NMF.Transformations.InPlaceComputation`1.#ctor(NMF.Transformations.InPlaceTransformationRuleBase{`0},NMF.Transformations.Core.IComputationContext,`0)">
            <summary>
            Creates a new in-place computation for the given transformation rule and the given transformation context
            </summary>
            <param name="transformationRule">The transformation rule for this computation</param>
            <param name="context">The transformation context in which this computations resides</param>
            <param name="input">The input parameter for this computation</param>
        </member>
        <member name="P:NMF.Transformations.InPlaceComputation`1.OutputCore">
            <summary>
            Gets a null instance as the output of the in-place computation
            </summary>
        </member>
        <member name="T:NMF.Transformations.InPlaceComputation`2">
            <summary>
            Represents an in-place computation 
            </summary>
            <typeparam name="TIn1">The type of the first input parameter</typeparam>
            <typeparam name="TIn2">The type of the second input parameter</typeparam>
        </member>
        <member name="M:NMF.Transformations.InPlaceComputation`2.#ctor(NMF.Transformations.InPlaceTransformationRuleBase{`0,`1},NMF.Transformations.Core.IComputationContext,`0,`1)">
            <summary>
            Creates a new in-place computation for the given transformation rule and the given transformation context
            </summary>
            <param name="transformationRule">The transformation rule for this computation</param>
            <param name="context">The transformation context in which this computations resides</param>
            <param name="input1">The first input parameter for this computation</param>
            <param name="input2">The second input parameter for this computation</param>
        </member>
        <member name="P:NMF.Transformations.InPlaceComputation`2.OutputCore">
            <summary>
            Gets a null instance as the output of the in-place computation
            </summary>
        </member>
        <member name="T:NMF.Transformations.InPlaceComputation">
            <summary>
            Represents an in-place computation 
            </summary>
        </member>
        <member name="M:NMF.Transformations.InPlaceComputation.#ctor(NMF.Transformations.InPlaceTransformationRuleBase,NMF.Transformations.Core.IComputationContext,System.Object[])">
            <summary>
            Creates a new in-place computation for the given transformation rule and the given transformation context
            </summary>
            <param name="transformationRule">The transformation rule for this computation</param>
            <param name="context">The transformation context in which this computations resides</param>
            <param name="inputs">The input parameters for this computation</param>
        </member>
        <member name="P:NMF.Transformations.InPlaceComputation.OutputCore">
            <summary>
            Gets a null instance as the output of the in-place computation
            </summary>
        </member>
        <member name="T:NMF.Transformations.InPlaceTransformationRule`1">
            <summary>
            Defines a simple transformation rule of a transformation that has one input argument and no output
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <remarks>Simple means that the transformation rule does not require a custom computation class</remarks>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`1.#ctor">
            <summary>
            Creates a new transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.InPlaceTransformationRule`1.NeedDependenciesForOutputCreation">
            <summary>
            Gets a value indicating whether the output for all dependencies must have been created before this rule creates the output
            </summary>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`1.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new Computation instance for this transformation rule or the given input 
            </summary>
            <param name="input">The input arguments for this computation</param>
            <param name="context">The context for this computation</param>
            <returns>A computation object</returns>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`1.Transform(`0,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation output
            </summary>
            <param name="input">The input of the transformation rule</param>
            <param name="context">The context (and trace!) object</param>
            <remarks>At this point, all the transformation outputs are created (also the delayed ones), thus, the trace is fully reliable</remarks>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`1.Init(`0,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation. This is done before any other transformation rule hits Transform
            </summary>
            <param name="input">The input for this transformation rule</param>
            <param name="context">The current transformation context</param>
        </member>
        <member name="T:NMF.Transformations.InPlaceTransformationRuleBase`1">
            <summary>
            Defines a transformation rule that takes an input argument, but does not produce a result
            </summary>
            <typeparam name="T">The type of the input argument</typeparam>
        </member>
        <member name="P:NMF.Transformations.InPlaceTransformationRuleBase`1.OutputType">
            <summary>
            Gets the output type of this transformation rule
            </summary>
        </member>
        <member name="T:NMF.Transformations.InPlaceTransformationRuleBase`2">
            <summary>
            Represents an in-place transformation rule that operates on two input arguments
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
        </member>
        <member name="P:NMF.Transformations.InPlaceTransformationRuleBase`2.OutputType">
            <summary>
            Gets the output type of the transformation rule
            </summary>
        </member>
        <member name="T:NMF.Transformations.InPlaceTransformationRuleBase">
            <summary>
            This class is used to describe transformation rules that have more than two input arguments and no output
            </summary>
        </member>
        <member name="P:NMF.Transformations.InPlaceTransformationRuleBase.OutputType">
            <summary>
            Gets the type signature of the output type of this transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRuleBase.MarkInstantiatingFor(NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{System.Object[]})">
            <summary>
            Marks the current transformation rule instantiating for the specified rule
            </summary>
            <param name="filter">The filter that should filter the inputs where this transformation rule is marked instantiating</param>
            <param name="rule">The transformation rule</param>
        </member>
        <member name="T:NMF.Transformations.InPlaceTransformationRule`2">
            <summary>
            Defines a simple transformation rule of a transformation that has two inputs argument and no output
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <remarks>Simple means that the transformation rule does not require a custom computation class</remarks>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`2.#ctor">
            <summary>
            Creates a new transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.InPlaceTransformationRule`2.NeedDependenciesForOutputCreation">
            <summary>
            Gets a value indicating whether the output for all dependencies must have been created before this rule creates the output
            </summary>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`2.Transform(`0,`1,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation output
            </summary>
            <param name="input1">The first input of the transformation rule</param>
            <param name="input2">The second input of the transformation rule</param>
            <param name="context">The context (and trace!) object</param>
            <remarks>At this point, all the transformation outputs are created (also the delayed ones), thus, the trace is fully reliable</remarks>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`2.Init(`0,`1,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation. This is done before any other transformation rule hits Transform
            </summary>
            <param name="input1">The first input for this transformation rule</param>
            <param name="input2">The second input for this transformation rule</param>
            <param name="context">The current transformation context</param>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule`2.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new Computation instance for this transformation rule or the given input 
            </summary>
            <param name="input">The input arguments for this computation</param>
            <param name="context">The context for this computation</param>
            <returns>A computation object</returns>
        </member>
        <member name="T:NMF.Transformations.InPlaceTransformationRule">
            <summary>
            Defines a simple transformation rule of a transformation that has multiple input arguments and no output
            </summary>
            <remarks>Simple means that the transformation rule does not require a custom computation class</remarks>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule.#ctor">
            <summary>
            Creates a new transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.InPlaceTransformationRule.NeedDependenciesForOutputCreation">
            <summary>
            Gets a value indicating whether the output for all dependencies must have been created before this rule creates the output
            </summary>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new Computation instance for this transformation rule or the given input 
            </summary>
            <param name="input">The input arguments for this computation</param>
            <param name="context">The context for this computation</param>
            <returns>A computation object</returns>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule.Init(System.Object[],NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation. This is done before any other transformation rule hits Transform
            </summary>
            <param name="input">The input for this transformation rule</param>
            <param name="context">The current transformation context</param>
        </member>
        <member name="M:NMF.Transformations.InPlaceTransformationRule.Transform(System.Object[],NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation output
            </summary>
            <param name="input">The input of the transformation rule</param>
            <param name="context">The context (and trace!) object</param>
            <remarks>At this point, all the transformation outputs are created (also the delayed ones), thus, the trace is fully reliable</remarks>
        </member>
        <member name="T:NMF.Transformations.ITransformationRulePattern`1">
            <summary>
            Represents a transformation pattern that can be tied to a transformation rule
            </summary>
            <typeparam name="TIn">The type of the first input parameter of the target transformation rule</typeparam>
        </member>
        <member name="P:NMF.Transformations.ITransformationRulePattern`1.TargetRule">
            <summary>
            Gets or sets the transformation rule that is the target for the current transformation rule pattern
            </summary>
        </member>
        <member name="T:NMF.Transformations.ITransformationRulePattern`2">
            <summary>
            Represents a transformation pattern that can be tied to a transformation rule
            </summary>
            <typeparam name="TIn1">The type of the first input parameter of the target transformation rule</typeparam>
            <typeparam name="TIn2">The type of the second input parameter of the target transformation rule</typeparam>
        </member>
        <member name="P:NMF.Transformations.ITransformationRulePattern`2.TargetRule">
            <summary>
            Gets or sets the transformation rule that is the target for the current transformation rule pattern
            </summary>
        </member>
        <member name="T:NMF.Transformations.OverrideRuleAttribute">
            <summary>
            Marks a transformation rule to override another transformation rule
            </summary>
        </member>
        <member name="T:NMF.Transformations.ReflectiveTransformation">
            <summary>
            This is a base class of a transformation that just creates an instance of each nested class, if it is not abstract and is a transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.ReflectiveTransformation.CreateRules">
            <summary>
            Creates all transformation rules of this transformation
            </summary>
            <remarks>This method is called during Initialization. The output IEnumerable-collection is saved into a list.</remarks>
            <returns>A collection of transformation rules</returns>
        </member>
        <member name="M:NMF.Transformations.ReflectiveTransformation.GetRuleForRuleType(System.Type)">
            <summary>
            Gets the rule with the specified type (exact match)
            </summary>
            <param name="transformationRule">The type of the transformation rule</param>
            <returns>The transformation rule with this type or null, if there is none</returns>
            <remarks>This method assumes there is only one transformation rule per type</remarks>
        </member>
        <member name="M:NMF.Transformations.ReflectiveTransformation.Rule``1">
            <summary>
            Gets the transformation rule instance of the given rule type within the given transformation
            </summary>
            <typeparam name="TRule">The type of the desired transformation rule</typeparam>
            <returns>The transformation rule</returns>
        </member>
        <member name="M:NMF.Transformations.ReflectiveTransformation.GetRulesForRuleType(System.Type)">
            <summary>
            Gets all rules with the specified type (exact match)
            </summary>
            <param name="transformationRule">The type of the transformation rules</param>
            <returns>A collection of all rules with this type</returns>
            <remarks>This method assumes there is only one transformation rule per type</remarks>
        </member>
        <member name="M:NMF.Transformations.ReflectiveTransformation.RegisterRules">
            <summary>
            Registers the rules of this transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.ReflectiveTransformation.CreateCustomRules">
            <summary>
            Creates the transformation rules that are no public nested classes (cannot be overridenn by reflected rules)
            </summary>
            <returns>A collection of transformation rules</returns>
        </member>
        <member name="M:NMF.Transformations.ReflectiveTransformation.CreateDefaultRules">
            <summary>
            Creates the default transformation rules (can be overridden by reflected rules)
            </summary>
            <returns>A collection of transformation rules</returns>
        </member>
        <member name="T:NMF.Transformations.Reflector">
            <summary>
            A helper class that reflects the transformation rules that reside as nested classes within a given type
            </summary>
        </member>
        <member name="M:NMF.Transformations.Reflector.ReflectDictionary``1(System.Collections.Generic.Stack{System.Type},System.Func{System.Collections.Generic.IEnumerable{``0}},System.Func{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Obtains the rules from the given type stack
            </summary>
            <typeparam name="T">The type of rules</typeparam>
            <param name="typeStack">A stack of types from which to reflect the rules</param>
            <param name="createDefaults">A function that returns the defaults</param>
            <param name="createCustoms">A function that returns the customs</param>
            <returns>A collection of rules</returns>
        </member>
        <member name="M:NMF.Transformations.Reflector.ReflectInType``1(System.Type,System.Action{System.Type,``0})">
            <summary>
            Reflects a type and instantiates all transformation rules contained in this type as nested classes
            </summary>
            <param name="transformationType">The type that should be reflected</param>
            <param name="persistor">A method that should be executed to save the reflected transformation rule</param>
            <remarks>This method reflects the nested classes contained in the given type. It does not look in base types!</remarks>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the transformationType parameter is passed a null instance</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the persistor parameter is passed a null instance</exception>
        </member>
        <member name="T:NMF.Transformations.TraceExtensions">
            <summary>
            This helper class provides additional methods for tracing purposes
            </summary>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveIn(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Object[])">
            <summary>
            Trace the output of the computation that transformed the given input with the given transformation type
            </summary>
            <param name="rule">The rule that transformed the argument</param>
            <param name="input">The input arguments</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>The output of the computation with the specified input argument or null, if there is none such</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)">
            <summary>
            Trace the output of the computation that transformed the given input with the given transformation type
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="trace">The trace component that is used as basis</param>
            <param name="input">The input argument</param>
            <returns>The output of the computation with the specified input argument or null, if there is none such</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.Resolve``2(NMF.Transformations.Core.ITransformationTrace,``0)">
            <summary>
            Trace the output of the computation that transformed the given input into a desired output
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="trace">The trace component that is used as basis</param>
            <param name="input">The input argument</param>
            <returns>The output of the computation with the specified input argument or null, if there is none such</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},``0,``1)">
            <summary>
            Trace the output of the computation that transformed the given input with the given transformation type
            </summary>
            <typeparam name="TIn1">The first input type that is looked for</typeparam>
            <typeparam name="TIn2">The second input type that is looked for</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="trace">The trace component that is used as basis</param>
            <param name="input1">The first input argument</param>
            <param name="input2">The second input argument</param>
            <returns>The output of the computation with the specified input argument or null, if there is none such</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.Resolve``3(NMF.Transformations.Core.ITransformationTrace,``0,``1)">
            <summary>
            Trace the output of the computation that transformed the given input with the given transformation type
            </summary>
            <typeparam name="TIn1">The first input type that is looked for</typeparam>
            <typeparam name="TIn2">The second input type that is looked for</typeparam>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="input1">The first input argument</param>
            <param name="trace">The trace component that is used as basis</param>
            <param name="input2">The second input argument</param>
            <returns>The output of the computation with the specified input argument or null, if there is none such</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Object[])">
            <summary>
            Trace the output of the computation that transformed the given input with the given transformation type
            </summary>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <param name="input">The input arguments</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>The output of the computation with the specified input argument or null, if there is none such</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.Resolve``1(NMF.Transformations.Core.ITransformationTrace,System.Object[])">
            <summary>
            Trace the output of the computation that transformed the given input with the given transformation type
            </summary>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="input">The input arguments</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>The output of the computation with the specified input argument or null, if there is none such</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``0})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="filter">The filter that should filter the inputs</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``0})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter into the desired type
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="trace">The trace component that is used as basis</param>
            <param name="filter">The filter that should filter the inputs</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0)">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="input">The input to resolve multiple outputs</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="list">A list of allowed input arguments</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter into the desired type
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="trace">The trace component that is used as basis</param>
            <param name="list">A list of allowed input arguments</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0)">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter into the desired type
            </summary>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="trace">The trace component that is used as basis</param>
            <param name="input">An input argument to look up multiple results</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{System.Object[]})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="filter">The filter that should filter the inputs</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{System.Object[]})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="inputTypes">The types of the input arguments that are expected to be matched</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="filter">The filter that should filter the inputs</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{``1})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TIn">The input type parameter of the transformation rule</typeparam>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="filter">The filter that should filter the inputs</param>
            <param name="trace">The trace component that is used as basis</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindWhere``2(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``1})">
            <summary>
            Finds all outputs of computations of from the specified source typpe to the specified target type that match the given filter
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TIn">The input type of the transformation rule</typeparam>
            <typeparam name="TOut">The output type of the transformation rule</typeparam>
            <param name="filter">The filter that should be applied to the transformation outputs</param>
            <returns>A collection with all suitable outputs</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Predicate{``2})">
            <summary>
            Finds all outputs of computations of the given transformation that match the given filter
            </summary>
            <typeparam name="TIn1">The type of the first transformation argument</typeparam>
            <typeparam name="TIn2">The type of the second transformation argument</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output type of the transformation rule</typeparam>
            <param name="filter">The filter that should be applied to the transformation outputs</param>
            <returns>A collection with all suitable outputs</returns>
            <param name="trace">The trace component that is used as basis</param>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Predicate{``2})">
            <summary>
            Finds all outputs of computations of from the specified source type to the specified target type that match the given filter
            </summary>
            <typeparam name="TIn1">The type of the first transformation argument</typeparam>
            <typeparam name="TIn2">The type of the second transformation argument</typeparam>
            <typeparam name="TOut">The output type of the transformation rule</typeparam>
            <param name="filter">The filter that should be applied to the transformation outputs</param>
            <returns>A collection with all suitable outputs</returns>
            <param name="trace">The trace component that is used as basis</param>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0},System.Predicate{``0})">
            <summary>
            Finds all outputs of computations of from the specified source type to the specified target type that match the given filter
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TOut">The output type of the transformation rule</typeparam>
            <param name="filter">The filter that should be applied to the transformation outputs</param>
            <param name="rule">The transformation rule the object was transformed with</param>
            <returns>A collection with all suitable outputs</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindWhere``1(NMF.Transformations.Core.ITransformationTrace,System.Type[],System.Predicate{``0})">
            <summary>
            Finds all outputs of computations of from the specified source type to the specified target type that match the given filter
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TOut">The output type of the transformation rule</typeparam>
            <param name="filter">The filter that should be applied to the transformation outputs</param>
            <param name="inputTypes">The input types for the transformation rule</param>
            <returns>A collection with all suitable outputs</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.TraceInWhere``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0},System.Predicate{``0})">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TIn">The input argument type of the transformation</typeparam>
            <param name="rule">The transformation rule</param>
            <param name="filter">The predicate of the inputs that are looked for</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.TraceInWhere``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TIn1">The first input argument type of the transformation</typeparam>
            <typeparam name="TIn2">The first input argument type of the transformation</typeparam>
            <param name="filter">The predicate of the inputs that are looked for</param>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.TraceInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{System.Object[]})">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <param name="filter">The predicate of the inputs that are looked for</param>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveInWhere(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{NMF.Transformations.Core.ITraceEntry})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <param name="rule">The transformation rule that was used to transform the outputs</param>
            <param name="filter">The filter that should filter the inputs</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindAllIn``1(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0})">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindAllIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1})">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindAllIn``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2})">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveInWhere``3(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Boolean})">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <param name="rule">The transformation rule</param>
            <param name="filter">A filter that is to be applied on the inputs</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveWhere``3(NMF.Transformations.Core.ITransformationTrace,System.Func{``0,``1,System.Boolean})">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <param name="filter">The filter that should filter the inputs</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindAll``1(NMF.Transformations.Core.ITransformationTrace,System.Type[])">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <returns>All outputs of computations</returns>
            <param name="inputTypes">The input types of the trace request</param>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindAll``2(NMF.Transformations.Core.ITransformationTrace)">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <typeparam name="TIn">The input parameter type of the transformation rule</typeparam>
            <returns>All outputs of computations</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.FindAll``3(NMF.Transformations.Core.ITransformationTrace)">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <typeparam name="TIn1">The first input parameter type of the transformation rule</typeparam>
            <typeparam name="TIn2">The second input parameter type of the transformation rule</typeparam>
            <returns>All outputs of computations</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveManyIn``2(NMF.Transformations.Core.ITransformationTrace,NMF.Transformations.TransformationRuleBase{``0,``1},``0[])">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter with the given transformation type
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <param name="rule">The transformation rule the object was transformed with</param>
            <typeparam name="TOut">The output that is returned by the transformation rule</typeparam>
            <param name="list">A list of allowed input arguments</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.ResolveMany``2(NMF.Transformations.Core.ITransformationTrace,``0[])">
            <summary>
            Trace the output of the computation that transformed any input that matches the filter into the desired type
            </summary>
            <param name="trace">The trace component that is used as basis</param>
            <typeparam name="TIn">The input type that is looked for</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="list">A list of allowed input arguments</param>
            <returns>All outputs of computations with suitable input arguments or null, if there are none</returns>
        </member>
        <member name="M:NMF.Transformations.TraceExtensions.GetOrCreateUserItem``1(NMF.Transformations.Core.ITransformationContext,System.Object,System.Func{``0})">
            <summary>
            Gets or creates the user item with the specified key
            </summary>
            <typeparam name="TValue">The type of the user item</typeparam>
            <param name="context">The transformation context</param>
            <param name="key">The key for the user item</param>
            <param name="valueCreator">A method that creates the default value if the user item does not yet exist or null, if no user item should be created</param>
            <returns>The user item with the specified key</returns>
        </member>
        <member name="T:NMF.Transformations.TraceEntry`2">
            <summary>
            Represents a computation that is only used for tracing purposes
            </summary>
            <typeparam name="TInput">The type of the trace key</typeparam>
            <typeparam name="TOut">The output type of the trace entry</typeparam>
        </member>
        <member name="M:NMF.Transformations.TraceEntry`2.#ctor(NMF.Transformations.TransformationRuleBase{`0,`1},`0,`1)">
            <summary>
            Creates a new trace-only computation
            </summary>
            <param name="rule">The transformation rule used as trace group</param>
            <param name="input">The trace key for this transformation rule</param>
            <param name="output">The output for this trace entry</param>
        </member>
        <member name="P:NMF.Transformations.TraceEntry`2.Output">
            <summary>
            Gets the output of the trace entry
            </summary>
        </member>
        <member name="P:NMF.Transformations.TraceEntry`2.TransformationRule">
            <summary>
            Gets the transformation rule used as trace key for this trace entry
            </summary>
        </member>
        <member name="T:NMF.Transformations.TraceEntryGroup`2">
            <summary>
            Represents a transformation rule that is only used for tracing purposes and must not be used to create computations
            </summary>
            <typeparam name="TKey">The type for the keys of the trace entries</typeparam>
            <typeparam name="TOut">The type of the values of the trace entries</typeparam>
        </member>
        <member name="M:NMF.Transformations.TraceEntryGroup`2.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Overridden to disallow creating computations
            </summary>
            <param name="input">Disallowed</param>
            <param name="context">Disallowed</param>
            <returns>Disallowed</returns>
        </member>
        <member name="P:NMF.Transformations.TraceEntryGroup`2.NeedDependenciesForOutputCreation">
            <inheritdoc />
        </member>
        <member name="T:NMF.Transformations.TransformationComputation`2">
            <summary>
            Represents a computation that represents that a set of input arguments are transformed into an output of type TOut
            </summary>
            <typeparam name="TOut">The type of the output</typeparam>
            <typeparam name="TIn">The type of the input parameter</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationComputation`2.#ctor(NMF.Transformations.TransformationRuleBase{`0,`1},NMF.Transformations.Core.IComputationContext,`0)">
            <summary>
            Creates a new transformation computation for the given input arguments
            </summary>
            <param name="transformationRule">The transformation rule for this computation</param>
            <param name="context">The context of this computation</param>
            <param name="input">The input for this computation</param>
        </member>
        <member name="P:NMF.Transformations.TransformationComputation`2.OutputCore">
            <summary>
            Gets or sets the output in a derived class
            </summary>
        </member>
        <member name="P:NMF.Transformations.TransformationComputation`2.Output">
            <summary>
            Gets the output of this computation
            </summary>
            <exception cref="T:System.InvalidOperationException">This property may throw a DelayedOutputCreationException in case that the output has been tried to access, although the output creation was delayed</exception>
        </member>
        <member name="T:NMF.Transformations.TransformationComputation`3">
            <summary>
            Represents a computation that represents that a set of input arguments are transformed into an output of type TOut
            </summary>
            <typeparam name="TOut">The type of the output</typeparam>
            <typeparam name="TIn1">The type of the first input parameter</typeparam>
            <typeparam name="TIn2">The type of the second input parameter</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationComputation`3.#ctor(NMF.Transformations.TransformationRuleBase{`0,`1,`2},NMF.Transformations.Core.IComputationContext,`0,`1)">
            <summary>
            Creates a new transformation computation for the given input arguments
            </summary>
            <param name="transformationRule">The transformation rule for this computation</param>
            <param name="context">The context of this computation</param>
            <param name="input1">The first input for this computation</param>
            <param name="input2">The second input for this computation</param>
        </member>
        <member name="P:NMF.Transformations.TransformationComputation`3.OutputCore">
            <summary>
            Gets or sets the output in a derived class
            </summary>
        </member>
        <member name="P:NMF.Transformations.TransformationComputation`3.Output">
            <summary>
            Gets the output of this computation
            </summary>
            <exception cref="T:System.InvalidOperationException">This property may throw a DelayedOutputCreationException in case that the output has been tried to access, although the output creation was delayed</exception>
        </member>
        <member name="T:NMF.Transformations.TransformationComputation`1">
            <summary>
            Represents a computation that represents that a set of input arguments are transformed into an output of type TOut
            </summary>
            <typeparam name="TOut">The type of the output</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationComputation`1.#ctor(NMF.Transformations.TransformationRuleBase{`0},NMF.Transformations.Core.IComputationContext,System.Object[])">
            <summary>
            Creates a new transformation computation for the given input arguments
            </summary>
            <param name="transformationRule">The transformation rule for this computation</param>
            <param name="context">The context of this computation</param>
            <param name="inputs">The input parameters for this computation</param>
        </member>
        <member name="P:NMF.Transformations.TransformationComputation`1.OutputCore">
            <summary>
            Gets or sets the output in a derived class
            </summary>
        </member>
        <member name="P:NMF.Transformations.TransformationComputation`1.Output">
            <summary>
            Gets the output of this computation
            </summary>
            <exception cref="T:System.InvalidOperationException">This property may throw a DelayedOutputCreationException in case that the output has been tried to access, although the output creation was delayed</exception>
        </member>
        <member name="T:NMF.Transformations.TransformationEngine">
            <summary>
            This class provides methods to execute transformations
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``1(System.Object[],NMF.Transformations.Core.Transformation)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input">The input parameter</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``1(System.Collections.Generic.IEnumerable{System.Object[]},System.Type[],NMF.Transformations.Core.Transformation)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="types">The types of the elements within the collection refered to in the inputs parameter</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``1(System.Object[],NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input">The input parameter</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``1(System.Collections.Generic.IEnumerable{System.Object[]},System.Type[],NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="types">The types of the elements within the collection refered to in the inputs parameter</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``1(System.Object[],NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input">The input parameter</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``1(System.Collections.Generic.IEnumerable{System.Object[]},System.Type[],NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="types">The types of the elements within the collection refered to in the inputs parameter</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``3(``0,``1,NMF.Transformations.Core.Transformation)">
            <summary>
            Transforms the input arguments into an output using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input1">The first input parameter</param>
            <param name="input2">The second input parameter</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},NMF.Transformations.Core.Transformation)">
            <summary>
            Transforms the input arguments into an output using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``3(``0,``1,NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input arguments into an output using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input1">The first input parameter</param>
            <param name="input2">The second input parameter</param>
            <param name="context">The context that should be used (must not be null)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input arguments into an output using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="context">The context that should be used (must not be null)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``3(``0,``1,NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.TransformationRuleBase{``0,``1,``2})">
            <summary>
            Transforms the input arguments into an output using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input1">The first input parameter</param>
            <param name="input2">The second input parameter</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``3(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.TransformationRuleBase{``0,``1,``2})">
            <summary>
            Transforms the input arguments into an output using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The first input parameters</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Process``2(``0,``1,NMF.Transformations.Core.Transformation)">
            <summary>
            Processes the input arguments using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <param name="input1">The first input parameter</param>
            <param name="input2">The second input parameter</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.ProcessMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},NMF.Transformations.Core.Transformation)">
            <summary>
            Processes the input arguments using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Process``2(``0,``1,NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Processes the input arguments using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <param name="input1">The first input parameter</param>
            <param name="input2">The second input parameter</param>
            <param name="context">The context that should be used (must not be null).</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.ProcessMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Processes the input arguments using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="context">The context that should be used (must not be null).</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Process``2(``0,``1,NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.GeneralTransformationRule{``0,``1})">
            <summary>
            Processes the input arguments using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <param name="input1">The first input parameter</param>
            <param name="input2">The second input parameter</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null).</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.ProcessMany``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.GeneralTransformationRule{``0,``1})">
            <summary>
            Processes the input arguments using the provided transformation
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null).</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``2(``0,NMF.Transformations.Core.Transformation)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input">The input parameter</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``2(System.Collections.Generic.IEnumerable{``0},NMF.Transformations.Core.Transformation)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``2(``0,NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input">The input parameter</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``2(System.Collections.Generic.IEnumerable{``0},NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Transform``2(``0,NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.TransformationRuleBase{``0,``1})">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="input">The input parameter</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.TransformMany``2(System.Collections.Generic.IEnumerable{``0},NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.TransformationRuleBase{``0,``1})">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The desired output type</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null).</param>
            <returns>The output from the transformation</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Process``1(``0,NMF.Transformations.Core.Transformation)">
            <summary>
            Processes the input argument using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <param name="input">The input parameter</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.ProcessMany``1(System.Collections.Generic.IEnumerable{``0},NMF.Transformations.Core.Transformation)">
            <summary>
            Processes the input argument using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <param name="inputs">The input parameter</param>
            <param name="transformation">The transformation that shall be used for this operation (must not be null, but can be uninitialized)</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Process``1(``0,NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Processes the input argument using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <param name="input">The input parameter</param>
            <param name="context">The context that should be used (must not be null)</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.ProcessMany``1(System.Collections.Generic.IEnumerable{``0},NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Processes the input argument using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="context">The context that should be used (must not be null)</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.Process``1(``0,NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.GeneralTransformationRule{``0})">
            <summary>
            Processes the input argument using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <param name="input">The input parameter</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null)</param>
        </member>
        <member name="M:NMF.Transformations.TransformationEngine.ProcessMany``1(System.Collections.Generic.IEnumerable{``0},NMF.Transformations.Core.ITransformationEngineContext,NMF.Transformations.GeneralTransformationRule{``0})">
            <summary>
            Processes the input argument using the provided transformation
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <param name="inputs">The input parameters</param>
            <param name="startRule">The rule that should be started with. If this is null, an applicable rule is found.</param>
            <param name="context">The context that should be used (must not be null)</param>
        </member>
        <member name="T:NMF.Transformations.TransformationRule`2">
            <summary>
            Defines a simple transformation rule of a transformation that has one input argument and an output
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The type of the output</typeparam>
            <remarks>Simple means that the transformation rule does not require a custom computation class</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`2.#ctor">
            <summary>
            Creates a new transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`2.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new Computation instance for this transformation rule or the given input 
            </summary>
            <param name="input">The input arguments for this computation</param>
            <param name="context">The context for this computation</param>
            <returns>A computation object</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`2.CreateOutput(`0,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates the output of this transformation rule
            </summary>
            <param name="input">The input of the transformation rule</param>
            <param name="context">The context (and trace!) object</param>
            <returns>The output for this transformation under this input</returns>
            <remarks>At this point, not all of the computations have created their output and thus, the trace is not complete. Use the OutputDelayLevel-feature to have the trace contain all elements created in earlier levels</remarks>
        </member>
        <member name="P:NMF.Transformations.TransformationRule`2.NeedDependenciesForOutputCreation">
            <summary>
            Gets a value indicating whether the output for all dependencies must have been created before this rule creates the output
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`2.Transform(`0,`1,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation output
            </summary>
            <param name="input">The input of the transformation rule</param>
            <param name="output">The output of the transformation rule generated earlier</param>
            <param name="context">The context (and trace!) object</param>
            <remarks>At this point, all the transformation outputs are created (also the delayed ones), thus, the trace is fully reliable</remarks>
        </member>
        <member name="T:NMF.Transformations.TransformationRuleBase`2">
            <summary>
            Defines a transformation rule of a transformation that has one input argument and an output
            </summary>
            <typeparam name="TIn">The type of the input argument</typeparam>
            <typeparam name="TOut">The type of the output</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.MarkInstantiatingFor``2">
            <summary>
            Marks the current transformation rule instantiating for every rule with the specified signature
            </summary>
            <typeparam name="TBaseIn">The input argument type of the base transformation rule</typeparam>
            <typeparam name="TBaseOut">The output argument type of the base transformation rule</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.MarkInstantiatingFor``2(System.Predicate{`0})">
            <summary>
            Marks the current transformation rule instantiating for every rule with the specified signature
            </summary>
            <param name="filter">The filter that should be used to filter the inputs</param>
            <typeparam name="TBaseIn">The input argument type of the base transformation rule</typeparam>
            <typeparam name="TBaseOut">The output argument type of the base transformation rule</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.RequireByType``2(System.Action{`1,``1})">
            <summary>
            Requires all transformation rules that transform items with the specified signature
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.Require``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Action{`1,``1})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.Require``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Predicate{`0},System.Action{`1,``1})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="filter">A predicate that filters the data</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.RequireByType``2(System.Func{`0,``0},System.Action{`1,``1})">
            <summary>
            Requires all transformation rules that transform items with the specified signature
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.RequireByType``3(System.Func{`0,``0},System.Func{`0,``1},System.Action{`1,``2})">
            <summary>
            Requires all transformation rules that transform items with the specified signature
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector1 parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector2 parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.Require``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,``0},System.Action{`1,``1})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.Require``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,``0},System.Func{`0,``1},System.Action{`1,``2})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector1 parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector2 parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.RequireManyByType``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Action{`1,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.RequireManyByType``3(System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`1,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.RequireMany``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Action{`1,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.RequireMany``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`1,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallByType``2(System.Action{`1,``1})">
            <summary>
            Calls all transformation rules that transform items with the specified signature after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.Call``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Action{`1,``1})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallByType``2(System.Func{`0,``0},System.Action{`1,``1})">
            <summary>
            Calls all transformation rules that transform items with the specified signature after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallByType``3(System.Func{`0,``0},System.Func{`0,``1},System.Action{`1,``2})">
            <summary>
            Calls all transformation rules that transform items with the specified signature after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector1 parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector2 parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.Call``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,``0},System.Action{`1,``1})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.Call``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,``0},System.Func{`0,``1},System.Action{`1,``2})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector1 parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector2 parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the rule parameter is passed a null instance</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallManyByType``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Action{`1,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Calls all transformation rules that transform S to T with all of the specified objects after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformations</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallManyByType``3(System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`1,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Calls all transformation rules that transform S to T with all of the specified objects after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallMany``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Action{`1,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallMany``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`1,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation rule</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,``0})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the input for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,``0},System.Func{`0,`1,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the input for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,``0},System.Func{`0,`1,``1})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector1">A method that selects the first input for the dependent transformation</param>
            <param name="selector2">A method that selects the second input for the dependent transformation</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector1 parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector2 parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,``0},System.Func{`0,`1,``1},System.Func{`0,`1,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector1">A method that selects the first input for the dependent transformation</param>
            <param name="selector2">A method that selects the second input for the dependent transformation</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector1 parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector2 parameter</exception>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallOutputSensitive(NMF.Transformations.GeneralTransformationRule{`0,`1})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallOutputSensitive(NMF.Transformations.GeneralTransformationRule{`0,`1},System.Func{`0,`1,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallManyOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallManyOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}},System.Func{`0,`1,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallManyOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallManyOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Func{`0,`1,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``2(System.Func{``0,`0},System.Action{`1,``1})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,`0},System.Action{`1,``1})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``3(System.Func{``0,``1,`0},System.Action{`1,``2})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,`0},System.Action{`1,``2})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``2(System.Func{``0,`0},System.Action{`1,``1},System.Predicate{``0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,`0},System.Action{`1,``1},System.Predicate{``0})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``3(System.Func{``0,``1,`0},System.Action{`1,``2},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallFor``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,`0},System.Action{`1,``2},System.Func{``0,``1,System.Boolean})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``2(System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Action{``1,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Action{``1,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``2(System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Predicate{``0},System.Action{``1,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{`0}},System.Predicate{``0},System.Action{``1,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``3(System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Action{``2,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Action{``2,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``3(System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,System.Boolean},System.Action{``2,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.CallForEach``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Collections.Generic.IEnumerable{`0}},System.Func{``0,``1,System.Boolean},System.Action{``2,System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation with the specified signature is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the source transformation rule</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="P:NMF.Transformations.TransformationRuleBase`2.OutputType">
            <summary>
            Gets the output type of this transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.SelectArrays``2(System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},NMF.Transformations.Core.Computation)">
            <summary>
            This method is a helper function that converts the given selector of tuples to a selector of object[]
            </summary>
            <typeparam name="TRequiredInput1">The first type argument of the selector output tuple</typeparam>
            <typeparam name="TRequiredInput2">The second type argument pf the selector output tuple</typeparam>
            <param name="selector">The source selector that selects the output of dependant transformation rules as typed tuples</param>
            <param name="computation">The computation from which the arrays are selected</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown if the inputs parameter is passed a null instance</exception>
            <returns>A collection of inputs for other transformation rules</returns>
            <remarks>This method is used as helper function for DependMany. This version is output sensitive. Use it only with the needOutput-parameter of DependMany set to true!</remarks>  
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.SelectArrays``1(System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}},NMF.Transformations.Core.Computation)">
            <summary>
            This method is a helper function that converts the given selector to a selector of object[]
            </summary>
            <typeparam name="TRequiredInput">The type argument of the selector output</typeparam>
            <param name="selector">The source selector that selects the output of dependant transformation rules as typed tuples</param>
            <param name="computation">The computation from which the arrays are selected</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the selector parameter</exception>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the inputs parameter</exception>
            <returns>A collection of inputs for other transformation rules</returns>
            <remarks>This method is used as helper function for DependMany. This version is output sensitive. Use it only with the needOutput-parameter of DependMany set to true!</remarks>      
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.TraceOutput``1(System.Func{`0,`1,``0})">
            <summary>
            Creates a trace entry for every computation with the key specified by the given selector method
            </summary>
            <typeparam name="TKey">The type of the trace entry key</typeparam>
            <param name="traceSelector">A method that selects for an input the appropriate key that should be added to the trace</param>
            <returns>A transformation rule that can be used as group or for direct tracing purposes</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.TraceOutput``1(NMF.Transformations.TraceEntryGroup{``0,`1},System.Func{`0,`1,``0})">
            <summary>
            Creates a trace entry for every computation with the key specified by the given selector method
            </summary>
            <typeparam name="TKey">The type of the trace entry key</typeparam>
            <param name="traceSelector">A method that selects for an input the appropriate key that should be added to the trace</param>
            <param name="traceKey">The transformation rule that is used as group for direct tracing purposes</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.TraceAs``2(NMF.Transformations.TraceEntryGroup{``0,``1})">
            <summary>
            Creates a trace entry for every computation of the current transformation rule
            </summary>
            <typeparam name="TTraceInput">The input type for the newly created trace entries</typeparam>
            <typeparam name="TTraceOutput">The output type for the newly created trace entries</typeparam>
            <param name="traceKey">A transformation rule that should be used as a key for tracing purposes</param>
            <remarks>Using this overload requires that the type parameter TTraceOutput is a base class of TOut and the type parameter TTraceInput is a base class of TIn. Sadly, this cannot be checked by the C# compiler</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.TraceAs``2(NMF.Transformations.TraceEntryGroup{``0,``1},System.Func{`0,`1,``0})">
            <summary>
            Creates a trace entry for every computation of the current transformation rule
            </summary>
            <typeparam name="TTraceInput">The input type for the newly created trace entries</typeparam>
            <typeparam name="TTraceOutput">The output type for the newly created trace entries</typeparam>
            <param name="traceKey">A transformation rule that should be used as a key for tracing purposes</param>
            <param name="inputSelector">A method that selects the input for the trace entry. If null is specified, the input is taken by default. If this is not possible, an exception is thrown.</param>
            <remarks>Using this overload requires that the type parameter TTraceOutput is a base class of TOut. Sadly, this cannot be checked by the C# compiler</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.TraceAs``2(NMF.Transformations.TraceEntryGroup{``0,``1},System.Func{`0,`1,``1})">
            <summary>
            Creates a trace entry for every computation of the current transformation rule
            </summary>
            <typeparam name="TTraceInput">The input type for the newly created trace entries</typeparam>
            <typeparam name="TTraceOutput">The output type for the newly created trace entries</typeparam>
            <param name="traceKey">A transformation rule that should be used as a key for tracing purposes</param>
            <remarks>Using this overload requires that the type parameter TTraceInput is a base class of TIn. Sadly, this cannot be checked by the C# compiler</remarks>
            <param name="outputSelector">A method that selects the output for the trace entry. If null is specified, the output is taken by default. If this is not possible, an exception is thrown.</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`2.TraceAs``2(NMF.Transformations.TraceEntryGroup{``0,``1},System.Func{`0,`1,``0},System.Func{`0,`1,``1})">
            <summary>
            Creates a trace entry for every computation of the current transformation rule
            </summary>
            <typeparam name="TTraceInput">The input type for the newly created trace entries</typeparam>
            <typeparam name="TTraceOutput">The output type for the newly created trace entries</typeparam>
            <param name="traceKey">A transformation rule that should be used as a key for tracing purposes</param>
            <param name="inputSelector">A method that selects the input for the trace entry. If null is specified, the input is taken by default. If this is not possible, an exception is thrown.</param>
            <param name="outputSelector">A method that selects the output for the trace entry. If null is specified, the output is taken by default. If this is not possible, an exception is thrown.</param>
        </member>
        <member name="T:NMF.Transformations.TransformationRuleBase`3">
            <summary>
            Defines a transformation rule of a transformation that has two input arguments and an output
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The type of the output</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.MarkInstantiatingFor``3">
            <summary>
            Marks the current transformation rule instantiating for every rule from S to T
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type</typeparam>
            <typeparam name="TRequiredOutput">The output argument type</typeparam>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.MarkInstantiatingFor``3(System.Func{`0,`1,System.Boolean})">
            <summary>
            Marks the current transformation rule instantiating for every rule from S to T
            </summary>
            <param name="filter">The filter that should be used to filter the inputs</param>
            <typeparam name="TRequiredInput1">The first input argument type</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type</typeparam>
            <typeparam name="TRequiredOutput">The output argument type</typeparam>
        </member>
        <member name="P:NMF.Transformations.TransformationRuleBase`3.OutputType">
            <summary>
            Gets the output type of this transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.RequireByType``3(System.Action{`2,``2})">
            <summary>
            Requires all transformation rules that transform items from S to T
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.RequireByType``3(System.Func{`0,`1,``0},System.Func{`0,`1,``1},System.Action{`2,``2})">
            <summary>
            Requires all transformation rules that transform items from S to T
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.RequireByType``2(System.Func{`0,`1,``0},System.Action{`2,``1})">
            <summary>
            Requires all transformation rules that transform items from S to T
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.Require``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Action{`2,``2})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.Require``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,`1,``0},System.Func{`0,`1,``1},System.Action{`2,``2})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <param name="selector2">A method that selects the second input for the dependent transformations</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.Require``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,`1,``0},System.Action{`2,``1})">
            <summary>
            Requires the transformation rule with the given type
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.RequireManyByType``3(System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`2,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.RequireManyByType``2(System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}},System.Action{`2,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Requires all transformation rules that transform S to T with all of the specified objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.RequireMany``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`2,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.RequireMany``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}},System.Action{`2,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Requires the transformation rule with the given type with all of the specified inputs
            </summary>
            <typeparam name="TRequiredInput">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallByType``3(System.Action{`2,``2})">
            <summary>
            Calls all transformation rules that transform items from S to T after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallByType``3(System.Func{`0,`1,``0},System.Func{`0,`1,``1},System.Action{`2,``2})">
            <summary>
            Calls all transformation rules that transform items from S to T after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector1">A method that selects the first input for the dependent transformations</param>
            <param name="selector2">A method that selects the second input for the dependent transformation</param>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallByType``2(System.Func{`0,`1,``0},System.Action{`2,``1})">
            <summary>
            Calls all transformation rules that transform items from S to T after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the input for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformations</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.Call``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Action{`2,``2})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.Call``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,`1,``0},System.Func{`0,`1,``1},System.Action{`2,``2})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector1">A method that selects the frist input for the dependent transformation</param>
            <param name="selector2">A method that selects the second input for the dependent transformation</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.Call``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,`1,``0},System.Action{`2,``1})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the input for the dependent transformation</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallManyByType``3(System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`2,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Calls all transformation rules that transform S to T with all of the specified objects after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallManyByType``2(System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}},System.Action{`2,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Calls all transformation rules that transform S to T with all of the specified objects after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the dependent transformations</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallMany``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{`0,`1,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Action{`2,System.Collections.Generic.IEnumerable{``2}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallMany``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{`0,`1,System.Collections.Generic.IEnumerable{``0}},System.Action{`2,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Calls the transformation rule with the given type with all of the specified inputs after the current transformation rule
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <typeparam name="TRequiredOutput">The output type of the dependent transformation</typeparam>
            <param name="selector">A method that selects the inputs for the dependent transformations</param>
            <param name="persistor">A method that persists the result of the dependent transformation</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``3(System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Action{`2,``2})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the frist input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``2(System.Func{``0,`0},System.Func{``0,`1},System.Action{`2,``1})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the frist input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``3(System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Func{``0,``1,System.Boolean},System.Action{`2,``2})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the first input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``2(System.Func{``0,`0},System.Func{``0,`1},System.Func{``0,System.Boolean},System.Action{`2,``1})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the first input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Action{`2,``2})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the frist input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,`0},System.Func{``0,`1},System.Action{`2,``1})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the frist input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,`0},System.Func{``0,``1,`1},System.Func{``0,``1,System.Boolean},System.Action{`2,``2})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the first input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallFor``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,`0},System.Func{``0,`1},System.Func{``0,System.Boolean},System.Action{`2,``1})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector1">A method that selects the first input for this transformation rule</param>
            <param name="selector2">A method that selects the second input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``3(System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Action{``2,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``2(System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Action{``1,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``3(System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,System.Boolean},System.Action{``2,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``2(System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,System.Boolean},System.Action{``1,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Action{``2,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Action{``1,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the inputs for this transformation rule</param>
            <param name="persistor">A method that persists the outputs of this rule back to the source instance</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},System.Func{``0,``1,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,``1,System.Boolean},System.Action{``2,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput1">The first input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallForEach``2(NMF.Transformations.TransformationRuleBase{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}}},System.Func{``0,System.Boolean},System.Action{``1,System.Collections.Generic.IEnumerable{`2}})">
            <summary>
            Create a call dependency, i.e., let this transformation be called as soon as a transformation from S to T is made
            This version calls this transformation rule for a whol collection of input objects
            </summary>
            <typeparam name="TRequiredInput">The input argument type of the dependent transformation</typeparam>
            <typeparam name="TRequiredOutput">The output type of the source transformation rule</typeparam>
            <param name="selector">A method that selects the input for this transformation rule</param>
            <param name="persistor">A method that persists the output of this rule back to the source instance</param>
            <param name="filter">A method that filters the applicable instances of S</param>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,`2,``0},System.Func{`0,`1,`2,``1})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector1">A method that selects the first input for the dependent transformation rule</param>
            <param name="selector2">A method that selects the second input for the dependent transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,`2,``0},System.Func{`0,`1,`2,``1},System.Func{`0,`1,`2,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector1">A method that selects the first input for the dependent transformation rule</param>
            <param name="selector2">A method that selects the second input for the dependent transformation rule</param>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,`2,``0})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the input for the dependent transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,`2,``0},System.Func{`0,`1,`2,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the input for the dependent transformation rule</param>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallManyOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,`2,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallManyOutputSensitive``2(NMF.Transformations.GeneralTransformationRule{``0,``1},System.Func{`0,`1,`2,System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}}},System.Func{`0,`1,`2,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput1">The first input argument for the called transformation</typeparam>
            <typeparam name="TRequiredInput2">The second input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallManyOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,`2,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.CallManyOutputSensitive``1(NMF.Transformations.GeneralTransformationRule{``0},System.Func{`0,`1,`2,System.Collections.Generic.IEnumerable{``0}},System.Func{`0,`1,`2,System.Boolean})">
            <summary>
            Calls the transformation rule with the given type after the current transformation rule for all inputs, but no earlier than it created its output
            </summary>
            <typeparam name="TRequiredInput">The input argument for the called transformation</typeparam>
            <param name="rule">The dependent transformation rule</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever a null reference is passed to the rule parameter</exception>
            <param name="selector">A method that selects the inputs for the dependent transformation rule</param>
            <param name="filter">A method that filters the cases where the dependency should fire</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.TraceOutput``1(System.Func{`0,`1,`2,``0})">
            <summary>
            Creates a trace entry for every computation with the key specified by the given selector method
            </summary>
            <typeparam name="TKey">The type of the trace entry key</typeparam>
            <param name="traceSelector">A method that selects for an input the appropriate key that should be added to the trace</param>
            <returns>A transformation rule that can be used as group or for direct tracing purposes</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`3.TraceOutput``1(NMF.Transformations.TraceEntryGroup{``0,`2},System.Func{`0,`1,`2,``0})">
            <summary>
            Creates a trace entry for every computation with the key specified by the given selector method
            </summary>
            <typeparam name="TKey">The type of the trace entry key</typeparam>
            <param name="traceKey">The transformation rule that is used as group for direct tracing purposes</param>
            <param name="traceSelector">A method that selects for an input the appropriate key that should be added to the trace</param>
        </member>
        <member name="T:NMF.Transformations.TransformationRuleBase`1">
            <summary>
            This class is used to describe transformation rules that have more than two input arguments
            </summary>
            <typeparam name="T">The type of the transformation rule output</typeparam>
        </member>
        <member name="P:NMF.Transformations.TransformationRuleBase`1.OutputType">
            <summary>
            Gets the type signature of the output type of this transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`1.MarkInstantiatingFor(NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{System.Object[]})">
            <summary>
            Marks the current transformation rule instantiating for the specified rule
            </summary>
            <param name="filter">The filter that should filter the inputs where this transformation rule is marked instantiating</param>
            <param name="rule">The transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.TransformationRuleBase`1.GetRule(System.Type)">
            <summary>
            Gets the rule with the specified type (exact match)
            </summary>
            <param name="type">The type of the transformation rule</param>
            <returns>The transformation rule with this type or null, if there is none</returns>
            <remarks>This method assumes there is only one transformation rule per type</remarks>
        </member>
        <member name="T:NMF.Transformations.TransformationRule`3">
            <summary>
            Defines a simple transformation rule of a transformation that has one input argument and an output
            </summary>
            <typeparam name="TIn1">The type of the first input argument</typeparam>
            <typeparam name="TIn2">The type of the second input argument</typeparam>
            <typeparam name="TOut">The type of the output</typeparam>
            <remarks>Simple means that the transformation rule does not require a custom computation class</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`3.#ctor">
            <summary>
            Creates a new transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.TransformationRule`3.NeedDependenciesForOutputCreation">
            <summary>
            Gets a value indicating whether the output for all dependencies must have been created before this rule creates the output
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`3.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new Computation instance for this transformation rule or the given input 
            </summary>
            <param name="input">The input arguments for this computation</param>
            <param name="context">The context for this computation</param>
            <returns>A computation object</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`3.CreateOutput(`0,`1,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates the output of this transformation rule
            </summary>
            <param name="input1">The first input of the transformation rule</param>
            <param name="input2">The second input of the transformation rule</param>
            <param name="context">The context (and trace!) object</param>
            <returns>The output for this transformation under this input</returns>
            <remarks>At this point, not all of the computations have created their output and thus, the trace is not complete. Use the OutputDelayLevel-feature to have the trace contain all elements created in earlier levels</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`3.Transform(`0,`1,`2,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation output
            </summary>
            <param name="input1">The first input of the transformation rule</param>
            <param name="input2">The second input of the transformation rule</param>
            <param name="output">The output of the transformation rule generated earlier</param>
            <param name="context">The context (and trace!) object</param>
            <remarks>At this point, all the transformation outputs are created (also the delayed ones), thus, the trace is fully reliable</remarks>
        </member>
        <member name="T:NMF.Transformations.TransformationRule`1">
            <summary>
            Defines a simple transformation rule of a transformation that has one input argument and an output
            </summary>
            <typeparam name="T">The type of the output</typeparam>
            <remarks>Simple means that the transformation rule does not require a custom computation class</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`1.#ctor">
            <summary>
            Creates a new transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.TransformationRule`1.NeedDependenciesForOutputCreation">
            <summary>
            Gets a value indicating whether the output for all dependencies must have been created before this rule creates the output
            </summary>
        </member>
        <member name="T:NMF.Transformations.TransformationRule`1.SimpleComputation">
            <summary>
            Represents a aimple computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`1.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new Computation instance for this transformation rule or the given input 
            </summary>
            <param name="input">The input arguments for this computation</param>
            <param name="context">The context for this computation</param>
            <returns>A computation object</returns>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`1.Transform(System.Object[],`0,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates the output of this transformation rule
            </summary>
            <param name="input">The input of the transformation rule</param>
            <param name="context">The context (and trace!) object</param>
            <param name="output">The output of the transformation created previously</param>
            <returns>The output for this transformation under this input</returns>
            <remarks>At this point, not all of the computations have created their output and thus, the trace is not complete. Use the OutputDelayLevel-feature to have the trace contain all elements created in earlier levels</remarks>
        </member>
        <member name="M:NMF.Transformations.TransformationRule`1.CreateOutput(System.Object[],NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Initializes the transformation output
            </summary>
            <param name="input">The input of the transformation rule</param>
            <param name="context">The context (and trace!) object</param>
            <remarks>At this point, all the transformation outputs are created (also the delayed ones), thus, the trace is fully reliable</remarks>
        </member>
        <member name="T:NMF.Transformations.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrAbstractRuleCreateOutput">
            <summary>
              Looks up a localized string similar to There was no instantiating rule for an element of type {0}. Consider creating a transformation rule for this case and mark it instantiating for the {1}-rule.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrAbstractRuleT2CreateOutput">
            <summary>
              Looks up a localized string similar to There was no instantiating rule for elements of type {0} and {1}. Consider creating a transformation rule for this case and mark it instantiating for the {2}-rule.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrCall1ArgNoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To call a transformation rule without specifying a selector, the input type TRequiredInput must be an assignable of TIn and the output type TRequiredOutput must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrCall2ArgNoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To call a transformation rule without specifying a selector, the input type TRequiredInput1 must be an assignable of TIn1, the input type TRequiredInput2 must be an assignable type of TIn2 and the output type TRequiredOutput must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrCallTransNoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To call a transformation rule without specifying a selector, the input type of the transformation must be an assignable of TIn and the output must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrCallTransT2NoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To call a transformation rule without specifying a selector, the input types of the transformation must be assignables of TIn1 and TIn2 and the output must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrComputationOutputDelayed">
            <summary>
              Looks up a localized string similar to The output of this computation has been delayed. Please subscribe to the OutputInitialized event to get informed when the Output has been created. If you were using the trace functionality, consider using the Trace methods to get the computation objects and wait until the output has been created. Alternatively, change the structure of your transformation rules to ensure that this computation has been initialized when you are making your request..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrMarkInstantiating1ArgMustInherit">
            <summary>
              Looks up a localized string similar to To instantiate transformation rules, the input type TRequiredInput must be an assignable of TIn and the output type TRequiredOutput must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrMarkInstantiating2ArgMustInherit">
            <summary>
              Looks up a localized string similar to To instantiate transformation rules, the input type TRequiredInput1 must be an assignable of TIn1, the input type TRequiredInput2 must be an assignable of TIn2 and the output type TRequiredOutput must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrMarkInstantiatingMustInherit">
            <summary>
              Looks up a localized string similar to To instantiate a transformation rule, the input type of the transformation must be an assignable of TIn and the output must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrMarkInstantiatingMustInheritT2">
            <summary>
              Looks up a localized string similar to To instantiate a transformation rule, the input types of the transformation must be assignables of TIn1 and TIn2 and the output must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrReflectiveTransformationCustomRulesRuleTypeAlreadyInUse">
            <summary>
              Looks up a localized string similar to This transformation already contains a rule of type {0}. Reflective transformation must not contain more than one rule per rule type..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrReflectiveTransformationOverrideNoInheritance">
            <summary>
              Looks up a localized string similar to The rule {0} cannot override the rule {1} because {0} does not inherit from {1}..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrRequires1ArgNoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To require a transformation rule without specifying a selector, the input type TRequiredInput must be an assignable of TIn and the output type TRequiredOutput must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrRequires2ArgNoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To require a transformation rule without specifying a selector, the input type TRequiredInput1 must be an assignable of TIn1, the input type TRequiredInput2 must be an assignable of TIn2 and the output type TRequiredOutput must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrRequiresTransNoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To require a transformation rule without specifying a selector, the input type of the transformation must be an assignable of TIn and the output must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrRequiresTransT2NoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To require a transformation rule without specifying a selector, the input types of the transformation must be assignables of TIn1 and TIn2 and the output must be an assignable of TOut.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrTransformationEngineStartRuleNotRuleOfTransformation">
            <summary>
              Looks up a localized string similar to The specified transformation rule to act as start rule is not a rule of the specified transformation!.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Properties.Resources.ErrTransformationRuleWrongNumberOfArguments">
            <summary>
              Looks up a localized string similar to The transformation rule {0} has been called with a wrong number of arguments..
            </summary>
        </member>
        <member name="T:NMF.Transformations.Tests.MockComputation">
            <summary>
            Mocks a computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Tests.MockComputation.OnTransform">
            <summary>
            Gets or sets an action that should be called when the computation is asked to perform its Transform task
            </summary>
        </member>
        <member name="P:NMF.Transformations.Tests.MockComputation.OnCreateOutput">
            <summary>
            Gets or sets a function that should be called when the computation is asked to create its output
            </summary>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputation.#ctor(System.Object[],NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.ITransformationContext,System.Object)">
            <summary>
            Creates a new mocked computation
            </summary>
            <param name="input">The input for the mocked computation</param>
            <param name="rule">The transformation rule for the mocked computation</param>
            <param name="context">The transformation context</param>
            <param name="output">The output for the transformation</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputation.#ctor(System.Object[],NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.IComputationContext,System.Object)">
            <summary>
            Creates a new mocked computation
            </summary>
            <param name="input">The input for the mocked computation</param>
            <param name="rule">The transformation rule for the mocked computation</param>
            <param name="context">The transformation context</param>
            <param name="output">The output for the transformation</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputation.#ctor(System.Object[],NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new mocked computation
            </summary>
            <param name="input">The input for the mocked computation</param>
            <param name="rule">The transformation rule for the mocked computation</param>
            <param name="context">The transformation context</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputation.#ctor(System.Object[],NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new mocked computation
            </summary>
            <param name="input">The input for the mocked computation</param>
            <param name="rule">The transformation rule for the mocked computation</param>
            <param name="context">The transformation context</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputation.Transform">
            <summary>
            Performs the Transform operation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputation.CreateOutput(System.Collections.IEnumerable)">
            <summary>
            Creates the output for the given transformation
            </summary>
            <returns>The output</returns>
        </member>
        <member name="P:NMF.Transformations.Tests.MockComputation.Output">
            <summary>
            Gets or sets the output of the MockComputation
            </summary>
            <remarks>Unlike the version of the Computation base class, this version ignores the output delay and thus does not throw an exception when accessed when the computation is delayed</remarks>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputation.GetInput(System.Int32)">
            <summary>
            Gets the input at the i-th position
            </summary>
            <param name="index">The index of the desired input parameter</param>
            <returns>The input parameter with the i-th position</returns>
        </member>
        <member name="P:NMF.Transformations.Tests.MockComputation.OutputCore">
            <summary>
            Gets or sets the output internal
            </summary>
        </member>
        <member name="T:NMF.Transformations.Tests.MockComputationCollection">
            <summary>
            Represents a collection of computations used by the mocked context
            </summary>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputationCollection.#ctor(NMF.Transformations.Tests.MockContext)">
            <summary>
            Creates a new mock computation collection for the given mocked context
            </summary>
            <param name="context">The mock context in which to create the computation collection</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputationCollection.Add``1(NMF.Transformations.GeneralTransformationRule{``0},``0)">
            <summary>
            Creates a computation mock for the given transformation rule with the given input and the given context and adds the computation to the context
            </summary>
            <param name="transformationRule">The transformation rule for this computation mock</param>
            <param name="input">The input for this computation</param>
            <returns>The computation mock</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputationCollection.Add``2(NMF.Transformations.TransformationRuleBase{``0,``1},``0,``1)">
            <summary>
            Creates a computation mock for the given transformation rule with the given input and the given context and adds the computation to the context
            </summary>
            <param name="transformationRule">The transformation rule for this computation mock</param>
            <param name="input">The input for this computation</param>
            <param name="output">The output for the mock computation</param>
            <returns>The computation mock</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputationCollection.Add``2(NMF.Transformations.GeneralTransformationRule{``0,``1},``0,``1)">
            <summary>
            Creates a computation mock for the given transformation rule with the given input and the given context and adds the computation to the context
            </summary>
            <param name="transformationRule">The transformation rule for this computation mock</param>
            <param name="input1">The first input for this computation</param>
            <param name="input2">The second input for this computation</param>
            <returns>The computation mock</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputationCollection.Add``3(NMF.Transformations.TransformationRuleBase{``0,``1,``2},``0,``1,``2)">
            <summary>
            Creates a computation mock for the given transformation rule with the given input and the given context and adds the computation to the context
            </summary>
            <param name="transformationRule">The transformation rule for this computation mock</param>
            <param name="input1">The first input for this computation</param>
            <param name="input2">The second input for this computation</param>
            <param name="output">The output of the mock computation</param>
            <returns>The computation mock</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputationCollection.Add(NMF.Transformations.Core.GeneralTransformationRule,System.Object[])">
            <summary>
            Creates a computation mock for the given transformation rule with the given input and the given context and adds the computation to the context
            </summary>
            <param name="transformationRule">The transformation rule for this computation mock</param>
            <param name="input">The input for this computation</param>
            <returns>The computation mock</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockComputationCollection.Add``1(NMF.Transformations.TransformationRuleBase{``0},System.Object[],``0)">
            <summary>
            Creates a computation mock for the given transformation rule with the given input and the given context and adds the computation to the context
            </summary>
            <param name="transformationRule">The transformation rule for this computation mock</param>
            <param name="input">The input for this computation</param>
            <param name="output">The output of the mock computation</param>
            <returns>The computation mock</returns>
        </member>
        <member name="T:NMF.Transformations.Tests.MockTransformation">
            <summary>
            Mocks a transformation
            </summary>
            <remarks>The mocking effect comes from the fact that the mock transformation does not initialize all of its transformation rules. Instead, the transformation rules must be initialized manually by calling the RegisterDependencies method</remarks>
        </member>
        <member name="M:NMF.Transformations.Tests.MockTransformation.#ctor(System.Collections.Generic.IEnumerable{NMF.Transformations.Core.GeneralTransformationRule})">
            <summary>
            Creates a new mock transformation with the given transformation rules
            </summary>
            <param name="rules">A collection of transformation rules</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockTransformation.#ctor(NMF.Transformations.Core.GeneralTransformationRule[])">
            <summary>
            Creates a new mock transformation with the given transformation rules
            </summary>
            <param name="rules">A collection of transformation rules</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockTransformation.CreateRules">
            <summary>
            This method is overridden for internal purpose and is not supposed to be called directly
            </summary>
            <returns>The collection of transformation rules</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockTransformation.RegisterRules">
            <summary>
            This method is overridden for internal purpose and is not supposed to be called directly
            </summary>
        </member>
        <member name="T:NMF.Transformations.Tests.MockContext">
            <summary>
            Represents a mock for the transformation context that does not execute any dependencies
            </summary>
        </member>
        <member name="M:NMF.Transformations.Tests.MockContext.#ctor(NMF.Transformations.Core.Transformation)">
            <summary>
            Creates a new MockContext for the given transformation
            </summary>
            <param name="transformation">The transformation for which the mock context should be created</param>
            <exception cref="T:System.ArgumentNullException">An ArgumentNullException is thrown whenever the transformation parameter is passed a null reference.</exception>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Bag">
            <summary>
            Gets a Bag, where dynamic data can be added
            </summary>
            <remarks>The value of this property is an ExpandoObject, so that the bag can be easily extended with new properties</remarks>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Data">
            <summary>
            Gets a data dictionary, where data set during the transformation can be added
            </summary>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Transformation">
            <summary>
            Gets the parent transformation, that the context is based upon
            </summary>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Computations">
            <summary>
            Gets all computations (for custom trace purposes)
            </summary>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.NMF#Transformations#Core#ITransformationContext#Computations">
            <summary>
            Gets all computations (for custom trace purposes)
            </summary>
        </member>
        <member name="M:NMF.Transformations.Tests.MockContext.ExecuteDependencies(NMF.Transformations.Core.Computation,System.Boolean)">
            <summary>
            Executes the dependencies of the given computation
            </summary>
            <param name="computation">The computation whose dependencies should be executed</param>
            <param name="before">A value indicating whether the dependencies before the computation or the dependencies after the computation should be executed</param>
        </member>
        <member name="M:NMF.Transformations.Tests.MockContext.CallTransformation(NMF.Transformations.Core.GeneralTransformationRule,System.Object[])">
            <summary>
            Calls the given transformation with the specified input
            </summary>
            <param name="input">The input for the transformation rule</param>
            <param name="transformationRule">The rule that should be applied</param>
            <returns>The computation that handles this request</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockContext.CallTransformation(NMF.Transformations.Core.GeneralTransformationRule,System.Object[],System.Collections.IEnumerable)">
            <summary>
            Calls the given transformation with the specified input
            </summary>
            <param name="input">The input for the transformation rule</param>
            <param name="transformationRule">The rule that should be applied</param>
            <param name="context">The context elements</param>
            <returns>The computation that handles this request</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockContext.CallTransformation``1(NMF.Transformations.GeneralTransformationRule{``0},``0)">
            <summary>
            Calls the given transformation with the specified input
            </summary>
            <typeparam name="TIn">The type of the first input parameter</typeparam>
            <param name="input">The input for the transformation rule</param>
            <param name="transformationRule">The rule that should be applied</param>
            <returns>The computation that handles this request</returns>
        </member>
        <member name="M:NMF.Transformations.Tests.MockContext.CallTransformation``2(NMF.Transformations.GeneralTransformationRule{``0,``1},``0,``1)">
            <summary>
            Calls the given transformation with the specified input
            </summary>
            <typeparam name="TIn1">The type of the first input parameter</typeparam>
            <typeparam name="TIn2">The type of the second input parameter</typeparam>
            <param name="input1">The first input for the transformation rule</param>
            <param name="input2">The second input for the transformation rule</param>
            <param name="transformationRule">The rule that should be applied</param>
            <returns>The computation that handles this request</returns>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Trace">
            <summary>
            Gets the object responsible for trace operations for this transformation context
            </summary>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Input">
            <summary>
            Gets the input of the transformation context
            </summary>
            <remarks>If the transformation has multiple inputs, this returns the first input</remarks>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Inputs">
            <summary>
            Gets a collection of inputs
            </summary>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Output">
            <summary>
            Gets the output of the transformation context
            </summary>
            <remarks>If the transformation has multiple outputs, this property returns the first output</remarks>
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.Outputs">
            <summary>
            Gets a collection of outputs
            </summary>
        </member>
        <member name="E:NMF.Transformations.Tests.MockContext.ComputationCompleted">
            <inheritdoc />
        </member>
        <member name="M:NMF.Transformations.Tests.MockContext.RegisterComputationDependency(NMF.Transformations.Core.Computation,NMF.Transformations.Core.Computation,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="P:NMF.Transformations.Tests.MockContext.IsThreadSafe">
            <inheritdoc />
        </member>
    </members>
</doc>
