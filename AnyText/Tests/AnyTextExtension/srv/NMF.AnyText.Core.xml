<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NMF.AnyText.Core</name>
    </assembly>
    <members>
        <member name="T:NMF.AnyText.ActionInfo">
            <summary>
            Denotes the abstract base class for a code action info
            </summary>
        </member>
        <member name="M:NMF.AnyText.ActionInfo.Invoke(NMF.AnyText.ExecuteCommandArguments)">
            <summary>
            Invokes the action with the given arguments
            </summary>
            <param name="arguments">A structure containing the rule application, context and position</param>
        </member>
        <member name="T:NMF.AnyText.ActionInfoApplication">
            <summary>
            Denotes an Action applied at a rule application
            </summary>
            <param name="Action">the action that is applied</param>
            <param name="RuleApplication">the rule application that is applied</param>
        </member>
        <member name="M:NMF.AnyText.ActionInfoApplication.#ctor(NMF.AnyText.CodeActionInfo,NMF.AnyText.Rules.RuleApplication)">
            <summary>
            Denotes an Action applied at a rule application
            </summary>
            <param name="Action">the action that is applied</param>
            <param name="RuleApplication">the rule application that is applied</param>
        </member>
        <member name="P:NMF.AnyText.ActionInfoApplication.Action">
            <summary>the action that is applied</summary>
        </member>
        <member name="P:NMF.AnyText.ActionInfoApplication.RuleApplication">
            <summary>the rule application that is applied</summary>
        </member>
        <member name="T:NMF.AnyText.CodeActionInfo">
            <summary>
            Represents the information about a code action.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.Title">
            <summary>
            The title is typically displayed in the UI to describe the action.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.Kind">
            <summary>
            Kind of the code action.
            Possible values:
            - "quickfix"
            - "refactor"
            - "refactor.extract"
            - "refactor.inline"
            - "refactor.rewrite"
            - "source"
            - "source.organizeImports"
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.Diagnostics">
            <summary>
            This array holds diagnostics for which this action is relevant. If no diagnostics are set, the action may apply generally.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.IsPreferred">
            <summary>
            A value of <c>true</c> indicates that the code action is preferred; otherwise, <c>false</c> or <c>null</c> if there's no preference.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.CommandTitle">
            <summary>
            This is the text that describes the command to execute, which can be shown to the user.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.CommandIdentifier">
            <summary>
            The command is the identifier or name of the action to execute when the user selects it.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.Arguments">
            <summary>
            These are the parameters passed to the command when it is executed.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo.DiagnosticIdentifier">
            <summary>
            Identifies the Diagnostic that this Action fixes
            </summary>
        </member>
        <member name="M:NMF.AnyText.CodeActionInfo.CreateWorkspaceEdit(NMF.AnyText.ExecuteCommandArguments)">
            <summary>
            Creates the workspace edit calculated for the given arguments
            </summary>
            <param name="arguments">the arguments for which to calculate the workspace edit</param>
            <returns>The workspace edit</returns>
        </member>
        <member name="T:NMF.AnyText.CodeActionInfo`1">
            <summary>
            Represents the information about a code action.
            </summary>
            <typeparam name="T">The semantic type of elements for which this action is executed</typeparam>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo`1.Action">
            <summary>
            The actual action that is executed
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeActionInfo`1.WorkspaceEdit">
            <summary>
            Defines the how the WorkspaceEdit Object of this CodeAction is created
            </summary>
        </member>
        <member name="M:NMF.AnyText.CodeActionInfo`1.Invoke(NMF.AnyText.ExecuteCommandArguments)">
            <inheritdoc/>
        </member>
        <member name="M:NMF.AnyText.CodeActionInfo`1.CreateWorkspaceEdit(NMF.AnyText.ExecuteCommandArguments)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.CodeLensApplication">
            <summary>
            Denotes a code lens applied to a rule application
            </summary>
            <param name="CodeLens">The code lens</param>
            <param name="RuleApplication">The rule application instance</param>
        </member>
        <member name="M:NMF.AnyText.CodeLensApplication.#ctor(NMF.AnyText.CodeLensInfo,NMF.AnyText.Rules.RuleApplication)">
            <summary>
            Denotes a code lens applied to a rule application
            </summary>
            <param name="CodeLens">The code lens</param>
            <param name="RuleApplication">The rule application instance</param>
        </member>
        <member name="P:NMF.AnyText.CodeLensApplication.CodeLens">
            <summary>The code lens</summary>
        </member>
        <member name="P:NMF.AnyText.CodeLensApplication.RuleApplication">
            <summary>The rule application instance</summary>
        </member>
        <member name="T:NMF.AnyText.CodeLensInfo">
            <summary>
            Represents a CodeLens item used for a Language Server Protocol (LSP) server.
            CodeLens provides information or actions associated with specific locations in a text document.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeLensInfo.Title">
            <summary>
            Gets or sets the title of the CodeLens item, typically a label displayed in the editor.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeLensInfo.CommandIdentifier">
            <summary>
            Gets or sets the identifier for the command to be executed when the CodeLens is activated.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeLensInfo.Arguments">
            <summary>
            Gets or sets the dictionary of arguments to be passed along with the command when invoked.
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeLensInfo.Data">
            <summary>
            Gets or sets additional data associated with this CodeLens, which can be used for custom functionality.
            </summary>
        </member>
        <member name="M:NMF.AnyText.CodeLensInfo.GetTitleForRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Calculates the title of the code lens for the given rule application
            </summary>
            <param name="ruleApplication">The rule application for which the title is being determined.</param>
            <param name="context">The parsing context used for evaluation.</param>
            <returns>The title of the code lens</returns>
        </member>
        <member name="T:NMF.AnyText.CodeLensInfo`1">
            <summary>
            Represents a CodeLens item used for a Language Server Protocol (LSP) server.
            CodeLens provides information or actions associated with specific locations in a text document.
            </summary>
            <typeparam name="T">The semantic type of elements for which this action is executed</typeparam>
        </member>
        <member name="P:NMF.AnyText.CodeLensInfo`1.Action">
            <summary>
            The actual execution of this CodeLens
            </summary>
        </member>
        <member name="P:NMF.AnyText.CodeLensInfo`1.TitleFunc">
            <summary>
            A function to calculate the title from the semantic element and ParseContext
            </summary>
        </member>
        <member name="M:NMF.AnyText.CodeLensInfo`1.Invoke(NMF.AnyText.ExecuteCommandArguments)">
            <inheritdoc/>
        </member>
        <member name="M:NMF.AnyText.CodeLensInfo`1.GetTitleForRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.DiagnosticItem">
            <summary>
            Denotes an error while parsing
            </summary>
        </member>
        <member name="M:NMF.AnyText.DiagnosticItem.#ctor(System.String,NMF.AnyText.Rules.RuleApplication,System.String,NMF.AnyText.DiagnosticSeverity)">
            <summary>
            Creates a new instance
            </summary>
            <param name="source">the source of the error</param>
            <param name="ruleApplication">the rule application that points to the error</param>
            <param name="message">the error message</param>
        </member>
        <member name="P:NMF.AnyText.DiagnosticItem.Severity">
            <summary>
            Gets the severity of the diagnostic item
            </summary>
        </member>
        <member name="P:NMF.AnyText.DiagnosticItem.Source">
            <summary>
            Gets the source of the error
            </summary>
        </member>
        <member name="P:NMF.AnyText.DiagnosticItem.RuleApplication">
            <summary>
            Gets the rule application that indicates the error position
            </summary>
        </member>
        <member name="P:NMF.AnyText.DiagnosticItem.Position">
            <summary>
            Gets the position of the error
            </summary>
        </member>
        <member name="P:NMF.AnyText.DiagnosticItem.Length">
            <summary>
            Gets the length of the error
            </summary>
        </member>
        <member name="P:NMF.AnyText.DiagnosticItem.Message">
            <summary>
            Gets the error message
            </summary>
        </member>
        <member name="M:NMF.AnyText.DiagnosticItem.CheckIfStillExist(NMF.AnyText.ParseContext)">
            <summary>
            Checks if the error still exists
            </summary>
            <param name="context">the parsing context</param>
            <returns>true, if the error still exists, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.DiagnosticItem.ToString">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.DiagnosticItem.Dispose">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.DiagnosticSeverity">
            <summary>
            Denotes the severity of a diagnostic item
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSeverity.None">
            <summary>
            Denotes no actual severity
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSeverity.Error">
            <summary>
            Indicates an error
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSeverity.Warning">
            <summary>
            Indicates a warning
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSeverity.Information">
            <summary>
            Indicates an informational message
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSeverity.Hint">
            <summary>
            Indicates a hint
            </summary>
        </member>
        <member name="T:NMF.AnyText.DiagnosticSources">
            <summary>
            Denotes default error sources
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSources.Parser">
            <summary>
            Denotes that an error occured while parsing
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSources.ResolveReferences">
            <summary>
            Denotes that an error occured while resolving references
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSources.Grammar">
            <summary>
            Denotes that there is an error in the grammar
            </summary>
        </member>
        <member name="F:NMF.AnyText.DiagnosticSources.Validation">
            <summary>
            Denotes that there is an error appeared during validation
            </summary>
        </member>
        <member name="T:NMF.AnyText.DocumentHighlight">
            <summary>
            A document highlight is a range inside a text document which deserves
            special attention. Usually a document highlight is visualized by changing
            the background color of its range.
            Analogous to the LspTypes DocumentHighlight interface.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentHighlight.Range">
            <summary>
            The range this highlight applies to.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentHighlight.Kind">
            <summary>
            The highlight kind, default is DocumentHighlightKind.Text.
            </summary>
        </member>
        <member name="T:NMF.AnyText.DocumentHighlightKind">
            <summary>
            Document highlight kinds used for document highlights requests
            </summary>
        </member>
        <member name="F:NMF.AnyText.DocumentHighlightKind.Text">
            <summary>
            A textual occurrence.
            </summary>
        </member>
        <member name="F:NMF.AnyText.DocumentHighlightKind.Read">
            <summary>
            Read-access of a symbol, like reading a variable.
            </summary>
        </member>
        <member name="F:NMF.AnyText.DocumentHighlightKind.Write">
            <summary>
            Write-access of a symbol, like writing to a variable.
            </summary>
        </member>
        <member name="T:NMF.AnyText.DocumentSymbol">
            <summary>
            Represents programming constructs like variables, classes, interfaces etc.
            that appear in a document.Document symbols can be hierarchical and they
            have two ranges: one that encloses its definition and one that points to its
            most interesting range, e.g.the range of an identifier.
            Analogous to the LspTypes DocumentSymbol interface.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentSymbol.Name">
            <summary>
            The name of this symbol. Will be displayed in the user interface and
            therefore must not be an empty string or a string only consisting of
            white spaces.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentSymbol.Detail">
            <summary>
            More detail for this symbol, e.g the signature of a function.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentSymbol.Kind">
            <summary>
            The kind of this symbol.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentSymbol.Tags">
            <summary>
            Tags for this document symbol.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentSymbol.Range">
            <summary>
            The range enclosing this symbol not including leading/trailing whitespace
            but everything else like comments.This information is typically used to
            determine if the clients cursor is inside the symbol to reveal in the
            symbol in the UI.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentSymbol.SelectionRange">
            <summary>
            The range that should be selected and revealed when this symbol is being
            picked, e.g.the name of a function. Must be contained by the <see cref="P:NMF.AnyText.DocumentSymbol.Range"></see>.
            </summary>
        </member>
        <member name="P:NMF.AnyText.DocumentSymbol.Children">
            <summary>
            Children of this symbol, e.g. properties of a class.
            </summary>
        </member>
        <member name="T:NMF.AnyText.ExecuteCommandArguments">
            <summary>
            Represents the arguments for executing a command on a document.
            </summary>
        </member>
        <member name="P:NMF.AnyText.ExecuteCommandArguments.RuleApplication">
            <summary>
            RuleApplication of the Action
            </summary>
        </member>
        <member name="P:NMF.AnyText.ExecuteCommandArguments.Context">
            <summary>
            ParseContext of the Document
            </summary>
        </member>
        <member name="P:NMF.AnyText.ExecuteCommandArguments.DocumentUri">
            <summary>
            URI of the document.
            </summary>
        </member>
        <member name="P:NMF.AnyText.ExecuteCommandArguments.Start">
            <summary>
            Starting position of the Range.
            </summary>
        </member>
        <member name="P:NMF.AnyText.ExecuteCommandArguments.End">
            <summary>
            Ending position of the Range.
            </summary>
        </member>
        <member name="P:NMF.AnyText.ExecuteCommandArguments.OtherOptions">
            <summary>
            Additional options for the command execution.
            </summary>
        </member>
        <member name="M:NMF.AnyText.ExecuteCommandArguments.SendLog(System.String,NMF.AnyText.MessageType)">
            <summary>
            Sends a log to the client
            </summary>
            <param name="message">the message to log</param>
            <param name="messageType">the type of the message</param>
        </member>
        <member name="M:NMF.AnyText.ExecuteCommandArguments.ShowRequest(System.String,NMF.AnyText.MessageType,System.String[])">
            <summary>
            Shows a message to the client
            </summary>
            <param name="message">the message to show</param>
            <param name="messageType">the type of the message</param>
            <param name="buttons">the available buttons for the user</param>
        </member>
        <member name="M:NMF.AnyText.ExecuteCommandArguments.ShowNotification(System.String,NMF.AnyText.MessageType)">
            <summary>
            Shows a notification to the client
            </summary>
            <param name="message">the notification</param>
            <param name="messageType">the type of the message</param>
        </member>
        <member name="M:NMF.AnyText.ExecuteCommandArguments.ShowDocument(System.String,System.Nullable{NMF.AnyText.ParseRange},System.Boolean,System.Boolean)">
            <summary>
            Requests a client to open a document
            </summary>
            <param name="uri">The URI of the document to show.</param>
            <param name="selection">The optional selection range in the document.</param>
            <param name="external">If true, requests to open the document externally.</param>
            <param name="takeFocus">If true, requests the client to take focus.</param>
        </member>
        <member name="M:NMF.AnyText.ExecuteCommandArguments.ShowReferences(NMF.AnyText.ParsePosition)">
            <summary>
            Requests a client to show references of a symbol
            </summary>
            <param name="position">The position of the symbol in the document</param>
        </member>
        <member name="T:NMF.AnyText.FoldingRange">
            <summary>
            Denotes a part in a parsed document that can be folded away (hidden).
            Analogous to the LspTypes FoldingRange interface.
            </summary>
        </member>
        <member name="P:NMF.AnyText.FoldingRange.StartLine">
            <summary>
            The zero-based start line of the range to fold. The folded area starts
            after the line's last character. To be valid, the end must be zero or
            larger and smaller than the number of lines in the document.
            </summary>
        </member>
        <member name="P:NMF.AnyText.FoldingRange.StartCharacter">
            <summary>
            The zero-based character offset from where the folded range starts.
            If not defined, defaults to the length of the start line. 
            </summary>
        </member>
        <member name="P:NMF.AnyText.FoldingRange.EndLine">
            <summary>
            The zero-based end line of the range to fold. The folded area ends with
            the line's last character. To be valid, the end must be zero or larger
            and smaller than the number of lines in the document.
            </summary>
        </member>
        <member name="P:NMF.AnyText.FoldingRange.EndCharacter">
            <summary>
            The zero-based character offset before the folded range ends.
            If not defined, defaults to the length of the end line.
            </summary>
        </member>
        <member name="P:NMF.AnyText.FoldingRange.Kind">
            <summary>
            Describes the kind of the folding range.
            Supports values "comment", "imports" and "region".
            </summary>
        </member>
        <member name="T:NMF.AnyText.Grammars.AdHocGrammar">
            <summary>
            Wraps a rule (with pre-initialized dependencies) into a grammar
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.AdHocGrammar.#ctor(NMF.AnyText.Rules.Rule,System.Collections.Generic.IEnumerable{NMF.AnyText.Rules.Rule})">
            <summary>
            Creates a new instance
            </summary>
            <param name="root">the rule that should be wrapped</param>
            <param name="furtherRules">other rules</param>
        </member>
        <member name="P:NMF.AnyText.Grammars.AdHocGrammar.LanguageId">
            <inheritdoc/>
        </member>
        <member name="M:NMF.AnyText.Grammars.AdHocGrammar.CreateCustomRules">
            <inheritdoc/>
        </member>
        <member name="M:NMF.AnyText.Grammars.AdHocGrammar.CreateTypedRules">
            <inheritdoc/>
        </member>
        <member name="M:NMF.AnyText.Grammars.AdHocGrammar.GetRootRule(NMF.AnyText.Grammars.GrammarContext)">
            <inheritdoc/>
        </member>
        <member name="P:NMF.AnyText.Grammars.AdHocGrammar.Rules">
            <summary>
            Gets a collection of all rules
            </summary>
        </member>
        <member name="T:NMF.AnyText.Grammars.Grammar">
            <summary>
            Denotes an abstract grammar
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.GetRule``1">
            <summary>
            Gets the rule with the given rule type
            </summary>
            <typeparam name="T">the type of the rule</typeparam>
            <returns>the rule with the provided type, if it exists and registered for this type</returns>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.Rules">
            <summary>
            Gets a collection of all rules in this grammar
            </summary>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.Keywords">
            <summary>
            Gets the keywords used in the grammar
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.Initialize">
            <summary>
            Initializes the current grammar
            </summary>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.CommentRules">
            <summary>
            Gets an array of comment rules used by this grammar
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.CreateKeywordRule(System.String)">
            <summary>
            Creates the keyword rule for the given keyword
            </summary>
            <param name="keyword">the keyword</param>
            <returns>A literal rule that represents matching the provided keyword</returns>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.CompletionTriggerCharacters">
            <summary>
            Retrieves an array of characters that can trigger completion suggestions.
            </summary>
            <returns>
            An array of strings representing the trigger characters. 
            By default, this method returns array only containing periods (.)
            </returns>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.CreateTypedRules">
            <summary>
            Create the typed rules as a dictionary
            </summary>
            <returns>a dictionary of rules by type</returns>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.CreateCustomRules">
            <summary>
            Create custom rules that are not resolvable by type
            </summary>
            <returns>a collection of custom rules</returns>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.CreateParser">
            <summary>
            Create a parser for this grammar
            </summary>
            <returns>a parser configured for this grammar</returns>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.LanguageId">
            <summary>
            Gets the language id for this grammar
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.CreateParseContext">
            <summary>
            Creates a parsing context for this grammar
            </summary>
            <returns>a parsing context for the current grammar</returns>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.Root">
            <summary>
            Gets the root rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.TokenTypes">
            <summary>
            Gets an array of token types used by this grammar
            </summary>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.TokenModifiers">
            <summary>
            Gets an array of token modifiers used by this grammar
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.GetRootRule(NMF.AnyText.Grammars.GrammarContext)">
            <summary>
            Gets the root rule
            </summary>
            <param name="context">a context to resolve the root rule</param>
            <returns>the root rule for this grammar</returns>
        </member>
        <member name="P:NMF.AnyText.Grammars.Grammar.ExecutableActions">
            <summary>
            Dictionary of executable actions.
            The key is the action identifier, and the value is the action executor.
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.Grammar.GetSymbolKindForType(System.Type)">
            <summary>
            Retrieves the <see cref="T:NMF.AnyText.SymbolKind"/> for a given type or one of its supertypes.
            </summary>
            <param name="type">The type for which the corresponding <see cref="T:NMF.AnyText.SymbolKind"/> is being searched.</param>
            <returns>
            The matching <see cref="T:NMF.AnyText.SymbolKind"/> if the type or one of its supertypes is found in <c>_symbolKinds</c>.  
            If no matching entry is found, <see cref="F:NMF.AnyText.SymbolKind.String"/> is returned.
            </returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="type"/> is null.</exception>
        </member>
        <member name="T:NMF.AnyText.Grammars.GrammarContext">
            <summary>
            Denotes the context in which a rule is initialized
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.GrammarContext.#ctor(System.Collections.Generic.IDictionary{System.Type,NMF.AnyText.Rules.Rule},NMF.AnyText.Grammars.Grammar)">
            <summary>
            Creates a new instance
            </summary>
            <param name="rules">a dictionary of rules that should be used in this context</param>
            <param name="grammar">the context grammar, used to resolve keywords</param>
        </member>
        <member name="P:NMF.AnyText.Grammars.GrammarContext.Keywords">
            <summary>
            Gets the keywords used in the grammar
            </summary>
        </member>
        <member name="M:NMF.AnyText.Grammars.GrammarContext.ResolveRule``1">
            <summary>
            Resolves the grammar rule of the given type
            </summary>
            <typeparam name="T">the rule type</typeparam>
            <returns>the rule instance with the given rule type</returns>
        </member>
        <member name="M:NMF.AnyText.Grammars.GrammarContext.ResolveFormattedRule``1(NMF.AnyText.PrettyPrinting.FormattingInstruction[])">
            <summary>
            Resolves the grammar rule of the given type and adds formatting instructions
            </summary>
            <typeparam name="T">the rule type</typeparam>
            <param name="formattingInstructions">formatting instructions</param>
            <returns>the rule instance with the given rule type</returns>
        </member>
        <member name="M:NMF.AnyText.Grammars.GrammarContext.ResolveKeyword(System.String)">
            <summary>
            Resolves the rule for the given keyword
            </summary>
            <param name="keyword">the keyword</param>
            <returns>a literal rule that represents matching the provided keyword</returns>
        </member>
        <member name="M:NMF.AnyText.Grammars.GrammarContext.ResolveKeyword(System.String,NMF.AnyText.PrettyPrinting.FormattingInstruction[])">
            <summary>
            Resolves the rule for the given keyword
            </summary>
            <param name="keyword">the keyword</param>
            <param name="formattingInstructions">formatting instructions for this keyword</param>
            <returns>a literal rule that represents matching the provided keyword</returns>
        </member>
        <member name="T:NMF.AnyText.Matcher">
            <summary>
            Denotes a class that matches text using an incremental packrat parser
            </summary>
        </member>
        <member name="M:NMF.AnyText.Matcher.#ctor(NMF.AnyText.Rules.CommentRule[])">
            <summary>
            Creates a new instance
            </summary>
            <param name="comments">the comment rules</param>
        </member>
        <member name="M:NMF.AnyText.Matcher.Reset">
            <summary>
            Resets the memoization table
            </summary>
        </member>
        <member name="M:NMF.AnyText.Matcher.NextTokenPosition(NMF.AnyText.ParsePosition)">
            <summary>
            Gets the position of the next token, starting from the given position
            </summary>
            <param name="position">the position where to look for the next token</param>
            <returns>the position of the next token position</returns>
        </member>
        <member name="M:NMF.AnyText.Matcher.IsWhiteSpaceTo(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
            Determines whether the input between the given position and the target position only consists of white space
            </summary>
            <param name="position">the start position</param>
            <param name="targetPosition">the target position</param>
            <returns>true, if there is only white spaces between the given position and the target position, otherwise false</returns>
        </member>
        <member name="P:NMF.AnyText.Matcher.TrailingComments">
            <summary>
            Gets a collection of comments found after the last rule application
            </summary>
        </member>
        <member name="M:NMF.AnyText.Matcher.GetErrorsExactlyAt(NMF.AnyText.ParsePosition)">
            <summary>
            Gets a collection of failed rule applications exactly at the given position 
            </summary>
            <param name="position">the position</param>
            <returns>a collection of rule applications</returns>
        </member>
        <member name="M:NMF.AnyText.Matcher.Match(NMF.AnyText.ParseContext)">
            <summary>
            Matches the provided rule with the given parse context
            </summary>
            <param name="context">The context in which the text is parsed, including the current input</param>
            <returns>A rule application for the entire text</returns>
        </member>
        <member name="M:NMF.AnyText.Matcher.Apply(NMF.AnyText.TextEdit)">
            <summary>
            Removes any memoization based on the given text edit and updates the memo table
            </summary>
            <param name="edit">The change in the input text</param>
        </member>
        <member name="T:NMF.AnyText.MessageType">
            <summary>
            Denotes the type of a message
            </summary>
        </member>
        <member name="F:NMF.AnyText.MessageType.Error">
            <summary>
            Indicates an error
            </summary>
        </member>
        <member name="F:NMF.AnyText.MessageType.Warning">
            <summary>
            Indicates a warning
            </summary>
        </member>
        <member name="F:NMF.AnyText.MessageType.Info">
            <summary>
            Indicates an informational message
            </summary>
        </member>
        <member name="F:NMF.AnyText.MessageType.Log">
            <summary>
            Indicates a log message
            </summary>
        </member>
        <member name="T:NMF.AnyText.Model.AddAssignReferenceRule`2">
            <summary>
            Denotes a rule that adds the value of an inner rule to a collection of the semantic element
            </summary>
            <typeparam name="TSemanticElement">The type of the context element</typeparam>
            <typeparam name="TReference">The type of the property value</typeparam>
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignReferenceRule`2.OnActivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignReferenceRule`2.OnDeactivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignReferenceRule`2.OnValueChange(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignReferenceRule`2.CreateRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignReferenceRule`2.GetCollection(`0,NMF.AnyText.ParseContext)">
            <summary>
            Obtains the child collection
            </summary>
            <param name="semanticElement">the semantic element</param>
            <param name="context">the parse context in which the collection is obtained</param>
            <returns>a collection of values</returns>
        </member>
        <member name="P:NMF.AnyText.Model.AddAssignReferenceRule`2.Feature">
            <summary>
            Gets the name of the feature that is assigned
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignReferenceRule`2.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignReferenceRule`2.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.AddAssignRule`2">
            <summary>
            Denotes a rule that adds the value of an inner rule to a collection of the semantic element
            </summary>
            <typeparam name="TSemanticElement">The type of the context element</typeparam>
            <typeparam name="TProperty">The type of the property value</typeparam>
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.OnActivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.OnDeactivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.OnValueChange(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.CreateRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Model.AddAssignRule`2.Feature">
            <summary>
            Gets the name of the feature that is assigned
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.CreateSynthesisRequirements">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AddAssignRule`2.GetCollection(`0,NMF.AnyText.ParseContext)">
            <summary>
            Obtains the child collection
            </summary>
            <param name="semanticElement">the semantic element</param>
            <param name="context">the parse context in which the collection is obtained</param>
            <returns>a collection of values</returns>
        </member>
        <member name="T:NMF.AnyText.Model.AssignReferenceRule`2">
            <summary>
            Denotes a rule that assigns the resolved value of a child rule to a certain property
            </summary>
            <typeparam name="TSemanticElement">The type of the context element</typeparam>
            <typeparam name="TReference">The type of the property value</typeparam>
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.OnActivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.OnDeactivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.OnValueChange(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.SetValue(`0,`1,NMF.AnyText.ParseContext)">
            <summary>
            Gets called when the value changes
            </summary>
            <param name="semanticElement">the context element</param>
            <param name="propertyValue">the property value</param>
            <param name="context">the parsing context</param>
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.GetValue(`0,NMF.AnyText.ParseContext)">
            <summary>
            Gets the value of the given property
            </summary>
            <param name="semanticElement">the context element</param>
            <param name="context">the parsing context</param>
            <returns>the property value</returns>
        </member>
        <member name="P:NMF.AnyText.Model.AssignReferenceRule`2.Feature">
            <summary>
            Gets the name of the feature that is assigned
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignReferenceRule`2.CreateSynthesisRequirements">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.AssignRule`2">
            <summary>
            Denotes a rule that assigns the value of a child rule to a certain property
            </summary>
            <typeparam name="TSemanticElement">The type of the context element</typeparam>
            <typeparam name="TProperty">The type of the property value</typeparam>
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.OnActivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.OnDeactivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.OnValueChange(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.SetValue(`0,`1,NMF.AnyText.ParseContext)">
            <summary>
            Gets called when the value changes
            </summary>
            <param name="semanticElement">the context element</param>
            <param name="propertyValue">the property value</param>
            <param name="context">the parsing context</param>
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.GetValue(`0,NMF.AnyText.ParseContext)">
            <summary>
            Gets the value of the given property
            </summary>
            <param name="semanticElement">the context element</param>
            <param name="context">the parsing context</param>
            <returns>the property value</returns>
        </member>
        <member name="P:NMF.AnyText.Model.AssignRule`2.Feature">
            <summary>
            Gets the name of the feature that is assigned
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.CanSynthesize(`0,`1)">
            <summary>
            Determines whether the current rule can synthesize rule applications for the given semantic element
            </summary>
            <param name="semanticElement">the semantic element</param>
            <param name="propertyValue">the assigned property value</param>
            <returns>true, if a rule application can be synthesized, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.AssignRule`2.CreateSynthesisRequirements">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.ConvertRule`1">
            <summary>
            Denotes a rule that applies custom conversions
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NMF.AnyText.Model.ConvertRule`1.CreateRuleApplication(System.String,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ConvertRule`1.Convert(System.String,NMF.AnyText.ParseContext)">
            <summary>
            Converts the provided text to an element of type TElement
            </summary>
            <param name="text">the input text</param>
            <param name="context">the parse context</param>
            <returns>the parsed element</returns>
        </member>
        <member name="M:NMF.AnyText.Model.ConvertRule`1.ConvertToString(`0,NMF.AnyText.ParseContext)">
            <summary>
            Converts the provided element to text
            </summary>
            <param name="semanticElement">the semantic element</param>
            <param name="context">the parse context</param>
            <returns>the input text</returns>
        </member>
        <member name="M:NMF.AnyText.Model.ConvertRule`1.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ConvertRule`1.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.ElementRule`1">
            <summary>
            Denotes a rule that is used to create elements
            </summary>
            <typeparam name="TElement">the type of elements to create</typeparam>
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.OnActivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.OnDeactivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.CreateElement(System.Collections.Generic.IEnumerable{NMF.AnyText.Rules.RuleApplication})">
            <summary>
            Creates an element
            </summary>
            <param name="inner">the inner rule applications</param>
            <returns>an instance of the model element type</returns>
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.CreateRuleApplication(NMF.AnyText.ParsePosition,System.Collections.Generic.List{NMF.AnyText.Rules.RuleApplication},NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.GetReferenceString(`0,NMF.AnyText.ParseContext)">
            <summary>
            Gets the printed reference for the given object
            </summary>
            <param name="reference">the referenced object</param>
            <param name="context">the parse context</param>
            <returns>a string representation</returns>
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.Validate(`0,NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Validates the given semantic element
            </summary>
            <param name="element">the element that should be validated</param>
            <param name="context">the context in which validation is performed</param>
            <param name="ruleApplication">the rule application in the context of which validation is performed</param>
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Model.ElementRule`1.CodeLenses">
            <summary>
            Gets the list of code lenses for this rule.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Model.ElementRule`1.CodeActions">
            <summary>
            Gets the list of code actions for this rule.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Model.ElementRule`1.IsDefinition">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ElementRule`1.ResolveSymbolKind(System.Collections.Generic.Dictionary{System.Type,NMF.AnyText.SymbolKind})">
            <inheritdoc/>
        </member>
        <member name="T:NMF.AnyText.Model.EnumRule`1">
            <summary>
            Denotes an enumeration rule
            </summary>
            <typeparam name="TEnum">the type of the enumeration</typeparam>
        </member>
        <member name="P:NMF.AnyText.Model.EnumRule`1.Values">
            <summary>
            Gets the enum values assigned to the alternatives
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.EnumRule`1.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.EnumRule`1.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.EnumRule`1.CreateSynthesisRequirements">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.EnumRule`1.CreateRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParsePositionDelta)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.EscapedConvertRule`1">
            <summary>
            Denotes a class for a rule that applies escaping to a conversion
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.EscapedConvertRule`1.Escape(System.String)">
            <summary>
            Escapes the given string
            </summary>
            <param name="value">the unescaped string</param>
            <returns>the escaped string</returns>
        </member>
        <member name="M:NMF.AnyText.Model.EscapedConvertRule`1.Unescape(System.String)">
            <summary>
            Unescapes the given string
            </summary>
            <param name="value">the escaped string</param>
            <returns>the unescaped string</returns>
        </member>
        <member name="M:NMF.AnyText.Model.EscapedConvertRule`1.CreateRuleApplication(System.String,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.EscapedConvertRule`1.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.ExistsAssignRule`1">
            <summary>
            Denotes a rule that catches whether a given rule matched
            </summary>
            <typeparam name="TSemanticElement"></typeparam>
        </member>
        <member name="M:NMF.AnyText.Model.ExistsAssignRule`1.OnActivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ExistsAssignRule`1.OnDeactivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ExistsAssignRule`1.SetValue(`0,System.Boolean,NMF.AnyText.ParseContext)">
            <summary>
            Assigns the value to the given semantic element
            </summary>
            <param name="semanticElement">the semantic element</param>
            <param name="value">the value to assign</param>
            <param name="context">the parse context</param>
        </member>
        <member name="M:NMF.AnyText.Model.ExistsAssignRule`1.GetValue(`0,NMF.AnyText.ParseContext)">
            <summary>
            Gets the value of the given property
            </summary>
            <param name="semanticElement">the context element</param>
            <param name="context">the parsing context</param>
            <returns>the property value</returns>
        </member>
        <member name="P:NMF.AnyText.Model.ExistsAssignRule`1.Feature">
            <summary>
            Gets the name of the feature that is assigned
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.ExistsAssignRule`1.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ExistsAssignRule`1.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.ParanthesesRule">
            <summary>
            Denotes a special sequence rule whose value is the value of the second child
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.ParanthesesRule.CreateRuleApplication(NMF.AnyText.ParsePosition,System.Collections.Generic.List{NMF.AnyText.Rules.RuleApplication},NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ParanthesesRule.HasFoldingKind(System.String@)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Model.ResolveRule`2">
            <summary>
            Denotes the base class for a rule that resolves elements
            </summary>
        </member>
        <member name="M:NMF.AnyText.Model.ResolveRule`2.TryResolveReference(`0,System.String,NMF.AnyText.ParseContext,`1@)">
            <summary>
            Resolves the given input
            </summary>
            <param name="contextElement">the element in the context of which the string is resolved</param>
            <param name="input">the textual reference</param>
            <param name="resolved">the resolved reference or the default</param>
            <param name="context">the context in which the element is resolved</param>
            <returns>true, if the reference could be resolved, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.Model.ResolveRule`2.GetCandidates(System.Object,System.String,NMF.AnyText.ParseContext)">
            <summary>
            Gets the candidates to resolve the given input straing
            </summary>
            <param name="contextElement">the context element in which the element should be resolved</param>
            <param name="input">the input string</param>
            <param name="context">the parse context in which candidates are resolved</param>
            <returns>A collection of potential references</returns>
            <remarks>In case the parse tree was not successful, the context element may be of a different type than <typeparamref name="TSemanticElement"/>.</remarks>
        </member>
        <member name="M:NMF.AnyText.Model.ResolveRule`2.GetReferenceString(`1,System.Object,NMF.AnyText.ParseContext)">
            <summary>
            Gets the printed reference for the given object
            </summary>
            <param name="reference">the referenced object</param>
            <param name="context">the parse context</param>
            <param name="contextElement">the semantic context element</param>
            <returns>a string representation</returns>
        </member>
        <member name="M:NMF.AnyText.Model.ResolveRule`2.SuggestCompletions(NMF.AnyText.ParseContext,NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParsePosition)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Model.ResolveRule`2.CreateRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Model.ResolveRule`2.IsReference">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Model.ResolveRule`2.ResolveDelayLevel">
            <summary>
            Gets the delay level
            </summary>
            <remarks>Reference are resolved in layers, one after the other. </remarks>
        </member>
        <member name="P:NMF.AnyText.Model.ResolveRule`2.TryResolveOnActivate">
            <summary>
            Determines, whether the rule should attempt to resolve references directly when a rule application gets activated
            </summary>
        </member>
        <member name="T:NMF.AnyText.ParseContext">
            <summary>
            The context in which a text is parsed
            </summary>
        </member>
        <member name="M:NMF.AnyText.ParseContext.#ctor(NMF.AnyText.Grammars.Grammar,NMF.AnyText.Matcher,System.StringComparison)">
            <summary>
            Creates a new instance
            </summary>
            <param name="grammar">the grammar for this context</param>
            <param name="matcher">the matcher for the context</param>
            <param name="stringComparison">the string comparison mode</param>
        </member>
        <member name="P:NMF.AnyText.ParseContext.Grammar">
            <summary>
            Gets the grammar for this context
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.RootRule">
            <summary>
            Gets the root rule of this parse context
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.Imports">
            <summary>
            Gets a collection of imports
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.Root">
            <summary>
            Gets the semantic root of the parsed text
            </summary>
        </member>
        <member name="M:NMF.AnyText.ParseContext.RefreshRoot">
            <summary>
            Refreshes the current root value
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.RootRuleApplication">
            <summary>
            Gets or sets the current root rule application
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.LastSuccessfulRootRuleApplication">
            <summary>
            Gets the last successful root rule application
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.Input">
            <summary>
            Gets or sets the input text in lines
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.Matcher">
            <summary>
            Gets the matcher used in this parse context
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.IsLastUpdateSuccessful">
            <summary>
            Indicates whether the last update sent to the parser was successful
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseContext.StringComparison">
            <summary>
            Gets the string comparison mode
            </summary>
        </member>
        <member name="M:NMF.AnyText.ParseContext.TryResolveReference``1(System.Object,System.String,``0@)">
            <summary>
            Resolves the given input
            </summary>
            <param name="contextElement">the element in the context of which the string is resolved</param>
            <param name="input">the textual reference</param>
            <param name="resolved">the resolved reference or the default</param>
            <returns>true, if the reference could be resolved, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.ParseContext.GetPotentialReferences``1(System.Object,System.String)">
            <summary>
            Retrieves all potential references for a given context element.
            </summary>
            <typeparam name="T">The type of references to retrieve.</typeparam>
            <param name="contextElement">The context element.</param>
            <param name="input">The input from the user</param>
            <returns>A collection of references.</returns>
        </member>
        <member name="M:NMF.AnyText.ParseContext.EnqueueResolveAction(NMF.AnyText.ParseResolveAction)">
            <summary>
            Enqueues the given resolve action
            </summary>
            <param name="action">the resolve action</param>
        </member>
        <member name="M:NMF.AnyText.ParseContext.RunResolveActions">
            <summary>
            Runs all resolve actions
            </summary>
        </member>
        <member name="M:NMF.AnyText.ParseContext.AddDefinition(System.Object,NMF.AnyText.Rules.RuleApplication)">
            <summary>
            Add a rule application to the list of definitions in the document
            </summary>
            <param name="key">The semantic element of the rule application</param>
            <param name="value">The rule application</param>
        </member>
        <member name="M:NMF.AnyText.ParseContext.TryGetDefinition(System.Object,NMF.AnyText.Rules.RuleApplication@)">
            <summary>
            Get the rule application for a definition
            </summary>
            <param name="key">The semantic element of the rule application</param>
            <param name="definition">The rule application for the definition</param>
            <returns>True, if a definition is present for the given key</returns>
        </member>
        <member name="M:NMF.AnyText.ParseContext.RemoveDefinition(System.Object)">
            <summary>
            Remove a rule application from the list of definitions
            </summary>
            <param name="key">The semantic element of the rule application</param>
        </member>
        <member name="M:NMF.AnyText.ParseContext.AddReference(System.Object,NMF.AnyText.Rules.RuleApplication)">
            <summary>
            Add a rule application to the list of references in the document
            </summary>
            <param name="key">The semantic element of the rule application</param>
            <param name="value">The rule application</param>
        </member>
        <member name="M:NMF.AnyText.ParseContext.RemoveReference(System.Object,NMF.AnyText.Rules.RuleApplication)">
            <summary>
            Remove a reference of an object from the corresponding list of references
            </summary>
            <param name="key">The semantic element of the referenced rule application</param>
            <param name="value">The the referencing rule application to be removed</param>
        </member>
        <member name="M:NMF.AnyText.ParseContext.TryGetReferences(System.Object,System.Collections.Generic.ICollection{NMF.AnyText.Rules.RuleApplication}@)">
            <summary>
            Get the rule applications for references
            </summary>
            <param name="key">The semantic element of the referenced rule application</param>
            <param name="references">A list of rule applications that reference the rule application</param>
            <returns>True, if references are present for the given key</returns>
        </member>
        <member name="M:NMF.AnyText.ParseContext.RestoreContextElement(NMF.AnyText.Rules.RuleApplication)">
            <summary>
            Calculates the context element for the given rule application
            </summary>
            <param name="ruleApplication">the rule application</param>
            <returns>A restored semantic context element or null, if it cannot be restored</returns>
        </member>
        <member name="M:NMF.AnyText.ParseContext.AddDiagnosticItem(NMF.AnyText.DiagnosticItem)">
            <summary>
            Adds the given diagnostic item
            </summary>
            <param name="diagnosticItem">the diagnostic item to add</param>
        </member>
        <member name="M:NMF.AnyText.ParseContext.RemoveDiagnosticItem(NMF.AnyText.DiagnosticItem)">
            <summary>
            Removes the given diagnostic item
            </summary>
            <param name="diagnosticItem">the diagnostic item</param>
            <returns>true, if the diagnostic item was present, otherwise false</returns>
        </member>
        <member name="P:NMF.AnyText.ParseContext.Errors">
            <summary>
            Gets the errors that occured while parsing
            </summary>
        </member>
        <member name="T:NMF.AnyText.ParsePosition">
            <summary>
            Denotes a position of a parser
            </summary>
            <param name="Line">The line of the position</param>
            <param name="Col">The column of the position</param>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Denotes a position of a parser
            </summary>
            <param name="Line">The line of the position</param>
            <param name="Col">The column of the position</param>
        </member>
        <member name="P:NMF.AnyText.ParsePosition.Line">
            <summary>The line of the position</summary>
        </member>
        <member name="P:NMF.AnyText.ParsePosition.Col">
            <summary>The column of the position</summary>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.Proceed(System.Int32)">
            <summary>
            Proceeds the position by the given number of characters
            </summary>
            <param name="chars">the numbers of characters to proceed</param>
            <returns>The updated parser position</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.CompareTo(NMF.AnyText.ParsePosition)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.ParsePosition.op_LessThan(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
            Decides which of the two positions is smaller
            </summary>
            <param name="pos1">the first position</param>
            <param name="pos2">the second position</param>
            <returns>true, if the first position is smaller, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.op_GreaterThan(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
            Decides which of the two positions is greater
            </summary>
            <param name="pos1">the first position</param>
            <param name="pos2">the second position</param>
            <returns>true, if the first position is greater, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.op_LessThanOrEqual(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
            Decides which of the two positions is smaller or equal
            </summary>
            <param name="pos1">the first position</param>
            <param name="pos2">the second position</param>
            <returns>true, if the first position is smaller or equal, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.op_GreaterThanOrEqual(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
            Decides which of the two positions is greater or equal
            </summary>
            <param name="pos1">the first position</param>
            <param name="pos2">the second position</param>
            <returns>true, if the first position is greater or equal, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.op_Subtraction(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
            Subtracts two parse positions
            </summary>
            <param name="to">the forward position</param>
            <param name="from">the backward position</param>
            <returns>The delta between the given positions</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePosition.op_Addition(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Adds the given delta to the current position
            </summary>
            <param name="pos">the origin position</param>
            <param name="delta">the position delta</param>
            <returns>the updated position</returns>
        </member>
        <member name="T:NMF.AnyText.ParsePositionDelta">
            <summary>
            Denotes a delta between parser positions
            </summary>
            <param name="Line">the line delta</param>
            <param name="Col">the column delta</param>
        </member>
        <member name="M:NMF.AnyText.ParsePositionDelta.#ctor(System.Int32,System.Int32)">
            <summary>
            Denotes a delta between parser positions
            </summary>
            <param name="Line">the line delta</param>
            <param name="Col">the column delta</param>
        </member>
        <member name="P:NMF.AnyText.ParsePositionDelta.Line">
            <summary>the line delta</summary>
        </member>
        <member name="P:NMF.AnyText.ParsePositionDelta.Col">
            <summary>the column delta</summary>
        </member>
        <member name="M:NMF.AnyText.ParsePositionDelta.Larger(NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Calculates the larger of two diffs
            </summary>
            <param name="delta1">the first delta</param>
            <param name="delta2">the second delta</param>
            <returns>the larger delta of the two deltas</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePositionDelta.Smaller(NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Calculates the smaller of two diffs
            </summary>
            <param name="delta1">the first delta</param>
            <param name="delta2">the second delta</param>
            <returns>the smaller delta of the two deltas</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePositionDelta.op_GreaterThan(NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Determines whether the first delta is larger than the second
            </summary>
            <param name="delta1">the first delta</param>
            <param name="delta2">the second delta</param>
            <returns>true, if the first delta is larger than the second</returns>
        </member>
        <member name="M:NMF.AnyText.ParsePositionDelta.op_LessThan(NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Determines whether the first delta is smaller than the second
            </summary>
            <param name="delta1">the first delta</param>
            <param name="delta2">the second delta</param>
            <returns>true, if the first delta is smaller than the second</returns>
        </member>
        <member name="T:NMF.AnyText.Parser">
            <summary>
            Denotes an incremental parser system
            </summary>
        </member>
        <member name="M:NMF.AnyText.Parser.GetCodeActionInfo(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition,System.Predicate{NMF.AnyText.Rules.RuleApplication})">
            <summary>
            Retrieves code action information within a specified range of parse positions.
            </summary>
            <param name="start">The starting position of the range.</param>
            <param name="end">The ending position of the range.</param>
            <param name="predicate">An optional predicate to filter rule applications.</param>
            <returns>A collection of <see cref="T:NMF.AnyText.ActionInfo"/> objects representing available code actions.</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.SuggestCompletions(NMF.AnyText.ParsePosition)">
            <summary>
            Calculates completion suggestions for the given position
            </summary>
            <param name="position">the position where completions should be calculated</param>
            <returns>A collection of code completions</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.#ctor(NMF.AnyText.Rules.Rule,System.StringComparison)">
            <summary>
            Creates a new parser system
            </summary>
            <param name="root">the root rule</param>
            <param name="stringComparison">the string comparison mode</param>
        </member>
        <member name="M:NMF.AnyText.Parser.#ctor(NMF.AnyText.ParseContext)">
            <summary>
            Creates a new parser system
            </summary>
            <param name="context">the parse context to use</param>
        </member>
        <member name="M:NMF.AnyText.Parser.#ctor(NMF.AnyText.Grammars.Grammar)">
            <summary>
            Creates a new parser system
            </summary>
            <param name="grammar">the underlying grammar</param>
        </member>
        <member name="P:NMF.AnyText.Parser.Context">
            <summary>
            Gets the parse context for this parser
            </summary>
        </member>
        <member name="M:NMF.AnyText.Parser.Initialize(System.String[])">
            <summary>
            Initializes the parser system
            </summary>
            <param name="input">the initial input</param>
            <returns>the value parsed for the given input</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.Update(NMF.AnyText.TextEdit)">
            <summary>
            Updates the parse result with the given edit
            </summary>
            <param name="edit">An edit operations</param>
            <returns>the updated value parsed for the given input</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.Update(System.Collections.Generic.IEnumerable{NMF.AnyText.TextEdit})">
            <summary>
            Updates the parse result with the given edits
            </summary>
            <param name="edits">A collection of edit operations</param>
            <returns>the updated value parsed for the given input</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetDocumentHighlights(NMF.AnyText.ParsePosition)">
            <summary>
            Parses the locations and kinds of document highlights for a literal at a given position
            </summary>
            <param name="position">The position of the literal in the document</param>
            <returns>An IEnumerable of <see cref="T:NMF.AnyText.DocumentHighlight"/> objects, each containing a range between parse positions and the kind of the highlight.</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetDocumentSymbolsFromRoot">
            <summary>
            Parses the document symbols starting from the root rule application
            </summary>
            <returns>An IEnumerable of <see cref="T:NMF.AnyText.DocumentSymbol"/> objects, each containing details on a document symbol in the document.</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetReferences(NMF.AnyText.ParsePosition)">
            <summary>
            Gets the locations for references of a symbol
            </summary>
            <param name="position">The position of the symbol in the document</param>
            <returns>An IEnumerable of <see cref="T:NMF.AnyText.ParseRange"/> objects, each denoting a range between parse positions.</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetFoldingRangesFromRoot">
            <summary>
            Parses folding ranges starting from the root rule application
            </summary>
            <returns>An IEnumerable of <see cref="T:NMF.AnyText.FoldingRange"/> objects, each containing details on a folding range in the document.</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.Format(System.Nullable{NMF.AnyText.ParsePosition},System.Nullable{NMF.AnyText.ParsePosition},System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Formats the current text using the parser's context and generates text edits based on the specified range of lines.
            </summary>
        </member>
        <member name="M:NMF.AnyText.Parser.GetDefinition(NMF.AnyText.ParsePosition)">
            <summary>
            Gets the rule application for the definition of a symbol
            </summary>
            <param name="position">The position of the symbol in the document</param>
            <returns>The rule application of the symbol definition</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetRenameTextEdits(NMF.AnyText.ParsePosition,System.String)">
            <summary>
            Gets the text edits for a rename operation of a symbol
            </summary>
            <param name="position">The position of the symbol in the document</param>
            <param name="newName">The new name of the symbol</param>
            <returns>An IEnumerable of <see cref="T:NMF.AnyText.TextEdit"/> objects, each containing details on a text edit to be performed.</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetSelectionRanges(System.Collections.Generic.IEnumerable{NMF.AnyText.ParsePosition})">
            <summary>
            Parses the selection range for given positions
            </summary>
            <param name="positions">The positions in the document</param>
            <returns>An IEnumerable of <see cref="T:NMF.AnyText.SelectionRange"/> objects, each containing details on a selection range in the document.</returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetSemanticElementsFromRoot(System.Nullable{NMF.AnyText.ParsePosition},System.Nullable{NMF.AnyText.ParsePosition})">
            <summary>
                Retrieves semantic elements from the root application with delta encoding for Language Server Protocol (LSP).
            </summary>
            <param name="start">
                An optional <see cref="T:NMF.AnyText.ParsePosition"/> specifying the starting range of tokens to include.
                If null, all tokens from the beginning are considered.
            </param>
            <param name="end">
                An optional <see cref="T:NMF.AnyText.ParsePosition"/> specifying the ending range of tokens to include.
                If null, all tokens to the end are considered.
            </param>
            <returns>
                A list of semantic tokens represented as unsigned integers,
                including delta-encoded line and character positions, length, token type, and modifiers.
            </returns>
        </member>
        <member name="M:NMF.AnyText.Parser.IsTokenInRange(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
                Checks whether a token's range is within a specified range.
            </summary>
        </member>
        <member name="M:NMF.AnyText.Parser.GetTokenModifierIndexFromHierarchy(NMF.AnyText.Rules.RuleApplication)">
            <summary>
                Traverses the parent hierarchy of a <see cref="T:NMF.AnyText.Rules.RuleApplication" /> to find the first non-null TokenModifierIndex.
            </summary>
            <param name="application">The starting <see cref="T:NMF.AnyText.Rules.RuleApplication" /> from which to begin the traversal.</param>
            <returns>
                The first non-null TokenModifierIndex encountered in the hierarchy, or <c>null</c> if no non-null index is
                found.
            </returns>
        </member>
        <member name="M:NMF.AnyText.Parser.GetTokenTypeIndexFromHierarchy(NMF.AnyText.Rules.RuleApplication)">
            <summary>
                Traverses the parent hierarchy of a <see cref="T:NMF.AnyText.Rules.RuleApplication" /> to find the first non-null TokenTypeIndex.
            </summary>
            <param name="application">The starting <see cref="T:NMF.AnyText.Rules.RuleApplication" /> from which to begin the traversal.</param>
            <returns>The first non-null TokenTypeIndex encountered in the hierarchy, or <c>null</c> if no non-null index is found.</returns>
        </member>
        <member name="T:NMF.AnyText.ParseRange">
            <summary>
            Denotes a range between two parse positions
            </summary>
            <param name="Start">The start of the range</param>
            <param name="End">The end of the range</param>
        </member>
        <member name="M:NMF.AnyText.ParseRange.#ctor(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition)">
            <summary>
            Denotes a range between two parse positions
            </summary>
            <param name="Start">The start of the range</param>
            <param name="End">The end of the range</param>
        </member>
        <member name="P:NMF.AnyText.ParseRange.Start">
            <summary>The start of the range</summary>
        </member>
        <member name="P:NMF.AnyText.ParseRange.End">
            <summary>The end of the range</summary>
        </member>
        <member name="T:NMF.AnyText.ParseResolveAction">
            <summary>
            Denotes an action that occurs when the parser
            </summary>
        </member>
        <member name="M:NMF.AnyText.ParseResolveAction.#ctor(NMF.AnyText.Rules.RuleApplication,System.String)">
            <summary>
            Creates a new instance
            </summary>
            <param name="ruleApplication">the rule application for which the action is performed</param>
            <param name="resolveString">the resolve string</param>
        </member>
        <member name="P:NMF.AnyText.ParseResolveAction.RuleApplication">
            <summary>
            Gets the rule application for which the action is performed
            </summary>
        </member>
        <member name="P:NMF.AnyText.ParseResolveAction.ResolveString">
            <summary>
            Gets the resolve string
            </summary>
        </member>
        <member name="M:NMF.AnyText.ParseResolveAction.OnParsingComplete(NMF.AnyText.ParseContext)">
            <summary>
            Gets called when the parsing is complete
            </summary>
            <param name="parseContext">the parse context</param>
        </member>
        <member name="T:NMF.AnyText.PrettyPrinting.FormattedRule">
            <summary>
            Denotes a tuple of a rule and formatting instructions
            </summary>
            <param name="Rule">The actual rule</param>
            <param name="FormattingInstructions">Formatting instructions</param>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.FormattedRule.#ctor(NMF.AnyText.Rules.Rule,NMF.AnyText.PrettyPrinting.FormattingInstruction[])">
            <summary>
            Denotes a tuple of a rule and formatting instructions
            </summary>
            <param name="Rule">The actual rule</param>
            <param name="FormattingInstructions">Formatting instructions</param>
        </member>
        <member name="P:NMF.AnyText.PrettyPrinting.FormattedRule.Rule">
            <summary>The actual rule</summary>
        </member>
        <member name="P:NMF.AnyText.PrettyPrinting.FormattedRule.FormattingInstructions">
            <summary>Formatting instructions</summary>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.FormattedRule.op_Implicit(NMF.AnyText.Rules.Rule)~NMF.AnyText.PrettyPrinting.FormattedRule">
            <summary>
            Implicitly converts a rule into a formatted rule by not applying formatting
            </summary>
            <param name="rule"></param>
        </member>
        <member name="T:NMF.AnyText.PrettyPrinting.FormattingInstruction">
            <summary>
            Denotes a formatting instruction
            </summary>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.FormattingInstruction.Apply(NMF.AnyText.PrettyPrinting.PrettyPrintWriter)">
            <summary>
            Applies the formatting instruction to the provided pretty print writer
            </summary>
            <param name="writer">the writer to apply the instruction on</param>
        </member>
        <member name="F:NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent">
            <summary>
            Denotes a shared instance for an indenting instruction
            </summary>
        </member>
        <member name="F:NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent">
            <summary>
            Denotes a shared instance for an unindent instruction
            </summary>
        </member>
        <member name="F:NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline">
            <summary>
            Denotes a shared instance for a newline instruction
            </summary>
        </member>
        <member name="F:NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace">
            <summary>
            Denotes a shared instance for a space supression
            </summary>
        </member>
        <member name="T:NMF.AnyText.PrettyPrinting.PrettyPrintWriter">
            <summary>
            Denotes a helper class to pretty-print texts
            </summary>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.PrettyPrintWriter.SupressSpace">
            <summary>
            Supresses rendering a space character before the next token
            </summary>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.PrettyPrintWriter.#ctor(System.IO.TextWriter,System.String)">
            <summary>
            Creates a new instance
            </summary>
            <param name="inner">the inner text writer</param>
            <param name="indentString">the indentation string</param>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.PrettyPrintWriter.Indent">
            <summary>
            Increase the indentation level
            </summary>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.PrettyPrintWriter.Unindent">
            <summary>
            Decrease the indentation level
            </summary>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.PrettyPrintWriter.WriteToken(System.String,System.Boolean)">
            <summary>
            Writes the given token to the underlying writer
            </summary>
            <param name="token">the token that should be written</param>
            <param name="appendSpace">true, if a space should be appended when necessary</param>
        </member>
        <member name="M:NMF.AnyText.PrettyPrinting.PrettyPrintWriter.WriteNewLine">
            <summary>
            Writes a newline to the underlying writer
            </summary>
        </member>
        <member name="T:NMF.AnyText.PrettyPrinting.RuleFormatter">
            <summary>
            Helper class to format rules
            </summary>
        </member>
        <member name="T:NMF.AnyText.Rules.ChoiceRule">
            <summary>
            Denotes a choice of multiple alternative rules
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.#ctor(NMF.AnyText.PrettyPrinting.FormattedRule[])">
            <summary>
            Creates a new instance
            </summary>
            <param name="alternatives">the alternatives</param>
        </member>
        <member name="P:NMF.AnyText.Rules.ChoiceRule.Alternatives">
            <summary>
            Gets or sets the alternatives
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.CreateRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Creates a rule application for a success
            </summary>
            <param name="match">the matched candidate</param>
            <param name="examined">the amount of text examined</param>
            <returns>a new rule application</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ChoiceRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.CommentRule">
            <summary>
            Denotes a rule for a (single-line) comment
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.CommentRule.CommentStart">
            <summary>
            Gets or sets the beginning 
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.CommentRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.CommentRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.CommentRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.CommentRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.CommentRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.CommentRule.IsLiteral">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.CommentRule.IsComment">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.CommentRule.TokenType">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.EscapedRegexRule">
            <summary>
            Denotes a class for a rule that applies escaping
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.EscapedRegexRule.Escape(System.String)">
            <summary>
            Escapes the given string
            </summary>
            <param name="value">the unescaped string</param>
            <returns>the escaped string</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.EscapedRegexRule.Unescape(System.String)">
            <summary>
            Unescapes the given string
            </summary>
            <param name="value">the escaped string</param>
            <returns>the unescaped string</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.EscapedRegexRule.CreateRuleApplication(System.String,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.EscapedRegexRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.FailedRuleApplication">
            <summary>
            Denotes a rule application that failed
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.FailedRuleApplication.#ctor(NMF.AnyText.Rules.Rule,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta,System.String)">
            <summary>
            Creates a new failed rule application
            </summary>
            <param name="rule">the rule that failed</param>
            <param name="currentPosition">the current position of this rule application</param>
            <param name="examinedTo">the amount of text that was analyzed to draw the conclusion</param>
            <param name="message">the message to indicate why the rule application failed</param>
        </member>
        <member name="P:NMF.AnyText.Rules.FailedRuleApplication.Message">
            <summary>
            Gets the message to indicate why the rule application failed
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.FailedRuleApplication.ErrorPosition">
            <summary>
            Gets the position of the error
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.FailedRuleApplication.IsPositive">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.FailedRuleApplication.ApplyTo(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.FailedRuleApplication.GetValue(NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.FailedRuleApplication.IterateLiterals(System.Action{NMF.AnyText.Rules.LiteralRuleApplication})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.FailedRuleApplication.IterateLiterals``1(System.Action{NMF.AnyText.Rules.LiteralRuleApplication,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.FailedRuleApplication.Write(NMF.AnyText.PrettyPrinting.PrettyPrintWriter,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.InheritedFailRuleApplication.IsPositive">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.InheritedFailRuleApplication.ApplyTo(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.InheritedMultiFailRuleApplication.IsPositive">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.InheritedMultiFailRuleApplication.ApplyTo(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.LiteralRule">
            <summary>
            Denotes a rule that matches a constant text
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRule.#ctor(System.String)">
            <summary>
            Creates a new instance
            </summary>
            <param name="literal">the literal that should be matched</param>
        </member>
        <member name="P:NMF.AnyText.Rules.LiteralRule.IsLiteral">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.LiteralRule.Literal">
            <summary>
            Gets the literal that should be matched
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.LiteralRule.TokenType">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRule.SuggestCompletions(NMF.AnyText.ParseContext,NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParsePosition)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.LiteralRuleApplication">
            <summary>
            Denotes a rule application that matches a given literal string
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.#ctor(NMF.AnyText.Rules.Rule,System.String,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Creates a new instance
            </summary>
            <param name="rule">the rule</param>
            <param name="literal">the matched literal</param>
            <param name="currentPosition">the current position</param>
            <param name="examinedTo"></param>
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.#ctor(NMF.AnyText.Rules.Rule,System.String,NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Creates a new instance
            </summary>
            <param name="rule">the rule</param>
            <param name="literal">the matched literal</param>
            <param name="length">the length (use in case of multiline literals)</param>
            <param name="currentPosition">the current position</param>
            <param name="examinedTo"></param>
        </member>
        <member name="P:NMF.AnyText.Rules.LiteralRuleApplication.Literal">
            <summary>
            Gets the matched literal
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.ApplyTo(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.OnMigrate(System.String,System.String,NMF.AnyText.ParseContext)">
            <summary>
            Gets called when the rule application is migrated
            </summary>
            <param name="oldValue">the old literal</param>
            <param name="newValue">the new literal</param>
            <param name="context">the parse context</param>
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.GetValue(NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.IterateLiterals(System.Action{NMF.AnyText.Rules.LiteralRuleApplication})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.IterateLiterals``1(System.Action{NMF.AnyText.Rules.LiteralRuleApplication,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.LiteralRuleApplication.Write(NMF.AnyText.PrettyPrinting.PrettyPrintWriter,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.MultilineCommentRule">
            <summary>
            Denotes a rule for a multiline comment
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.MultilineCommentRule.CommentEnd">
            <summary>
            Gets or sets the end of a multiline comment
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.MultilineCommentRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.MultiRuleApplication.GetIdentifier">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.MultiRuleApplication.AddCodeLenses(System.Collections.Generic.ICollection{NMF.AnyText.CodeLensApplication},System.Predicate{NMF.AnyText.Rules.RuleApplication})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.MultiRuleApplication.AddDocumentSymbols(NMF.AnyText.ParseContext,System.Collections.Generic.ICollection{NMF.AnyText.DocumentSymbol})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.MultiRuleApplication.AddFoldingRanges(System.Collections.Generic.ICollection{NMF.AnyText.FoldingRange})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.MultiRuleApplication.IterateLiterals(System.Action{NMF.AnyText.Rules.LiteralRuleApplication})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.MultiRuleApplication.IterateLiterals``1(System.Action{NMF.AnyText.Rules.LiteralRuleApplication,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.MultiRuleApplication.Write(NMF.AnyText.PrettyPrinting.PrettyPrintWriter,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.NegativeLookaheadRule">
            <summary>
            Denotes a negative lookahead rule
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.#ctor(NMF.AnyText.Rules.Rule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="inner">the negative lookahead</param>
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.#ctor(NMF.AnyText.PrettyPrinting.FormattedRule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="inner">the negative lookahead</param>
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.NegativeLookaheadRule.Inner">
            <summary>
            Gets or sets the negative lookahead
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.NegativeLookaheadRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.OneOrMoreRule">
            <summary>
            Denotes a rule that is matched at least once
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.#ctor(NMF.AnyText.Rules.Rule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="innerRule">the inner rule</param>
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.#ctor(NMF.AnyText.PrettyPrinting.FormattedRule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="innerRule">the inner rule</param>
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.OneOrMoreRule.PassAlongDocumentSymbols">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.OneOrMoreRule.InnerRule">
            <summary>
            Gets or sets the inner rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.OneOrMoreRule.FormattingInstructions">
            <summary>
            Gets or sets the formatting instructions
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.CreateSynthesisRequirements">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.OneOrMoreRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.QuoteRule">
            <summary>
            Denotes a rule that delegates to an inner rule without changes
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.QuoteRule.Inner">
            <summary>
            Gets or sets the inner rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.QuoteRule.InnerRule">
            <summary>
            Gets or sets the inner rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.QuoteRule.FormattingInstructions">
            <summary>
            Gets or sets formatting instructions
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.QuoteRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.QuoteRule.CreateSynthesisRequirements">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.QuoteRule.CreateRuleApplication(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Creates the rule application for this rule
            </summary>
            <param name="app">the inner rule application</param>
            <param name="context">the parse context</param>
            <returns>the new rule application</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.QuoteRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.QuoteRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.QuoteRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.QuoteRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.RegexRule">
            <summary>
            Denotes a rule that parses text based on regular expressions
            </summary>
            <remarks>Regular expressions are always restricted to a single line, only</remarks>
        </member>
        <member name="P:NMF.AnyText.Rules.RegexRule.Regex">
            <summary>
            Gets or sets the regular expression
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.RegexRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.RegexRule.IsLiteral">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.RegexRule.TokenType">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.RegexRule.CreateRuleApplication(System.String,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParseContext)">
            <summary>
            Creates a new rule application
            </summary>
            <param name="matched">the matched string content</param>
            <param name="position">the position where the rule matched</param>
            <param name="examined">the examined length of text</param>
            <param name="context">the parse context</param>
            <returns>a rule application</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.RegexRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.RegexRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.RegexRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.RegexRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.Rule">
            <summary>
            Denotes a rule for parsing rules
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <summary>
            Matches the the context at the provided position
            </summary>
            <param name="context">the context in which the rule is matched</param>
            <param name="position">the position in the input</param>
            <returns>the rule application for the provided position</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.OnActivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Gets called when a rule application is activated
            </summary>
            <param name="application">the rule application that is activated</param>
            <param name="context">the context in which the rule application is activated</param>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.OnDeactivate(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Gets called when a rule application is deactivated
            </summary>
            <param name="application">the rule application that is deactivated</param>
            <param name="context">the context in which the rule application is deactivated</param>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.OnValueChange(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Gets called when the value of a rule application changes
            </summary>
            <param name="application">the rule application for which the value changed</param>
            <param name="context">the context in which the value changed</param>
            <returns>true, if the rule processed the value change, otherwise false (in which case the value change is propagated)</returns>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.IsLiteral">
            <summary>
            True, if the rule contributes characters, otherwise false
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.IsComment">
            <summary>
            True, if the rule is ignored in the parse tree, otherwise false
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.IsFoldable">
            <summary>
            True, if the application of this rule can be folded away (hidden)
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.IsImports">
            <summary>
            True, if the rule is used to define imports
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.HasFoldingKind(System.String@)">
            <summary>
            Returns the folding kind for a rule if one is defined for the rule
            </summary>
            <param name="kind">The folding kind of the rule</param>
            <returns>True, if a folding kind is defined for the rule</returns>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.TrailingWhitespaces">
            <summary>
            True, if the rule permits trailing whitespaces, otherwise false
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.Initialize(NMF.AnyText.Grammars.GrammarContext)">
            <summary>
            Initializes the rule based on the provided grammar context
            </summary>
            <param name="context">the grammar context</param>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.PostInitialize(NMF.AnyText.Grammars.GrammarContext)">
            <summary>
            Initializes the rule based on the provided grammar context
            </summary>
            <param name="context">the grammar context</param>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.TokenType">
            <summary>
            Gets the token type of tokens created for this rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.IsDefinition">
            <summary>
            True, if the application of this rule denotes a definition
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.IsReference">
            <summary>
            True, if the application of this rule denotes a reference
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.IsIdentifier">
            <summary>
            True, if the rule application of this rule denotes an identifier
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.SymbolKind">
            <summary>
            Gets the kind of document symbol to be used for this rule
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.SymbolTags(NMF.AnyText.Rules.RuleApplication)">
            <summary>
            Gets the kind of document symbol to be used for this rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.PassAlongDocumentSymbols">
            <summary>
            True, if inner document symbols should be passed on to be handled separately,
            e.g. if the inner elements of the corresponding rule application should be
            visible in the outline, but not the rule application itself
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.IsLeftRecursive">
            <summary>
            Indicates whether the rule is recursive
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <summary>
            Determines whether the current rule can synthesize rule applications for the given semantic element
            </summary>
            <param name="semanticElement">the semantic element</param>
            <param name="context">the context in which the rule is synthesized</param>
            <returns>true, if a rule application can be synthesized, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.CreateSynthesisRequirements">
            <summary>
            Creates a collection of requirements for synthesis
            </summary>
            <returns>A collection of synthesis requirements</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.Synthesize(System.Object,NMF.AnyText.ParseContext,System.String)">
            <summary>
            Synthesizes text for the given element
            </summary>
            <param name="element">the element for which text should be synthesized</param>
            <param name="context">the parse context</param>
            <param name="indentString">an indentation string. If none is provided, a double space is used as default.</param>
            <returns>the synthesized text or null, if no text can be synthesized</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.Synthesize(System.Object,NMF.AnyText.ParseContext,System.IO.TextWriter,System.String)">
            <summary>
            Synthesizes text for the given element
            </summary>
            <param name="element">the element for which text should be synthesized</param>
            <param name="context">the parse context</param>
            <param name="writer">the text writer the synthesized text should be written to</param>
            <param name="indentString">an indentation string. If none is provided, a double space is used as default.</param>
            <returns>the synthesized text or null, if no text can be synthesized</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <summary>
            Synthesizes a rule application for the given semantic element
            </summary>
            <param name="semanticElement"></param>
            <param name="position">the parse position at which the element should be synthesized</param>
            <param name="context">the parse context</param>
            <returns>a rule application</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.IsEpsilonAllowed">
            <summary>
            Determines whether the rule could capture empty input
            </summary>
            <returns>true, if the rule can be expanded to an empty string, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <summary>
            Determines whether the rule could capture empty input
            </summary>
            <returns>true, if the rule can be expanded to an empty string, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.CanStartWith(NMF.AnyText.Rules.Rule)">
            <summary>
            Indicates whether the rule could start with the given other rule
            </summary>
            <param name="rule">the other rule</param>
            <returns>true, if the rule could start with the given other rule, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <summary>
            Indicates whether the rule could start with the given other rule
            </summary>
            <param name="rule">the other rule</param>
            <param name="trace">a list of rules visited so far</param>
            <returns>true, if the rule could start with the given other rule, otherwise false</returns>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.TokenModifiers">
            <summary>
            Gets the token modifiers of
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.SuggestCompletions(NMF.AnyText.ParseContext,NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParsePosition)">
            <summary>
            Suggests useful code completions
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.TokenTypeIndex">
            <summary>
            Gets the index of the token type
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.TokenModifierIndex">
            <summary>
            Gets the index of the token modifiers
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.SupportedCodeActions">
            <summary>
            Gets the list of code actions for this rule.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.Rule.SupportedCodeLenses">
            <summary>
            Gets the list of code lenses for this rule.
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.GetHoverText(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.Parser,NMF.AnyText.ParsePosition)">
            <summary>
            Gibt den Hover-Text fr diese Rule zurck, wenn definiert.
            </summary>
            <param name="context">Der Kontext, in dem die Rule verarbeitet wird.</param>
            <param name="position">Die Position, an der der Hover-Text angefordert wird.</param>
            <returns>Der Hover-Text oder null, wenn keiner definiert ist.</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.Rule.ResolveSymbolKind(System.Collections.Generic.Dictionary{System.Type,NMF.AnyText.SymbolKind})">
            <summary>
            Resolves correct symbol kind for the reference type if any.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Rules.RuleApplication">
            <summary>
            Denotes the application of a rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.Description">
            <summary>
            Gets the debugger description for this rule application
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.#ctor(NMF.AnyText.Rules.Rule,NMF.AnyText.ParsePosition,NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Creates a new instance
            </summary>
            <param name="rule">the rule that was matched</param>
            <param name="currentPosition">the current position of this rule application</param>
            <param name="length">the length of the rule application</param>
            <param name="examinedTo">the amount of text that was analyzed to come to the conclusion of this rule application</param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.IsPositive">
            <summary>
            True, if the rule application was successful, otherwise false
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.ContextElement">
            <summary>
            Gets the element that denotes the context for this rule application
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.SemanticElement">
            <summary>
            Gets the semantic element of the rule application
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.DiagnosticItems">
            <summary>
            Gets a collection of diagnostic items related to this rule application
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.FindChildAt(NMF.AnyText.ParsePosition,NMF.AnyText.Rules.Rule)">
            <summary>
            Gets the child rule application at the given position
            </summary>
            <param name="position">The position</param>
            <param name="rule">The expected rule of the child</param>
            <returns>The child at the given position or null</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.Validate(NMF.AnyText.ParseContext)">
            <summary>
            Validates the rule semantically
            </summary>
            <param name="context">the parse context in which the rule is validated</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.GetValue(NMF.AnyText.ParseContext)">
            <summary>
            Gets the parsed newPosition under the given context
            </summary>
            <param name="context">the parse context</param>
            <returns>the parsed newPosition</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.AddDocumentSymbols(NMF.AnyText.ParseContext,System.Collections.Generic.ICollection{NMF.AnyText.DocumentSymbol})">
            <summary>
            Adds document symbols to a list
            </summary>
            <param name="context">the parse context</param>
            <param name="result">the list to add document symbols to</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.AddDocumentSymbol(NMF.AnyText.ParseContext,System.Collections.Generic.ICollection{NMF.AnyText.DocumentSymbol},System.Collections.Generic.IEnumerable{NMF.AnyText.DocumentSymbol})">
            <summary>
            Adds a document symbol to a list
            </summary>
            <param name="context">the parse context</param>
            <param name="result">the list to add the document symbol to</param>
            <param name="children">the children symbols of the document symbol</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.AddFoldingRanges(System.Collections.Generic.ICollection{NMF.AnyText.FoldingRange})">
            <summary>
            Gets the folding ranges present in the rule application
            </summary>
            <param name="result">The IEnumerable to hold the folding ranges</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.GetFirstReferenceOrDefinition">
            <summary>
            Gets the first reference or definition rule in the upward parse tree starting from this rule application
            </summary>
            <returns>The rule application of the reference or definition rule</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.GetIdentifier">
            <summary>
            Gets the first contained rule application that represents an identifier
            </summary>
            <returns>The rule application for the literal rule representing the identifier</returns>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.Rule">
            <summary>
            The rule that was matched
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.Comments">
            <summary>
            Gets a collection of comments for this rule application
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.Length">
            <summary>
            the length of the rule application
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.ExaminedTo">
            <summary>
            the amount of text that was analyzed to come to the conclusion of this rule application
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.IsActive">
            <summary>
            True, if the rule application is part of the current parse tree
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.CurrentPosition">
            <summary>
            Gets the last position of this rule application
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.EnsurePosition(NMF.AnyText.ParsePosition,System.Boolean)">
            <summary>
            Sets a new current position
            </summary>
            <param name="newPosition">the new current position</param>
            <param name="updateChildren">true, if the position of child rule applications should be updated as well, otherwise false</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.Shift(NMF.AnyText.ParsePositionDelta,System.Int32)">
            <summary>
            Shifts the current rule application by the given position delta
            </summary>
            <param name="originalLine">the line of the original shoft</param>
            <param name="shift"></param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.Activate(NMF.AnyText.ParseContext)">
            <summary>
            Activates the rule application, i.e. marks it as part of the current parse tree
            </summary>
            <param name="context">the context in which the parse tree exists</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.Deactivate(NMF.AnyText.ParseContext)">
            <summary>
            Deactivates the rule application, i.e. unmarks it as part of the parse tree
            </summary>
            <param name="context">the context in which the parse tree exists</param>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.Parent">
            <summary>
            Gets the parent rule application in the parse tree
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.CreateParseErrors">
            <summary>
            Gets a collection of parse errors represented by this rule application
            </summary>
            <returns>A collection of parse errors</returns>
        </member>
        <member name="P:NMF.AnyText.Rules.RuleApplication.PotentialError">
            <summary>
            Denotes a potential error to improve error reporting
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.AddCodeLenses(System.Collections.Generic.ICollection{NMF.AnyText.CodeLensApplication},System.Predicate{NMF.AnyText.Rules.RuleApplication})">
            <summary>
            Adds all CodeLens information of this <see cref="T:NMF.AnyText.Rules.RuleApplication"/> to the provided collection.
            </summary>
            <param name="codeLenses">The collection to which the <see cref="T:NMF.AnyText.CodeLensInfo"/> objects will be added.</param>
            <param name="predicate">An optional predicate that filters which rule applications should have their CodeLenses added. Default is <c>true</c> for all.</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.OnValueChange(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Gets called when the newPosition of the given rule application changes
            </summary>
            <param name="changedChild">the changed rule application (either this or a child in the parse tree)</param>
            <param name="context">the parse context</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.ApplyTo(NMF.AnyText.Rules.RuleApplication,NMF.AnyText.ParseContext)">
            <summary>
            Applies the structure of the current rule application to the given other rule application
            </summary>
            <param name="other">the rule application to which the rule should be applied</param>
            <param name="context">the parse context</param>
            <returns>the merged rule application</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.GetLiteralAt(NMF.AnyText.ParsePosition)">
            <summary>
            Gets the literal at the given position
            </summary>
            <param name="position">the position</param>
            <returns>the literal rule application or null, if there is no literal there</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.IterateLiterals(System.Action{NMF.AnyText.Rules.LiteralRuleApplication})">
            <summary>
            Iterate over all literals
            </summary>
            <param name="action">the action that should be performed for all literals</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.IterateLiterals``1(System.Action{NMF.AnyText.Rules.LiteralRuleApplication,``0},``0)">
            <summary>
            Iterate over all literals
            </summary>
            <typeparam name="T">the parameter type</typeparam>
            <param name="action">the action that should be performed for all literals</param>
            <param name="parameter">the parameter</param>
        </member>
        <member name="M:NMF.AnyText.Rules.RuleApplication.Write(NMF.AnyText.PrettyPrinting.PrettyPrintWriter,NMF.AnyText.ParseContext)">
            <summary>
            Writes the given rule application to the provided text writer
            </summary>
            <param name="writer">the writer to which the rule application should be written</param>
            <param name="context">the parse context</param>
            <returns>true, if any content has been written, otherwise false</returns>
        </member>
        <member name="T:NMF.AnyText.Rules.SequenceRule">
            <summary>
            Denotes a rule that other rules occur in sequence
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.#ctor(NMF.AnyText.PrettyPrinting.FormattedRule[])">
            <summary>
            Creates a new instance
            </summary>
            <param name="rules">The rules that should occur in sequence</param>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.HasFoldingKind(System.String@)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.SequenceRule.Rules">
            <summary>
            The rules that should occur in sequence
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.GetOrCreateSynthesisRequirements">
            <summary>
            Gets or creates synthesis requirements for the individual rules
            </summary>
            <returns>An array with the synthesis requirements for the individual rules of the sequence</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.CreateSynthesisRequirements">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.CreateRuleApplication(NMF.AnyText.ParsePosition,System.Collections.Generic.List{NMF.AnyText.Rules.RuleApplication},NMF.AnyText.ParsePositionDelta,NMF.AnyText.ParsePositionDelta)">
            <summary>
            Creates a rule application for a success
            </summary>
            <param name="currentPosition">the current parser position</param>
            <param name="inner">the inner list of rule applications</param>
            <param name="length">the length of the match</param>
            <param name="examined">the amount of text examined</param>
            <returns>a new rule application</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.IsRegion">
            <summary>
            Determines whether the current rule represents a region
            </summary>
            <returns>true, if it represents a region, otherwise false</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.IsFoldable">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.IsRegionStartLiteral(System.String)">
            <summary>
            Checks if a literal denotes the start of a region
            </summary>
            <param name="literal">The start literal</param>
            <returns>True, if the given literal denotes the start of a region</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.IsRangeStartLiteral(System.String)">
            <summary>
            Checks if a given literal denotes the start of a generic folding range
            </summary>
            <param name="literal"></param>
            <returns>True, if the given literal denotes the start of a generic foldable range</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.IsMatchingEndLiteral(System.String,System.String)">
            <summary>
            Checks if a given pair of start and end literal match
            </summary>
            <param name="literal">The end literal</param>
            <param name="startLiteral">The start literal</param>
            <returns>True, if the given literal is a matching end literal for a given start literal</returns>
        </member>
        <member name="M:NMF.AnyText.Rules.SequenceRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SingleRuleApplication.AddCodeLenses(System.Collections.Generic.ICollection{NMF.AnyText.CodeLensApplication},System.Predicate{NMF.AnyText.Rules.RuleApplication})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SingleRuleApplication.AddDocumentSymbols(NMF.AnyText.ParseContext,System.Collections.Generic.ICollection{NMF.AnyText.DocumentSymbol})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SingleRuleApplication.AddFoldingRanges(System.Collections.Generic.ICollection{NMF.AnyText.FoldingRange})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SingleRuleApplication.IterateLiterals(System.Action{NMF.AnyText.Rules.LiteralRuleApplication})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SingleRuleApplication.IterateLiterals``1(System.Action{NMF.AnyText.Rules.LiteralRuleApplication,``0},``0)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.SingleRuleApplication.Write(NMF.AnyText.PrettyPrinting.PrettyPrintWriter,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.SynthesisRequirement">
            <summary>
            Denotes the abstract base class for a synthesis requirement
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.SynthesisRequirement.Matches(System.Object)">
            <summary>
            Determines whether the requirement is satisfied
            </summary>
            <param name="semanticObject">the semantic object that should be matched</param>
            <returns>true, if the requirement is satisfied, otherwise false</returns>
        </member>
        <member name="P:NMF.AnyText.Rules.SynthesisRequirement.Feature">
            <summary>
            Gets the feature that is required for synthesis
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.SynthesisRequirement.CanConsumeMany">
            <summary>
            True, if the synthesis requirement can consume many values, otherwise false
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.SynthesisRequirement.PlaceReservations(NMF.AnyText.Model.ParseObject)">
            <summary>
            Places reservations for the given semantic object
            </summary>
            <param name="semanticObject">the semantic object</param>
        </member>
        <member name="M:NMF.AnyText.Rules.SynthesisRequirement.FreeReservations(NMF.AnyText.Model.ParseObject)">
            <summary>
            Frees reservations for the semantic object
            </summary>
            <param name="semanticObject">the semantic object</param>
        </member>
        <member name="T:NMF.AnyText.Rules.ZeroOrMoreRule">
            <summary>
            Denotes that another rule can occur an arbitrary number of times
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.#ctor(NMF.AnyText.Rules.Rule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="innerRule">the inner rule</param>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.#ctor(NMF.AnyText.PrettyPrinting.FormattedRule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="innerRule">the inner rule</param>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.HasFoldingKind(System.String@)">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.ZeroOrMoreRule.PassAlongDocumentSymbols">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.ZeroOrMoreRule.InnerRule">
            <summary>
            Gets or sets the inner rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.ZeroOrMoreRule.FormattingInstructions">
            <summary>
            Gets or sets the formatting instructions
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrMoreRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.Rules.ZeroOrOneRule">
            <summary>
            Denotes that a rule that can be matched at most once
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.#ctor(NMF.AnyText.Rules.Rule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="innerRule">the inner rule</param>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.#ctor(NMF.AnyText.PrettyPrinting.FormattedRule)">
            <summary>
            Creates a new instance
            </summary>
            <param name="innerRule">the inner rule</param>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.CanStartWith(NMF.AnyText.Rules.Rule,System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.IsEpsilonAllowed(System.Collections.Generic.List{NMF.AnyText.Rules.Rule})">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.ZeroOrOneRule.PassAlongDocumentSymbols">
            <inheritdoc />
        </member>
        <member name="P:NMF.AnyText.Rules.ZeroOrOneRule.InnerRule">
            <summary>
            The inner rule
            </summary>
        </member>
        <member name="P:NMF.AnyText.Rules.ZeroOrOneRule.FormattingInstructions">
            <summary>
            Gets or sets the formatting instructions
            </summary>
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.Match(NMF.AnyText.ParseContext,NMF.AnyText.ParsePosition@)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.CanSynthesize(System.Object,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="M:NMF.AnyText.Rules.ZeroOrOneRule.Synthesize(System.Object,NMF.AnyText.ParsePosition,NMF.AnyText.ParseContext)">
            <inheritdoc />
        </member>
        <member name="T:NMF.AnyText.SelectionRange">
            <summary>
            A selection range around a cursor position that the user might be interested in selecting.
            Analogous to LspTypes SelectionRange.
            </summary>
        </member>
        <member name="P:NMF.AnyText.SelectionRange.Range">
            <summary>
            The range of this selection range
            </summary>
        </member>
        <member name="P:NMF.AnyText.SelectionRange.Parent">
            <summary>
            The parent selection range containing this selection range
            </summary>
        </member>
        <member name="T:NMF.AnyText.SymbolKind">
            <summary>
            Symbol kinds used for document symbol requests
            </summary>
        </member>
        <member name="T:NMF.AnyText.SymbolTag">
            <summary>
            Symbol tags are extra annotations that tweak the rendering of a symbol.
            </summary>
        </member>
        <member name="F:NMF.AnyText.SymbolTag.Deprecated">
            <summary>
            Render a symbol as obsolete, usually using a strike-out.
            </summary>
        </member>
        <member name="T:NMF.AnyText.TextEdit">
            <summary>
            Denotes an edit for text
            </summary>
        </member>
        <member name="M:NMF.AnyText.TextEdit.#ctor(NMF.AnyText.ParsePosition,NMF.AnyText.ParsePosition,System.String[])">
            <summary>
            Creates a new text edit
            </summary>
            <param name="start">the start of the edit</param>
            <param name="end">the end of the edit</param>
            <param name="newText">the new text inserted between start and end</param>
            <exception cref="T:System.ArgumentException">thrown if start is after end</exception>
        </member>
        <member name="P:NMF.AnyText.TextEdit.Start">
            <summary>
            Gets the start of the edit
            </summary>
        </member>
        <member name="P:NMF.AnyText.TextEdit.End">
            <summary>
            Gets the end of the edit
            </summary>
        </member>
        <member name="P:NMF.AnyText.TextEdit.NewText">
            <summary>
            Gets the new text inserted between start and end
            </summary>
        </member>
        <member name="M:NMF.AnyText.TextEdit.Apply(System.String[])">
            <summary>
            Applies the text edit to the given input
            </summary>
            <param name="input">an input array of string lines</param>
            <returns>a text array including the changes</returns>
        </member>
        <member name="M:NMF.AnyText.TextEdit.UpdatePosition(NMF.AnyText.ParsePosition@)">
            <summary>
            Updates the position after applying this edit.
            Only Updates the Postion if it is fully after the Edit.
            </summary>
            <param name="position">The position to update.</param>
        </member>
        <member name="T:NMF.AnyText.Workspace.ChangeAnnotation">
            <summary>
                Represents metadata or instructions for an annotation associated with a change.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.ChangeAnnotation.Label">
            <summary>
                A label for the annotation (e.g., "Refactor").
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.ChangeAnnotation.NeedsConfirmation">
            <summary>
                Indicates if the change requires user confirmation.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.ChangeAnnotation.Description">
            <summary>
                A description or explanation of the annotation.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.CreateFile">
            <summary>
                Represents the information needed to create a new file.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.CreateFile.Kind">
            <summary>
                The type of file creation (e.g., "create").
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.CreateFile.Uri">
            <summary>
                The URI of the file to be created.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.CreateFile.Options">
            <summary>
                File options (e.g., whether to overwrite an existing file).
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.CreateFile.AnnotationId">
            <summary>
                An optional annotation ID related to the file creation.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.DeleteFile">
            <summary>
                Represents the information needed to delete an existing file.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DeleteFile.Kind">
            <summary>
                The type of file operation (e.g., "delete").
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DeleteFile.Uri">
            <summary>
                The URI of the file to be deleted.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DeleteFile.Options">
            <summary>
                File deletion options (e.g., whether to delete recursively).
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DeleteFile.AnnotationId">
            <summary>
                An optional annotation ID related to the file deletion.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.DeleteFileOptions">
            <summary>
                Options for deleting files, such as recursive deletion and handling missing files.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DeleteFileOptions.Recursive">
            <summary>
                If true, delete directories recursively.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DeleteFileOptions.IgnoreIfNotExists">
            <summary>
                If true, ignore the operation if the file does not exist.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.DocumentChange">
            <summary>
                Represents a change to a document, including text edits, file creation, renaming, or deletion.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DocumentChange.TextDocumentEdit">
            <summary>
                Text document edits (e.g., line insertions, deletions).
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DocumentChange.CreateFile">
            <summary>
                Information for creating a new file.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DocumentChange.RenameFile">
            <summary>
                Information for renaming an existing file.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.DocumentChange.DeleteFile">
            <summary>
                Information for deleting an existing file.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.FileOptions">
            <summary>
                Options for creating or renaming files, such as overwrite behavior.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.FileOptions.Overwrite">
            <summary>
                If true, overwrite an existing file.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.FileOptions.IgnoreIfExists">
            <summary>
                If true, ignore the operation if the file already exists.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.OptionalVersionedTextDocumentIdentifier">
            <summary>
                Identifies a text document with optional versioning.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.OptionalVersionedTextDocumentIdentifier.Uri">
            <summary>
                The URI of the text document.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.OptionalVersionedTextDocumentIdentifier.Version">
            <summary>
                An optional version number for the document, if versioning is supported.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.RenameFile">
            <summary>
                Represents the information needed to rename an existing file.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.RenameFile.Kind">
            <summary>
                The type of file operation (e.g., "rename").
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.RenameFile.OldUri">
            <summary>
                The URI of the old file name.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.RenameFile.NewUri">
            <summary>
                The URI of the new file name.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.RenameFile.Options">
            <summary>
                File options (e.g., whether to overwrite).
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.RenameFile.AnnotationId">
            <summary>
                An optional annotation ID related to the file rename.
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.TextDocumentEdit">
            <summary>
                Represents the text document edit instructions, including the document and the edits.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.TextDocumentEdit.TextDocument">
            <summary>
                Identifies the text document to edit, including optional version information.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.TextDocumentEdit.Edits">
            <summary>
                An Array of edits to perform on the document (e.g., insertions, deletions).
            </summary>
        </member>
        <member name="T:NMF.AnyText.Workspace.WorkspaceEdit">
            <summary>
                Represents changes to a workspace, including text edits, document changes, and change annotations.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.WorkspaceEdit.Changes">
            <summary>
                A dictionary of changes to text documents, keyed by document URI, with the value being the text edits for that
                document.
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.WorkspaceEdit.DocumentChanges">
            <summary>
                A list of document-level changes (e.g., file creation, renaming, deletion).
            </summary>
        </member>
        <member name="P:NMF.AnyText.Workspace.WorkspaceEdit.ChangeAnnotations">
            <summary>
                A dictionary of annotations associated with changes, keyed by annotation ID.
            </summary>
        </member>
    </members>
</doc>
