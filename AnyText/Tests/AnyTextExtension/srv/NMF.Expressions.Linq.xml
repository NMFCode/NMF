<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NMF.Expressions.Linq</name>
    </assembly>
    <members>
        <member name="T:NMF.Expressions.Linq.ExpressionExtensions">
            <summary>
            Defines a set of extension methods on the <see cref="T:NMF.Expressions.INotifyValue`1">INotifyValue</see> monad
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.All``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets a value indicating whether all items in the given collection match the given predicate
            </summary>
            <typeparam name="TSource">The type of the elements in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">A custom predicate that is applied to all items in the collection</param>
            <returns>True, if all items in the collection match the given predicate</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Any``1(NMF.Expressions.IEnumerableExpression{``0})">
            <summary>
            Gets a value indicating whether there is any item in the source collection
            </summary>
            <typeparam name="TSource">The type of the elements in the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>True, if the collection has an item, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Any``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets a value indicating whether there is any item in the source collection that matches the given predicate
            </summary>
            <typeparam name="TSource">The type of the elements in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">A custom predicate that is checked for every item</param>
            <returns>True, if there is an item that matches the givn criteria, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Int32})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Int64})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Single})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Double})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Decimal})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Int32}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Int64}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Single}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Double}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Decimal}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Average``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Cast``1(NMF.Expressions.IEnumerableExpression)">
            <summary>
            Casts the given notifying enumerable to the given type
            </summary>
            <typeparam name="TResult">The true type of the items in the collection</typeparam>
            <param name="source">The source collection</param>
            <returns>A notifying collection casted to the given type</returns>
            <remarks>If any item in the source collection is not of type <typeparamref name="TResult"/>, an exception is thrown. Consider using <see cref="M:NMF.Expressions.Linq.ExpressionExtensions.OfType``1(NMF.Expressions.IEnumerableExpression)"/> in this scenario.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Concat``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concats the given notifying enumerables
            </summary>
            <typeparam name="TSource">The type of the items</typeparam>
            <param name="source">The first source</param>
            <param name="source2">The second source</param>
            <returns>The concatenation of both sources</returns>
            <remarks>The second collection does not have to be a notifying collection, but if it is not, it must not change its contents.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Contains``1(NMF.Expressions.IEnumerableExpression{``0},``0)">
            <summary>
            Searches the given collection for the given item
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="item">The item that needs to be checked</param>
            <returns>True, if the given source collection contains the provided item, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Contains``1(NMF.Expressions.IEnumerableExpression{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Searches the given collection for the given item
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="item">The item that needs to be checked</param>
            <param name="comparer">The equality comparer to decide whether items are equal. Can be omitted</param>
            <returns>True, if the given source collection contains the provided item, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Count``1(NMF.Expressions.IEnumerableExpression{``0})">
            <summary>
            Returns how many items are in the source collection
            </summary>
            <typeparam name="TSource">The type of elements within the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>The amount of elements in the source collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Count``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Returns how many items are in the source collection that match the given predicate
            </summary>
            <typeparam name="TSource">The type of elements within the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The predicate that is to be checked for each item</param>
            <returns>The amount of elements in the source collection that match the given predicate</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Distinct``1(NMF.Expressions.IEnumerableExpression{``0})">
            <summary>
            Eliminates duplicates from the given collection
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>A notifying collection with no duplicates</returns>
            <remarks>This method destroys the original order of the items</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Distinct``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Eliminates duplicates from the given collection
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="comparer">The comparer to decide whether items match</param>
            <returns>A notifying collection with no duplicates</returns>
            <remarks>This method destroys the original order of the items</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Except``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the given source collection without the elements from the second collection
            </summary>
            <typeparam name="TSource">The type of the items</typeparam>
            <param name="source">The source collection</param>
            <param name="exceptions">The exceptions. Can be a static collection, but in that case must not change</param>
            <returns>The source collection without the exceptions</returns>
            <remarks>If the exceptions collection will ever change, it must implement <see cref="T:NMF.Expressions.ICollectionExpression"/>, otherwise the implementation will get corrupted.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Except``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns the given source collection without the elements from the second collection
            </summary>
            <typeparam name="TSource">The type of the items</typeparam>
            <param name="source">The source collection</param>
            <param name="comparer">A comparer to decide whether two items match</param>
            <param name="exceptions">The exceptions. Can be a static collection, but in that case must not change</param>
            <returns>The source collection without the exceptions</returns>
            <remarks>If the exceptions collection will ever change, it must implement <see cref="T:NMF.Expressions.ICollectionExpression"/>, otherwise the implementation will get corrupted.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.FirstOrDefault``1(NMF.Expressions.IEnumerableExpression{``0})">
            <summary>
            Gets the first item of the given source collection or the item type default value, if the collection is empty
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>The first item of the collection or the type default value, if the collection is empty</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.FirstOrDefault``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets the first item of the given source collection that matches the given predicate or the item type default value, if the collection is empty or no item matches the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The filter predicate</param>
            <returns>The first item of the collection that matches the predicate or the type default value</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.GroupBy``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.GroupBy``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.GroupBy``3(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.GroupBy``3(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.GroupJoin``4(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})">
            <summary>
            Joins the given collections based on keys into groups
            </summary>
            <typeparam name="TOuter">The element type of the outer collection</typeparam>
            <typeparam name="TInner">The element type of the inner collection</typeparam>
            <typeparam name="TKey">The key type to be matched</typeparam>
            <typeparam name="TResult">The resulting type</typeparam>
            <param name="outer">The outer collection</param>
            <param name="inner">The inner collection</param>
            <param name="outerKeySelector">A predicate that returns the key for each outer item</param>
            <param name="innerKeySelector">A predicate that returns the key for each inner item</param>
            <param name="resultSelector">A function that creates a result for each group of an outer item and a group of inner items</param>
            <returns>A collection of grouped results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.GroupJoin``4(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Joins the given collections based on keys into groups
            </summary>
            <typeparam name="TOuter">The element type of the outer collection</typeparam>
            <typeparam name="TInner">The element type of the inner collection</typeparam>
            <typeparam name="TKey">The key type to be matched</typeparam>
            <typeparam name="TResult">The resulting type</typeparam>
            <param name="outer">The outer collection</param>
            <param name="inner">The inner collection</param>
            <param name="outerKeySelector">A predicate that returns the key for each outer item</param>
            <param name="innerKeySelector">A predicate that returns the key for each inner item</param>
            <param name="comparer">A comparer to decide when two items are equal</param>
            <param name="resultSelector">A function that creates a result for each group of an outer item and a group of inner items</param>
            <returns>A collection of grouped results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Intersect``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Intersects two collections
            </summary>
            <typeparam name="TSource">The element type of the collections</typeparam>
            <param name="source">The first collection</param>
            <param name="source2">The second collection</param>
            <returns>The intersection of both collections</returns>
            <remarks>No deduplication is done</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Intersect``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Intersects two collections
            </summary>
            <typeparam name="TSource">The element type of the collections</typeparam>
            <param name="source">The first collection</param>
            <param name="source2">The second collection</param>
            <param name="comparer">A comparer to decide when two items are equal</param>
            <returns>The intersection of both collections</returns>
            <remarks>No deduplication is done</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsProperSubsetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the current collection are contained in the given collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsProperSubsetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the current collection are contained in the given collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsProperSupersetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the given collection are contained in the current collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsProperSupersetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the given collection are contained in the current collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsSubsetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the current collection are contained in the given collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsSubsetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the current collection are contained in the given collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsSupersetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the given collection are contained in the current collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.IsSupersetOf``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the given collection are contained in the current collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Join``4(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
            <summary>
            Joins the current collection with the given other collection
            </summary>
            <typeparam name="TOuter">The element type of the current collection</typeparam>
            <typeparam name="TInner">The element type of the other collection</typeparam>
            <typeparam name="TKey">The type of the keys for which the collections should be joined</typeparam>
            <typeparam name="TResult">The join result type</typeparam>
            <param name="outerSource">The current collection</param>
            <param name="innerSource">The other collection to join with</param>
            <param name="outerKeySelector">A lambda expression to select the key for the current collections items</param>
            <param name="innerKeySelector">A lambda expression to select the key for the given other collections items</param>
            <param name="resultSelector">A lambda expression to select the result for a given pair of elements</param>
            <returns>A joined collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Join``4(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Joins the current collection with the given other collection
            </summary>
            <typeparam name="TOuter">The element type of the current collection</typeparam>
            <typeparam name="TInner">The element type of the other collection</typeparam>
            <typeparam name="TKey">The type of the keys for which the collections should be joined</typeparam>
            <typeparam name="TResult">The join result type</typeparam>
            <param name="outerSource">The current collection</param>
            <param name="innerSource">The other collection to join with</param>
            <param name="outerKeySelector">A lambda expression to select the key for the current collections items</param>
            <param name="innerKeySelector">A lambda expression to select the key for the given other collections items</param>
            <param name="resultSelector">A lambda expression to select the result for a given pair of elements</param>
            <param name="comparer">An equality comparer to define when two keys are equivalent</param>
            <returns>A joined collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``1(NMF.Expressions.IEnumerableExpression{``0})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="selectorCompiled">A compiled version of the selector</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``1(NMF.Expressions.IEnumerableExpression{System.Nullable{``0}})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``1(NMF.Expressions.IEnumerableExpression{System.Nullable{``0}},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Max``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``1(NMF.Expressions.IEnumerableExpression{``0})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``1(NMF.Expressions.IEnumerableExpression{System.Nullable{``0}})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``1(NMF.Expressions.IEnumerableExpression{System.Nullable{``0}},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Min``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.OfType``1(NMF.Expressions.IEnumerableExpression)">
            <summary>
            Filters the given collection for elements of the given type
            </summary>
            <typeparam name="TResult">The result type</typeparam>
            <param name="source">The current collection</param>
            <returns>A collection containing the elements of the given type</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.OfType``2(NMF.Expressions.ICollectionExpression{``0})">
            <summary>
            Filters the given collection for elements of the given type
            </summary>
            <typeparam name="TSource">The type of the original collection</typeparam>
            <typeparam name="TResult">The result type</typeparam>
            <param name="source">The current collection</param>
            <returns>A collection containing the elements of the given type</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.OfType``1(NMF.Expressions.ICollectionExpression)">
            <summary>
            Filters the given collection for elements of the given type as a collection using the non-generic interface
            </summary>
            <typeparam name="TResult">The result type</typeparam>
            <param name="source">The current collection</param>
            <returns>A collection containing the elements of the given type</returns>
            <remarks>Only use this method if a generic collection interface is for some reason unavailable.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.AsOne``1(``0)">
            <summary>
            Captures the given element as a collection containing just this element
            </summary>
            <typeparam name="T">The type of the element</typeparam>
            <param name="item">The item</param>
            <returns>A collection expression consisting only of this element</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.OrderBy``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given collection ascending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.OrderBy``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given collection ascending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.OrderByDescending``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given collection descending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.OrderByDescending``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given collection descending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Select``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Maps the current collection to the given lambda expression
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="selector">A lambda expression representing the mapping result for a given item</param>
            <returns>A collection with the mapping results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Select``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1})">
            <summary>
            Maps the current collection to the given lambda expression
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="selector">A lambda expression representing the mapping result for a given item</param>
            <param name="selectorCompiled">A compiled version of the selector</param>
            <returns>A collection with the mapping results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.SelectMany``3(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Flattens the given collection of collections where the subsequent collections are selected by a predicate
            </summary>
            <typeparam name="TSource">The source element type</typeparam>
            <typeparam name="TIntermediate">The element type of the subsequent collection</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="func">A lambda expression to select subsequent collections</param>
            <param name="selector">A lambda expression that determines the result element given the element of the source collection and the element of the subsequent collection</param>
            <returns>A collection with the results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.SelectMany``2(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Flattens the given collection of collections where the subsequent collections are selected by a predicate
            </summary>
            <typeparam name="TSource">The source element type</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="selector">A lambda expression to select subsequent collections</param>
            <returns>A collection with the results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.SetEquals``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the current collection and the given collection contain the same set of elements, regardless of their order
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="other">The given other collection</param>
            <returns>True, if both collections contain the same set of elements, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.SetEquals``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the current collection and the given collection contain the same set of elements, regardless of their order
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="other">The given other collection</param>
            <param name="comparer">An equality comparer used to determine equality in the sets</param>
            <returns>True, if both collections contain the same set of elements, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.SingleOrDefault``1(NMF.Expressions.IEnumerableExpression{``0})">
            <summary>
            Gets the single item of the given source collection or the item type default value, if the collection is empty
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>The single item of the collection or the type default value, if the collection is empty</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.SingleOrDefault``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets the first item of the given source collection that matches the given predicate or the item type default value, if the collection is empty or no item matches the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The filter predicate</param>
            <returns>The first item of the collection that matches the predicate or the type default value</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.SingleOrDefault``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Func{``0,System.Boolean})">
            <summary>
            Gets the first item of the given source collection that matches the given predicate or the item type default value, if the collection is empty or no item matches the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The filter predicate</param>
            <param name="predicateCompiled">The filter predicate precompiled</param>
            <returns>The first item of the collection that matches the predicate or the type default value</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Int32})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Int64})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Single})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Double})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Decimal})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Int32}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Int64}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Single}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Double}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum(NMF.Expressions.IEnumerableExpression{System.Nullable{System.Decimal}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Sum``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.ThenBy``2(NMF.Expressions.IOrderableEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given orderable collection by the given predicate ascending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.ThenBy``2(NMF.Expressions.IOrderableEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given orderable collection by the given predicate ascending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <param name="comparer">A comparer to determine comparison</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.ThenByDescending``2(NMF.Expressions.IOrderableEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given orderable collection by the given predicate descending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.ThenByDescending``2(NMF.Expressions.IOrderableEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given orderable collection by the given predicate descending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <param name="comparer">A comparer to determine comparison</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.TopX``2(NMF.Expressions.IEnumerableExpression{``0},System.Int32,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the top x elements of the given collection, ordered by the given feature
            </summary>
            <typeparam name="TItem">The item type</typeparam>
            <typeparam name="TKey">The key type</typeparam>
            <param name="source">The element source</param>
            <param name="x">A number indicating how many items should be selected</param>
            <param name="keySelector">An expression to denote the selection of key features</param>
            <returns>An array with the largest entries of the underlying collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.TopX``2(NMF.Expressions.IEnumerableExpression{``0},System.Int32,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the top x elements of the given collection, ordered by the given feature
            </summary>
            <typeparam name="TItem">The item type</typeparam>
            <typeparam name="TKey">The key type</typeparam>
            <param name="source">The element source</param>
            <param name="x">A number indicating how many items should be selected</param>
            <param name="keySelector">An expression to denote the selection of key features</param>
            <param name="comparer">A custom comparer</param>
            <returns>An array with the largest entries of the underlying collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Union``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Unions the current collection with the given other collection 
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <param name="source">The current collection</param>
            <param name="source2">The given other collection</param>
            <returns>A collection containing the union of both collections</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Union``1(NMF.Expressions.IEnumerableExpression{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Unions the current collection with the given other collection 
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <param name="source">The current collection</param>
            <param name="source2">The given other collection</param>
            <param name="comparer">A comparer to determine equality</param>
            <returns>A collection containing the union of both collections</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Where``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Where``1(NMF.Expressions.IEnumerableExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Func{``0,System.Boolean})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <param name="filterCompiled">The filter predicate precompiled</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Where``1(NMF.Expressions.ICollectionExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ExpressionExtensions.Where``1(NMF.Expressions.ICollectionExpression{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Func{``0,System.Boolean},System.Action{``0,System.Boolean})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <param name="filterGetter">A precompiled filter getter</param>
            <param name="filterSetter">A precompiled filter setter</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="T:NMF.Expressions.Linq.ObservableExtensions">
            <summary>
            Defines a set of extension methods on the <see cref="T:NMF.Expressions.INotifyValue`1">INotifyValue</see> monad
            </summary>
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableExtensions.KeepOrder">
            <summary>
            Gets or sets a global flag indicating whether projections and filters should maintain the element order
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.RestoreIndices``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Restores the indices of the given collection
            </summary>
            <typeparam name="T">The type of elements</typeparam>
            <param name="source">the source incremental collection</param>
            <returns>A collection that mirrors the given incremental collection but restores change indices</returns>
            <remarks>Some frameworks (like Avalonia) require that indices of elements are always set</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.All``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets a value indicating whether all items in the given collection match the given predicate
            </summary>
            <typeparam name="TSource">The type of the elements in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">A custom predicate that is applied to all items in the collection</param>
            <returns>True, if all items in the collection match the given predicate</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Any``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Gets a value indicating whether there is any item in the source collection
            </summary>
            <typeparam name="TSource">The type of the elements in the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>True, if the collection has an item, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Any``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets a value indicating whether there is any item in the source collection that matches the given predicate
            </summary>
            <typeparam name="TSource">The type of the elements in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">A custom predicate that is checked for every item</param>
            <returns>True, if there is an item that matches the givn criteria, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Int32})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Int64})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Single})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Double})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Decimal})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Single}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Double}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Gets the average of the given collection of numbers
            </summary>
            <param name="source">A collection of numbers</param>
            <returns>The average of the given collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Average``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
            <summary>
            Gets the average of the given feature based on items of the given collection
            </summary>
            <typeparam name="TSource">The type of the items in the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The feature of the source items that should be averaged</param>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Cast``1(NMF.Expressions.INotifyEnumerable)">
            <summary>
            Casts the given notifying enumerable to the given type
            </summary>
            <typeparam name="TResult">The true type of the items in the collection</typeparam>
            <param name="source">The source collection</param>
            <returns>A notifying collection casted to the given type</returns>
            <remarks>If any item in the source collection is not of type <typeparamref name="TResult"/>, an exception is thrown. Consider using <see cref="M:NMF.Expressions.Linq.ObservableExtensions.OfType``1(NMF.Expressions.INotifyEnumerable)"/> in this scenario.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Concat``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concats the given notifying enumerables
            </summary>
            <typeparam name="TSource">The type of the items</typeparam>
            <param name="source">The first source</param>
            <param name="source2">The second source</param>
            <returns>The concatenation of both sources</returns>
            <remarks>The second collection does not have to be a notifying collection, but if it is not, it must not change its contents.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Contains``1(NMF.Expressions.INotifyEnumerable{``0},``0)">
            <summary>
            Searches the given collection for the given item
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="item">The item that needs to be checked</param>
            <returns>True, if the given source collection contains the provided item, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Contains``1(NMF.Expressions.INotifyEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Searches the given collection for the given item
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="item">The item that needs to be checked</param>
            <param name="comparer">The equality comparer to decide whether items are equal. Can be omitted</param>
            <returns>True, if the given source collection contains the provided item, otherwise false</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Count``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Returns how many items are in the source collection
            </summary>
            <typeparam name="TSource">The type of elements within the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>The amount of elements in the source collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Count``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Returns how many items are in the source collection that match the given predicate
            </summary>
            <typeparam name="TSource">The type of elements within the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The predicate that is to be checked for each item</param>
            <returns>The amount of elements in the source collection that match the given predicate</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Distinct``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Eliminates duplicates from the given collection
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>A notifying collection with no duplicates</returns>
            <remarks>This method destroys the original order of the items</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Distinct``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Eliminates duplicates from the given collection
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="comparer">The comparer to decide whether items match</param>
            <returns>A notifying collection with no duplicates</returns>
            <remarks>This method destroys the original order of the items</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Except``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the given source collection without the elements from the second collection
            </summary>
            <typeparam name="TSource">The type of the items</typeparam>
            <param name="source">The source collection</param>
            <param name="exceptions">The exceptions. Can be a static collection, but in that case must not change</param>
            <returns>The source collection without the exceptions</returns>
            <remarks>If the exceptions collection will ever change, it must implement <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>, otherwise the implementation will get corrupted.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Except``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns the given source collection without the elements from the second collection
            </summary>
            <typeparam name="TSource">The type of the items</typeparam>
            <param name="source">The source collection</param>
            <param name="comparer">A comparer to decide whether two items match</param>
            <param name="exceptions">The exceptions. Can be a static collection, but in that case must not change</param>
            <returns>The source collection without the exceptions</returns>
            <remarks>If the exceptions collection will ever change, it must implement <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>, otherwise the implementation will get corrupted.</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.FirstOrDefault``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Gets the first item of the given source collection or the item type default value, if the collection is empty
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>The first item of the collection or the type default value, if the collection is empty</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.FirstOrDefault``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets the first item of the given source collection that matches the given predicate or the item type default value, if the collection is empty or no item matches the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The filter predicate</param>
            <returns>The first item of the collection that matches the predicate or the type default value</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="keySelectorCompiled">A compiled version of keySelector</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="keySelectorCompiled">A compiled version of keySelector</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``3(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``3(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="keySelectorCompiled">A compiled version of keySelector</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <param name="resultSelectorCompiled">A compiled version of resultSelector</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``3(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupBy``3(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="keySelectorCompiled">A compiled version of keySelector</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <param name="resultSelectorCompiled">A compiled version of resultSelector</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupJoin``4(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})">
            <summary>
            Joins the given collections based on keys into groups
            </summary>
            <typeparam name="TOuter">The element type of the outer collection</typeparam>
            <typeparam name="TInner">The element type of the inner collection</typeparam>
            <typeparam name="TKey">The key type to be matched</typeparam>
            <typeparam name="TResult">The resulting type</typeparam>
            <param name="outer">The outer collection</param>
            <param name="inner">The inner collection</param>
            <param name="outerKeySelector">A predicate that returns the key for each outer item</param>
            <param name="innerKeySelector">A predicate that returns the key for each inner item</param>
            <param name="resultSelector">A function that creates a result for each group of an outer item and a group of inner items</param>
            <returns>A collection of grouped results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.GroupJoin``4(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Joins the given collections based on keys into groups
            </summary>
            <typeparam name="TOuter">The element type of the outer collection</typeparam>
            <typeparam name="TInner">The element type of the inner collection</typeparam>
            <typeparam name="TKey">The key type to be matched</typeparam>
            <typeparam name="TResult">The resulting type</typeparam>
            <param name="outer">The outer collection</param>
            <param name="inner">The inner collection</param>
            <param name="outerKeySelector">A predicate that returns the key for each outer item</param>
            <param name="innerKeySelector">A predicate that returns the key for each inner item</param>
            <param name="comparer">A comparer to decide when two items are equal</param>
            <param name="resultSelector">A function that creates a result for each group of an outer item and a group of inner items</param>
            <returns>A collection of grouped results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Intersect``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Intersects two collections
            </summary>
            <typeparam name="TSource">The element type of the collections</typeparam>
            <param name="source">The first collection</param>
            <param name="source2">The second collection</param>
            <returns>The intersection of both collections</returns>
            <remarks>No deduplication is done</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Intersect``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Intersects two collections
            </summary>
            <typeparam name="TSource">The element type of the collections</typeparam>
            <param name="source">The first collection</param>
            <param name="source2">The second collection</param>
            <param name="comparer">A comparer to decide when two items are equal</param>
            <returns>The intersection of both collections</returns>
            <remarks>No deduplication is done</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsProperSubsetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the current collection are contained in the given collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsProperSubsetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the current collection are contained in the given collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsProperSupersetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the given collection are contained in the current collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsProperSupersetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the given collection are contained in the current collection but not inverse, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsSubsetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the current collection are contained in the given collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsSubsetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper subset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the current collection are contained in the given collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsSupersetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <returns>True, if all elements of the given collection are contained in the current collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.IsSupersetOf``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the given collection is a proper superset of the current collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The source collection</param>
            <param name="other">The collection that is compared to</param>
            <param name="comparer">The comparer to define equality</param>
            <returns>True, if all elements of the given collection are contained in the current collection, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Join``4(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
            <summary>
            Joins the current collection with the given other collection
            </summary>
            <typeparam name="TOuter">The element type of the current collection</typeparam>
            <typeparam name="TInner">The element type of the other collection</typeparam>
            <typeparam name="TKey">The type of the keys for which the collections should be joined</typeparam>
            <typeparam name="TResult">The join result type</typeparam>
            <param name="outerSource">The current collection</param>
            <param name="innerSource">The other collection to join with</param>
            <param name="outerKeySelector">A lambda expression to select the key for the current collections items</param>
            <param name="innerKeySelector">A lambda expression to select the key for the given other collections items</param>
            <param name="resultSelector">A lambda expression to select the result for a given pair of elements</param>
            <returns>A joined collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Join``4(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Joins the current collection with the given other collection
            </summary>
            <typeparam name="TOuter">The element type of the current collection</typeparam>
            <typeparam name="TInner">The element type of the other collection</typeparam>
            <typeparam name="TKey">The type of the keys for which the collections should be joined</typeparam>
            <typeparam name="TResult">The join result type</typeparam>
            <param name="outerSource">The current collection</param>
            <param name="innerSource">The other collection to join with</param>
            <param name="outerKeySelector">A lambda expression to select the key for the current collections items</param>
            <param name="innerKeySelector">A lambda expression to select the key for the given other collections items</param>
            <param name="resultSelector">A lambda expression to select the result for a given pair of elements</param>
            <param name="comparer">An equality comparer to define when two keys are equivalent</param>
            <returns>A joined collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``1(NMF.Expressions.INotifyEnumerable{System.Nullable{``0}})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``1(NMF.Expressions.INotifyEnumerable{System.Nullable{``0}},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the maximum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Max``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the maximum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is maximal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``1(NMF.Expressions.INotifyEnumerable{System.Nullable{``0}})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``1(NMF.Expressions.INotifyEnumerable{System.Nullable{``0}},System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets the minimum element of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An element which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Min``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the minimum feature of the given collection
            </summary>
            <typeparam name="TSource">The element type</typeparam>
            <typeparam name="TResult">The result type of the comparison</typeparam>
            <param name="selector">A lambda expression to obtain the elements feature in quest</param>
            <param name="source">The collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>An elements feature which is minimal</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.OfType``1(NMF.Expressions.INotifyEnumerable)">
            <summary>
            Filters the given collection for elements of the given type
            </summary>
            <typeparam name="TResult">The result type</typeparam>
            <param name="source">The current collection</param>
            <returns>A collection containing the elements of the given type</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.OfType``2(NMF.Expressions.INotifyCollection{``0})">
            <summary>
            Filters the given collection for elements of the given type
            </summary>
            <typeparam name="TSource">The type of the original collection</typeparam>
            <typeparam name="TResult">The result type</typeparam>
            <param name="source">The current collection</param>
            <returns>A collection containing the elements of the given type</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.OrderBy``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given collection ascending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.OrderBy``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given collection ascending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.OrderByDescending``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given collection descending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.OrderByDescending``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given collection descending by the given predicate
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The type of the keys used for ordering</typeparam>
            <param name="source">The collection that should be sorted</param>
            <param name="keySelector">A lambda expression selecting the sorting keys for the given collection</param>
            <param name="comparer">A comparer for custom comparison</param>
            <returns>A collection with the elements contained in the current collection sorted by the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Select``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Maps the current collection to the given lambda expression
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="selector">A lambda expression representing the mapping result for a given item</param>
            <returns>A collection with the mapping results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Select``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``0,``1})">
            <summary>
            Maps the current collection to the given lambda expression
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="selector">A lambda expression representing the mapping result for a given item</param>
            <param name="selectorCompiled">A compiled form of the selector</param>
            <returns>A collection with the mapping results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SelectMany``3(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Flattens the given collection of collections where the subsequent collections are selected by a predicate
            </summary>
            <typeparam name="TSource">The source element type</typeparam>
            <typeparam name="TIntermediate">The element type of the subsequent collection</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="func">A lambda expression to select subsequent collections</param>
            <param name="selector">A lambda expression that determines the result element given the element of the source collection and the element of the subsequent collection</param>
            <returns>A collection with the results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SelectMany``3(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Func{``0,``1,``2})">
            <summary>
            Flattens the given collection of collections where the subsequent collections are selected by a predicate
            </summary>
            <typeparam name="TSource">The source element type</typeparam>
            <typeparam name="TIntermediate">The element type of the subsequent collection</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="func">A lambda expression to select subsequent collections</param>
            <param name="funcCompiled">A compiled version of func</param>
            <param name="selector">A lambda expression that determines the result element given the element of the source collection and the element of the subsequent collection</param>
            <param name="selectorCompiled">A compiled version of selector</param>
            <returns>A collection with the results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SelectMany``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Flattens the given collection of collections where the subsequent collections are selected by a predicate
            </summary>
            <typeparam name="TSource">The source element type</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="selector">A lambda expression to select subsequent collections</param>
            <returns>A collection with the results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SelectMany``2(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Flattens the given collection of collections where the subsequent collections are selected by a predicate
            </summary>
            <typeparam name="TSource">The source element type</typeparam>
            <typeparam name="TResult">The result element type</typeparam>
            <param name="source">The current collection</param>
            <param name="selector">A lambda expression to select subsequent collections</param>
            <param name="selectorCompiled">A compiled version of the selector</param>
            <returns>A collection with the results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SetEquals``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets a value indicating whether the current collection and the given collection contain the same set of elements, regardless of their order
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="other">The given other collection</param>
            <returns>True, if both collections contain the same set of elements, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SetEquals``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Gets a value indicating whether the current collection and the given collection contain the same set of elements, regardless of their order
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="other">The given other collection</param>
            <param name="comparer">An equality comparer used to determine equality in the sets</param>
            <returns>True, if both collections contain the same set of elements, otherwise False</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SingleOrDefault``1(NMF.Expressions.INotifyEnumerable{``0})">
            <summary>
            Gets the single item of the given source collection or the item type default value, if the collection is empty
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <returns>The single item of the collection or the type default value, if the collection is empty</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.SingleOrDefault``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Gets the first item of the given source collection that matches the given predicate or the item type default value, if the collection is empty or no item matches the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <param name="source">The source collection</param>
            <param name="predicate">The filter predicate</param>
            <returns>The first item of the collection that matches the predicate or the type default value</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Int32})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Int64})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Single})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Double})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Decimal})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Single}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Double}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum(NMF.Expressions.INotifyEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Gets the sum of the current collection
            </summary>
            <param name="source">The collection of numbers</param>
            <returns>The sum of the numbers contained in this collection</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Sum``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})">
            <summary>
            Gets the sum of the current collections features
            </summary>
            <param name="source">The collection of numbers</param>
            <param name="selector">A lambda expression to represent the feature to be summed up</param>
            <returns>The sum of the numbers contained in this collection elements features</returns>
            <remarks>This method has an observable proxy, i.e. it can be used in a observable expression</remarks>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.ThenBy``2(NMF.Expressions.IOrderableNotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given orderable collection by the given predicate ascending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.ThenBy``2(NMF.Expressions.IOrderableNotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given orderable collection by the given predicate ascending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <param name="comparer">A comparer to determine comparison</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.ThenByDescending``2(NMF.Expressions.IOrderableNotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders the given orderable collection by the given predicate descending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.ThenByDescending``2(NMF.Expressions.IOrderableNotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Orders the given orderable collection by the given predicate descending
            </summary>
            <typeparam name="TItem">The elements type</typeparam>
            <typeparam name="TKey">The ordering key type</typeparam>
            <param name="source">The current collection</param>
            <param name="keySelector">A lambda expression to select the features used for ordering</param>
            <param name="comparer">A comparer to determine comparison</param>
            <returns>A collection with the elements of the current collection but ordered in lower priority for the given predicate</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.TopX``2(NMF.Expressions.INotifyEnumerable{``0},System.Int32,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the top x elements of the given collection, ordered by the given feature
            </summary>
            <typeparam name="TItem">The item type</typeparam>
            <typeparam name="TKey">The key type</typeparam>
            <param name="source">The element source</param>
            <param name="x">A number indicating how many items should be selected</param>
            <param name="keySelector">An expression to denote the selection of key features</param>
            <returns>An array with the largest entries of the underlying collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.TopX``2(NMF.Expressions.INotifyEnumerable{``0},System.Int32,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})">
            <summary>
            Gets the top x elements of the given collection, ordered by the given feature
            </summary>
            <typeparam name="TItem">The item type</typeparam>
            <typeparam name="TKey">The key type</typeparam>
            <param name="source">The element source</param>
            <param name="x">A number indicating how many items should be selected</param>
            <param name="keySelector">An expression to denote the selection of key features</param>
            <param name="comparer">A custom comparer</param>
            <returns>An array with the largest entries of the underlying collection</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Union``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Unions the current collection with the given other collection 
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <param name="source">The current collection</param>
            <param name="source2">The given other collection</param>
            <returns>A collection containing the union of both collections</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Union``1(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Unions the current collection with the given other collection 
            </summary>
            <typeparam name="TSource">The elements type</typeparam>
            <param name="source">The current collection</param>
            <param name="source2">The given other collection</param>
            <param name="comparer">A comparer to determine equality</param>
            <returns>A collection containing the union of both collections</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Where``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Where``1(NMF.Expressions.INotifyEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Func{``0,System.Boolean})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <param name="filterCompiled">A compiled version of filter</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Where``1(NMF.Expressions.INotifyCollection{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.Where``1(NMF.Expressions.INotifyCollection{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Func{``0,System.Boolean})">
            <summary>
            Filters the given collection with the given predicate
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="filter">The predicate used for filtering</param>
            <param name="filterCompiled">A compiled version of filter</param>
            <returns>A collection containing the elements that passed the filter</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.WithUpdates``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches updates of the given collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <returns>The same collection as INotifyEnumerable</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.WithUpdates``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Fetches updates of the given collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <param name="failIfNoOnCollectionChanged">If true, an exception is thrown if no collection changes can be obtained for the given collection, otherwise null is returned in this case.</param>
            <returns>The same collection as INotifyEnumerable</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensions.WithUpdates``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Fetches updates of the given collection
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="source">The current collection</param>
            <returns>The same collection as INotifyEnumerable</returns>
        </member>
        <member name="T:NMF.Expressions.Linq.ObservableAggregate`3">
            <summary>
            Denotes an abstract class for an aggregator incrementalization
            </summary>
            <typeparam name="TSource">The source type of elements</typeparam>
            <typeparam name="TAccumulator">The accumulator used</typeparam>
            <typeparam name="TResult">The result type</typeparam>
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableAggregate`3.Accumulator">
            <summary>
            Gets the current accumulator
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableAggregate`3.#ctor(NMF.Expressions.INotifyEnumerable{`0},`1)">
            <summary>
            Creates a new instance
            </summary>
            <param name="source">The incrementalized source collection</param>
            <param name="accumulator">The initial value for the accumulator</param>
            <exception cref="T:System.ArgumentNullException">Thrown if source is null</exception>
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableAggregate`3.Source">
            <summary>
            Gets the source collection
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableAggregate`3.ResetAccumulator">
            <summary>
            Resets the accumulator
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableAggregate`3.RemoveItem(`0)">
            <summary>
            Removes the given item
            </summary>
            <param name="item">the item</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableAggregate`3.AddItem(`0)">
            <summary>
            Adds the given item
            </summary>
            <param name="item">the item</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableAggregate`3.Attach">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableAggregate`3.Detach">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableAggregate`3.Notify(System.Collections.Generic.IList{NMF.Expressions.INotificationResult})">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableAggregate`3.Dependencies">
            <inheritdoc />
        </member>
        <member name="T:NMF.Expressions.Linq.ObservableEnumerable`1">
            <summary>
            Denotes an abstract base class for collection-valued DDG nodes
            </summary>
            <typeparam name="T">The type of elements</typeparam>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnAddItem(`0,System.Int32)">
            <summary>
            Raises the collection changed event for an added item
            </summary>
            <param name="item">The item that is added</param>
            <param name="index">The index at which the item is added or -1</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnAddItems(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Raises the collection changed event for added items
            </summary>
            <param name="items">The items that are added</param>
            <param name="index">The start index at which items are added</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.RaiseEvents(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Raises the events for the collections of changes
            </summary>
            <param name="added">A list of the added items</param>
            <param name="removed">A list of the removed items</param>
            <param name="moved">A list of the moved items</param>
            <param name="oldItemsStartIndex">the start index of old items or -1</param>
            <param name="newItemsStartIndex">the start index of new items or -1</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnRemoveItem(`0,System.Int32)">
            <summary>
            Raises the event that an item was removed
            </summary>
            <param name="item">The item that was removed</param>
            <param name="index">The index at which the item was removed or -1</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnRemoveItems(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Raises the event that items were removed
            </summary>
            <param name="items">The items that have been removed</param>
            <param name="index">The index at which items have been removed</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnReplaceItems(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Raises the event that items were replaced
            </summary>
            <param name="oldItems">the old items</param>
            <param name="newItems">the new items</param>
            <param name="index">the index at which the items have been replaced</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnCleared">
            <summary>
            Raises the event that the collection was cleared
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnReplaceItem(`0,`0,System.Int32)">
            <summary>
            Raises the event that the item was replaced
            </summary>
            <param name="item">the new item</param>
            <param name="old">the old item</param>
            <param name="index">the index of the elemnt or -1</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnMoveItem(`0,System.Int32,System.Int32)">
            <summary>
            Raises the event that the item was moved
            </summary>
            <param name="item">the moved item</param>
            <param name="oldIndex">the old index</param>
            <param name="newIndex">the new index</param>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnMoveItems(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32)">
            <summary>
            Raises the event that the items were moved
            </summary>
            <param name="items">the moved items</param>
            <param name="oldIndex">the old index</param>
            <param name="newIndex">the new index</param>
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.HasEventSubscriber">
            <summary>
            Indicates whether the collection has event subscribers attached
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises a collection changed event
            </summary>
            <param name="e">the event data</param>
        </member>
        <member name="E:NMF.Expressions.Linq.ObservableEnumerable`1.CollectionChanged">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Clear">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.Count">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.Successors">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.Dependencies">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.ExecutionMetaData">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.HasSuccessors">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.IsAttached">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.NMF#Expressions#ISuccessorList#Count">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.Linq.ObservableEnumerable`1.AllSuccessors">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Set(NMF.Expressions.INotifiable)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.SetDummy">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Unset(NMF.Expressions.INotifiable,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.UnsetAll">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.GetSuccessor(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnAttach">
            <summary>
            Gets called when a successor attaches and there was no successor before
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.OnDetach">
            <summary>
            Gets called when the last successor detaches
            </summary>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableEnumerable`1.Notify(System.Collections.Generic.IList{NMF.Expressions.INotificationResult})">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensionProxies.GroupBy``2(NMF.Expressions.INotifyEnumerable{``0},NMF.Expressions.ObservingFunc{``0,``1})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensionProxies.GroupByWithComparer``2(NMF.Expressions.INotifyEnumerable{``0},NMF.Expressions.ObservingFunc{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensionProxies.GroupByWithSelector``3(NMF.Expressions.INotifyEnumerable{``0},NMF.Expressions.ObservingFunc{``0,``1},NMF.Expressions.ObservingFunc{``1,System.Collections.Generic.IEnumerable{``0},``2})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensionProxies.GroupByWithSelectorAndComparer``3(NMF.Expressions.INotifyEnumerable{``0},NMF.Expressions.ObservingFunc{``0,``1},NMF.Expressions.ObservingFunc{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the given collection by the given predicate into the given result
            </summary>
            <typeparam name="TSource">The element type of the source collection</typeparam>
            <typeparam name="TKey">The type of keys used for grouping</typeparam>
            <typeparam name="TResult">The type of the result</typeparam>
            <param name="source">The source collection</param>
            <param name="keySelector">The predicate expression selecting the keys for grouping</param>
            <param name="comparer">A comparer that decides whether items are identical</param>
            <param name="resultSelector">A function to get the result element for a group</param>
            <returns>A collection of groups</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensionProxies.GroupJoin``4(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``1},NMF.Expressions.ObservingFunc{``0,``2},NMF.Expressions.ObservingFunc{``1,``2},NMF.Expressions.ObservingFunc{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>
            Joins the given collections based on keys into groups
            </summary>
            <typeparam name="TOuter">The element type of the outer collection</typeparam>
            <typeparam name="TInner">The element type of the inner collection</typeparam>
            <typeparam name="TKey">The key type to be matched</typeparam>
            <typeparam name="TResult">The resulting type</typeparam>
            <param name="outer">The outer collection</param>
            <param name="inner">The inner collection</param>
            <param name="outerKeySelector">A predicate that returns the key for each outer item</param>
            <param name="innerKeySelector">A predicate that returns the key for each inner item</param>
            <param name="resultSelector">A function that creates a result for each group of an outer item and a group of inner items</param>
            <returns>A collection of grouped results</returns>
        </member>
        <member name="M:NMF.Expressions.Linq.ObservableExtensionProxies.GroupJoinWithComparer``4(NMF.Expressions.INotifyEnumerable{``0},System.Collections.Generic.IEnumerable{``1},NMF.Expressions.ObservingFunc{``0,``2},NMF.Expressions.ObservingFunc{``1,``2},NMF.Expressions.ObservingFunc{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Joins the given collections based on keys into groups
            </summary>
            <typeparam name="TOuter">The element type of the outer collection</typeparam>
            <typeparam name="TInner">The element type of the inner collection</typeparam>
            <typeparam name="TKey">The key type to be matched</typeparam>
            <typeparam name="TResult">The resulting type</typeparam>
            <param name="outer">The outer collection</param>
            <param name="inner">The inner collection</param>
            <param name="outerKeySelector">A predicate that returns the key for each outer item</param>
            <param name="innerKeySelector">A predicate that returns the key for each inner item</param>
            <param name="comparer">A comparer to decide when two items are equal</param>
            <param name="resultSelector">A function that creates a result for each group of an outer item and a group of inner items</param>
            <returns>A collection of grouped results</returns>
        </member>
        <member name="T:NMF.Expressions.IEnumerableExpression`1">
            <summary>
            Represents a collection that can be accessed incrementally, i.e. with change notifications
            </summary>
            <typeparam name="T">The type of the elements</typeparam>
        </member>
        <member name="M:NMF.Expressions.IEnumerableExpression`1.AsNotifiable">
            <summary>
            Gets notifications for this collection
            </summary>
            <returns>A collection that will notify clients as new elements change</returns>
        </member>
        <member name="T:NMF.Expressions.IEnumerableExpression">
            <summary>
            Represents a (non-generoc) collection that can be accessed incrementally, i.e. with change notifications
            </summary>
        </member>
        <member name="M:NMF.Expressions.IEnumerableExpression.AsNotifiable">
            <summary>
            Gets notifications for this collection
            </summary>
            <returns>A collection that will notify clients as new elements change</returns>
        </member>
        <member name="T:NMF.Expressions.ICollectionExpression`1">
            <summary>
            Represents an editable collection that can be accessed incrementally, i.e. with change notifications
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NMF.Expressions.ICollectionExpression`1.AsNotifiable">
            <summary>
            Gets notifications for this collection
            </summary>
            <returns>A collection that will notify clients as new elements change</returns>
        </member>
        <member name="T:NMF.Expressions.ICollectionExpression">
            <summary>
            Represents an editable collection that can be accessed incrementally, i.e. with change notifications
            </summary>
        </member>
        <member name="T:NMF.Expressions.IOrderableEnumerableExpression`1">
            <summary>
            Represents an orderable collection that can be accessed incrementally, i.e. with change notifications
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NMF.Expressions.IOrderableEnumerableExpression`1.AsNotifiable">
            <summary>
            Gets notifications for this collection
            </summary>
            <returns>A collection that will notify clients as new elements change</returns>
        </member>
        <member name="T:NMF.Expressions.IListExpression`1">
            <summary>
            Represents a list that can be accessed incrementally, i.e. with change notifications
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NMF.Expressions.ISetExpression`1">
            <summary>
            Represents a set that can be accessed incrementally, i.e. with change notifications
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NMF.Expressions.IGroupingExpression`2">
            <summary>
            Represents a group of elements sharing a common key
            </summary>
            <typeparam name="TKey">The type of the key</typeparam>
            <typeparam name="TElement">The type of the elements</typeparam>
        </member>
        <member name="T:NMF.Expressions.INotifyEnumerable">
            <summary>
            Denotes an incremental collection
            </summary>
        </member>
        <member name="T:NMF.Expressions.INotifyEnumerable`1">
            <summary>
            Denotes an incremental collection
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="T:NMF.Expressions.IOrderableNotifyEnumerable`1">
            <summary>
            Denotes an orderable incremental collection
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="P:NMF.Expressions.IOrderableNotifyEnumerable`1.Sequences">
            <summary>
            Gets the sequences contained in this collection
            </summary>
        </member>
        <member name="M:NMF.Expressions.IOrderableNotifyEnumerable`1.GetSequenceForItem(`0)">
            <summary>
            Gets the sequence that contains the given item
            </summary>
            <param name="item">The item</param>
            <returns>The sequence in which the item is contained</returns>
        </member>
        <member name="T:NMF.Expressions.INotifyCollection`1">
            <summary>
            Denotes an incremental collection
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="T:NMF.Expressions.INotifyGrouping`2">
            <summary>
            Denotes an incremental grouping
            </summary>
            <typeparam name="TKey">The type of the key</typeparam>
            <typeparam name="TItem">The type of items</typeparam>
        </member>
        <member name="T:NMF.Expressions.INotifySplit`1">
            <summary>
            Denotes an incremental split
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="P:NMF.Expressions.INotifySplit`1.Head">
            <summary>
            Gets the head of the split
            </summary>
        </member>
        <member name="P:NMF.Expressions.INotifySplit`1.Empty">
            <summary>
            Indicates whether the split is empty
            </summary>
        </member>
        <member name="P:NMF.Expressions.INotifySplit`1.Tail">
            <summary>
            Gets the tail of the split
            </summary>
        </member>
        <member name="T:NMF.Expressions.NotifyCollection`1">
            <summary>
            Denotes a collection that listens for updates
            </summary>
            <typeparam name="T">The type of elements</typeparam>
        </member>
        <member name="P:NMF.Expressions.NotifyCollection`1.Dependencies">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.NotifyCollection`1.ExecutionMetaData">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.NotifyCollection`1.Successors">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.Notify(System.Collections.Generic.IList{NMF.Expressions.INotificationResult})">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.ToString">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.NotifyCollection`1.HasSuccessors">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.NotifyCollection`1.IsAttached">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.NotifyCollection`1.NMF#Expressions#ISuccessorList#Count">
            <inheritdoc />
        </member>
        <member name="P:NMF.Expressions.NotifyCollection`1.AllSuccessors">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.Set(NMF.Expressions.INotifiable)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.SetDummy">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.Unset(NMF.Expressions.INotifiable,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.UnsetAll">
            <inheritdoc />
        </member>
        <member name="M:NMF.Expressions.NotifyCollection`1.GetSuccessor(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:NMF.Expressions.ReverseComparer`1">
            <summary>
            Denotes a comparer that reverses another comparer
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NMF.Expressions.ReverseComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a new instance
            </summary>
            <param name="baseComparer">The inner comparer or null</param>
        </member>
        <member name="M:NMF.Expressions.ReverseComparer`1.Compare(`0,`0)">
            <inheritdoc />
        </member>
    </members>
</doc>
