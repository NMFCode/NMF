<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NMF.Transformations.Core</name>
    </assembly>
    <members>
        <member name="T:NMF.Transformations.Core.Computation">
            <summary>
            This class represents a single computation within the transformation engine of NMF.Transformations
            </summary>
            <remarks>This class is visible to public as it provides reaction to delayness</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.#ctor(NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new computation for the given transformation rule with the given input arguments
            </summary>
            <param name="transformationRule">The transformation rule responsible for the transformation of the input data</param>
            <param name="context">The transformation context, in which the computation is done</param>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.TransformationRule">
            <summary>
            Gets the transformation rule, which has been used to compute this computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.TransformationContext">
            <summary>
            Gets the context, in which the computation has been made
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.Context">
            <summary>
            Gets the computation context for this computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.InputArguments">
            <summary>
            Gets the number of input arguments
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.GetInput(System.Int32)">
            <summary>
            Gets the input argument for this computation with the given index
            </summary>
            <param name="index">The index of the input parameter</param>
            <returns>The input parameter at the ith position</returns>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.CreateInputArray">
            <summary>
            Copies the input of this computation into an array
            </summary>
            <returns>An array with the inputs</returns>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.Output">
            <summary>
            Gets the output of this computation
            </summary>
            <exception cref="T:System.InvalidOperationException">This property may throw a DelayedOutputCreationException in case that the output has been tried to access, although the output creation was delayed</exception>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.ThrowDelayedException">
            <summary>
            Throws an exception that the output has been accessed although the output of teh computation is delayed
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.MarkRequire(NMF.Transformations.Core.Computation,System.Boolean,NMF.Transformations.Core.ITransformationRuleDependency)">
            <summary>
            Marks that this computations requires another to be transformed.
            </summary>
            <param name="other">The other computation</param>
            <param name="isRequired">A value indicating whether the other computation must be execute before or after the current computation</param>
            <param name="dependency">The dependency that required this</param>
            <remarks>The default implementation does nothing, so feel free to override. This method is intended to be called by NMF.Transformations, only.</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.OutputCore">
            <summary>
            Gets or sets the output in a derived class
            </summary>
        </member>
        <member name="E:NMF.Transformations.Core.Computation.OutputInitialized">
            <summary>
            This event is fired as soon as the output of this computation is initialized
            </summary>
        </member>
        <member name="E:NMF.Transformations.Core.Computation.Computed">
            <summary>
            This event is fired as soon as the computation has been computed,
            i.e., the computation has been processed in the computation list
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.DelayOutputAtLeast(System.Byte)">
            <summary>
            Configures the computation to create its output at minimum with the given delay level
            </summary>
            <param name="delayLevel">The minimum delay level for this computation</param>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.DelayTransformationAtLeast(System.Byte)">
            <summary>
            Configures the computation to be transformed at least with the given delay level
            </summary>
            <param name="delayLevel"></param>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.OnOutputInitialized(System.EventArgs)">
            <summary>
            Fires the <see cref="E:NMF.Transformations.Core.Computation.OutputInitialized"/>-event
            </summary>
            <param name="e">The event arguments</param>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.OutputDelayLevel">
            <summary>
            Gets the output delay level
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Computation.IsDelayed">
            <summary>
            Gets a value indicating whether the output creation for this computation is delayed
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.OnComputed(System.EventArgs)">
            <summary>
            Fires the <see cref="E:NMF.Transformations.Core.Computation.Computed"/>-event
            </summary>
            <param name="e">The event arguments</param>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.Transform">
            <summary>
            Initializes the transformation output
            </summary>
            <remarks>At this point, all the transformation outputs are created (also the delayed ones), thus, the trace is fully reliable</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.CreateOutput(System.Collections.IEnumerable)">
            <summary>
            Creates the output of this transformation rule
            </summary>
            <returns>The output for this transformation under this input</returns>
            <remarks>At this point, not all of the computations have created their output and thus, the trace is not complete. Use the OutputDelayLevel-feature to have the trace contain all elements created in earlier levels</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.InitializeOutput(System.Object)">
            <summary>
            Initializes the output for the actual computation
            </summary>
            <param name="output">The intended output</param>
        </member>
        <member name="M:NMF.Transformations.Core.Computation.SetBaseComputation(NMF.Transformations.Core.Computation)">
            <summary>
            Sets the provided computation as the base computation
            </summary>
            <param name="baseComputation">The base computation</param>
            <remarks>By default, this method is blank.</remarks>
        </member>
        <member name="T:NMF.Transformations.Core.IComputationContext">
            <summary>
            This interface represents the transformation engine context information attached to a computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.IComputationContext.TransformationContext">
            <summary>
            The transformation context in which the computation is made
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.IComputationContext.MarkRequire(NMF.Transformations.Core.Computation,System.Boolean)">
            <summary>
            Mark that this computation context requires another computation context to be done
            </summary>
            <param name="other">The other computation context</param>
            <param name="isRequired">True, if the other context is a strict requirement</param>
        </member>
        <member name="P:NMF.Transformations.Core.IComputationContext.IsDelayed">
            <summary>
            Gets a value indicating whether this computation is delayed
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.IComputationContext.InitializeOutput(System.Object)">
            <summary>
            Initializes the output of this computation
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:NMF.Transformations.Core.IComputationContext.DelayOutputAtLeast(System.Byte)">
            <summary>
            Configures the computation to create its output at minimum with the given delay level
            </summary>
            <param name="delayLevel">The minimum delay level for this computation</param>
        </member>
        <member name="M:NMF.Transformations.Core.IComputationContext.DelayTransformationAtLeast(System.Byte)">
            <summary>
            Configures the computation to be transformed at least with the given delay level
            </summary>
            <param name="delayLevel"></param>
        </member>
        <member name="P:NMF.Transformations.Core.IComputationContext.MinOutputDelayLevel">
            <summary>
            Gets the minimum viable output delay level
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.IComputationContext.MinTransformDelayLevel">
            <summary>
            Gets the minimum viable transformation delay level
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.IComputationContext.ConnectWith(NMF.Transformations.Core.Computation)">
            <summary>
            Connects the computation context with the given computation
            </summary>
            <param name="computation">The computation thst is handled by this computation context</param>
        </member>
        <member name="T:NMF.Transformations.Core.ComputationContext">
            <summary>
            The default implementation for a computation context
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ComputationContext.#ctor(NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Creates a new computation context for the given transformation context
            </summary>
            <param name="context">The transformation context</param>
        </member>
        <member name="P:NMF.Transformations.Core.ComputationContext.TransformationContext">
            <summary>
            The transformation context in which the computation is made
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ComputationContext.MarkRequire(NMF.Transformations.Core.Computation,System.Boolean)">
            <summary>
            Mark that this computation context requires another computation context to be done
            </summary>
            <param name="other">The other computation context</param>
            <param name="isRequired">True, if the other context is a strict requirement</param>
        </member>
        <member name="P:NMF.Transformations.Core.ComputationContext.IsDelayed">
            <summary>
            Gets a value indicating whether the output creation for this computation is delayed
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ComputationContext.OutputDelayLevel">
            <summary>
            Gets the output delay level
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ComputationContext.DelayOutputAtLeast(System.Byte)">
            <summary>
            Configures the computation to create its output at minimum with the given delay level
            </summary>
            <param name="delayLevel">The minimum delay level for this computation</param>
        </member>
        <member name="M:NMF.Transformations.Core.ComputationContext.DelayTransformationAtLeast(System.Byte)">
            <summary>
            Configures the computation to be transformed at least with the given delay level
            </summary>
            <param name="delayLevel"></param>
        </member>
        <member name="P:NMF.Transformations.Core.ComputationContext.MinOutputDelayLevel">
            <summary>
            Gets the minimum output delay level for this cmputation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ComputationContext.MinTransformDelayLevel">
            <summary>
            Gets the minimum transformation delay level for this computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ComputationContext.DelayOutput(NMF.Transformations.Core.OutputDelay)">
            <summary>
            Delays the ouput of this computation with the given output delay
            </summary>
            <param name="delay"></param>
        </member>
        <member name="M:NMF.Transformations.Core.ComputationContext.InitializeOutput(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NMF.Transformations.Core.ComputationContext.ConnectWith(NMF.Transformations.Core.Computation)">
            <summary>
            Connects the computation context with the given computation
            </summary>
            <param name="computation">The computation thst is handled by this computation context</param>
        </member>
        <member name="T:NMF.Transformations.Core.DelayedOutputCreation">
            <summary>
            This class is used to represent delayed output creations
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.OutputDelay">
            <summary>
            Represents a delay of a computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.OutputDelay.#ctor">
            <summary>
            Creates a new output delay with the given list of persistors
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.OutputDelay.Persistors">
            <summary>
            Gets a list of persistors that need to be called as soon as the output has been created
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.OutputDelay.DelayLevel">
            <summary>
            Gets the delay level of the current delay
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.Dependency">
            <summary>
            This class represents a (non-calling) dependency
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Dependency.NeedOutput">
            <summary>
            Gets or sets a value indicating whether the dependency needs the output of the base computation set
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Dependency.ExecuteBefore">
            <summary>
            Gets or sets a value indicating whether the dependency is executed before or after the base computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Dependency.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Calls the transformation dependency for the given computation
            </summary>
            <param name="computation">The computation that this dependency is to be called</param>
        </member>
        <member name="T:NMF.Transformations.Core.Transformation">
            <summary>
            This is the base class for transformations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.CreateRules">
            <summary>
            Creates the transformation rules for this transformation
            </summary>
            <returns>A collection of transformation rules</returns>
        </member>
        <member name="P:NMF.Transformations.Core.Transformation.Patterns">
            <summary>
            Gets a collection of pattern objects used within the transformation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Transformation.IsInitialized">
            <summary>
            Gets a value indicating whether the transformation has been initialized yet
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Transformation.IsRulesRegistered">
            <summary>
            Gets a value indicating whether the transformation has registered its rules requirements
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.CreateRulesInternal">
            <summary>
            Creates the rules of this transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.CreateContext">
            <summary>
            Creates a new transformation context
            </summary>
            <returns></returns>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.RegisterRules">
            <summary>
            Registers the rules of this transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.Initialize">
            <summary>
            Initializes the transformation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Transformation.MaxOutputDelay">
            <summary>
            Gets the maximum output delay level
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Transformation.MaxTransformationDelay">
            <summary>
            Gets the maximum transformation delay level
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.ComputeInstantiatingTransformationRulePath(NMF.Transformations.Core.Computation)">
            <summary>
            Computes the path of transformation rules for a given input
            </summary>
            <param name="computation">The computation for which to compute the instantiating rule path</param>
            <returns>A stack of transformation rules that are involved with the output creation. The top element of the stack should be able to instantiate the output (i.e. must not be abstract)</returns>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.GetRuleForRuleType(System.Type)">
            <summary>
            Gets the rule with the specified type (exact match)
            </summary>
            <param name="transformationRule">The type of the transformation rule</param>
            <returns>The transformation rule with this type or null, if there is none</returns>
            <remarks>This method assumes there is only one transformation rule per type</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.GetRulesForRuleType(System.Type)">
            <summary>
            Gets all rules with the specified type (exact match)
            </summary>
            <param name="transformationRule">The type of the transformation rules</param>
            <returns>A collection of all rules with this type</returns>
            <remarks>This method assumes there is only one transformation rule per type</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.GetRulesForTypeSignature(System.Type[],System.Type)">
            <summary>
            Gets all rules that apply the given signature
            </summary>
            <param name="inputTypes">The input argument type list</param>
            <param name="outputType">The output type</param>
            <returns>A collection with all the rules that have the given signature</returns>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.GetRulesExact(System.Type[],System.Type)">
            <summary>
            Gets all rules that apply the given signature exactly
            </summary>
            <param name="input">The input argument type list</param>
            <param name="output">The output type</param>
            <returns>A collection with all the rules that have the given signature</returns>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.GetRuleForTypeSignature(System.Type[],System.Type)">
            <summary>
            Gets any rules that apply the given signature
            </summary>
            <param name="inputTypes">The input argument type list</param>
            <param name="outputType">The output type</param>
            <returns>A random rule that has the given signature</returns>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.GetRulesForInputTypes(System.Type[])">
            <summary>
            Gets the applicable rules for the given input type signature
            </summary>
            <param name="input">The signature of the input types</param>
            <returns>A collection of rules that are applicable for this signature</returns>
        </member>
        <member name="P:NMF.Transformations.Core.Transformation.Rules">
            <summary>
            Gets a collection of all rules of this transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Transformation.GetRulesForTypeSignature(System.Type[],System.Type,System.Boolean)">
            <summary>
            Gets all rules that apply the given signature
            </summary>
            <param name="input">The input argument type list</param>
            <param name="output">The output type</param>
            <param name="exact">A value indicating whether the signatures must match exactly</param>
            <returns>A collection with all the rules that have the given signature</returns>
        </member>
        <member name="T:NMF.Transformations.Core.GeneralTransformationRule">
            <summary>
            This class represents the base class for a transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.#ctor">
            <summary>
            Creates a new transformation rule
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.RegisterDependencies">
            <summary>
            Registers all the dependencies (both calling and non-calling) and additional configuration
            </summary>
            <remarks>This method is called during initialization of the entire transformation and is independent of any transformation contexts. However, this method may rely on the <see cref="P:NMF.Transformations.Core.GeneralTransformationRule.Transformation"/>-property.</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.InputType">
            <summary>
            Gets the type signature of the input arguments of this transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.OutputType">
            <summary>
            Gets the type signature of the output type of this transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.CreateComputation(System.Object[],NMF.Transformations.Core.IComputationContext)">
            <summary>
            Creates a new Computation instance for this transformation rule or the given input 
            </summary>
            <param name="input">The input arguments for this computation</param>
            <param name="context">The context for this computation</param>
            <returns>A computation object</returns>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.NeedDependenciesForOutputCreation">
            <summary>
            Gets a value indicating whether the output for all dependencies must have been created before this rule creates the output
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.Transformation">
            <summary>
            Gets the transformation, that this rule is assigned to
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.Dependencies">
            <summary>
            Gets a collection of dependencies for this transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.OutputDelayLevel">
            <summary>
            Gets or sets the output delay level
            </summary>
            <remarks>The default delay level is 0. The delay level has an influence on the availability of the trace data during output creation.</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.TransformationDelayLevel">
            <summary>
            Gets or sets the transformation delay level
            </summary>
            <remarks>The default transformation delay level is 0. The delay has an influence when computations are made</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.IsUnique">
            <summary>
            Gets or sets a value indicating whether this transformation rule is unique per input and context
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.GeneralTransformationRule.BaseRule">
            <summary>
            Gets the base rule, i.e. the rule the current rule can instantiate
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.IsInstantiating(NMF.Transformations.Core.Computation)">
            <summary>
            Determines whether the current transformation rule can instantiate the output of the given computation
            </summary>
            <param name="computation">The computation that may be instantiated by the current rule</param>
            <returns>True, if the computation instantiates the given computation, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.HasCompliantInput(NMF.Transformations.Core.Computation)">
            <summary>
            Gets a value indicating whether the given computation has a compliant input to be instantiated by the current transformation rule
            </summary>
            <param name="computation">The computation that is a candidate for instantiation</param>
            <returns>True, if the input arguments match the input types of the current transformation rule, otherwise false</returns>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.Require(NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Requires the given transformation rule
            </summary>
            <param name="rule">The transformation rule that should be required</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.Call(NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Requires the given transformation rule
            </summary>
            <param name="rule">The transformation rule that should be required</param>
            <remarks>This version Always takes the input parameter as input for the dependent transformations. Thus, this method will throw an exception, if the types do not match</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.MarkInstantiatingFor(NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Marks the current transformation rule instantiating for the specified rule
            </summary>
            <param name="rule">The base transformation rule</param>
        </member>
        <member name="M:NMF.Transformations.Core.GeneralTransformationRule.MarkInstantiatingFor(NMF.Transformations.Core.GeneralTransformationRule,System.Predicate{NMF.Transformations.Core.Computation})">
            <summary>
            Marks the current transformation rule instantiating for the specified rule
            </summary>
            <param name="rule">The base transformation rule</param>
            <param name="filter">A method that filters the possible computations</param>
            <remarks>Note that in this version, the filter method is also responsible for checking the types!</remarks>
        </member>
        <member name="T:NMF.Transformations.Core.ITransformationContext">
            <summary>
            This is the basic interface for a transformation context, providing a full trace
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.IsThreadSafe">
            <summary>
            Indicates whether the transformation context is thread-safe
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Bag">
            <summary>
            Gets a Bag, where dynamic data can be added
            </summary>
            <remarks>The value of this property is an ExpandoObject, so that the bag can be easily extended with new properties</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Data">
            <summary>
            Gets a data dictionary, where data set during the transformation can be added
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Transformation">
            <summary>
            Gets the parent transformation, that the context is based upon
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Computations">
            <summary>
            Gets all computations (for custom trace purposes)
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationContext.CallTransformation(NMF.Transformations.Core.GeneralTransformationRule,System.Object[],System.Collections.IEnumerable)">
            <summary>
            Calls the given transformation with the specified input
            </summary>
            <param name="transformationRule">The rule that should be applied</param>
            <param name="context">The context in which the transformation rule is executed</param>
            <param name="input">The input for the transformation rule</param>
            <returns>The computation that handles this request</returns>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Trace">
            <summary>
            Gets the object responsible for trace operations for this transformation context
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Inputs">
            <summary>
            Gets a collection of inputs
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Input">
            <summary>
            Gets or sets the single input collection of this transformation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationContext.Outputs">
            <summary>
            Gets a collection of outputs
            </summary>
        </member>
        <member name="E:NMF.Transformations.Core.ITransformationContext.ComputationCompleted">
            <summary>
            Gets fired when a computation is done
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.TransformationContextExtensions">
            <summary>
            Extensions for the transformation context
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContextExtensions.CallTransformation(NMF.Transformations.Core.ITransformationContext,NMF.Transformations.Core.GeneralTransformationRule,System.Object[])">
            <summary>
            Calls the given transformation with the specified input
            </summary>
            <param name="context">The current transformation context</param>
            <param name="transformationRule">The rule that should be applied</param>
            <param name="input">The input for the transformation rule</param>
            <returns>The computation that handles this request</returns>
        </member>
        <member name="T:NMF.Transformations.Core.ComputationEventArgs">
            <summary>
            Represents the data for events that belong to certain computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ComputationEventArgs.#ctor(NMF.Transformations.Core.Computation)">
            <summary>
            Creates new event data for the given computation
            </summary>
            <param name="computation">The computation</param>
        </member>
        <member name="P:NMF.Transformations.Core.ComputationEventArgs.Computation">
            <summary>
            Gets the computation
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.ITransformationEngineContext">
            <summary>
            Denotes the transformation context of a parallel transformation engine
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationEngineContext.ExecutePending">
            <summary>
            Waits until all pending actions have been processed
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.ITransformationPattern">
            <summary>
            Represents a transformation pattern
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationPattern.CreatePattern(NMF.Transformations.Core.ITransformationContext)">
            <summary>
            Applies the current pattern to the given transformation context
            </summary>
            <param name="context">The transformation context in which the pattern should be applied</param>
            <returns>A transformation pattern context object that represents the pattern within the given transformation context</returns>
        </member>
        <member name="T:NMF.Transformations.Core.ITransformationPatternContext">
            <summary>
            Represents the application of a transformation pattern to a transformation context
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationPatternContext.Begin">
            <summary>
            Is called by the transformation context when the transformation pattern should start working
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationPatternContext.Finish">
            <summary>
            Is called by the transformation context when the transformation pass is finished for cleanup purposes
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.ITransformationRulePattern">
            <summary>
            Represents a transformation pattern that can be tied to a transformation rule
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationRulePattern.TargetRule">
            <summary>
            Gets or sets the transformation rule that is the target for the current transformation rule pattern
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.ITransformationRuleDependency">
            <summary>
            Represents an interface for dependencies for transformation rules
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationRuleDependency.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Calls the transformation dependency for the given computation
            </summary>
            <param name="computation">The computation that this dependency is to be called</param>
        </member>
        <member name="P:NMF.Transformations.Core.ITransformationRuleDependency.ExecuteBefore">
            <summary>
            Gets a value indicating whether the dependency should be executed before or after the computation is added to the computation order
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.ITransformationTrace">
            <summary>
            Represents a trace for a transformation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.RevokeEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Revokes the given computation and deletes it from the trace
            </summary>
            <param name="traceEntry">The computation that is to be revoked</param>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.PublishEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Publishes the given computation to the trace
            </summary>
            <param name="traceEntry">The computation that should be added to the trace</param>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.TraceIn(NMF.Transformations.Core.GeneralTransformationRule,System.Object[])">
            <summary>
            Traces the computation based upon the specified input with the specified transformation rule
            </summary>
            <param name="rule">The transformation rule the object was transformed with</param>
            <returns>The computation or null, if there was none</returns>
            <param name="input">The input arguments</param>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.Trace(System.Object[])">
            <summary>
            Traces the computations based upon the specified input
            </summary>
            <returns>The computations with the given inputs</returns>
            <param name="input">The input arguments</param>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.TraceManyIn(NMF.Transformations.Core.GeneralTransformationRule,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Traces the computations of the specified inputs with the specified transformation rules
            </summary>
            <param name="rule">The transformation rules that transformed the specified inputs</param>
            <param name="inputs">A collection of input arguments</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.TraceMany(System.Type[],System.Type,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Traces the computations of the specified inputs that match the given type signature
            </summary>
            <param name="inputs">A collection of input arguments</param>
            <param name="inputTypes">The input types</param>
            <param name="outputType">The output types</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.TraceAllIn(NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.Core.ITransformationTrace.TraceAll(System.Type[],System.Type)">
            <summary>
            Traces all computations that match the given type signature
            </summary>
            <param name="inputTypes">The input types</param>
            <param name="outputType">The output types</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="T:NMF.Transformations.Core.MultipleDependency">
            <summary>
            This class is used to represent dependencies on more than one child object
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.MultipleDependency.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Calls the transformation dependency for the given computation
            </summary>
            <param name="computation">The computation that this dependency is to be called</param>
        </member>
        <member name="T:NMF.Transformations.Core.MultipleItemPersistor">
            <summary>
            This class is used for persistance of multiple dependencies
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.MultipleResultAwaitingPersistor">
            <summary>
            This class is used to persist call dependencies on multiple objects, in case anything is delayed
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.MultipleResultAwaitingPersistor.Persistor">
            <summary>
            Gets the method that needs to be called
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.MultipleResultAwaitingPersistor.List">
            <summary>
            Gets the collection of dependent outputs
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.MultipleResultAwaitingPersistor.Remaining">
            <summary>
            Gets a value indicating how many outputs need to complete before the selector is called
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.MultipleResultAwaitingPersistor.Target">
            <summary>
            The output of the base computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.MultipleResultAwaitingPersistor.Persist(System.Object)">
            <summary>
            Persists the output of a computation
            </summary>
            <param name="output">The output of a computation</param>
            <remarks>This method is called by nmf transformations core</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.MultipleResultAwaitingPersistor.WaitFor(NMF.Transformations.Core.Computation)">
            <summary>
            Waits for the given computation to initialize its output
            </summary>
            <param name="comp">The computation to wait for</param>
        </member>
        <member name="T:NMF.Transformations.Core.OutputDependency">
            <summary>
            Represents a default implementation for a dependency that requires a computation to have its output initialized
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.OutputDependency.HandleReadyComputation(NMF.Transformations.Core.Computation)">
            <summary>
            Handles the computation that is ready (i.e. the output is clear)
            </summary>
            <param name="computation"></param>
        </member>
        <member name="P:NMF.Transformations.Core.OutputDependency.ExecuteBefore">
            <inheritdoc />
        </member>
        <member name="T:NMF.Transformations.Core.IPersistor">
            <summary>
            This interface is internally used to persist an output of transformation rules somehow
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.IPersistor.Persist(System.Object)">
            <summary>
            Persists the output of a computation
            </summary>
            <param name="output">The output of a computation</param>
            <remarks>This method is called by nmf transformations core</remarks>
        </member>
        <member name="T:NMF.Transformations.Core.SingleDependency">
            <summary>
            This class represents a single require- or call-after- dependency
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.SingleDependency.HandleDependency(NMF.Transformations.Core.Computation)">
            <summary>
            Calls the transformation dependency for the given computation
            </summary>
            <param name="computation">The computation that this dependency is to be called</param>
        </member>
        <member name="T:NMF.Transformations.Core.SingleItemPersistor">
            <summary>
            This class is used to call a persistor of a single dependency
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.SingleItemPersistor.Persistor">
            <summary>
            The persistor that needs to be called
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.SingleItemPersistor.Output">
            <summary>
            The output that is passed to the persistor
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.SingleItemPersistor.Persist(System.Object)">
            <summary>
            Persists the output of a computation
            </summary>
            <param name="output">The output of a computation</param>
            <remarks>This method is called by nmf transformations core</remarks>
        </member>
        <member name="T:NMF.Transformations.Core.SingleResultAwaitingPersistor">
            <summary>
            This class is used for single dependencies when something is delayed to wait for the result of the base computation or the output of the dependent computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.SingleResultAwaitingPersistor.Persistor">
            <summary>
            Gets the method that persists the output of the dependent computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.SingleResultAwaitingPersistor.Result">
            <summary>
            Gets the output of the dependent computation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.SingleResultAwaitingPersistor.Target">
            <summary>
            Gets the output of the base computation
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.SingleResultAwaitingPersistor.#ctor(System.Action{System.Object,System.Object})">
            <summary>
            Creates a new awaitor with the given persist method
            </summary>
            <param name="persistor">A method that has to be called as soon as the outputs are available</param>
        </member>
        <member name="M:NMF.Transformations.Core.SingleResultAwaitingPersistor.#ctor(System.Action{System.Object,System.Object},System.Object)">
            <summary>
            Creates a new awaitor with the given persist method
            </summary>
            <param name="persistor">A method that has to be called as soon as the outputs are available</param>
            <param name="target">The output of the base computation</param>
        </member>
        <member name="M:NMF.Transformations.Core.SingleResultAwaitingPersistor.Persist(System.Object)">
            <summary>
            Persists the output of a computation
            </summary>
            <param name="output">The output of a computation</param>
            <remarks>This method is called by nmf transformations core</remarks>
        </member>
        <member name="M:NMF.Transformations.Core.SingleResultAwaitingPersistor.WaitFor(NMF.Transformations.Core.Computation)">
            <summary>
            Waits for the given computation to initialize its output
            </summary>
            <param name="comp">The computation to wait for</param>
        </member>
        <member name="T:NMF.Transformations.Core.Trace">
            <summary>
            Represents a trace class based on a collection of computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Trace.#ctor">
            <summary>
            Creates a trace object for an empty set of computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Trace.#ctor(System.Collections.Generic.ICollection{NMF.Transformations.Core.ITraceEntry})">
            <summary>
            Creates the trace for the given collection of computations
            </summary>
            <param name="computations">The collection of computations</param>
        </member>
        <member name="P:NMF.Transformations.Core.Trace.Computations">
            <summary>
            The computations, the trace is based upon
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.Trace.RevokeEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Revokes the given computation and deletes it from the trace
            </summary>
            <param name="traceEntry">The computation that is to be revoked</param>
        </member>
        <member name="M:NMF.Transformations.Core.Trace.PublishEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Publishes the given computation to the trace
            </summary>
            <param name="traceEntry">The computation that should be added to the trace</param>
        </member>
        <member name="T:NMF.Transformations.Core.AbstractTrace">
            <summary>
            Represents the base class for traces.
            </summary>
            <remarks>All trace operations are implemented and fully functional. However, they might be accelerated using index structures.</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.AbstractTrace.Computations">
            <summary>
            The computations, the trace is based upon
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.TraceIn(NMF.Transformations.Core.GeneralTransformationRule,System.Object[])">
            <summary>
            Traces the computation based upon the specified input with the specified transformation rule
            </summary>
            <param name="rule">The transformation rule the object was transformed with</param>
            <returns>The computation or null, if there was none</returns>
            <param name="input">The input arguments</param>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.TraceAllIn(NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.Trace(System.Object[])">
            <summary>
            Traces the computations based upon the specified input
            </summary>
            <returns>The computations with the given inputs</returns>
            <param name="input">The input arguments</param>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.RevokeEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Revokes the given computation and deletes it from the trace
            </summary>
            <param name="traceEntry">The computation that is to be revoked</param>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.PublishEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Publishes the given computation to the trace
            </summary>
            <param name="traceEntry">The computation that should be added to the trace</param>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.TraceManyIn(NMF.Transformations.Core.GeneralTransformationRule,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Traces the computations of the specified inputs with the specified transformation rules
            </summary>
            <param name="rule">The transformation rules that transformed the specified inputs</param>
            <param name="inputs">A collection of input arguments</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.TraceMany(System.Type[],System.Type,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Traces the computations of the specified inputs that match the given type signature
            </summary>
            <param name="inputs">A collection of input arguments</param>
            <param name="inputTypes">The input types</param>
            <param name="outputType">The output types</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="M:NMF.Transformations.Core.AbstractTrace.TraceAll(System.Type[],System.Type)">
            <summary>
            Traces all computations that match the given type signature
            </summary>
            <param name="inputTypes">The input types</param>
            <param name="outputType">The output types</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="T:NMF.Transformations.Core.ITraceEntry">
            <summary>
            Represents a trace entry
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.ITraceEntry.GetInput(System.Int32)">
            <summary>
            Gets the input for this trace entry at the ith position
            </summary>
            <param name="index">The position index</param>
            <returns>The input at the ith position</returns>
        </member>
        <member name="P:NMF.Transformations.Core.ITraceEntry.Output">
            <summary>
            Gets the transformation output for this trace entry
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.ITraceEntry.TransformationRule">
            <summary>
            Gets the transformation rule for which the trace entry was generated
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.TraceEntryExtensions">
            <summary>
            Provides some helper functionality for tracing
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TraceEntryExtensions.CreateInputArray(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Creates a new array of input elements for the given trace entry
            </summary>
            <param name="traceEntry">The current trace entry</param>
            <returns>A new object array containing all trace entries for this trace entry</returns>
        </member>
        <member name="T:NMF.Transformations.Core.TransformationContext">
            <summary>
            This is the most important class of NMF.Transformations as it handles all the transformation
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Transformation">
            <summary>
            Gets the parent transformation, that the context is based upon
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.#ctor(NMF.Transformations.Core.Transformation)">
            <summary>
            Creates a new transformation context for the given transformation
            </summary>
            <param name="transformation">The transformation, a context should be generated for</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.CallTransformation(NMF.Transformations.Core.GeneralTransformationRule,System.Object[],System.Collections.IEnumerable)">
            <summary>
            Calls the given transformation with the specified input
            </summary>
            <param name="input">The input for the transformation rule</param>
            <param name="transformationRule">The rule that should be applied</param>
            <param name="context">The callers context</param>
            <returns>The computation that handles this request</returns>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.HandleComputation(NMF.Transformations.Core.GeneralTransformationRule,System.Object[],System.Collections.IEnumerable,System.Collections.Generic.List{NMF.Transformations.Core.ITraceEntry},NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.Computation,NMF.Transformations.Core.ComputationContext)">
            <summary>
            Handles the computation internally, i.e. calls dependencies, creates output, manages delays, etc
            </summary>
            <param name="transformationRule">The transformation rule</param>
            <param name="input">The input elements for this computation</param>
            <param name="context">The transformation context</param>
            <param name="computations">The computations for the input</param>
            <param name="originalTransformationRule">The transformation rule of the original call</param>
            <param name="comp">The computation</param>
            <param name="compCon">The computation context</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.CreateComputationContext(System.Object[],NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Creates a computation context for the given input with the given transformation rule
            </summary>
            <param name="input">The inputs</param>
            <param name="rule">The transformation rule to process these inputs</param>
            <returns>A computation context</returns>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.AddTraceEntry(NMF.Transformations.Core.Computation)">
            <summary>
            Creates a trace entry for the given computation object
            </summary>
            <remarks>Override for custom trace entries. A null-check for the argument is not required.</remarks>
            <param name="computation">The computation that needs to be added to the trace</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.ExecutePendingComputations">
            <summary>
            Executes all computations registered,but not already handled
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.ExecuteLevel(System.Collections.Generic.IList{NMF.Transformations.Core.Computation})">
            <summary>
            Executes all computations of the given level
            </summary>
            <param name="computationsOfLevel">The computations of the given level</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.CreateDelayedOutputs">
            <summary>
            Creates the outputs of all delayed computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.GetRules(System.Type[],System.Type)">
            <summary>
            Gets all rules that apply the given signature
            </summary>
            <param name="input">The input argument type list</param>
            <param name="output">The output type</param>
            <returns>A collection with all the rules that have the given signature</returns>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.GetRule(System.Type[],System.Type)">
            <summary>
            Gets any rules that apply the given signature
            </summary>
            <param name="input">The input argument type list</param>
            <param name="output">The output type</param>
            <returns>A random rule that has the given signature</returns>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Bag">
            <summary>
            Gets a Bag, where dynamic data can be added
            </summary>
            <remarks>The value of this property is an ExpandoObject, so that the bag can be easily extended with new properties</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Data">
            <summary>
            Gets a data dictionary, where data set during the transformation can be added
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.TransformationContext.TransformationContextTrace">
            <summary>
            Represents the trace class for TransformationContext
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.#ctor(NMF.Transformations.Core.TransformationContext)">
            <summary>
            Creates a new trace class for the given TraceContext
            </summary>
            <param name="context">The trace class for which the trace should be generated</param>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.Computations">
            <summary>
            Gets a collection of the underlying computations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.Trace(System.Object[])">
            <summary>
            Traces the computations based upon the specified input
            </summary>
            <returns>The computations with the given inputs</returns>
            <param name="input">The input arguments</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.TraceManyIn(NMF.Transformations.Core.GeneralTransformationRule,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Traces the computations of the specified inputs with the specified transformation rules
            </summary>
            <param name="rule">The transformation rules that transformed the specified inputs</param>
            <param name="inputs">A collection of input arguments</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.TraceIn(NMF.Transformations.Core.GeneralTransformationRule,System.Object[])">
            <summary>
            Traces the computation based upon the specified input with the specified transformation rule
            </summary>
            <param name="rule">The transformation rule the object was transformed with</param>
            <returns>The computation or null, if there was none</returns>
            <param name="input">The input arguments</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.TraceMany(System.Type[],System.Type,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>
            Traces the computations of the specified inputs that match the given type signature
            </summary>
            <param name="inputs">A collection of input arguments</param>
            <param name="inputTypes">The input types</param>
            <param name="outputType">The output types</param>
            <returns>A collection of computations</returns>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.TraceAllIn(NMF.Transformations.Core.GeneralTransformationRule)">
            <summary>
            Traces all computations with any inputs that math the given filters with the specified transformation rule
            </summary>
            <param name="rule">The transformation rule</param>
            <returns>A collection with all computations made under these circumstances</returns>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.RevokeEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Revokes the given computation and deletes it from the trace
            </summary>
            <param name="traceEntry">The computation that is to be revoked</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.TransformationContextTrace.PublishEntry(NMF.Transformations.Core.ITraceEntry)">
            <summary>
            Publishes the given computation to the trace
            </summary>
            <param name="traceEntry">The computation that should be added to the trace</param>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.ExecutePending">
            <summary>
            Calls the transformation context to finish any things yet undone
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.CallPendingDependencies">
            <summary>
            Calls dependencies of transformations executed so far
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Computations">
            <summary>
            Gets all computations (for custom trace purposes)
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Trace">
            <summary>
            Gets the object responsible for trace operations for this transformation context
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Input">
            <summary>
            Gets the input of the transformation context
            </summary>
            <remarks>If the transformation has multiple inputs, this returns the first input</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Inputs">
            <summary>
            Gets a collection of inputs
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Output">
            <summary>
            Gets the output of the transformation context
            </summary>
            <remarks>If the transformation has multiple outputs, this property returns the first output</remarks>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.Outputs">
            <summary>
            Gets a collection of outputs
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationContext.OnComputationCompleted(NMF.Transformations.Core.ComputationEventArgs)">
            <summary>
            Fires the ComputationCompleted event with the given event data
            </summary>
            <param name="e">The event data</param>
        </member>
        <member name="E:NMF.Transformations.Core.TransformationContext.ComputationCompleted">
            <summary>
            Gets fired when a computation completes
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.TransformationContext.NMF#Transformations#Core#ITransformationContext#IsThreadSafe">
            <summary>
            Gets a value indicating whether calls to this transformation context implementation are thread-safe
            </summary>
        </member>
        <member name="T:NMF.Transformations.Core.TransformationRunner">
            <summary>
            Service class to run transformations
            </summary>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationRunner.Transform(System.Object[],System.Collections.IEnumerable,NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <param name="input">The input arguments as an array. This must not be null. The correct amount of parameters depends on the rule to start with.</param>
            <param name="inputContext">The context in which the transformation rule is executed</param>
            <param name="startRule">The start rule to begin with (must not be null)</param>
            <param name="context">The transformation context (must not be null)</param>
            <returns>The transformation computation</returns>
        </member>
        <member name="M:NMF.Transformations.Core.TransformationRunner.TransformMany(System.Collections.Generic.IEnumerable{System.Object[]},System.Collections.IEnumerable,NMF.Transformations.Core.GeneralTransformationRule,NMF.Transformations.Core.ITransformationEngineContext)">
            <summary>
            Transforms the input argument into an output using the provided transformation
            </summary>
            <param name="inputs">The input arguments as an array. This must not be null. The correct amount of parameters depends on the rule to start with.</param>
            <param name="inputContext">The context object in which the transformation is run</param>
            <param name="startRule">The start rule to begin with (must not be null)</param>
            <param name="context">The transformation context (must not be null)</param>
            <returns>The transformation computations</returns>
        </member>
        <member name="T:NMF.Transformations.Core.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ErrComputationOutputDelayed">
            <summary>
              Looks up a localized string similar to The output of this computation has been delayed. Please subscribe to the OutputInitialized event to get informed when the Output has been created. If you were using the trace functionality, consider using the Trace methods to get the computation objects and wait until the output has been created. Alternatively, change the structure of your transformation rules to ensure that this computation has been initialized when you are making your request..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ErrMarkInstantiatingForMustInherit">
            <summary>
              Looks up a localized string similar to To instantiate a transformation rule, the current transformation rule must be an assignable of the specified transformation rule..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ErrMarkInstantiatingForOneRuleAtMost">
            <summary>
              Looks up a localized string similar to The rule already instantiates another rule. Transformation rules must not instantiate multiple other transformation rules..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ErrRequiresTransNoSelectorMustInherit">
            <summary>
              Looks up a localized string similar to To require a transformation rule without specifying a selector, the current transformation rule must be assignable of the specified transformation rule..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ErrTransformationCreateRulesNull">
            <summary>
              Looks up a localized string similar to The collection of created rules returned a null instance. This is not allowed. Please change the implementation to return a meaningful collection of transformation rules..
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ErrTransformationSetIsInitializedNoRulesRegistered">
            <summary>
              Looks up a localized string similar to The rules must be created and registered, before the transformation can be set initialized.
            </summary>
        </member>
        <member name="P:NMF.Transformations.Core.Properties.Resources.ErrTransformationSetIsRulesInitializedNoRulesCreated">
            <summary>
              Looks up a localized string similar to The rules must be created, before they can be set initialized..
            </summary>
        </member>
    </members>
</doc>
