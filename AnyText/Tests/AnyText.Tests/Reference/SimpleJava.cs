//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.AnyText;
using NMF.AnyText.Grammars;
using NMF.AnyText.Model;
using NMF.AnyText.PrettyPrinting;
using NMF.AnyText.Rules;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;


namespace AnyText.Tests.SimpleJava
{


    /// <summary>
    /// Denotes a class capable to parse the language simplejava
    /// </summary>
    public partial class SimpleJavaGrammar : ReflectiveGrammar
    {

        /// <summary>
        /// Gets the language id for this grammar
        /// </summary>
        public override string LanguageId
        {
            get
            {
                return "simplejava";
            }
        }

        /// <summary>
        /// Gets the root rule
        /// </summary>
        /// <returns>the root rule for this grammar</returns>
        /// <param name="context">a context to resolve the root rule</param>
        protected override Rule GetRootRule(GrammarContext context)
        {
            return context.ResolveRule<CodeUnitRule>();
        }

        /// <summary>
        /// A rule class representing the rule &apos;CodeUnit&apos;
        /// </summary>
        public partial class CodeUnitRule : ModelElementRule<CodeUnit>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("package"),
                        context.ResolveFormattedRule<CodeUnitPackageQualifiedIdentifierRule>(),
                        context.ResolveKeyword(";", FormattingInstruction.Newline),
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<CodeUnitImportsImportRule>(), FormattingInstruction.Newline),
                        context.ResolveFormattedRule<CodeUnitTypesTypeDeclarationRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Import&apos;
        /// </summary>
        public partial class ImportRule : ModelElementRule<Import>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("import"),
                        context.ResolveFormattedRule<ImportImportedPackageQualifiedIdentifierRule>(),
                        context.ResolveKeyword(";", FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;TypeDeclaration&apos;
        /// </summary>
        public partial class TypeDeclarationRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<ClassDeclarationRule>(),
                        context.ResolveRule<InterfaceDeclarationRule>(),
                        context.ResolveRule<EnumDeclarationRule>(),
                        context.ResolveRule<AnnotationDeclarationRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ClassDeclaration&apos;
        /// </summary>
        public partial class ClassDeclarationRule : ModelElementRule<ClassDeclaration>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<ClassDeclarationModifiersModifierRule>()),
                        context.ResolveKeyword("class"),
                        context.ResolveFormattedRule<ClassDeclarationNameIdentifierRule>(),
                        context.ResolveFormattedRule<TypeParametersRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("extends"), context.ResolveFormattedRule<ClassDeclarationSuperClassTypeReferenceRule>())),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("implements"), context.ResolveFormattedRule<ClassDeclarationImplementsTypeReferenceRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<ClassDeclarationImplementsTypeReferenceRule>())))),
                        context.ResolveFormattedRule<ClassBodyRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;TypeParameters&apos;
        /// </summary>
        public partial class TypeParametersRule : QuoteRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("<", FormattingInstruction.SupressSpace), context.ResolveFormattedRule<TypeDeclarationTypeParametersTypeParameterRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<TypeDeclarationTypeParametersTypeParameterRule>(FormattingInstruction.SupressSpace))), context.ResolveKeyword(">")));
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;TypeParameter&apos;
        /// </summary>
        public partial class TypeParameterRule : ModelElementRule<TypeParameter>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<TypeParameterNameIdentifierRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("extends"), context.ResolveFormattedRule<TypeParameterExtendsTypeReferenceRule>()))};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;InterfaceDeclaration&apos;
        /// </summary>
        public partial class InterfaceDeclarationRule : ModelElementRule<InterfaceDeclaration>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<InterfaceDeclarationModifiersModifierRule>()),
                        context.ResolveKeyword("interface"),
                        context.ResolveFormattedRule<InterfaceDeclarationNameIdentifierRule>(),
                        context.ResolveFormattedRule<TypeParametersRule>(),
                        context.ResolveFormattedRule<InterfaceBodyRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;EnumDeclaration&apos;
        /// </summary>
        public partial class EnumDeclarationRule : ModelElementRule<EnumDeclaration>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<EnumDeclarationModifiersModifierRule>()),
                        context.ResolveKeyword("enum"),
                        context.ResolveFormattedRule<EnumDeclarationNameIdentifierRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("implements"), context.ResolveFormattedRule<EnumDeclarationImplementsTypeReferenceRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<EnumDeclarationImplementsTypeReferenceRule>())))),
                        context.ResolveFormattedRule<EnumBodyRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AnnotationDeclaration&apos;
        /// </summary>
        public partial class AnnotationDeclarationRule : ModelElementRule<AnnotationDeclaration>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("@interface"),
                        context.ResolveFormattedRule<AnnotationDeclarationNameIdentifierRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;TypeReference&apos;
        /// </summary>
        public partial class TypeReferenceRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<ArrayTypeReferenceRule>(),
                        context.ResolveRule<GenericTypeReferenceRule>(),
                        context.ResolveRule<PrimitiveTypeReferenceRule>(),
                        context.ResolveRule<ReferenceTypeReferenceRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ArrayTypeReference&apos;
        /// </summary>
        public partial class ArrayTypeReferenceRule : ModelElementRule<ArrayTypeReference>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<ArrayTypeReferenceBaseTypeTypeReferenceRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("[]")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;PrimitiveTypeReference&apos;
        /// </summary>
        public partial class PrimitiveTypeReferenceRule : ModelElementRule<PrimitiveTypeReference>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<PrimitiveTypeReferencePrimitiveTypePrimitiveTypeRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;GenericTypeReference&apos;
        /// </summary>
        public partial class GenericTypeReferenceRule : ModelElementRule<GenericTypeReference>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<GenericTypeReferenceBaseTypeQualifiedIdentifierRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("<", FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<GenericTypeReferenceTypeArgumentsTypeArgumentRule>(FormattingInstruction.SupressSpace),
                        RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<GenericTypeReferenceTypeArgumentsTypeArgumentRule>(FormattingInstruction.SupressSpace))),
                        context.ResolveKeyword(">")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;TypeArgument&apos;
        /// </summary>
        public partial class TypeArgumentRule : ModelElementRule<TypeArgument>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("?"), new ChoiceRule(context.ResolveFormattedRule<TypeArgumentIsExtendsRule>(), context.ResolveFormattedRule<TypeArgumentIsSuperRule>()))),
                        context.ResolveFormattedRule<TypeArgumentReferencedTypeTypeReferenceRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;PrimitiveType&apos;
        /// </summary>
        public partial class PrimitiveTypeRule : EnumRule<PrimitiveType>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("byte"),
                        context.ResolveKeyword("short"),
                        context.ResolveKeyword("int"),
                        context.ResolveKeyword("long"),
                        context.ResolveKeyword("float"),
                        context.ResolveKeyword("double"),
                        context.ResolveKeyword("boolean")};
                Values = new PrimitiveType[] {
                        PrimitiveType.Byte,
                        PrimitiveType.Short,
                        PrimitiveType.Integer,
                        PrimitiveType.Long,
                        PrimitiveType.Float,
                        PrimitiveType.Double,
                        PrimitiveType.Boolean};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ReferenceTypeReference&apos;
        /// </summary>
        public partial class ReferenceTypeReferenceRule : ModelElementRule<ReferenceTypeReference>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<ReferenceTypeReferenceTargetTypeClassDeclarationRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Modifier&apos;
        /// </summary>
        public partial class ModifierRule : EnumRule<Modifier>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("public"),
                        context.ResolveKeyword("protected"),
                        context.ResolveKeyword("private"),
                        context.ResolveKeyword("static"),
                        context.ResolveKeyword("abstract"),
                        context.ResolveKeyword("final"),
                        context.ResolveKeyword("native"),
                        context.ResolveKeyword("synchronized"),
                        context.ResolveKeyword("transient"),
                        context.ResolveKeyword("volatile"),
                        context.ResolveKeyword("strictfp")};
                Values = new Modifier[] {
                        Modifier.Public,
                        Modifier.Protected,
                        Modifier.Private,
                        Modifier.Static,
                        Modifier.Abstract,
                        Modifier.Final,
                        Modifier.Native,
                        Modifier.Synchronized,
                        Modifier.Transient,
                        Modifier.Volatile,
                        Modifier.StrictFp};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ClassBody&apos;
        /// </summary>
        public partial class ClassBodyRule : QuoteRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = new SequenceRule(context.ResolveKeyword("{", FormattingInstruction.Newline, FormattingInstruction.Indent), RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<ClassDeclarationMembersTypeMemberRule>(), FormattingInstruction.Unindent, FormattingInstruction.Newline), context.ResolveKeyword("}", FormattingInstruction.Newline));
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;TypeMember&apos;
        /// </summary>
        public partial class TypeMemberRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<TypeDeclarationRule>(),
                        context.ResolveRule<ConstructorDeclarationRule>(),
                        context.ResolveRule<MethodDeclarationRule>(),
                        context.ResolveRule<FieldDeclarationRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;InterfaceBody&apos;
        /// </summary>
        public partial class InterfaceBodyRule : QuoteRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = new SequenceRule(context.ResolveKeyword("{", FormattingInstruction.Newline, FormattingInstruction.Indent, FormattingInstruction.Unindent), context.ResolveKeyword("}", FormattingInstruction.Newline));
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;EnumBody&apos;
        /// </summary>
        public partial class EnumBodyRule : QuoteRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = new SequenceRule(context.ResolveKeyword("{", FormattingInstruction.Newline, FormattingInstruction.Indent), context.ResolveFormattedRule<EnumDeclarationConstantsEnumConstantRule>(), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(",", FormattingInstruction.Newline), context.ResolveFormattedRule<EnumDeclarationConstantsEnumConstantRule>())), RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<EnumDeclarationMembersTypeMemberRule>(), FormattingInstruction.Unindent, FormattingInstruction.Newline), context.ResolveKeyword("}", FormattingInstruction.Newline));
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;EnumConstant&apos;
        /// </summary>
        public partial class EnumConstantRule : ModelElementRule<EnumConstant>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<EnumConstantNameIdentifierRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("("), context.ResolveFormattedRule<EnumConstantArgumentsExpressionRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<EnumConstantArgumentsExpressionRule>())), context.ResolveKeyword(")")))};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;FieldDeclaration&apos;
        /// </summary>
        public partial class FieldDeclarationRule : ModelElementRule<FieldDeclaration>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<FieldDeclarationAnnotationsAnnotationRule>()),
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<FieldDeclarationModifiersModifierRule>()),
                        context.ResolveFormattedRule<FieldDeclarationTypeTypeReferenceRule>(),
                        context.ResolveFormattedRule<FieldDeclarationNameIdentifierRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("="), context.ResolveFormattedRule<FieldDeclarationDefaultExpressionRule>())),
                        context.ResolveKeyword(";")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MethodDeclaration&apos;
        /// </summary>
        public partial class MethodDeclarationRule : ModelElementRule<MethodDeclaration>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<MethodDeclarationAnnotationsAnnotationRule>()),
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<MethodDeclarationModifiersModifierRule>()),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("<"), context.ResolveFormattedRule<MethodDeclarationTypeParametersTypeParameterRule>(), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<MethodDeclarationTypeParametersTypeParameterRule>())), context.ResolveKeyword(">"))),
                        new ChoiceRule(context.ResolveKeyword("void"), context.ResolveFormattedRule<MethodDeclarationReturnTypeTypeReferenceRule>()),
                        context.ResolveFormattedRule<MethodDeclarationNameIdentifierRule>(),
                        context.ResolveKeyword("("),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<MethodDeclarationParametersParameterSpecificationRule>(), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<MethodDeclarationParametersParameterSpecificationRule>())))),
                        context.ResolveKeyword(")"),
                        context.ResolveFormattedRule<MethodDeclarationBodyBlockStatementRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ConstructorDeclaration&apos;
        /// </summary>
        public partial class ConstructorDeclarationRule : ModelElementRule<ConstructorDeclaration>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<ConstructorDeclarationAnnotationsAnnotationRule>()),
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<ConstructorDeclarationModifiersModifierRule>()),
                        context.ResolveFormattedRule<ConstructorDeclarationNameIdentifierRule>(),
                        context.ResolveKeyword("("),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<ConstructorDeclarationParametersParameterSpecificationRule>(), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<ConstructorDeclarationParametersParameterSpecificationRule>())))),
                        context.ResolveKeyword(")"),
                        context.ResolveFormattedRule<ConstructorDeclarationBodyBlockStatementRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ParameterSpecification&apos;
        /// </summary>
        public partial class ParameterSpecificationRule : ModelElementRule<ParameterSpecification>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<ParameterSpecificationAnnotationsAnnotationRule>()),
                        RuleFormatter.ZeroOrOne(context.ResolveFormattedRule<ParameterSpecificationIsFinalRule>()),
                        context.ResolveFormattedRule<ParameterSpecificationTypeTypeReferenceRule>(),
                        context.ResolveFormattedRule<ParameterSpecificationNameIdentifierRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Annotation&apos;
        /// </summary>
        public partial class AnnotationRule : ModelElementRule<Annotation>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("@"),
                        context.ResolveFormattedRule<AnnotationNameQualifiedIdentifierRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("("), RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<AnnotationArgumentsLiteralRule>(), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<AnnotationArgumentsLiteralRule>())))), context.ResolveKeyword(")")), FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Statement&apos;
        /// </summary>
        public partial class StatementRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<WhileStatementRule>(),
                        context.ResolveRule<BlockStatementRule>(),
                        context.ResolveRule<ConditionalStatementRule>(),
                        context.ResolveRule<SwitchStatementRule>(),
                        context.ResolveRule<TryStatementRule>(),
                        context.ResolveRule<DoStatementRule>(),
                        context.ResolveRule<ContinueStatementRule>(),
                        context.ResolveRule<BreakStatementRule>(),
                        context.ResolveRule<ReturnStatementRule>(),
                        context.ResolveRule<ThrowStatementRule>(),
                        context.ResolveRule<VariableStatementRule>(),
                        context.ResolveRule<ExpressionStatementRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;VariableStatement&apos;
        /// </summary>
        public partial class VariableStatementRule : ModelElementRule<VariableStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<VariableStatementModifiersModifierRule>()),
                        context.ResolveFormattedRule<VariableStatementTypeTypeReferenceRule>(),
                        context.ResolveFormattedRule<VariableStatementNameIdentifierRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("="), context.ResolveFormattedRule<VariableStatementInitExpressionExpressionRule>()))};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;WhileStatement&apos;
        /// </summary>
        public partial class WhileStatementRule : ModelElementRule<WhileStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("while"),
                        context.ResolveKeyword("("),
                        context.ResolveFormattedRule<WhileStatementTestExpressionRule>(),
                        context.ResolveKeyword(")", FormattingInstruction.Newline),
                        context.ResolveFormattedRule<WhileStatementStatementStatementRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ConditionalStatement&apos;
        /// </summary>
        public partial class ConditionalStatementRule : ModelElementRule<ConditionalStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("if"),
                        context.ResolveKeyword("("),
                        context.ResolveFormattedRule<ConditionalStatementTestExpressionRule>(),
                        context.ResolveKeyword(")", FormattingInstruction.Newline),
                        context.ResolveFormattedRule<ConditionalStatementTrueStatementStatementRule>(FormattingInstruction.Newline),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("else", FormattingInstruction.Newline), context.ResolveFormattedRule<ConditionalStatementElseStatementStatementRule>(FormattingInstruction.Newline)))};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;DoStatement&apos;
        /// </summary>
        public partial class DoStatementRule : ModelElementRule<DoStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("do", FormattingInstruction.Newline),
                        context.ResolveFormattedRule<DoStatementDoStatementBlockStatementRule>(FormattingInstruction.Newline),
                        context.ResolveKeyword("while"),
                        context.ResolveKeyword("("),
                        context.ResolveFormattedRule<DoStatementTestExpressionExpressionRule>(),
                        context.ResolveKeyword(")")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;SwitchStatement&apos;
        /// </summary>
        public partial class SwitchStatementRule : ModelElementRule<SwitchStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("switch"),
                        context.ResolveKeyword("(", FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<SwitchStatementExpressionExpressionRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(")", FormattingInstruction.Newline),
                        context.ResolveKeyword("{", FormattingInstruction.Indent, FormattingInstruction.Newline),
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<SwitchStatementCasesSwitchCaseRule>(FormattingInstruction.Newline)),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("default", FormattingInstruction.SupressSpace), context.ResolveKeyword(":"), context.ResolveFormattedRule<SwitchStatementDefaultBlockStatementRule>(FormattingInstruction.Newline))),
                        context.ResolveKeyword("}", FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;SwitchCase&apos;
        /// </summary>
        public partial class SwitchCaseRule : ModelElementRule<SwitchCase>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("case"),
                        context.ResolveFormattedRule<SwitchCaseExpressionExpressionRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(":"),
                        context.ResolveFormattedRule<SwitchCaseStatementsBlockStatementRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;BlockStatement&apos;
        /// </summary>
        public partial class BlockStatementRule : ModelElementRule<BlockStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("{", FormattingInstruction.Indent, FormattingInstruction.Newline),
                        RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveFormattedRule<BlockStatementStatementsStatementRule>(FormattingInstruction.SupressSpace), context.ResolveKeyword(";", FormattingInstruction.Newline)), FormattingInstruction.Unindent, FormattingInstruction.Newline),
                        context.ResolveKeyword("}", FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;TryStatement&apos;
        /// </summary>
        public partial class TryStatementRule : ModelElementRule<TryStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("try", FormattingInstruction.Newline),
                        context.ResolveFormattedRule<TryStatementTryBlockBlockStatementRule>(FormattingInstruction.Newline),
                        new ChoiceRule(context.ResolveFormattedRule<CatchClausesRule>(), new SequenceRule(RuleFormatter.ZeroOrOne(context.ResolveFormattedRule<CatchClausesRule>()), context.ResolveKeyword("finally", FormattingInstruction.Newline), context.ResolveFormattedRule<TryStatementFinallyBlockBlockStatementRule>()))};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;CatchClause&apos;
        /// </summary>
        public partial class CatchClauseRule : ModelElementRule<CatchClause>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("catch"),
                        context.ResolveKeyword("("),
                        context.ResolveFormattedRule<CatchClauseCatchTypeTypeReferenceRule>(),
                        context.ResolveFormattedRule<CatchClauseVariableNameIdentifierRule>(),
                        context.ResolveKeyword(")", FormattingInstruction.Newline),
                        context.ResolveFormattedRule<CatchClauseStatementsBlockStatementRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;CatchClauses&apos;
        /// </summary>
        public partial class CatchClausesRule : QuoteRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = RuleFormatter.OneOrMore(context.ResolveFormattedRule<TryStatementCatchClausesCatchClauseRule>(FormattingInstruction.Newline));
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ExpressionStatement&apos;
        /// </summary>
        public partial class ExpressionStatementRule : ModelElementRule<ExpressionStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<ExpressionStatementExpressionExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;BreakStatement&apos;
        /// </summary>
        public partial class BreakStatementRule : ModelElementRule<BreakStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("break")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ContinueStatement&apos;
        /// </summary>
        public partial class ContinueStatementRule : ModelElementRule<ContinueStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("continue")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ReturnStatement&apos;
        /// </summary>
        public partial class ReturnStatementRule : ModelElementRule<ReturnStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("return"),
                        RuleFormatter.ZeroOrOne(context.ResolveFormattedRule<ReturnStatementReturnExpressionExpressionRule>())};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ThrowStatement&apos;
        /// </summary>
        public partial class ThrowStatementRule : ModelElementRule<ThrowStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("throw"),
                        context.ResolveFormattedRule<ThrowStatementThrowExpressionExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;VariableDeclarationStatement&apos;
        /// </summary>
        public partial class VariableDeclarationStatementRule : ModelElementRule<VariableDeclarationStatement>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<VariableDeclarationStatementTypeTypeReferenceRule>(),
                        context.ResolveFormattedRule<VariableDeclarationStatementNameIdentifierRule>(),
                        RuleFormatter.ZeroOrOne(context.ResolveFormattedRule<VariableDeclarationStatementInitExpressionExpressionRule>())};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Expression&apos;
        /// </summary>
        public partial class ExpressionRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<AssignmentExpressionRule>(),
                        context.ResolveRule<LogicalRule>(),
                        context.ResolveRule<LambdaExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;LambdaExpression&apos;
        /// </summary>
        public partial class LambdaExpressionRule : ModelElementRule<LambdaExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        new ChoiceRule(context.ResolveFormattedRule<LambdaExpressionParameterIdentifierRule>(), new SequenceRule(context.ResolveKeyword("(", FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<LambdaExpressionParameterIdentifierRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<LambdaExpressionParameterIdentifierRule>(FormattingInstruction.SupressSpace))))), context.ResolveKeyword(")"))),
                        context.ResolveKeyword("->"),
                        new ChoiceRule(context.ResolveFormattedRule<LambdaExpressionReturnExpressionExpressionRule>(), context.ResolveFormattedRule<LambdaExpressionBodyBlockStatementRule>())};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AssignmentExpression&apos;
        /// </summary>
        public partial class AssignmentExpressionRule : ModelElementRule<AssignmentExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<AssignmentExpressionLeftExpressionRule>(),
                        context.ResolveFormattedRule<AssignmentExpressionAssignmentAssignmentOperatorRule>(),
                        context.ResolveFormattedRule<AssignmentExpressionValueExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AssignmentOperator&apos;
        /// </summary>
        public partial class AssignmentOperatorRule : EnumRule<AssignmentOperator>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("="),
                        context.ResolveKeyword("+="),
                        context.ResolveKeyword("-="),
                        context.ResolveKeyword("/="),
                        context.ResolveKeyword("&="),
                        context.ResolveKeyword("|="),
                        context.ResolveKeyword("^="),
                        context.ResolveKeyword("%="),
                        context.ResolveKeyword("<<="),
                        context.ResolveKeyword(">>="),
                        context.ResolveKeyword(">>>=")};
                Values = new AssignmentOperator[] {
                        AssignmentOperator.Assign,
                        AssignmentOperator.AddAssign,
                        AssignmentOperator.SubtractAssign,
                        AssignmentOperator.DivideAssign,
                        AssignmentOperator.AndAssign,
                        AssignmentOperator.OrAssign,
                        AssignmentOperator.XorAssign,
                        AssignmentOperator.ModAssign,
                        AssignmentOperator.LeftShiftAssign,
                        AssignmentOperator.RightShiftAssign,
                        AssignmentOperator.RightShiftOverflowAssign};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Logical&apos;
        /// </summary>
        public partial class LogicalRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<LogicalBinaryRule>(),
                        context.ResolveRule<ComparisonRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;LogicalBinary&apos;
        /// </summary>
        public partial class LogicalBinaryRule : ModelElementRule<BinaryExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<BinaryExpressionLeftLogicalRule>(),
                        context.ResolveFormattedRule<BinaryExpressionOperatorLogicalOperatorRule>(),
                        context.ResolveFormattedRule<BinaryExpressionRightLogicalRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Comparison&apos;
        /// </summary>
        public partial class ComparisonRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<ComparisonBinaryRule>(),
                        context.ResolveRule<AdditiveRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ComparisonBinary&apos;
        /// </summary>
        public partial class ComparisonBinaryRule : ModelElementRule<BinaryExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<BinaryExpressionLeftComparisonRule>(),
                        context.ResolveFormattedRule<BinaryExpressionOperatorComparisonOperatorRule>(),
                        context.ResolveFormattedRule<BinaryExpressionRightComparisonRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Additive&apos;
        /// </summary>
        public partial class AdditiveRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<AdditiveBinaryRule>(),
                        context.ResolveRule<MultiplicativeRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AdditiveBinary&apos;
        /// </summary>
        public partial class AdditiveBinaryRule : ModelElementRule<BinaryExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<BinaryExpressionLeftAdditiveRule>(),
                        context.ResolveFormattedRule<BinaryExpressionOperatorAdditiveOperatorRule>(),
                        context.ResolveFormattedRule<BinaryExpressionRightAdditiveRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AdditiveOperator&apos;
        /// </summary>
        public partial class AdditiveOperatorRule : EnumRule<BinaryOperator>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("+"),
                        context.ResolveKeyword("-")};
                Values = new BinaryOperator[] {
                        BinaryOperator.Add,
                        BinaryOperator.Subtract};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;LogicalOperator&apos;
        /// </summary>
        public partial class LogicalOperatorRule : EnumRule<BinaryOperator>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("||"),
                        context.ResolveKeyword("&&"),
                        context.ResolveKeyword("|"),
                        context.ResolveKeyword("&"),
                        context.ResolveKeyword("^"),
                        context.ResolveKeyword("<<"),
                        context.ResolveKeyword(">>"),
                        context.ResolveKeyword(">>>"),
                        context.ResolveKeyword("%")};
                Values = new BinaryOperator[] {
                        BinaryOperator.OrElse,
                        BinaryOperator.AndAlso,
                        BinaryOperator.Or,
                        BinaryOperator.And,
                        BinaryOperator.Xor,
                        BinaryOperator.LeftShift,
                        BinaryOperator.RightShift,
                        BinaryOperator.RightShiftCirc,
                        BinaryOperator.Modulo};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ComparisonOperator&apos;
        /// </summary>
        public partial class ComparisonOperatorRule : EnumRule<BinaryOperator>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("=="),
                        context.ResolveKeyword("!="),
                        context.ResolveKeyword("<="),
                        context.ResolveKeyword(">="),
                        context.ResolveKeyword("<"),
                        context.ResolveKeyword(">")};
                Values = new BinaryOperator[] {
                        BinaryOperator.Equals,
                        BinaryOperator.NotEquals,
                        BinaryOperator.LessOrEqual,
                        BinaryOperator.GreaterOrEqual,
                        BinaryOperator.LessThan,
                        BinaryOperator.GreaterThan};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Multiplicative&apos;
        /// </summary>
        public partial class MultiplicativeRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<MultiplicativeBinaryRule>(),
                        context.ResolveRule<LiteralRule>(),
                        context.ResolveRule<ChainedExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ChainedExpression&apos;
        /// </summary>
        public partial class ChainedExpressionRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<MemberAccessExpressionRule>(),
                        context.ResolveRule<InvokeExpressionRule>(),
                        context.ResolveRule<IndexExpressionRule>(),
                        context.ResolveRule<ThisExpressionRule>(),
                        context.ResolveRule<SuperExpressionRule>(),
                        context.ResolveRule<NullExpressionRule>(),
                        context.ResolveRule<ObjectCreateExpressionRule>(),
                        context.ResolveRule<ArrayCreateExpressionRule>(),
                        context.ResolveRule<ArrayInitializeExpressionRule>(),
                        context.ResolveRule<VariableExpressionRule>(),
                        context.ResolveRule<ParanthesisExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ThisExpression&apos;
        /// </summary>
        public partial class ThisExpressionRule : ModelElementRule<ThisExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("this")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;SuperExpression&apos;
        /// </summary>
        public partial class SuperExpressionRule : ModelElementRule<SuperExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("super")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;NullExpression&apos;
        /// </summary>
        public partial class NullExpressionRule : ModelElementRule<NullExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("null")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MemberAccessExpression&apos;
        /// </summary>
        public partial class MemberAccessExpressionRule : ModelElementRule<MemberAccessExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<MemberAccessExpressionTargetChainedExpressionRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(".", FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<MemberAccessExpressionMemberIdentifierRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ArrayCreateExpression&apos;
        /// </summary>
        public partial class ArrayCreateExpressionRule : ModelElementRule<ArrayCreateExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("new"),
                        context.ResolveFormattedRule<ArrayCreateExpressionTypeTypeReferenceRule>(),
                        context.ResolveKeyword("[", FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<ArrayCreateExpressionSizeExpressionRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("]")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ArrayInitializeExpression&apos;
        /// </summary>
        public partial class ArrayInitializeExpressionRule : ModelElementRule<ArrayInitializeExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("new"),
                        context.ResolveFormattedRule<ArrayInitializeExpressionTypeTypeReferenceRule>(),
                        context.ResolveKeyword("[", FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("]"),
                        context.ResolveKeyword("{"),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<ArrayInitializeExpressionValuesExpressionRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<ArrayInitializeExpressionValuesExpressionRule>(FormattingInstruction.SupressSpace))))),
                        context.ResolveKeyword("}")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ObjectCreateExpression&apos;
        /// </summary>
        public partial class ObjectCreateExpressionRule : ModelElementRule<ObjectCreateExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("new"),
                        context.ResolveFormattedRule<ObjectCreateExpressionTypeTypeReferenceRule>(),
                        context.ResolveKeyword("(", FormattingInstruction.SupressSpace),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<ObjectCreateExpressionArgumentsExpressionRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<ObjectCreateExpressionArgumentsExpressionRule>(FormattingInstruction.SupressSpace))))),
                        context.ResolveKeyword(")")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;InvokeExpression&apos;
        /// </summary>
        public partial class InvokeExpressionRule : ModelElementRule<InvokeExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<InvokeExpressionTargetChainedExpressionRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("(", FormattingInstruction.SupressSpace),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<InvokeExpressionArgumentsExpressionRule>(FormattingInstruction.SupressSpace), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<InvokeExpressionArgumentsExpressionRule>(FormattingInstruction.SupressSpace))))),
                        context.ResolveKeyword(")")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;IndexExpression&apos;
        /// </summary>
        public partial class IndexExpressionRule : ModelElementRule<IndexExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<IndexExpressionTargetChainedExpressionRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("[", FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<IndexExpressionIndexExpressionRule>(FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("]")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MultiplicativeBinary&apos;
        /// </summary>
        public partial class MultiplicativeBinaryRule : ModelElementRule<BinaryExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<BinaryExpressionLeftMultiplicativeRule>(),
                        context.ResolveFormattedRule<BinaryExpressionOperatorMultiplicativeOperatorRule>(),
                        context.ResolveFormattedRule<BinaryExpressionRightMultiplicativeRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MultiplicativeOperator&apos;
        /// </summary>
        public partial class MultiplicativeOperatorRule : EnumRule<BinaryOperator>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("*"),
                        context.ResolveKeyword("/")};
                Values = new BinaryOperator[] {
                        BinaryOperator.Multiply,
                        BinaryOperator.Divide};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Literal&apos;
        /// </summary>
        public partial class LiteralRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<IntegerLiteralRule>(),
                        context.ResolveRule<DoubleLiteralRule>(),
                        context.ResolveRule<StringLiteralRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;StringLiteral&apos;
        /// </summary>
        public partial class StringLiteralRule : ModelElementRule<StringLiteral>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<StringLiteralValueStringRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;IntegerLiteral&apos;
        /// </summary>
        public partial class IntegerLiteralRule : ModelElementRule<IntegerLiteral>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<IntegerLiteralValueIntegerNumberRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;DoubleLiteral&apos;
        /// </summary>
        public partial class DoubleLiteralRule : ModelElementRule<DoubleLiteral>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<DoubleLiteralValueDoubleNumberRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;VariableExpression&apos;
        /// </summary>
        public partial class VariableExpressionRule : ModelElementRule<VariableExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<VariableExpressionVariableIdentifierRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ParanthesisExpression&apos;
        /// </summary>
        public partial class ParanthesisExpressionRule : ParanthesesRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("("),
                        context.ResolveFormattedRule<ExpressionRule>(),
                        context.ResolveKeyword(")")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;String&apos;
        /// </summary>
        public partial class StringRule : EscapedRegexRule
        {

            /// <summary>
            /// Escapes the given string
            /// </summary>
            /// <returns>the escaped string</returns>
            /// <param name="value">the unescaped string</param>
            public override string Escape(string value)
            {
                return (("\"" + value.Replace("\"", "\\\""))
                            + "\"");
            }

            /// <summary>
            /// Unescapes the given string
            /// </summary>
            /// <returns>the unescaped string</returns>
            /// <param name="value">the escaped string</param>
            public override string Unescape(string value)
            {
                return value.Substring(1, (value.Length - 2)).Replace("\\\"", "\"");
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\"([^\"]|\\\\\")*\"", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;IntegerNumber&apos;
        /// </summary>
        public partial class IntegerNumberRule : ConvertRule<int>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\\d+", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;DoubleNumber&apos;
        /// </summary>
        public partial class DoubleNumberRule : ConvertRule<double>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\\d+\\.\\d+", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Identifier&apos;
        /// </summary>
        public partial class IdentifierRule : NMF.AnyText.Rules.RegexRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\\w+", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;QualifiedIdentifier&apos;
        /// </summary>
        public partial class QualifiedIdentifierRule : NMF.AnyText.Rules.RegexRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\\w+(\\.\\w+)*", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to types
        /// </summary>
        public partial class CodeUnitTypesTypeDeclarationRule : AddAssignRule<ICodeUnit, ITypeDeclaration>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "types";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeDeclarationRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeDeclaration> GetCollection(ICodeUnit semanticElement, ParseContext context)
            {
                return semanticElement.Types;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to imports
        /// </summary>
        public partial class CodeUnitImportsImportRule : AddAssignRule<ICodeUnit, IImport>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "imports";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ImportRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IImport> GetCollection(ICodeUnit semanticElement, ParseContext context)
            {
                return semanticElement.Imports;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to package
        /// </summary>
        public partial class CodeUnitPackageQualifiedIdentifierRule : AssignRule<ICodeUnit, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "package";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<QualifiedIdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(ICodeUnit semanticElement, ParseContext context)
            {
                return semanticElement.Package;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ICodeUnit semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Package = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to importedPackage
        /// </summary>
        public partial class ImportImportedPackageQualifiedIdentifierRule : AssignRule<IImport, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "importedPackage";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<QualifiedIdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IImport semanticElement, ParseContext context)
            {
                return semanticElement.ImportedPackage;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IImport semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.ImportedPackage = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to implements
        /// </summary>
        public partial class ClassDeclarationImplementsTypeReferenceRule : AddAssignRule<IClassDeclaration, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "implements";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeReference> GetCollection(IClassDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Implements;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to superClass
        /// </summary>
        public partial class ClassDeclarationSuperClassTypeReferenceRule : AssignRule<IClassDeclaration, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "superClass";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IClassDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.SuperClass;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IClassDeclaration semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.SuperClass = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class ClassDeclarationNameIdentifierRule : AssignRule<IClassDeclaration, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IClassDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IClassDeclaration semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to modifiers
        /// </summary>
        public partial class ClassDeclarationModifiersModifierRule : AddAssignRule<IClassDeclaration, Modifier>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "modifiers";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ModifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<Modifier> GetCollection(IClassDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Modifiers;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to extends
        /// </summary>
        public partial class TypeParameterExtendsTypeReferenceRule : AssignRule<ITypeParameter, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "extends";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(ITypeParameter semanticElement, ParseContext context)
            {
                return semanticElement.Extends;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ITypeParameter semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Extends = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class TypeParameterNameIdentifierRule : AssignRule<ITypeParameter, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(ITypeParameter semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ITypeParameter semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class InterfaceDeclarationNameIdentifierRule : AssignRule<IInterfaceDeclaration, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IInterfaceDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IInterfaceDeclaration semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to modifiers
        /// </summary>
        public partial class InterfaceDeclarationModifiersModifierRule : AddAssignRule<IInterfaceDeclaration, Modifier>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "modifiers";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ModifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<Modifier> GetCollection(IInterfaceDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Modifiers;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to implements
        /// </summary>
        public partial class EnumDeclarationImplementsTypeReferenceRule : AddAssignRule<IEnumDeclaration, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "implements";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeReference> GetCollection(IEnumDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Implements;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class EnumDeclarationNameIdentifierRule : AssignRule<IEnumDeclaration, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IEnumDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IEnumDeclaration semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to modifiers
        /// </summary>
        public partial class EnumDeclarationModifiersModifierRule : AddAssignRule<IEnumDeclaration, Modifier>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "modifiers";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ModifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<Modifier> GetCollection(IEnumDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Modifiers;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class AnnotationDeclarationNameIdentifierRule : AssignRule<IAnnotationDeclaration, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IAnnotationDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IAnnotationDeclaration semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to baseType
        /// </summary>
        public partial class ArrayTypeReferenceBaseTypeTypeReferenceRule : AssignRule<IArrayTypeReference, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "baseType";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IArrayTypeReference semanticElement, ParseContext context)
            {
                return semanticElement.BaseType;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IArrayTypeReference semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.BaseType = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to primitiveType
        /// </summary>
        public partial class PrimitiveTypeReferencePrimitiveTypePrimitiveTypeRule : AssignRule<IPrimitiveTypeReference, PrimitiveType>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "primitiveType";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<PrimitiveTypeRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override PrimitiveType GetValue(IPrimitiveTypeReference semanticElement, ParseContext context)
            {
                return semanticElement.PrimitiveType;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IPrimitiveTypeReference semanticElement, PrimitiveType propertyValue, ParseContext context)
            {
                semanticElement.PrimitiveType = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to typeArguments
        /// </summary>
        public partial class GenericTypeReferenceTypeArgumentsTypeArgumentRule : AddAssignRule<IGenericTypeReference, ITypeArgument>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "typeArguments";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeArgumentRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeArgument> GetCollection(IGenericTypeReference semanticElement, ParseContext context)
            {
                return semanticElement.TypeArguments;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to baseType
        /// </summary>
        public partial class GenericTypeReferenceBaseTypeQualifiedIdentifierRule : AssignRule<IGenericTypeReference, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "baseType";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<QualifiedIdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IGenericTypeReference semanticElement, ParseContext context)
            {
                return semanticElement.BaseType;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IGenericTypeReference semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.BaseType = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to referencedType
        /// </summary>
        public partial class TypeArgumentReferencedTypeTypeReferenceRule : AssignRule<ITypeArgument, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "referencedType";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(ITypeArgument semanticElement, ParseContext context)
            {
                return semanticElement.ReferencedType;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ITypeArgument semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.ReferencedType = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to isSuper
        /// </summary>
        public partial class TypeArgumentIsSuperRule : ExistsAssignRule<ITypeArgument>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "isSuper";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveKeyword("super");
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override bool GetValue(ITypeArgument semanticElement, ParseContext context)
            {
                return semanticElement.IsSuper.GetValueOrDefault();
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ITypeArgument semanticElement, bool propertyValue, ParseContext context)
            {
                semanticElement.IsSuper = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to isExtends
        /// </summary>
        public partial class TypeArgumentIsExtendsRule : ExistsAssignRule<ITypeArgument>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "isExtends";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveKeyword("extends");
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override bool GetValue(ITypeArgument semanticElement, ParseContext context)
            {
                return semanticElement.IsExtends.GetValueOrDefault();
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ITypeArgument semanticElement, bool propertyValue, ParseContext context)
            {
                semanticElement.IsExtends = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to targetType
        /// </summary>
        public partial class ReferenceTypeReferenceTargetTypeClassDeclarationRule : AssignModelReferenceRule<IReferenceTypeReference, IClassDeclaration>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "targetType";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<QualifiedIdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IClassDeclaration GetValue(IReferenceTypeReference semanticElement, ParseContext context)
            {
                return semanticElement.TargetType;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IReferenceTypeReference semanticElement, IClassDeclaration propertyValue, ParseContext context)
            {
                semanticElement.TargetType = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to arguments
        /// </summary>
        public partial class EnumConstantArgumentsExpressionRule : AddAssignRule<IEnumConstant, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "arguments";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IExpression> GetCollection(IEnumConstant semanticElement, ParseContext context)
            {
                return semanticElement.Arguments;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class EnumConstantNameIdentifierRule : AssignRule<IEnumConstant, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IEnumConstant semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IEnumConstant semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to default
        /// </summary>
        public partial class FieldDeclarationDefaultExpressionRule : AssignRule<IFieldDeclaration, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "default";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IFieldDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Default;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IFieldDeclaration semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Default = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class FieldDeclarationNameIdentifierRule : AssignRule<IFieldDeclaration, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IFieldDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IFieldDeclaration semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to type
        /// </summary>
        public partial class FieldDeclarationTypeTypeReferenceRule : AssignRule<IFieldDeclaration, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "type";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IFieldDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Type;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IFieldDeclaration semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Type = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to modifiers
        /// </summary>
        public partial class FieldDeclarationModifiersModifierRule : AddAssignRule<IFieldDeclaration, Modifier>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "modifiers";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ModifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<Modifier> GetCollection(IFieldDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Modifiers;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to annotations
        /// </summary>
        public partial class FieldDeclarationAnnotationsAnnotationRule : AddAssignRule<IFieldDeclaration, IAnnotation>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "annotations";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AnnotationRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IAnnotation> GetCollection(IFieldDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Annotations;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to body
        /// </summary>
        public partial class MethodDeclarationBodyBlockStatementRule : AssignRule<IMethodDeclaration, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "body";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(IMethodDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Body;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMethodDeclaration semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.Body = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to parameters
        /// </summary>
        public partial class MethodDeclarationParametersParameterSpecificationRule : AddAssignRule<IMethodDeclaration, IParameterSpecification>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "parameters";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ParameterSpecificationRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IParameterSpecification> GetCollection(IMethodDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Parameters;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class MethodDeclarationNameIdentifierRule : AssignRule<IMethodDeclaration, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IMethodDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMethodDeclaration semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to returnType
        /// </summary>
        public partial class MethodDeclarationReturnTypeTypeReferenceRule : AssignRule<IMethodDeclaration, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "returnType";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IMethodDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.ReturnType;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMethodDeclaration semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.ReturnType = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to typeParameters
        /// </summary>
        public partial class MethodDeclarationTypeParametersTypeParameterRule : AddAssignRule<IMethodDeclaration, ITypeParameter>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "typeParameters";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeParameterRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeParameter> GetCollection(IMethodDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.TypeParameters;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to modifiers
        /// </summary>
        public partial class MethodDeclarationModifiersModifierRule : AddAssignRule<IMethodDeclaration, Modifier>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "modifiers";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ModifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<Modifier> GetCollection(IMethodDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Modifiers;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to annotations
        /// </summary>
        public partial class MethodDeclarationAnnotationsAnnotationRule : AddAssignRule<IMethodDeclaration, IAnnotation>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "annotations";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AnnotationRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IAnnotation> GetCollection(IMethodDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Annotations;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to body
        /// </summary>
        public partial class ConstructorDeclarationBodyBlockStatementRule : AssignRule<IConstructorDeclaration, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "body";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(IConstructorDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Body;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IConstructorDeclaration semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.Body = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to parameters
        /// </summary>
        public partial class ConstructorDeclarationParametersParameterSpecificationRule : AddAssignRule<IConstructorDeclaration, IParameterSpecification>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "parameters";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ParameterSpecificationRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IParameterSpecification> GetCollection(IConstructorDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Parameters;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class ConstructorDeclarationNameIdentifierRule : AssignRule<IConstructorDeclaration, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IConstructorDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IConstructorDeclaration semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to modifiers
        /// </summary>
        public partial class ConstructorDeclarationModifiersModifierRule : AddAssignRule<IConstructorDeclaration, Modifier>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "modifiers";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ModifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<Modifier> GetCollection(IConstructorDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Modifiers;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to annotations
        /// </summary>
        public partial class ConstructorDeclarationAnnotationsAnnotationRule : AddAssignRule<IConstructorDeclaration, IAnnotation>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "annotations";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AnnotationRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IAnnotation> GetCollection(IConstructorDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Annotations;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class ParameterSpecificationNameIdentifierRule : AssignRule<IParameterSpecification, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IParameterSpecification semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IParameterSpecification semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to type
        /// </summary>
        public partial class ParameterSpecificationTypeTypeReferenceRule : AssignRule<IParameterSpecification, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "type";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IParameterSpecification semanticElement, ParseContext context)
            {
                return semanticElement.Type;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IParameterSpecification semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Type = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to isFinal
        /// </summary>
        public partial class ParameterSpecificationIsFinalRule : ExistsAssignRule<IParameterSpecification>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "isFinal";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveKeyword("final");
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override bool GetValue(IParameterSpecification semanticElement, ParseContext context)
            {
                return semanticElement.IsFinal.GetValueOrDefault();
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IParameterSpecification semanticElement, bool propertyValue, ParseContext context)
            {
                semanticElement.IsFinal = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to annotations
        /// </summary>
        public partial class ParameterSpecificationAnnotationsAnnotationRule : AddAssignRule<IParameterSpecification, IAnnotation>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "annotations";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AnnotationRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IAnnotation> GetCollection(IParameterSpecification semanticElement, ParseContext context)
            {
                return semanticElement.Annotations;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to arguments
        /// </summary>
        public partial class AnnotationArgumentsLiteralRule : AddAssignRule<IAnnotation, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "arguments";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<LiteralRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IExpression> GetCollection(IAnnotation semanticElement, ParseContext context)
            {
                return semanticElement.Arguments;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Name
        /// </summary>
        public partial class AnnotationNameQualifiedIdentifierRule : AssignRule<IAnnotation, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<QualifiedIdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IAnnotation semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IAnnotation semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to initExpression
        /// </summary>
        public partial class VariableStatementInitExpressionExpressionRule : AssignRule<IVariableStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "initExpression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IVariableStatement semanticElement, ParseContext context)
            {
                return semanticElement.InitExpression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.InitExpression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class VariableStatementNameIdentifierRule : AssignRule<IVariableStatement, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IVariableStatement semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableStatement semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to type
        /// </summary>
        public partial class VariableStatementTypeTypeReferenceRule : AssignRule<IVariableStatement, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "type";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IVariableStatement semanticElement, ParseContext context)
            {
                return semanticElement.Type;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableStatement semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Type = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to modifiers
        /// </summary>
        public partial class VariableStatementModifiersModifierRule : AddAssignRule<IVariableStatement, Modifier>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "modifiers";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ModifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<Modifier> GetCollection(IVariableStatement semanticElement, ParseContext context)
            {
                return semanticElement.Modifiers;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to statement
        /// </summary>
        public partial class WhileStatementStatementStatementRule : AssignRule<IWhileStatement, IStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "statement";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<StatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IStatement GetValue(IWhileStatement semanticElement, ParseContext context)
            {
                return semanticElement.Statement;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IWhileStatement semanticElement, IStatement propertyValue, ParseContext context)
            {
                semanticElement.Statement = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to test
        /// </summary>
        public partial class WhileStatementTestExpressionRule : AssignRule<IWhileStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "test";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IWhileStatement semanticElement, ParseContext context)
            {
                return semanticElement.Test;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IWhileStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Test = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to elseStatement
        /// </summary>
        public partial class ConditionalStatementElseStatementStatementRule : AssignRule<IConditionalStatement, IStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "elseStatement";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<StatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IStatement GetValue(IConditionalStatement semanticElement, ParseContext context)
            {
                return semanticElement.ElseStatement;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IConditionalStatement semanticElement, IStatement propertyValue, ParseContext context)
            {
                semanticElement.ElseStatement = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to trueStatement
        /// </summary>
        public partial class ConditionalStatementTrueStatementStatementRule : AssignRule<IConditionalStatement, IStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "trueStatement";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<StatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IStatement GetValue(IConditionalStatement semanticElement, ParseContext context)
            {
                return semanticElement.TrueStatement;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IConditionalStatement semanticElement, IStatement propertyValue, ParseContext context)
            {
                semanticElement.TrueStatement = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to test
        /// </summary>
        public partial class ConditionalStatementTestExpressionRule : AssignRule<IConditionalStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "test";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IConditionalStatement semanticElement, ParseContext context)
            {
                return semanticElement.Test;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IConditionalStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Test = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to testExpression
        /// </summary>
        public partial class DoStatementTestExpressionExpressionRule : AssignRule<IDoStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "testExpression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IDoStatement semanticElement, ParseContext context)
            {
                return semanticElement.TestExpression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IDoStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.TestExpression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to doStatement
        /// </summary>
        public partial class DoStatementDoStatementBlockStatementRule : AssignRule<IDoStatement, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "doStatement";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(IDoStatement semanticElement, ParseContext context)
            {
                return semanticElement.DoStatement_;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IDoStatement semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.DoStatement_ = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to default
        /// </summary>
        public partial class SwitchStatementDefaultBlockStatementRule : AssignRule<ISwitchStatement, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "default";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(ISwitchStatement semanticElement, ParseContext context)
            {
                return semanticElement.Default;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ISwitchStatement semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.Default = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to cases
        /// </summary>
        public partial class SwitchStatementCasesSwitchCaseRule : AddAssignRule<ISwitchStatement, ISwitchCase>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "cases";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<SwitchCaseRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ISwitchCase> GetCollection(ISwitchStatement semanticElement, ParseContext context)
            {
                return semanticElement.Cases;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to expression
        /// </summary>
        public partial class SwitchStatementExpressionExpressionRule : AssignRule<ISwitchStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "expression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(ISwitchStatement semanticElement, ParseContext context)
            {
                return semanticElement.Expression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ISwitchStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Expression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to statements
        /// </summary>
        public partial class SwitchCaseStatementsBlockStatementRule : AssignRule<ISwitchCase, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "statements";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(ISwitchCase semanticElement, ParseContext context)
            {
                return semanticElement.Statements;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ISwitchCase semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.Statements = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to expression
        /// </summary>
        public partial class SwitchCaseExpressionExpressionRule : AssignRule<ISwitchCase, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "expression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(ISwitchCase semanticElement, ParseContext context)
            {
                return semanticElement.Expression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ISwitchCase semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Expression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to statements
        /// </summary>
        public partial class BlockStatementStatementsStatementRule : AddAssignRule<IBlockStatement, IStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "statements";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<StatementRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IStatement> GetCollection(IBlockStatement semanticElement, ParseContext context)
            {
                return semanticElement.Statements;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to finallyBlock
        /// </summary>
        public partial class TryStatementFinallyBlockBlockStatementRule : AssignRule<ITryStatement, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "finallyBlock";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(ITryStatement semanticElement, ParseContext context)
            {
                return semanticElement.FinallyBlock;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ITryStatement semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.FinallyBlock = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to tryBlock
        /// </summary>
        public partial class TryStatementTryBlockBlockStatementRule : AssignRule<ITryStatement, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "tryBlock";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(ITryStatement semanticElement, ParseContext context)
            {
                return semanticElement.TryBlock;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ITryStatement semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.TryBlock = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to statements
        /// </summary>
        public partial class CatchClauseStatementsBlockStatementRule : AssignRule<ICatchClause, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "statements";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(ICatchClause semanticElement, ParseContext context)
            {
                return semanticElement.Statements;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ICatchClause semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.Statements = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to variableName
        /// </summary>
        public partial class CatchClauseVariableNameIdentifierRule : AssignRule<ICatchClause, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "variableName";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(ICatchClause semanticElement, ParseContext context)
            {
                return semanticElement.VariableName;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ICatchClause semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.VariableName = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to catchType
        /// </summary>
        public partial class CatchClauseCatchTypeTypeReferenceRule : AssignRule<ICatchClause, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "catchType";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(ICatchClause semanticElement, ParseContext context)
            {
                return semanticElement.CatchType;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ICatchClause semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.CatchType = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to expression
        /// </summary>
        public partial class ExpressionStatementExpressionExpressionRule : AssignRule<IExpressionStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "expression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IExpressionStatement semanticElement, ParseContext context)
            {
                return semanticElement.Expression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IExpressionStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Expression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to returnExpression
        /// </summary>
        public partial class ReturnStatementReturnExpressionExpressionRule : AssignRule<IReturnStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "returnExpression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IReturnStatement semanticElement, ParseContext context)
            {
                return semanticElement.ReturnExpression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IReturnStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.ReturnExpression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to throwExpression
        /// </summary>
        public partial class ThrowStatementThrowExpressionExpressionRule : AssignRule<IThrowStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "throwExpression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IThrowStatement semanticElement, ParseContext context)
            {
                return semanticElement.ThrowExpression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IThrowStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.ThrowExpression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to initExpression
        /// </summary>
        public partial class VariableDeclarationStatementInitExpressionExpressionRule : AssignRule<IVariableDeclarationStatement, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "initExpression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IVariableDeclarationStatement semanticElement, ParseContext context)
            {
                return semanticElement.InitExpression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableDeclarationStatement semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.InitExpression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to name
        /// </summary>
        public partial class VariableDeclarationStatementNameIdentifierRule : AssignRule<IVariableDeclarationStatement, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "name";
                }
            }

            /// <summary>
            /// Gets the first contained rule application that represents an identifier
            /// </summary>
            public override bool IsIdentifier
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IVariableDeclarationStatement semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableDeclarationStatement semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to type
        /// </summary>
        public partial class VariableDeclarationStatementTypeTypeReferenceRule : AssignRule<IVariableDeclarationStatement, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "type";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IVariableDeclarationStatement semanticElement, ParseContext context)
            {
                return semanticElement.Type;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableDeclarationStatement semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Type = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to body
        /// </summary>
        public partial class LambdaExpressionBodyBlockStatementRule : AssignRule<ILambdaExpression, IBlockStatement>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "body";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<BlockStatementRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IBlockStatement GetValue(ILambdaExpression semanticElement, ParseContext context)
            {
                return semanticElement.Body;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ILambdaExpression semanticElement, IBlockStatement propertyValue, ParseContext context)
            {
                semanticElement.Body = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to returnExpression
        /// </summary>
        public partial class LambdaExpressionReturnExpressionExpressionRule : AssignRule<ILambdaExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "returnExpression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(ILambdaExpression semanticElement, ParseContext context)
            {
                return semanticElement.ReturnExpression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ILambdaExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.ReturnExpression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to parameter
        /// </summary>
        public partial class LambdaExpressionParameterIdentifierRule : AddAssignRule<ILambdaExpression, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "parameter";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<string> GetCollection(ILambdaExpression semanticElement, ParseContext context)
            {
                return semanticElement.Parameter;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to value
        /// </summary>
        public partial class AssignmentExpressionValueExpressionRule : AssignRule<IAssignmentExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "value";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IAssignmentExpression semanticElement, ParseContext context)
            {
                return semanticElement.Value;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IAssignmentExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Value = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to assignment
        /// </summary>
        public partial class AssignmentExpressionAssignmentAssignmentOperatorRule : AssignRule<IAssignmentExpression, AssignmentOperator>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "assignment";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AssignmentOperatorRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override AssignmentOperator GetValue(IAssignmentExpression semanticElement, ParseContext context)
            {
                return semanticElement.Assignment;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IAssignmentExpression semanticElement, AssignmentOperator propertyValue, ParseContext context)
            {
                semanticElement.Assignment = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to left
        /// </summary>
        public partial class AssignmentExpressionLeftExpressionRule : AssignRule<IAssignmentExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "left";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IAssignmentExpression semanticElement, ParseContext context)
            {
                return semanticElement.Left;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IAssignmentExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Left = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to right
        /// </summary>
        public partial class BinaryExpressionRightLogicalRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "right";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<LogicalRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Right;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Right = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to operator
        /// </summary>
        public partial class BinaryExpressionOperatorLogicalOperatorRule : AssignRule<IBinaryExpression, BinaryOperator>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "operator";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<LogicalOperatorRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override BinaryOperator GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Operator;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, BinaryOperator propertyValue, ParseContext context)
            {
                semanticElement.Operator = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to left
        /// </summary>
        public partial class BinaryExpressionLeftLogicalRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "left";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<LogicalRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Left;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Left = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to right
        /// </summary>
        public partial class BinaryExpressionRightComparisonRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "right";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ComparisonRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Right;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Right = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to operator
        /// </summary>
        public partial class BinaryExpressionOperatorComparisonOperatorRule : AssignRule<IBinaryExpression, BinaryOperator>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "operator";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ComparisonOperatorRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override BinaryOperator GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Operator;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, BinaryOperator propertyValue, ParseContext context)
            {
                semanticElement.Operator = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to left
        /// </summary>
        public partial class BinaryExpressionLeftComparisonRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "left";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ComparisonRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Left;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Left = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to right
        /// </summary>
        public partial class BinaryExpressionRightAdditiveRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "right";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AdditiveRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Right;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Right = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to operator
        /// </summary>
        public partial class BinaryExpressionOperatorAdditiveOperatorRule : AssignRule<IBinaryExpression, BinaryOperator>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "operator";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AdditiveOperatorRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override BinaryOperator GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Operator;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, BinaryOperator propertyValue, ParseContext context)
            {
                semanticElement.Operator = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to left
        /// </summary>
        public partial class BinaryExpressionLeftAdditiveRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "left";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<AdditiveRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Left;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Left = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to member
        /// </summary>
        public partial class MemberAccessExpressionMemberIdentifierRule : AssignRule<IMemberAccessExpression, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "member";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IMemberAccessExpression semanticElement, ParseContext context)
            {
                return semanticElement.Member;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMemberAccessExpression semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Member = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to target
        /// </summary>
        public partial class MemberAccessExpressionTargetChainedExpressionRule : AssignRule<IMemberAccessExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "target";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ChainedExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IMemberAccessExpression semanticElement, ParseContext context)
            {
                return semanticElement.Target;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMemberAccessExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Target = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to size
        /// </summary>
        public partial class ArrayCreateExpressionSizeExpressionRule : AssignRule<IArrayCreateExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "size";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IArrayCreateExpression semanticElement, ParseContext context)
            {
                return semanticElement.Size;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IArrayCreateExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Size = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to type
        /// </summary>
        public partial class ArrayCreateExpressionTypeTypeReferenceRule : AssignRule<IArrayCreateExpression, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "type";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IArrayCreateExpression semanticElement, ParseContext context)
            {
                return semanticElement.Type;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IArrayCreateExpression semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Type = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to values
        /// </summary>
        public partial class ArrayInitializeExpressionValuesExpressionRule : AddAssignRule<IArrayInitializeExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "values";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IExpression> GetCollection(IArrayInitializeExpression semanticElement, ParseContext context)
            {
                return semanticElement.Values;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to type
        /// </summary>
        public partial class ArrayInitializeExpressionTypeTypeReferenceRule : AssignRule<IArrayInitializeExpression, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "type";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IArrayInitializeExpression semanticElement, ParseContext context)
            {
                return semanticElement.Type;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IArrayInitializeExpression semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Type = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to arguments
        /// </summary>
        public partial class ObjectCreateExpressionArgumentsExpressionRule : AddAssignRule<IObjectCreateExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "arguments";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IExpression> GetCollection(IObjectCreateExpression semanticElement, ParseContext context)
            {
                return semanticElement.Arguments;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to type
        /// </summary>
        public partial class ObjectCreateExpressionTypeTypeReferenceRule : AssignRule<IObjectCreateExpression, ITypeReference>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "type";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeReferenceRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override ITypeReference GetValue(IObjectCreateExpression semanticElement, ParseContext context)
            {
                return semanticElement.Type;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IObjectCreateExpression semanticElement, ITypeReference propertyValue, ParseContext context)
            {
                semanticElement.Type = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to arguments
        /// </summary>
        public partial class InvokeExpressionArgumentsExpressionRule : AddAssignRule<IInvokeExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "arguments";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IExpression> GetCollection(IInvokeExpression semanticElement, ParseContext context)
            {
                return semanticElement.Arguments;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to target
        /// </summary>
        public partial class InvokeExpressionTargetChainedExpressionRule : AssignRule<IInvokeExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "target";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ChainedExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IInvokeExpression semanticElement, ParseContext context)
            {
                return semanticElement.Target;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IInvokeExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Target = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to index
        /// </summary>
        public partial class IndexExpressionIndexExpressionRule : AssignRule<IIndexExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "index";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IIndexExpression semanticElement, ParseContext context)
            {
                return semanticElement.Index;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IIndexExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Index = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to target
        /// </summary>
        public partial class IndexExpressionTargetChainedExpressionRule : AssignRule<IIndexExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "target";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<ChainedExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IIndexExpression semanticElement, ParseContext context)
            {
                return semanticElement.Target;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IIndexExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Target = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to right
        /// </summary>
        public partial class BinaryExpressionRightMultiplicativeRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "right";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<MultiplicativeRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Right;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Right = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to operator
        /// </summary>
        public partial class BinaryExpressionOperatorMultiplicativeOperatorRule : AssignRule<IBinaryExpression, BinaryOperator>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "operator";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<MultiplicativeOperatorRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override BinaryOperator GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Operator;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, BinaryOperator propertyValue, ParseContext context)
            {
                semanticElement.Operator = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to left
        /// </summary>
        public partial class BinaryExpressionLeftMultiplicativeRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "left";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<MultiplicativeRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Left;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Left = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to value
        /// </summary>
        public partial class StringLiteralValueStringRule : AssignRule<IStringLiteral, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "value";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<StringRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IStringLiteral semanticElement, ParseContext context)
            {
                return semanticElement.Value;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IStringLiteral semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Value = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to value
        /// </summary>
        public partial class IntegerLiteralValueIntegerNumberRule : AssignRule<IIntegerLiteral, int>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "value";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IntegerNumberRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override int GetValue(IIntegerLiteral semanticElement, ParseContext context)
            {
                return semanticElement.Value;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IIntegerLiteral semanticElement, int propertyValue, ParseContext context)
            {
                semanticElement.Value = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to value
        /// </summary>
        public partial class DoubleLiteralValueDoubleNumberRule : AssignRule<IDoubleLiteral, double>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "value";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<DoubleNumberRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override double GetValue(IDoubleLiteral semanticElement, ParseContext context)
            {
                return semanticElement.Value;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IDoubleLiteral semanticElement, double propertyValue, ParseContext context)
            {
                semanticElement.Value = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to variable
        /// </summary>
        public partial class VariableExpressionVariableIdentifierRule : AssignRule<IVariableExpression, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "variable";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IVariableExpression semanticElement, ParseContext context)
            {
                return semanticElement.Variable;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableExpression semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Variable = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to typeParameters
        /// </summary>
        public partial class TypeDeclarationTypeParametersTypeParameterRule : AddAssignRule<ITypeDeclaration, ITypeParameter>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "typeParameters";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeParameterRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeParameter> GetCollection(ITypeDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.TypeParameters;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to members
        /// </summary>
        public partial class ClassDeclarationMembersTypeMemberRule : AddAssignRule<IClassDeclaration, ITypeMember>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "members";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeMemberRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeMember> GetCollection(IClassDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Members;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to members
        /// </summary>
        public partial class EnumDeclarationMembersTypeMemberRule : AddAssignRule<IEnumDeclaration, ITypeMember>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "members";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<TypeMemberRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ITypeMember> GetCollection(IEnumDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Members;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to constants
        /// </summary>
        public partial class EnumDeclarationConstantsEnumConstantRule : AddAssignRule<IEnumDeclaration, IEnumConstant>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "constants";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<EnumConstantRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IEnumConstant> GetCollection(IEnumDeclaration semanticElement, ParseContext context)
            {
                return semanticElement.Constants;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to catchClauses
        /// </summary>
        public partial class TryStatementCatchClausesCatchClauseRule : AddAssignRule<ITryStatement, ICatchClause>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "catchClauses";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveFormattedRule<CatchClauseRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ICatchClause> GetCollection(ITryStatement semanticElement, ParseContext context)
            {
                return semanticElement.CatchClauses;
            }
        }
    }
}
