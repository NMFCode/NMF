//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:8.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using AnyText.Test.Metamodel.Expressions;
using NMF.AnyText;
using NMF.AnyText.Grammars;
using NMF.AnyText.Model;
using NMF.AnyText.PrettyPrinting;
using NMF.AnyText.Rules;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;


namespace AnyText.Tests.ExpressionGrammar
{


    /// <summary>
    /// Denotes a class capable to parse the language exp
    /// </summary>
    public partial class ExpressionsGrammar : ReflectiveGrammar
    {

        /// <summary>
        /// Gets the language id for this grammar
        /// </summary>
        public override string LanguageId
        {
            get
            {
                return "exp";
            }
        }

        /// <summary>
        /// Gets the root rule
        /// </summary>
        /// <returns>the root rule for this grammar</returns>
        /// <param name="context">a context to resolve the root rule</param>
        protected override Rule GetRootRule(GrammarContext context)
        {
            return context.ResolveRule<ExpressionRule>();
        }

        /// <summary>
        /// A rule class representing the rule &apos;Expression&apos;
        /// </summary>
        public partial class ExpressionRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<AdditiveBinaryRule>(),
                        context.ResolveRule<MultiplicativeRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AdditiveBinary&apos;
        /// </summary>
        public partial class AdditiveBinaryRule : ModelElementRule<BinaryExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<BinaryExpressionLeftExpressionRule>(),
                        context.ResolveFormattedRule<BinaryExpressionOperatorAdditiveOperatorRule>(),
                        context.ResolveFormattedRule<BinaryExpressionRightExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AdditiveOperator&apos;
        /// </summary>
        public partial class AdditiveOperatorRule : EnumRule<BinaryOperator>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("+"),
                        context.ResolveKeyword("-")};
                Values = new BinaryOperator[] {
                        BinaryOperator.Add,
                        BinaryOperator.Subtract};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Multiplicative&apos;
        /// </summary>
        public partial class MultiplicativeRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<MultiplicativeBinaryRule>(),
                        context.ResolveRule<LiteralExpressionRule>(),
                        context.ResolveRule<VariableExpressionRule>(),
                        context.ResolveRule<ParanthesisExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MultiplicativeBinary&apos;
        /// </summary>
        public partial class MultiplicativeBinaryRule : ModelElementRule<BinaryExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<BinaryExpressionLeftMultiplicativeRule>(),
                        context.ResolveFormattedRule<BinaryExpressionOperatorMultiplicativeOperatorRule>(),
                        context.ResolveFormattedRule<BinaryExpressionRightMultiplicativeRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MultiplicativeOperator&apos;
        /// </summary>
        public partial class MultiplicativeOperatorRule : EnumRule<BinaryOperator>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("*"),
                        context.ResolveKeyword("/")};
                Values = new BinaryOperator[] {
                        BinaryOperator.Multiply,
                        BinaryOperator.Divide};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;LiteralExpression&apos;
        /// </summary>
        public partial class LiteralExpressionRule : ModelElementRule<LiteralExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<LiteralExpressionValueNumberRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;VariableExpression&apos;
        /// </summary>
        public partial class VariableExpressionRule : ModelElementRule<VariableExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<VariableExpressionVariableIdentifierRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ParanthesisExpression&apos;
        /// </summary>
        public partial class ParanthesisExpressionRule : ParanthesesRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("("),
                        context.ResolveRule<ExpressionRule>(),
                        context.ResolveKeyword(")")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Number&apos;
        /// </summary>
        public partial class NumberRule : ConvertRule<Int32>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\\d+", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Identifier&apos;
        /// </summary>
        public partial class IdentifierRule : NMF.AnyText.Rules.RegexRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^[a-zA-Z]\\S*", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to right
        /// </summary>
        public partial class BinaryExpressionRightExpressionRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "right";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Right;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Right = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to operator
        /// </summary>
        public partial class BinaryExpressionOperatorAdditiveOperatorRule : AssignRule<IBinaryExpression, BinaryOperator>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "operator";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<AdditiveOperatorRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override BinaryOperator GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Operator;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, BinaryOperator propertyValue, ParseContext context)
            {
                semanticElement.Operator = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to left
        /// </summary>
        public partial class BinaryExpressionLeftExpressionRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "left";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<ExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Left;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Left = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to right
        /// </summary>
        public partial class BinaryExpressionRightMultiplicativeRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "right";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<MultiplicativeRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Right;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Right = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to operator
        /// </summary>
        public partial class BinaryExpressionOperatorMultiplicativeOperatorRule : AssignRule<IBinaryExpression, BinaryOperator>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "operator";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<MultiplicativeOperatorRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override BinaryOperator GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Operator;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, BinaryOperator propertyValue, ParseContext context)
            {
                semanticElement.Operator = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to left
        /// </summary>
        public partial class BinaryExpressionLeftMultiplicativeRule : AssignRule<IBinaryExpression, IExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "left";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<MultiplicativeRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IExpression GetValue(IBinaryExpression semanticElement, ParseContext context)
            {
                return semanticElement.Left;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IBinaryExpression semanticElement, IExpression propertyValue, ParseContext context)
            {
                semanticElement.Left = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to value
        /// </summary>
        public partial class LiteralExpressionValueNumberRule : AssignRule<ILiteralExpression, int>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "value";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<NumberRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override int GetValue(ILiteralExpression semanticElement, ParseContext context)
            {
                return semanticElement.Value;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ILiteralExpression semanticElement, int propertyValue, ParseContext context)
            {
                semanticElement.Value = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to variable
        /// </summary>
        public partial class VariableExpressionVariableIdentifierRule : AssignRule<IVariableExpression, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override String Feature
            {
                get
                {
                    return "variable";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IdentifierRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IVariableExpression semanticElement, ParseContext context)
            {
                return semanticElement.Variable;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IVariableExpression semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Variable = propertyValue;
            }
        }
    }
}
