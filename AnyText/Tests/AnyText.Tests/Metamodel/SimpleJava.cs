//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AnyText.Tests.SimpleJava
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Linq;
    using NMF.Expressions;
    using NMF.Expressions.Linq;
    using NMF.Models;
    using NMF.Models.Meta;
    using NMF.Models.Collections;
    using NMF.Models.Expressions;
    using NMF.Collections.Generic;
    using NMF.Collections.ObjectModel;
    using NMF.Serialization;
    using NMF.Utilities;
    using System.Collections.Specialized;
    using NMF.Models.Repository;
    
    
    /// <summary>
    /// The default implementation of the CodeUnit class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//CodeUnit")]
    public partial class CodeUnit : ModelElement, ICodeUnit, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Package property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _package;
        
        private static Lazy<ITypedElement> _packageAttribute = new Lazy<ITypedElement>(RetrievePackageAttribute);
        
        private static Lazy<ITypedElement> _typesReference = new Lazy<ITypedElement>(RetrieveTypesReference);
        
        /// <summary>
        /// The backing field for the Types property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeDeclaration> _types;
        
        private static Lazy<ITypedElement> _importsReference = new Lazy<ITypedElement>(RetrieveImportsReference);
        
        /// <summary>
        /// The backing field for the Imports property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IImport> _imports;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public CodeUnit()
        {
            this._types = new ObservableCompositionList<ITypeDeclaration>(this);
            this._types.CollectionChanging += this.TypesCollectionChanging;
            this._types.CollectionChanged += this.TypesCollectionChanged;
            this._imports = new ObservableCompositionList<IImport>(this);
            this._imports.CollectionChanging += this.ImportsCollectionChanging;
            this._imports.CollectionChanged += this.ImportsCollectionChanged;
        }
        
        /// <summary>
        /// The package property
        /// </summary>
        [DisplayNameAttribute("package")]
        [CategoryAttribute("CodeUnit")]
        [XmlElementNameAttribute("package")]
        [XmlAttributeAttribute(true)]
        public string Package
        {
            get
            {
                return this._package;
            }
            set
            {
                if ((this._package != value))
                {
                    string old = this._package;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Package", e, _packageAttribute);
                    this._package = value;
                    this.OnPropertyChanged("Package", e, _packageAttribute);
                }
            }
        }
        
        /// <summary>
        /// The types property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("types")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeDeclaration> Types
        {
            get
            {
                return this._types;
            }
        }
        
        /// <summary>
        /// The imports property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("imports")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IImport> Imports
        {
            get
            {
                return this._imports;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new CodeUnitChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new CodeUnitReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//CodeUnit")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrievePackageAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.CodeUnit.ClassInstance)).Resolve("package")));
        }
        
        private static ITypedElement RetrieveTypesReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.CodeUnit.ClassInstance)).Resolve("types")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Types property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypesCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Types", e, _typesReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Types property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Types", e, _typesReference);
        }
        
        private static ITypedElement RetrieveImportsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.CodeUnit.ClassInstance)).Resolve("imports")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Imports property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ImportsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Imports", e, _importsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Imports property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ImportsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Imports", e, _importsReference);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "PACKAGE"))
            {
                return this.Package;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "TYPES"))
            {
                return this._types;
            }
            if ((feature == "IMPORTS"))
            {
                return this._imports;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "PACKAGE"))
            {
                this.Package = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "PACKAGE"))
            {
                return new PackageProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._types))
            {
                return "types";
            }
            if ((container == this._imports))
            {
                return "imports";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//CodeUnit")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the CodeUnit class
        /// </summary>
        public class CodeUnitChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private CodeUnit _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public CodeUnitChildrenCollection(CodeUnit parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Types.Count);
                    count = (count + this._parent.Imports.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Types.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Imports.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Types.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Imports.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeDeclaration typesCasted = item.As<ITypeDeclaration>();
                if ((typesCasted != null))
                {
                    this._parent.Types.Add(typesCasted);
                }
                IImport importsCasted = item.As<IImport>();
                if ((importsCasted != null))
                {
                    this._parent.Imports.Add(importsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Types.Clear();
                this._parent.Imports.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Types.Contains(item))
                {
                    return true;
                }
                if (this._parent.Imports.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> typesEnumerator = this._parent.Types.GetEnumerator();
                try
                {
                    for (
                    ; typesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typesEnumerator.Dispose();
                }
                IEnumerator<IModelElement> importsEnumerator = this._parent.Imports.GetEnumerator();
                try
                {
                    for (
                    ; importsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = importsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    importsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeDeclaration typeDeclarationItem = item.As<ITypeDeclaration>();
                if (((typeDeclarationItem != null) 
                            && this._parent.Types.Remove(typeDeclarationItem)))
                {
                    return true;
                }
                IImport importItem = item.As<IImport>();
                if (((importItem != null) 
                            && this._parent.Imports.Remove(importItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Types).Concat(this._parent.Imports).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the CodeUnit class
        /// </summary>
        public class CodeUnitReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private CodeUnit _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public CodeUnitReferencedElementsCollection(CodeUnit parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Types.Count);
                    count = (count + this._parent.Imports.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Types.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Imports.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Types.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Imports.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeDeclaration typesCasted = item.As<ITypeDeclaration>();
                if ((typesCasted != null))
                {
                    this._parent.Types.Add(typesCasted);
                }
                IImport importsCasted = item.As<IImport>();
                if ((importsCasted != null))
                {
                    this._parent.Imports.Add(importsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Types.Clear();
                this._parent.Imports.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Types.Contains(item))
                {
                    return true;
                }
                if (this._parent.Imports.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> typesEnumerator = this._parent.Types.GetEnumerator();
                try
                {
                    for (
                    ; typesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typesEnumerator.Dispose();
                }
                IEnumerator<IModelElement> importsEnumerator = this._parent.Imports.GetEnumerator();
                try
                {
                    for (
                    ; importsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = importsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    importsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeDeclaration typeDeclarationItem = item.As<ITypeDeclaration>();
                if (((typeDeclarationItem != null) 
                            && this._parent.Types.Remove(typeDeclarationItem)))
                {
                    return true;
                }
                IImport importItem = item.As<IImport>();
                if (((importItem != null) 
                            && this._parent.Imports.Remove(importItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Types).Concat(this._parent.Imports).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the package property
        /// </summary>
        private sealed class PackageProxy : ModelPropertyChange<ICodeUnit, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public PackageProxy(ICodeUnit modelElement) : 
                    base(modelElement, "package")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Package;
                }
                set
                {
                    this.ModelElement.Package = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the Import class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Import")]
    public partial class Import : ModelElement, IImport, IModelElement
    {
        
        /// <summary>
        /// The backing field for the ImportedPackage property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _importedPackage;
        
        private static Lazy<ITypedElement> _importedPackageAttribute = new Lazy<ITypedElement>(RetrieveImportedPackageAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The importedPackage property
        /// </summary>
        [DisplayNameAttribute("importedPackage")]
        [CategoryAttribute("Import")]
        [XmlElementNameAttribute("importedPackage")]
        [XmlAttributeAttribute(true)]
        public string ImportedPackage
        {
            get
            {
                return this._importedPackage;
            }
            set
            {
                if ((this._importedPackage != value))
                {
                    string old = this._importedPackage;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ImportedPackage", e, _importedPackageAttribute);
                    this._importedPackage = value;
                    this.OnPropertyChanged("ImportedPackage", e, _importedPackageAttribute);
                }
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Import")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveImportedPackageAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.Import.ClassInstance)).Resolve("importedPackage")));
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "IMPORTEDPACKAGE"))
            {
                return this.ImportedPackage;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "IMPORTEDPACKAGE"))
            {
                this.ImportedPackage = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "IMPORTEDPACKAGE"))
            {
                return new ImportedPackageProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Import")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the importedPackage property
        /// </summary>
        private sealed class ImportedPackageProxy : ModelPropertyChange<IImport, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ImportedPackageProxy(IImport modelElement) : 
                    base(modelElement, "importedPackage")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.ImportedPackage;
                }
                set
                {
                    this.ModelElement.ImportedPackage = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the TypeDeclaration class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeDeclaration")]
    public partial class TypeDeclaration : TypeMember, ITypeDeclaration, IModelElement
    {
        
        private static Lazy<ITypedElement> _typeParametersReference = new Lazy<ITypedElement>(RetrieveTypeParametersReference);
        
        /// <summary>
        /// The backing field for the TypeParameters property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeParameter> _typeParameters;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public TypeDeclaration()
        {
            this._typeParameters = new ObservableCompositionList<ITypeParameter>(this);
            this._typeParameters.CollectionChanging += this.TypeParametersCollectionChanging;
            this._typeParameters.CollectionChanged += this.TypeParametersCollectionChanged;
        }
        
        /// <summary>
        /// The typeParameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("typeParameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeParameter> TypeParameters
        {
            get
            {
                return this._typeParameters;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new TypeDeclarationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new TypeDeclarationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeDeclaration")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveTypeParametersReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TypeDeclaration.ClassInstance)).Resolve("typeParameters")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TypeParameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypeParametersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TypeParameters", e, _typeParametersReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TypeParameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypeParametersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TypeParameters", e, _typeParametersReference);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "TYPEPARAMETERS"))
            {
                return this._typeParameters;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._typeParameters))
            {
                return "typeParameters";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TypeDeclaration class
        /// </summary>
        public class TypeDeclarationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TypeDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TypeDeclarationChildrenCollection(TypeDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.TypeParameters.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.TypeParameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.TypeParameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeParameter typeParametersCasted = item.As<ITypeParameter>();
                if ((typeParametersCasted != null))
                {
                    this._parent.TypeParameters.Add(typeParametersCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TypeParameters.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.TypeParameters.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> typeParametersEnumerator = this._parent.TypeParameters.GetEnumerator();
                try
                {
                    for (
                    ; typeParametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typeParametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typeParametersEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeParameter typeParameterItem = item.As<ITypeParameter>();
                if (((typeParameterItem != null) 
                            && this._parent.TypeParameters.Remove(typeParameterItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TypeParameters).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TypeDeclaration class
        /// </summary>
        public class TypeDeclarationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TypeDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TypeDeclarationReferencedElementsCollection(TypeDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.TypeParameters.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.TypeParameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.TypeParameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeParameter typeParametersCasted = item.As<ITypeParameter>();
                if ((typeParametersCasted != null))
                {
                    this._parent.TypeParameters.Add(typeParametersCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TypeParameters.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.TypeParameters.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> typeParametersEnumerator = this._parent.TypeParameters.GetEnumerator();
                try
                {
                    for (
                    ; typeParametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typeParametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typeParametersEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeParameter typeParameterItem = item.As<ITypeParameter>();
                if (((typeParameterItem != null) 
                            && this._parent.TypeParameters.Remove(typeParameterItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TypeParameters).GetEnumerator();
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ClassDeclaration class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ClassDeclaration")]
    [DebuggerDisplayAttribute("ClassDeclaration {Name}")]
    public partial class ClassDeclaration : TypeDeclaration, IClassDeclaration, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Modifiers property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<Modifier> _modifiers;
        
        private static Lazy<ITypedElement> _modifiersAttribute = new Lazy<ITypedElement>(RetrieveModifiersAttribute);
        
        private static Lazy<ITypedElement> _implementsReference = new Lazy<ITypedElement>(RetrieveImplementsReference);
        
        /// <summary>
        /// The backing field for the Implements property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeReference> _implements;
        
        private static Lazy<ITypedElement> _superClassReference = new Lazy<ITypedElement>(RetrieveSuperClassReference);
        
        /// <summary>
        /// The backing field for the SuperClass property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _superClass;
        
        private static Lazy<ITypedElement> _membersReference = new Lazy<ITypedElement>(RetrieveMembersReference);
        
        /// <summary>
        /// The backing field for the Members property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeMember> _members;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public ClassDeclaration()
        {
            this._modifiers = new ObservableList<Modifier>();
            this._modifiers.CollectionChanging += this.ModifiersCollectionChanging;
            this._modifiers.CollectionChanged += this.ModifiersCollectionChanged;
            this._implements = new ObservableCompositionList<ITypeReference>(this);
            this._implements.CollectionChanging += this.ImplementsCollectionChanging;
            this._implements.CollectionChanged += this.ImplementsCollectionChanged;
            this._members = new ObservableCompositionList<ITypeMember>(this);
            this._members.CollectionChanging += this.MembersCollectionChanging;
            this._members.CollectionChanged += this.MembersCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("ClassDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("ClassDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<Modifier> Modifiers
        {
            get
            {
                return this._modifiers;
            }
        }
        
        /// <summary>
        /// The implements property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("implements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeReference> Implements
        {
            get
            {
                return this._implements;
            }
        }
        
        /// <summary>
        /// The superClass property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("superClass")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference SuperClass
        {
            get
            {
                return this._superClass;
            }
            set
            {
                if ((this._superClass != value))
                {
                    ITypeReference old = this._superClass;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("SuperClass", e, _superClassReference);
                    this._superClass = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetSuperClass;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetSuperClass;
                    }
                    this.OnPropertyChanged("SuperClass", e, _superClassReference);
                }
            }
        }
        
        /// <summary>
        /// The members property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("members")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeMember> Members
        {
            get
            {
                return this._members;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ClassDeclarationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ClassDeclarationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ClassDeclaration")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ClassDeclaration.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveModifiersAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ClassDeclaration.ClassInstance)).Resolve("modifiers")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Modifiers", e, _modifiersAttribute);
        }
        
        private static ITypedElement RetrieveImplementsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ClassDeclaration.ClassInstance)).Resolve("implements")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Implements property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ImplementsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Implements", e, _implementsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Implements property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ImplementsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Implements", e, _implementsReference);
        }
        
        private static ITypedElement RetrieveSuperClassReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ClassDeclaration.ClassInstance)).Resolve("superClass")));
        }
        
        /// <summary>
        /// Handles the event that the SuperClass property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSuperClass(object sender, EventArgs eventArgs)
        {
            if ((sender == this.SuperClass))
            {
                this.SuperClass = null;
            }
        }
        
        private static ITypedElement RetrieveMembersReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ClassDeclaration.ClassInstance)).Resolve("members")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Members property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MembersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Members", e, _membersReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Members property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MembersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Members", e, _membersReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.SuperClass))
            {
                return ModelHelper.CreatePath("superClass");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "SUPERCLASS"))
            {
                return this.SuperClass;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "IMPLEMENTS"))
            {
                return this._implements;
            }
            if ((feature == "MEMBERS"))
            {
                return this._members;
            }
            if ((feature == "MODIFIERS"))
            {
                return this._modifiers;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "SUPERCLASS"))
            {
                this.SuperClass = ((ITypeReference)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "SUPERCLASS"))
            {
                return new SuperClassProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._implements))
            {
                return "implements";
            }
            if ((container == this._members))
            {
                return "members";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ClassDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ClassDeclaration class
        /// </summary>
        public class ClassDeclarationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ClassDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ClassDeclarationChildrenCollection(ClassDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Implements.Count);
                    if ((this._parent.SuperClass != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Members.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Members.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Members.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeReference implementsCasted = item.As<ITypeReference>();
                if ((implementsCasted != null))
                {
                    this._parent.Implements.Add(implementsCasted);
                }
                if ((this._parent.SuperClass == null))
                {
                    ITypeReference superClassCasted = item.As<ITypeReference>();
                    if ((superClassCasted != null))
                    {
                        this._parent.SuperClass = superClassCasted;
                        return;
                    }
                }
                ITypeMember membersCasted = item.As<ITypeMember>();
                if ((membersCasted != null))
                {
                    this._parent.Members.Add(membersCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Implements.Clear();
                this._parent.SuperClass = null;
                this._parent.Members.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Implements.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.SuperClass))
                {
                    return true;
                }
                if (this._parent.Members.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> implementsEnumerator = this._parent.Implements.GetEnumerator();
                try
                {
                    for (
                    ; implementsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = implementsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    implementsEnumerator.Dispose();
                }
                if ((this._parent.SuperClass != null))
                {
                    array[arrayIndex] = this._parent.SuperClass;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> membersEnumerator = this._parent.Members.GetEnumerator();
                try
                {
                    for (
                    ; membersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = membersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    membersEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeReference typeReferenceItem = item.As<ITypeReference>();
                if (((typeReferenceItem != null) 
                            && this._parent.Implements.Remove(typeReferenceItem)))
                {
                    return true;
                }
                if ((this._parent.SuperClass == item))
                {
                    this._parent.SuperClass = null;
                    return true;
                }
                ITypeMember typeMemberItem = item.As<ITypeMember>();
                if (((typeMemberItem != null) 
                            && this._parent.Members.Remove(typeMemberItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Implements).Concat(this._parent.SuperClass).Concat(this._parent.Members).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ClassDeclaration class
        /// </summary>
        public class ClassDeclarationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ClassDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ClassDeclarationReferencedElementsCollection(ClassDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Implements.Count);
                    if ((this._parent.SuperClass != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Members.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Members.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Members.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeReference implementsCasted = item.As<ITypeReference>();
                if ((implementsCasted != null))
                {
                    this._parent.Implements.Add(implementsCasted);
                }
                if ((this._parent.SuperClass == null))
                {
                    ITypeReference superClassCasted = item.As<ITypeReference>();
                    if ((superClassCasted != null))
                    {
                        this._parent.SuperClass = superClassCasted;
                        return;
                    }
                }
                ITypeMember membersCasted = item.As<ITypeMember>();
                if ((membersCasted != null))
                {
                    this._parent.Members.Add(membersCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Implements.Clear();
                this._parent.SuperClass = null;
                this._parent.Members.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Implements.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.SuperClass))
                {
                    return true;
                }
                if (this._parent.Members.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> implementsEnumerator = this._parent.Implements.GetEnumerator();
                try
                {
                    for (
                    ; implementsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = implementsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    implementsEnumerator.Dispose();
                }
                if ((this._parent.SuperClass != null))
                {
                    array[arrayIndex] = this._parent.SuperClass;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> membersEnumerator = this._parent.Members.GetEnumerator();
                try
                {
                    for (
                    ; membersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = membersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    membersEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeReference typeReferenceItem = item.As<ITypeReference>();
                if (((typeReferenceItem != null) 
                            && this._parent.Implements.Remove(typeReferenceItem)))
                {
                    return true;
                }
                if ((this._parent.SuperClass == item))
                {
                    this._parent.SuperClass = null;
                    return true;
                }
                ITypeMember typeMemberItem = item.As<ITypeMember>();
                if (((typeMemberItem != null) 
                            && this._parent.Members.Remove(typeMemberItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Implements).Concat(this._parent.SuperClass).Concat(this._parent.Members).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IClassDeclaration, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IClassDeclaration modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the superClass property
        /// </summary>
        private sealed class SuperClassProxy : ModelPropertyChange<IClassDeclaration, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SuperClassProxy(IClassDeclaration modelElement) : 
                    base(modelElement, "superClass")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.SuperClass;
                }
                set
                {
                    this.ModelElement.SuperClass = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the TypeParameter class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeParameter")]
    [DebuggerDisplayAttribute("TypeParameter {Name}")]
    public partial class TypeParameter : ModelElement, ITypeParameter, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        private static Lazy<ITypedElement> _extendsReference = new Lazy<ITypedElement>(RetrieveExtendsReference);
        
        /// <summary>
        /// The backing field for the Extends property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _extends;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("TypeParameter")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The extends property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("extends")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Extends
        {
            get
            {
                return this._extends;
            }
            set
            {
                if ((this._extends != value))
                {
                    ITypeReference old = this._extends;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Extends", e, _extendsReference);
                    this._extends = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetExtends;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetExtends;
                    }
                    this.OnPropertyChanged("Extends", e, _extendsReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new TypeParameterChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new TypeParameterReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeParameter")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TypeParameter.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveExtendsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TypeParameter.ClassInstance)).Resolve("extends")));
        }
        
        /// <summary>
        /// Handles the event that the Extends property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetExtends(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Extends))
            {
                this.Extends = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Extends))
            {
                return ModelHelper.CreatePath("extends");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "EXTENDS"))
            {
                return this.Extends;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "EXTENDS"))
            {
                this.Extends = ((ITypeReference)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "EXTENDS"))
            {
                return new ExtendsProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeParameter")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TypeParameter class
        /// </summary>
        public class TypeParameterChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TypeParameter _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TypeParameterChildrenCollection(TypeParameter parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Extends != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Extends == null))
                {
                    ITypeReference extendsCasted = item.As<ITypeReference>();
                    if ((extendsCasted != null))
                    {
                        this._parent.Extends = extendsCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Extends = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Extends))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Extends != null))
                {
                    array[arrayIndex] = this._parent.Extends;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Extends == item))
                {
                    this._parent.Extends = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Extends).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TypeParameter class
        /// </summary>
        public class TypeParameterReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TypeParameter _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TypeParameterReferencedElementsCollection(TypeParameter parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Extends != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Extends == null))
                {
                    ITypeReference extendsCasted = item.As<ITypeReference>();
                    if ((extendsCasted != null))
                    {
                        this._parent.Extends = extendsCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Extends = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Extends))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Extends != null))
                {
                    array[arrayIndex] = this._parent.Extends;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Extends == item))
                {
                    this._parent.Extends = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Extends).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<ITypeParameter, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(ITypeParameter modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the extends property
        /// </summary>
        private sealed class ExtendsProxy : ModelPropertyChange<ITypeParameter, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExtendsProxy(ITypeParameter modelElement) : 
                    base(modelElement, "extends")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Extends;
                }
                set
                {
                    this.ModelElement.Extends = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the InterfaceDeclaration class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//InterfaceDeclaration")]
    [DebuggerDisplayAttribute("InterfaceDeclaration {Name}")]
    public partial class InterfaceDeclaration : TypeDeclaration, IInterfaceDeclaration, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Modifiers property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<Modifier> _modifiers;
        
        private static Lazy<ITypedElement> _modifiersAttribute = new Lazy<ITypedElement>(RetrieveModifiersAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public InterfaceDeclaration()
        {
            this._modifiers = new ObservableList<Modifier>();
            this._modifiers.CollectionChanging += this.ModifiersCollectionChanging;
            this._modifiers.CollectionChanged += this.ModifiersCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("InterfaceDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("InterfaceDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<Modifier> Modifiers
        {
            get
            {
                return this._modifiers;
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//InterfaceDeclaration")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.InterfaceDeclaration.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveModifiersAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.InterfaceDeclaration.ClassInstance)).Resolve("modifiers")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "MODIFIERS"))
            {
                return this._modifiers;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//InterfaceDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IInterfaceDeclaration, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IInterfaceDeclaration modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the EnumDeclaration class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//EnumDeclaration")]
    [DebuggerDisplayAttribute("EnumDeclaration {Name}")]
    public partial class EnumDeclaration : TypeDeclaration, IEnumDeclaration, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Modifiers property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<Modifier> _modifiers;
        
        private static Lazy<ITypedElement> _modifiersAttribute = new Lazy<ITypedElement>(RetrieveModifiersAttribute);
        
        private static Lazy<ITypedElement> _implementsReference = new Lazy<ITypedElement>(RetrieveImplementsReference);
        
        /// <summary>
        /// The backing field for the Implements property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeReference> _implements;
        
        private static Lazy<ITypedElement> _membersReference = new Lazy<ITypedElement>(RetrieveMembersReference);
        
        /// <summary>
        /// The backing field for the Members property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeMember> _members;
        
        private static Lazy<ITypedElement> _constantsReference = new Lazy<ITypedElement>(RetrieveConstantsReference);
        
        /// <summary>
        /// The backing field for the Constants property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IEnumConstant> _constants;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public EnumDeclaration()
        {
            this._modifiers = new ObservableList<Modifier>();
            this._modifiers.CollectionChanging += this.ModifiersCollectionChanging;
            this._modifiers.CollectionChanged += this.ModifiersCollectionChanged;
            this._implements = new ObservableCompositionList<ITypeReference>(this);
            this._implements.CollectionChanging += this.ImplementsCollectionChanging;
            this._implements.CollectionChanged += this.ImplementsCollectionChanged;
            this._members = new ObservableCompositionList<ITypeMember>(this);
            this._members.CollectionChanging += this.MembersCollectionChanging;
            this._members.CollectionChanged += this.MembersCollectionChanged;
            this._constants = new ObservableCompositionList<IEnumConstant>(this);
            this._constants.CollectionChanging += this.ConstantsCollectionChanging;
            this._constants.CollectionChanged += this.ConstantsCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("EnumDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("EnumDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<Modifier> Modifiers
        {
            get
            {
                return this._modifiers;
            }
        }
        
        /// <summary>
        /// The implements property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("implements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeReference> Implements
        {
            get
            {
                return this._implements;
            }
        }
        
        /// <summary>
        /// The members property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("members")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeMember> Members
        {
            get
            {
                return this._members;
            }
        }
        
        /// <summary>
        /// The constants property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("constants")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IEnumConstant> Constants
        {
            get
            {
                return this._constants;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new EnumDeclarationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new EnumDeclarationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//EnumDeclaration")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.EnumDeclaration.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveModifiersAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.EnumDeclaration.ClassInstance)).Resolve("modifiers")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Modifiers", e, _modifiersAttribute);
        }
        
        private static ITypedElement RetrieveImplementsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.EnumDeclaration.ClassInstance)).Resolve("implements")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Implements property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ImplementsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Implements", e, _implementsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Implements property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ImplementsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Implements", e, _implementsReference);
        }
        
        private static ITypedElement RetrieveMembersReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.EnumDeclaration.ClassInstance)).Resolve("members")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Members property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MembersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Members", e, _membersReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Members property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void MembersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Members", e, _membersReference);
        }
        
        private static ITypedElement RetrieveConstantsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.EnumDeclaration.ClassInstance)).Resolve("constants")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Constants property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConstantsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Constants", e, _constantsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Constants property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ConstantsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Constants", e, _constantsReference);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "IMPLEMENTS"))
            {
                return this._implements;
            }
            if ((feature == "MEMBERS"))
            {
                return this._members;
            }
            if ((feature == "CONSTANTS"))
            {
                return this._constants;
            }
            if ((feature == "MODIFIERS"))
            {
                return this._modifiers;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._implements))
            {
                return "implements";
            }
            if ((container == this._members))
            {
                return "members";
            }
            if ((container == this._constants))
            {
                return "constants";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//EnumDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the EnumDeclaration class
        /// </summary>
        public class EnumDeclarationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private EnumDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public EnumDeclarationChildrenCollection(EnumDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Implements.Count);
                    count = (count + this._parent.Members.Count);
                    count = (count + this._parent.Constants.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Members.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Constants.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Members.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Constants.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeReference implementsCasted = item.As<ITypeReference>();
                if ((implementsCasted != null))
                {
                    this._parent.Implements.Add(implementsCasted);
                }
                ITypeMember membersCasted = item.As<ITypeMember>();
                if ((membersCasted != null))
                {
                    this._parent.Members.Add(membersCasted);
                }
                IEnumConstant constantsCasted = item.As<IEnumConstant>();
                if ((constantsCasted != null))
                {
                    this._parent.Constants.Add(constantsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Implements.Clear();
                this._parent.Members.Clear();
                this._parent.Constants.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Implements.Contains(item))
                {
                    return true;
                }
                if (this._parent.Members.Contains(item))
                {
                    return true;
                }
                if (this._parent.Constants.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> implementsEnumerator = this._parent.Implements.GetEnumerator();
                try
                {
                    for (
                    ; implementsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = implementsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    implementsEnumerator.Dispose();
                }
                IEnumerator<IModelElement> membersEnumerator = this._parent.Members.GetEnumerator();
                try
                {
                    for (
                    ; membersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = membersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    membersEnumerator.Dispose();
                }
                IEnumerator<IModelElement> constantsEnumerator = this._parent.Constants.GetEnumerator();
                try
                {
                    for (
                    ; constantsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = constantsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    constantsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeReference typeReferenceItem = item.As<ITypeReference>();
                if (((typeReferenceItem != null) 
                            && this._parent.Implements.Remove(typeReferenceItem)))
                {
                    return true;
                }
                ITypeMember typeMemberItem = item.As<ITypeMember>();
                if (((typeMemberItem != null) 
                            && this._parent.Members.Remove(typeMemberItem)))
                {
                    return true;
                }
                IEnumConstant enumConstantItem = item.As<IEnumConstant>();
                if (((enumConstantItem != null) 
                            && this._parent.Constants.Remove(enumConstantItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Implements).Concat(this._parent.Members).Concat(this._parent.Constants).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the EnumDeclaration class
        /// </summary>
        public class EnumDeclarationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private EnumDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public EnumDeclarationReferencedElementsCollection(EnumDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Implements.Count);
                    count = (count + this._parent.Members.Count);
                    count = (count + this._parent.Constants.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Members.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Constants.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Implements.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Members.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Constants.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeReference implementsCasted = item.As<ITypeReference>();
                if ((implementsCasted != null))
                {
                    this._parent.Implements.Add(implementsCasted);
                }
                ITypeMember membersCasted = item.As<ITypeMember>();
                if ((membersCasted != null))
                {
                    this._parent.Members.Add(membersCasted);
                }
                IEnumConstant constantsCasted = item.As<IEnumConstant>();
                if ((constantsCasted != null))
                {
                    this._parent.Constants.Add(constantsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Implements.Clear();
                this._parent.Members.Clear();
                this._parent.Constants.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Implements.Contains(item))
                {
                    return true;
                }
                if (this._parent.Members.Contains(item))
                {
                    return true;
                }
                if (this._parent.Constants.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> implementsEnumerator = this._parent.Implements.GetEnumerator();
                try
                {
                    for (
                    ; implementsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = implementsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    implementsEnumerator.Dispose();
                }
                IEnumerator<IModelElement> membersEnumerator = this._parent.Members.GetEnumerator();
                try
                {
                    for (
                    ; membersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = membersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    membersEnumerator.Dispose();
                }
                IEnumerator<IModelElement> constantsEnumerator = this._parent.Constants.GetEnumerator();
                try
                {
                    for (
                    ; constantsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = constantsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    constantsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeReference typeReferenceItem = item.As<ITypeReference>();
                if (((typeReferenceItem != null) 
                            && this._parent.Implements.Remove(typeReferenceItem)))
                {
                    return true;
                }
                ITypeMember typeMemberItem = item.As<ITypeMember>();
                if (((typeMemberItem != null) 
                            && this._parent.Members.Remove(typeMemberItem)))
                {
                    return true;
                }
                IEnumConstant enumConstantItem = item.As<IEnumConstant>();
                if (((enumConstantItem != null) 
                            && this._parent.Constants.Remove(enumConstantItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Implements).Concat(this._parent.Members).Concat(this._parent.Constants).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IEnumDeclaration, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IEnumDeclaration modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the AnnotationDeclaration class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//AnnotationDeclaration")]
    [DebuggerDisplayAttribute("AnnotationDeclaration {Name}")]
    public partial class AnnotationDeclaration : TypeDeclaration, IAnnotationDeclaration, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("AnnotationDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//AnnotationDeclaration")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.AnnotationDeclaration.ClassInstance)).Resolve("name")));
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//AnnotationDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IAnnotationDeclaration, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IAnnotationDeclaration modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the TypeReference class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeReference")]
    public partial class TypeReference : ModelElement, ITypeReference, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeReference")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeReference")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the ArrayTypeReference class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ArrayTypeReference")]
    public partial class ArrayTypeReference : TypeReference, IArrayTypeReference, IModelElement
    {
        
        private static Lazy<ITypedElement> _baseTypeReference = new Lazy<ITypedElement>(RetrieveBaseTypeReference);
        
        /// <summary>
        /// The backing field for the BaseType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _baseType;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The baseType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("baseType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference BaseType
        {
            get
            {
                return this._baseType;
            }
            set
            {
                if ((this._baseType != value))
                {
                    ITypeReference old = this._baseType;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("BaseType", e, _baseTypeReference);
                    this._baseType = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetBaseType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetBaseType;
                    }
                    this.OnPropertyChanged("BaseType", e, _baseTypeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ArrayTypeReferenceChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ArrayTypeReferenceReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ArrayTypeReference")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveBaseTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ArrayTypeReference.ClassInstance)).Resolve("baseType")));
        }
        
        /// <summary>
        /// Handles the event that the BaseType property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetBaseType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.BaseType))
            {
                this.BaseType = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.BaseType))
            {
                return ModelHelper.CreatePath("baseType");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BASETYPE"))
            {
                return this.BaseType;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BASETYPE"))
            {
                this.BaseType = ((ITypeReference)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "BASETYPE"))
            {
                return new BaseTypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ArrayTypeReference")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ArrayTypeReference class
        /// </summary>
        public class ArrayTypeReferenceChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ArrayTypeReference _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ArrayTypeReferenceChildrenCollection(ArrayTypeReference parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.BaseType != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.BaseType == null))
                {
                    ITypeReference baseTypeCasted = item.As<ITypeReference>();
                    if ((baseTypeCasted != null))
                    {
                        this._parent.BaseType = baseTypeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.BaseType = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.BaseType))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.BaseType != null))
                {
                    array[arrayIndex] = this._parent.BaseType;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.BaseType == item))
                {
                    this._parent.BaseType = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.BaseType).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ArrayTypeReference class
        /// </summary>
        public class ArrayTypeReferenceReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ArrayTypeReference _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ArrayTypeReferenceReferencedElementsCollection(ArrayTypeReference parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.BaseType != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.BaseType == null))
                {
                    ITypeReference baseTypeCasted = item.As<ITypeReference>();
                    if ((baseTypeCasted != null))
                    {
                        this._parent.BaseType = baseTypeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.BaseType = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.BaseType))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.BaseType != null))
                {
                    array[arrayIndex] = this._parent.BaseType;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.BaseType == item))
                {
                    this._parent.BaseType = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.BaseType).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the baseType property
        /// </summary>
        private sealed class BaseTypeProxy : ModelPropertyChange<IArrayTypeReference, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BaseTypeProxy(IArrayTypeReference modelElement) : 
                    base(modelElement, "baseType")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.BaseType;
                }
                set
                {
                    this.ModelElement.BaseType = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the PrimitiveTypeReference class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//PrimitiveTypeReference")]
    public partial class PrimitiveTypeReference : TypeReference, IPrimitiveTypeReference, IModelElement
    {
        
        /// <summary>
        /// The backing field for the PrimitiveType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private PrimitiveType _primitiveType;
        
        private static Lazy<ITypedElement> _primitiveTypeAttribute = new Lazy<ITypedElement>(RetrievePrimitiveTypeAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The primitiveType property
        /// </summary>
        [DisplayNameAttribute("primitiveType")]
        [CategoryAttribute("PrimitiveTypeReference")]
        [XmlElementNameAttribute("primitiveType")]
        [XmlAttributeAttribute(true)]
        public PrimitiveType PrimitiveType
        {
            get
            {
                return this._primitiveType;
            }
            set
            {
                if ((this._primitiveType != value))
                {
                    PrimitiveType old = this._primitiveType;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("PrimitiveType", e, _primitiveTypeAttribute);
                    this._primitiveType = value;
                    this.OnPropertyChanged("PrimitiveType", e, _primitiveTypeAttribute);
                }
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//PrimitiveTypeReference")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrievePrimitiveTypeAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.PrimitiveTypeReference.ClassInstance)).Resolve("primitiveType")));
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "PRIMITIVETYPE"))
            {
                return this.PrimitiveType;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "PRIMITIVETYPE"))
            {
                this.PrimitiveType = ((PrimitiveType)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "PRIMITIVETYPE"))
            {
                return Observable.Box(new PrimitiveTypeProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//PrimitiveTypeReference")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the primitiveType property
        /// </summary>
        private sealed class PrimitiveTypeProxy : ModelPropertyChange<IPrimitiveTypeReference, PrimitiveType>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public PrimitiveTypeProxy(IPrimitiveTypeReference modelElement) : 
                    base(modelElement, "primitiveType")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override PrimitiveType Value
            {
                get
                {
                    return this.ModelElement.PrimitiveType;
                }
                set
                {
                    this.ModelElement.PrimitiveType = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the GenericTypeReference class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//GenericTypeReference")]
    public partial class GenericTypeReference : TypeReference, IGenericTypeReference, IModelElement
    {
        
        /// <summary>
        /// The backing field for the BaseType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _baseType;
        
        private static Lazy<ITypedElement> _baseTypeAttribute = new Lazy<ITypedElement>(RetrieveBaseTypeAttribute);
        
        private static Lazy<ITypedElement> _typeArgumentsReference = new Lazy<ITypedElement>(RetrieveTypeArgumentsReference);
        
        /// <summary>
        /// The backing field for the TypeArguments property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeArgument> _typeArguments;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public GenericTypeReference()
        {
            this._typeArguments = new ObservableCompositionList<ITypeArgument>(this);
            this._typeArguments.CollectionChanging += this.TypeArgumentsCollectionChanging;
            this._typeArguments.CollectionChanged += this.TypeArgumentsCollectionChanged;
        }
        
        /// <summary>
        /// The baseType property
        /// </summary>
        [DisplayNameAttribute("baseType")]
        [CategoryAttribute("GenericTypeReference")]
        [XmlElementNameAttribute("baseType")]
        [XmlAttributeAttribute(true)]
        public string BaseType
        {
            get
            {
                return this._baseType;
            }
            set
            {
                if ((this._baseType != value))
                {
                    string old = this._baseType;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("BaseType", e, _baseTypeAttribute);
                    this._baseType = value;
                    this.OnPropertyChanged("BaseType", e, _baseTypeAttribute);
                }
            }
        }
        
        /// <summary>
        /// The typeArguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("typeArguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeArgument> TypeArguments
        {
            get
            {
                return this._typeArguments;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new GenericTypeReferenceChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new GenericTypeReferenceReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//GenericTypeReference")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveBaseTypeAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.GenericTypeReference.ClassInstance)).Resolve("baseType")));
        }
        
        private static ITypedElement RetrieveTypeArgumentsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.GenericTypeReference.ClassInstance)).Resolve("typeArguments")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TypeArguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypeArgumentsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TypeArguments", e, _typeArgumentsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TypeArguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypeArgumentsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TypeArguments", e, _typeArgumentsReference);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "BASETYPE"))
            {
                return this.BaseType;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "TYPEARGUMENTS"))
            {
                return this._typeArguments;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BASETYPE"))
            {
                this.BaseType = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "BASETYPE"))
            {
                return new BaseTypeProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._typeArguments))
            {
                return "typeArguments";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//GenericTypeReference")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the GenericTypeReference class
        /// </summary>
        public class GenericTypeReferenceChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private GenericTypeReference _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public GenericTypeReferenceChildrenCollection(GenericTypeReference parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.TypeArguments.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.TypeArguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.TypeArguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeArgument typeArgumentsCasted = item.As<ITypeArgument>();
                if ((typeArgumentsCasted != null))
                {
                    this._parent.TypeArguments.Add(typeArgumentsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TypeArguments.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.TypeArguments.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> typeArgumentsEnumerator = this._parent.TypeArguments.GetEnumerator();
                try
                {
                    for (
                    ; typeArgumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typeArgumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typeArgumentsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeArgument typeArgumentItem = item.As<ITypeArgument>();
                if (((typeArgumentItem != null) 
                            && this._parent.TypeArguments.Remove(typeArgumentItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TypeArguments).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the GenericTypeReference class
        /// </summary>
        public class GenericTypeReferenceReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private GenericTypeReference _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public GenericTypeReferenceReferencedElementsCollection(GenericTypeReference parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.TypeArguments.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.TypeArguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.TypeArguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                ITypeArgument typeArgumentsCasted = item.As<ITypeArgument>();
                if ((typeArgumentsCasted != null))
                {
                    this._parent.TypeArguments.Add(typeArgumentsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TypeArguments.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.TypeArguments.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> typeArgumentsEnumerator = this._parent.TypeArguments.GetEnumerator();
                try
                {
                    for (
                    ; typeArgumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typeArgumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typeArgumentsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                ITypeArgument typeArgumentItem = item.As<ITypeArgument>();
                if (((typeArgumentItem != null) 
                            && this._parent.TypeArguments.Remove(typeArgumentItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TypeArguments).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the baseType property
        /// </summary>
        private sealed class BaseTypeProxy : ModelPropertyChange<IGenericTypeReference, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BaseTypeProxy(IGenericTypeReference modelElement) : 
                    base(modelElement, "baseType")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.BaseType;
                }
                set
                {
                    this.ModelElement.BaseType = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the TypeArgument class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeArgument")]
    public partial class TypeArgument : ModelElement, ITypeArgument, IModelElement
    {
        
        /// <summary>
        /// The backing field for the IsSuper property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private Nullable<bool> _isSuper;
        
        private static Lazy<ITypedElement> _isSuperAttribute = new Lazy<ITypedElement>(RetrieveIsSuperAttribute);
        
        /// <summary>
        /// The backing field for the IsExtends property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private Nullable<bool> _isExtends;
        
        private static Lazy<ITypedElement> _isExtendsAttribute = new Lazy<ITypedElement>(RetrieveIsExtendsAttribute);
        
        private static Lazy<ITypedElement> _referencedTypeReference = new Lazy<ITypedElement>(RetrieveReferencedTypeReference);
        
        /// <summary>
        /// The backing field for the ReferencedType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _referencedType;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The isSuper property
        /// </summary>
        [DisplayNameAttribute("isSuper")]
        [CategoryAttribute("TypeArgument")]
        [XmlElementNameAttribute("isSuper")]
        [XmlAttributeAttribute(true)]
        public Nullable<bool> IsSuper
        {
            get
            {
                return this._isSuper;
            }
            set
            {
                if ((this._isSuper != value))
                {
                    Nullable<bool> old = this._isSuper;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsSuper", e, _isSuperAttribute);
                    this._isSuper = value;
                    this.OnPropertyChanged("IsSuper", e, _isSuperAttribute);
                }
            }
        }
        
        /// <summary>
        /// The isExtends property
        /// </summary>
        [DisplayNameAttribute("isExtends")]
        [CategoryAttribute("TypeArgument")]
        [XmlElementNameAttribute("isExtends")]
        [XmlAttributeAttribute(true)]
        public Nullable<bool> IsExtends
        {
            get
            {
                return this._isExtends;
            }
            set
            {
                if ((this._isExtends != value))
                {
                    Nullable<bool> old = this._isExtends;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsExtends", e, _isExtendsAttribute);
                    this._isExtends = value;
                    this.OnPropertyChanged("IsExtends", e, _isExtendsAttribute);
                }
            }
        }
        
        /// <summary>
        /// The referencedType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("referencedType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference ReferencedType
        {
            get
            {
                return this._referencedType;
            }
            set
            {
                if ((this._referencedType != value))
                {
                    ITypeReference old = this._referencedType;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ReferencedType", e, _referencedTypeReference);
                    this._referencedType = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetReferencedType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetReferencedType;
                    }
                    this.OnPropertyChanged("ReferencedType", e, _referencedTypeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new TypeArgumentChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new TypeArgumentReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeArgument")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveIsSuperAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TypeArgument.ClassInstance)).Resolve("isSuper")));
        }
        
        private static ITypedElement RetrieveIsExtendsAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TypeArgument.ClassInstance)).Resolve("isExtends")));
        }
        
        private static ITypedElement RetrieveReferencedTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TypeArgument.ClassInstance)).Resolve("referencedType")));
        }
        
        /// <summary>
        /// Handles the event that the ReferencedType property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetReferencedType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.ReferencedType))
            {
                this.ReferencedType = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.ReferencedType))
            {
                return ModelHelper.CreatePath("referencedType");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "REFERENCEDTYPE"))
            {
                return this.ReferencedType;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ISSUPER"))
            {
                return this.IsSuper;
            }
            if ((attribute == "ISEXTENDS"))
            {
                return this.IsExtends;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "REFERENCEDTYPE"))
            {
                this.ReferencedType = ((ITypeReference)(value));
                return;
            }
            if ((feature == "ISSUPER"))
            {
                this.IsSuper = ((bool)(value));
                return;
            }
            if ((feature == "ISEXTENDS"))
            {
                this.IsExtends = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ISSUPER"))
            {
                return Observable.Box(new IsSuperProxy(this));
            }
            if ((attribute == "ISEXTENDS"))
            {
                return Observable.Box(new IsExtendsProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "REFERENCEDTYPE"))
            {
                return new ReferencedTypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeArgument")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TypeArgument class
        /// </summary>
        public class TypeArgumentChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TypeArgument _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TypeArgumentChildrenCollection(TypeArgument parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ReferencedType != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ReferencedType == null))
                {
                    ITypeReference referencedTypeCasted = item.As<ITypeReference>();
                    if ((referencedTypeCasted != null))
                    {
                        this._parent.ReferencedType = referencedTypeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ReferencedType = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ReferencedType))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ReferencedType != null))
                {
                    array[arrayIndex] = this._parent.ReferencedType;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ReferencedType == item))
                {
                    this._parent.ReferencedType = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ReferencedType).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TypeArgument class
        /// </summary>
        public class TypeArgumentReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TypeArgument _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TypeArgumentReferencedElementsCollection(TypeArgument parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ReferencedType != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ReferencedType == null))
                {
                    ITypeReference referencedTypeCasted = item.As<ITypeReference>();
                    if ((referencedTypeCasted != null))
                    {
                        this._parent.ReferencedType = referencedTypeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ReferencedType = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ReferencedType))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ReferencedType != null))
                {
                    array[arrayIndex] = this._parent.ReferencedType;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ReferencedType == item))
                {
                    this._parent.ReferencedType = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ReferencedType).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isSuper property
        /// </summary>
        private sealed class IsSuperProxy : ModelPropertyChange<ITypeArgument, Nullable<bool>>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsSuperProxy(ITypeArgument modelElement) : 
                    base(modelElement, "isSuper")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override Nullable<bool> Value
            {
                get
                {
                    return this.ModelElement.IsSuper;
                }
                set
                {
                    this.ModelElement.IsSuper = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isExtends property
        /// </summary>
        private sealed class IsExtendsProxy : ModelPropertyChange<ITypeArgument, Nullable<bool>>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsExtendsProxy(ITypeArgument modelElement) : 
                    base(modelElement, "isExtends")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override Nullable<bool> Value
            {
                get
                {
                    return this.ModelElement.IsExtends;
                }
                set
                {
                    this.ModelElement.IsExtends = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the referencedType property
        /// </summary>
        private sealed class ReferencedTypeProxy : ModelPropertyChange<ITypeArgument, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ReferencedTypeProxy(ITypeArgument modelElement) : 
                    base(modelElement, "referencedType")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.ReferencedType;
                }
                set
                {
                    this.ModelElement.ReferencedType = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ReferenceTypeReference class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ReferenceTypeReference")]
    public partial class ReferenceTypeReference : TypeReference, IReferenceTypeReference, IModelElement
    {
        
        private static Lazy<ITypedElement> _targetTypeReference = new Lazy<ITypedElement>(RetrieveTargetTypeReference);
        
        /// <summary>
        /// The backing field for the TargetType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IClassDeclaration _targetType;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The targetType property
        /// </summary>
        [DisplayNameAttribute("targetType")]
        [CategoryAttribute("ReferenceTypeReference")]
        [XmlElementNameAttribute("targetType")]
        [XmlAttributeAttribute(true)]
        public IClassDeclaration TargetType
        {
            get
            {
                return this._targetType;
            }
            set
            {
                if ((this._targetType != value))
                {
                    IClassDeclaration old = this._targetType;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TargetType", e, _targetTypeReference);
                    this._targetType = value;
                    if ((old != null))
                    {
                        old.Deleted -= this.OnResetTargetType;
                    }
                    if ((value != null))
                    {
                        value.Deleted += this.OnResetTargetType;
                    }
                    this.OnPropertyChanged("TargetType", e, _targetTypeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ReferenceTypeReferenceReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ReferenceTypeReference")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveTargetTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ReferenceTypeReference.ClassInstance)).Resolve("targetType")));
        }
        
        /// <summary>
        /// Handles the event that the TargetType property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTargetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.TargetType))
            {
                this.TargetType = null;
            }
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "TARGETTYPE"))
            {
                return this.TargetType;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TARGETTYPE"))
            {
                this.TargetType = ((IClassDeclaration)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TARGETTYPE"))
            {
                return new TargetTypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ReferenceTypeReference")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ReferenceTypeReference class
        /// </summary>
        public class ReferenceTypeReferenceReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ReferenceTypeReference _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ReferenceTypeReferenceReferencedElementsCollection(ReferenceTypeReference parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.TargetType != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.TargetType == null))
                {
                    IClassDeclaration targetTypeCasted = item.As<IClassDeclaration>();
                    if ((targetTypeCasted != null))
                    {
                        this._parent.TargetType = targetTypeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TargetType = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.TargetType))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.TargetType != null))
                {
                    array[arrayIndex] = this._parent.TargetType;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.TargetType == item))
                {
                    this._parent.TargetType = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TargetType).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the targetType property
        /// </summary>
        private sealed class TargetTypeProxy : ModelPropertyChange<IReferenceTypeReference, IClassDeclaration>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TargetTypeProxy(IReferenceTypeReference modelElement) : 
                    base(modelElement, "targetType")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IClassDeclaration Value
            {
                get
                {
                    return this.ModelElement.TargetType;
                }
                set
                {
                    this.ModelElement.TargetType = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the TypeMember class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeMember")]
    public partial class TypeMember : ModelElement, ITypeMember, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeMember")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TypeMember")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the EnumConstant class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//EnumConstant")]
    [DebuggerDisplayAttribute("EnumConstant {Name}")]
    public partial class EnumConstant : ModelElement, IEnumConstant, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        private static Lazy<ITypedElement> _argumentsReference = new Lazy<ITypedElement>(RetrieveArgumentsReference);
        
        /// <summary>
        /// The backing field for the Arguments property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IExpression> _arguments;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public EnumConstant()
        {
            this._arguments = new ObservableCompositionList<IExpression>(this);
            this._arguments.CollectionChanging += this.ArgumentsCollectionChanging;
            this._arguments.CollectionChanged += this.ArgumentsCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("EnumConstant")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IExpression> Arguments
        {
            get
            {
                return this._arguments;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new EnumConstantChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new EnumConstantReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//EnumConstant")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.EnumConstant.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveArgumentsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.EnumConstant.ClassInstance)).Resolve("arguments")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Arguments", e, _argumentsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Arguments", e, _argumentsReference);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ARGUMENTS"))
            {
                return this._arguments;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._arguments))
            {
                return "arguments";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//EnumConstant")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the EnumConstant class
        /// </summary>
        public class EnumConstantChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private EnumConstant _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public EnumConstantChildrenCollection(EnumConstant parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the EnumConstant class
        /// </summary>
        public class EnumConstantReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private EnumConstant _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public EnumConstantReferencedElementsCollection(EnumConstant parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IEnumConstant, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IEnumConstant modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the FieldDeclaration class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//FieldDeclaration")]
    [DebuggerDisplayAttribute("FieldDeclaration {Name}")]
    public partial class FieldDeclaration : TypeMember, IFieldDeclaration, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Modifiers property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<Modifier> _modifiers;
        
        private static Lazy<ITypedElement> _modifiersAttribute = new Lazy<ITypedElement>(RetrieveModifiersAttribute);
        
        private static Lazy<ITypedElement> _defaultReference = new Lazy<ITypedElement>(RetrieveDefaultReference);
        
        /// <summary>
        /// The backing field for the Default property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _default;
        
        private static Lazy<ITypedElement> _typeReference = new Lazy<ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _type;
        
        private static Lazy<ITypedElement> _annotationsReference = new Lazy<ITypedElement>(RetrieveAnnotationsReference);
        
        /// <summary>
        /// The backing field for the Annotations property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IAnnotation> _annotations;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public FieldDeclaration()
        {
            this._modifiers = new ObservableList<Modifier>();
            this._modifiers.CollectionChanging += this.ModifiersCollectionChanging;
            this._modifiers.CollectionChanged += this.ModifiersCollectionChanged;
            this._annotations = new ObservableCompositionList<IAnnotation>(this);
            this._annotations.CollectionChanging += this.AnnotationsCollectionChanging;
            this._annotations.CollectionChanged += this.AnnotationsCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("FieldDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("FieldDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<Modifier> Modifiers
        {
            get
            {
                return this._modifiers;
            }
        }
        
        /// <summary>
        /// The default property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("default")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Default
        {
            get
            {
                return this._default;
            }
            set
            {
                if ((this._default != value))
                {
                    IExpression old = this._default;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Default", e, _defaultReference);
                    this._default = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetDefault;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetDefault;
                    }
                    this.OnPropertyChanged("Default", e, _defaultReference);
                }
            }
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    ITypeReference old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IAnnotation> Annotations
        {
            get
            {
                return this._annotations;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new FieldDeclarationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new FieldDeclarationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//FieldDeclaration")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.FieldDeclaration.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveModifiersAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.FieldDeclaration.ClassInstance)).Resolve("modifiers")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Modifiers", e, _modifiersAttribute);
        }
        
        private static ITypedElement RetrieveDefaultReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.FieldDeclaration.ClassInstance)).Resolve("default")));
        }
        
        /// <summary>
        /// Handles the event that the Default property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDefault(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Default))
            {
                this.Default = null;
            }
        }
        
        private static ITypedElement RetrieveTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.FieldDeclaration.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        private static ITypedElement RetrieveAnnotationsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.FieldDeclaration.ClassInstance)).Resolve("annotations")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Default))
            {
                return ModelHelper.CreatePath("default");
            }
            if ((element == this.Type))
            {
                return ModelHelper.CreatePath("type");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "DEFAULT"))
            {
                return this.Default;
            }
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ANNOTATIONS"))
            {
                return this._annotations;
            }
            if ((feature == "MODIFIERS"))
            {
                return this._modifiers;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "DEFAULT"))
            {
                this.Default = ((IExpression)(value));
                return;
            }
            if ((feature == "TYPE"))
            {
                this.Type = ((ITypeReference)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "DEFAULT"))
            {
                return new DefaultProxy(this);
            }
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._annotations))
            {
                return "annotations";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//FieldDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the FieldDeclaration class
        /// </summary>
        public class FieldDeclarationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private FieldDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public FieldDeclarationChildrenCollection(FieldDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Default != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Default == null))
                {
                    IExpression defaultCasted = item.As<IExpression>();
                    if ((defaultCasted != null))
                    {
                        this._parent.Default = defaultCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Default = null;
                this._parent.Type = null;
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Default))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Default != null))
                {
                    array[arrayIndex] = this._parent.Default;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Default == item))
                {
                    this._parent.Default = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Default).Concat(this._parent.Type).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the FieldDeclaration class
        /// </summary>
        public class FieldDeclarationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private FieldDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public FieldDeclarationReferencedElementsCollection(FieldDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Default != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Default == null))
                {
                    IExpression defaultCasted = item.As<IExpression>();
                    if ((defaultCasted != null))
                    {
                        this._parent.Default = defaultCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Default = null;
                this._parent.Type = null;
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Default))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Default != null))
                {
                    array[arrayIndex] = this._parent.Default;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Default == item))
                {
                    this._parent.Default = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Default).Concat(this._parent.Type).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IFieldDeclaration, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IFieldDeclaration modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the default property
        /// </summary>
        private sealed class DefaultProxy : ModelPropertyChange<IFieldDeclaration, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DefaultProxy(IFieldDeclaration modelElement) : 
                    base(modelElement, "default")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Default;
                }
                set
                {
                    this.ModelElement.Default = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IFieldDeclaration, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IFieldDeclaration modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the MethodDeclaration class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//MethodDeclaration")]
    [DebuggerDisplayAttribute("MethodDeclaration {Name}")]
    public partial class MethodDeclaration : TypeMember, IMethodDeclaration, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Modifiers property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<Modifier> _modifiers;
        
        private static Lazy<ITypedElement> _modifiersAttribute = new Lazy<ITypedElement>(RetrieveModifiersAttribute);
        
        private static Lazy<ITypedElement> _bodyReference = new Lazy<ITypedElement>(RetrieveBodyReference);
        
        /// <summary>
        /// The backing field for the Body property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _body;
        
        private static Lazy<ITypedElement> _parametersReference = new Lazy<ITypedElement>(RetrieveParametersReference);
        
        /// <summary>
        /// The backing field for the Parameters property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IParameterSpecification> _parameters;
        
        private static Lazy<ITypedElement> _returnTypeReference = new Lazy<ITypedElement>(RetrieveReturnTypeReference);
        
        /// <summary>
        /// The backing field for the ReturnType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _returnType;
        
        private static Lazy<ITypedElement> _typeParametersReference = new Lazy<ITypedElement>(RetrieveTypeParametersReference);
        
        /// <summary>
        /// The backing field for the TypeParameters property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ITypeParameter> _typeParameters;
        
        private static Lazy<ITypedElement> _annotationsReference = new Lazy<ITypedElement>(RetrieveAnnotationsReference);
        
        /// <summary>
        /// The backing field for the Annotations property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IAnnotation> _annotations;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public MethodDeclaration()
        {
            this._modifiers = new ObservableList<Modifier>();
            this._modifiers.CollectionChanging += this.ModifiersCollectionChanging;
            this._modifiers.CollectionChanged += this.ModifiersCollectionChanged;
            this._parameters = new ObservableCompositionList<IParameterSpecification>(this);
            this._parameters.CollectionChanging += this.ParametersCollectionChanging;
            this._parameters.CollectionChanged += this.ParametersCollectionChanged;
            this._typeParameters = new ObservableCompositionList<ITypeParameter>(this);
            this._typeParameters.CollectionChanging += this.TypeParametersCollectionChanging;
            this._typeParameters.CollectionChanged += this.TypeParametersCollectionChanged;
            this._annotations = new ObservableCompositionList<IAnnotation>(this);
            this._annotations.CollectionChanging += this.AnnotationsCollectionChanging;
            this._annotations.CollectionChanged += this.AnnotationsCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("MethodDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("MethodDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<Modifier> Modifiers
        {
            get
            {
                return this._modifiers;
            }
        }
        
        /// <summary>
        /// The body property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement Body
        {
            get
            {
                return this._body;
            }
            set
            {
                if ((this._body != value))
                {
                    IBlockStatement old = this._body;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Body", e, _bodyReference);
                    this._body = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetBody;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetBody;
                    }
                    this.OnPropertyChanged("Body", e, _bodyReference);
                }
            }
        }
        
        /// <summary>
        /// The parameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("parameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IParameterSpecification> Parameters
        {
            get
            {
                return this._parameters;
            }
        }
        
        /// <summary>
        /// The returnType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("returnType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference ReturnType
        {
            get
            {
                return this._returnType;
            }
            set
            {
                if ((this._returnType != value))
                {
                    ITypeReference old = this._returnType;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ReturnType", e, _returnTypeReference);
                    this._returnType = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetReturnType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetReturnType;
                    }
                    this.OnPropertyChanged("ReturnType", e, _returnTypeReference);
                }
            }
        }
        
        /// <summary>
        /// The typeParameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("typeParameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ITypeParameter> TypeParameters
        {
            get
            {
                return this._typeParameters;
            }
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IAnnotation> Annotations
        {
            get
            {
                return this._annotations;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new MethodDeclarationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new MethodDeclarationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//MethodDeclaration")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MethodDeclaration.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveModifiersAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MethodDeclaration.ClassInstance)).Resolve("modifiers")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Modifiers", e, _modifiersAttribute);
        }
        
        private static ITypedElement RetrieveBodyReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MethodDeclaration.ClassInstance)).Resolve("body")));
        }
        
        /// <summary>
        /// Handles the event that the Body property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetBody(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Body))
            {
                this.Body = null;
            }
        }
        
        private static ITypedElement RetrieveParametersReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MethodDeclaration.ClassInstance)).Resolve("parameters")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Parameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ParametersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Parameters", e, _parametersReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Parameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ParametersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Parameters", e, _parametersReference);
        }
        
        private static ITypedElement RetrieveReturnTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MethodDeclaration.ClassInstance)).Resolve("returnType")));
        }
        
        /// <summary>
        /// Handles the event that the ReturnType property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetReturnType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.ReturnType))
            {
                this.ReturnType = null;
            }
        }
        
        private static ITypedElement RetrieveTypeParametersReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MethodDeclaration.ClassInstance)).Resolve("typeParameters")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the TypeParameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypeParametersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("TypeParameters", e, _typeParametersReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the TypeParameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void TypeParametersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("TypeParameters", e, _typeParametersReference);
        }
        
        private static ITypedElement RetrieveAnnotationsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MethodDeclaration.ClassInstance)).Resolve("annotations")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Body))
            {
                return ModelHelper.CreatePath("body");
            }
            if ((element == this.ReturnType))
            {
                return ModelHelper.CreatePath("returnType");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BODY"))
            {
                return this.Body;
            }
            if ((reference == "RETURNTYPE"))
            {
                return this.ReturnType;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "PARAMETERS"))
            {
                return this._parameters;
            }
            if ((feature == "TYPEPARAMETERS"))
            {
                return this._typeParameters;
            }
            if ((feature == "ANNOTATIONS"))
            {
                return this._annotations;
            }
            if ((feature == "MODIFIERS"))
            {
                return this._modifiers;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BODY"))
            {
                this.Body = ((IBlockStatement)(value));
                return;
            }
            if ((feature == "RETURNTYPE"))
            {
                this.ReturnType = ((ITypeReference)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "BODY"))
            {
                return new BodyProxy(this);
            }
            if ((reference == "RETURNTYPE"))
            {
                return new ReturnTypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._parameters))
            {
                return "parameters";
            }
            if ((container == this._typeParameters))
            {
                return "typeParameters";
            }
            if ((container == this._annotations))
            {
                return "annotations";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//MethodDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the MethodDeclaration class
        /// </summary>
        public class MethodDeclarationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private MethodDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public MethodDeclarationChildrenCollection(MethodDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Body != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Parameters.Count);
                    if ((this._parent.ReturnType != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.TypeParameters.Count);
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.TypeParameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.TypeParameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Body == null))
                {
                    IBlockStatement bodyCasted = item.As<IBlockStatement>();
                    if ((bodyCasted != null))
                    {
                        this._parent.Body = bodyCasted;
                        return;
                    }
                }
                IParameterSpecification parametersCasted = item.As<IParameterSpecification>();
                if ((parametersCasted != null))
                {
                    this._parent.Parameters.Add(parametersCasted);
                }
                if ((this._parent.ReturnType == null))
                {
                    ITypeReference returnTypeCasted = item.As<ITypeReference>();
                    if ((returnTypeCasted != null))
                    {
                        this._parent.ReturnType = returnTypeCasted;
                        return;
                    }
                }
                ITypeParameter typeParametersCasted = item.As<ITypeParameter>();
                if ((typeParametersCasted != null))
                {
                    this._parent.TypeParameters.Add(typeParametersCasted);
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Body = null;
                this._parent.Parameters.Clear();
                this._parent.ReturnType = null;
                this._parent.TypeParameters.Clear();
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Body))
                {
                    return true;
                }
                if (this._parent.Parameters.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.ReturnType))
                {
                    return true;
                }
                if (this._parent.TypeParameters.Contains(item))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Body != null))
                {
                    array[arrayIndex] = this._parent.Body;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> parametersEnumerator = this._parent.Parameters.GetEnumerator();
                try
                {
                    for (
                    ; parametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = parametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    parametersEnumerator.Dispose();
                }
                if ((this._parent.ReturnType != null))
                {
                    array[arrayIndex] = this._parent.ReturnType;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> typeParametersEnumerator = this._parent.TypeParameters.GetEnumerator();
                try
                {
                    for (
                    ; typeParametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typeParametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typeParametersEnumerator.Dispose();
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Body == item))
                {
                    this._parent.Body = null;
                    return true;
                }
                IParameterSpecification parameterSpecificationItem = item.As<IParameterSpecification>();
                if (((parameterSpecificationItem != null) 
                            && this._parent.Parameters.Remove(parameterSpecificationItem)))
                {
                    return true;
                }
                if ((this._parent.ReturnType == item))
                {
                    this._parent.ReturnType = null;
                    return true;
                }
                ITypeParameter typeParameterItem = item.As<ITypeParameter>();
                if (((typeParameterItem != null) 
                            && this._parent.TypeParameters.Remove(typeParameterItem)))
                {
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Body).Concat(this._parent.Parameters).Concat(this._parent.ReturnType).Concat(this._parent.TypeParameters).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the MethodDeclaration class
        /// </summary>
        public class MethodDeclarationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private MethodDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public MethodDeclarationReferencedElementsCollection(MethodDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Body != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Parameters.Count);
                    if ((this._parent.ReturnType != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.TypeParameters.Count);
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.TypeParameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.TypeParameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Body == null))
                {
                    IBlockStatement bodyCasted = item.As<IBlockStatement>();
                    if ((bodyCasted != null))
                    {
                        this._parent.Body = bodyCasted;
                        return;
                    }
                }
                IParameterSpecification parametersCasted = item.As<IParameterSpecification>();
                if ((parametersCasted != null))
                {
                    this._parent.Parameters.Add(parametersCasted);
                }
                if ((this._parent.ReturnType == null))
                {
                    ITypeReference returnTypeCasted = item.As<ITypeReference>();
                    if ((returnTypeCasted != null))
                    {
                        this._parent.ReturnType = returnTypeCasted;
                        return;
                    }
                }
                ITypeParameter typeParametersCasted = item.As<ITypeParameter>();
                if ((typeParametersCasted != null))
                {
                    this._parent.TypeParameters.Add(typeParametersCasted);
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Body = null;
                this._parent.Parameters.Clear();
                this._parent.ReturnType = null;
                this._parent.TypeParameters.Clear();
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Body))
                {
                    return true;
                }
                if (this._parent.Parameters.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.ReturnType))
                {
                    return true;
                }
                if (this._parent.TypeParameters.Contains(item))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Body != null))
                {
                    array[arrayIndex] = this._parent.Body;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> parametersEnumerator = this._parent.Parameters.GetEnumerator();
                try
                {
                    for (
                    ; parametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = parametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    parametersEnumerator.Dispose();
                }
                if ((this._parent.ReturnType != null))
                {
                    array[arrayIndex] = this._parent.ReturnType;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> typeParametersEnumerator = this._parent.TypeParameters.GetEnumerator();
                try
                {
                    for (
                    ; typeParametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = typeParametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    typeParametersEnumerator.Dispose();
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Body == item))
                {
                    this._parent.Body = null;
                    return true;
                }
                IParameterSpecification parameterSpecificationItem = item.As<IParameterSpecification>();
                if (((parameterSpecificationItem != null) 
                            && this._parent.Parameters.Remove(parameterSpecificationItem)))
                {
                    return true;
                }
                if ((this._parent.ReturnType == item))
                {
                    this._parent.ReturnType = null;
                    return true;
                }
                ITypeParameter typeParameterItem = item.As<ITypeParameter>();
                if (((typeParameterItem != null) 
                            && this._parent.TypeParameters.Remove(typeParameterItem)))
                {
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Body).Concat(this._parent.Parameters).Concat(this._parent.ReturnType).Concat(this._parent.TypeParameters).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IMethodDeclaration, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IMethodDeclaration modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the body property
        /// </summary>
        private sealed class BodyProxy : ModelPropertyChange<IMethodDeclaration, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BodyProxy(IMethodDeclaration modelElement) : 
                    base(modelElement, "body")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.Body;
                }
                set
                {
                    this.ModelElement.Body = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the returnType property
        /// </summary>
        private sealed class ReturnTypeProxy : ModelPropertyChange<IMethodDeclaration, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ReturnTypeProxy(IMethodDeclaration modelElement) : 
                    base(modelElement, "returnType")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.ReturnType;
                }
                set
                {
                    this.ModelElement.ReturnType = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ConstructorDeclaration class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ConstructorDeclaration")]
    [DebuggerDisplayAttribute("ConstructorDeclaration {Name}")]
    public partial class ConstructorDeclaration : TypeMember, IConstructorDeclaration, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Modifiers property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<Modifier> _modifiers;
        
        private static Lazy<ITypedElement> _modifiersAttribute = new Lazy<ITypedElement>(RetrieveModifiersAttribute);
        
        private static Lazy<ITypedElement> _bodyReference = new Lazy<ITypedElement>(RetrieveBodyReference);
        
        /// <summary>
        /// The backing field for the Body property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _body;
        
        private static Lazy<ITypedElement> _parametersReference = new Lazy<ITypedElement>(RetrieveParametersReference);
        
        /// <summary>
        /// The backing field for the Parameters property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IParameterSpecification> _parameters;
        
        private static Lazy<ITypedElement> _annotationsReference = new Lazy<ITypedElement>(RetrieveAnnotationsReference);
        
        /// <summary>
        /// The backing field for the Annotations property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IAnnotation> _annotations;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public ConstructorDeclaration()
        {
            this._modifiers = new ObservableList<Modifier>();
            this._modifiers.CollectionChanging += this.ModifiersCollectionChanging;
            this._modifiers.CollectionChanged += this.ModifiersCollectionChanged;
            this._parameters = new ObservableCompositionList<IParameterSpecification>(this);
            this._parameters.CollectionChanging += this.ParametersCollectionChanging;
            this._parameters.CollectionChanged += this.ParametersCollectionChanged;
            this._annotations = new ObservableCompositionList<IAnnotation>(this);
            this._annotations.CollectionChanging += this.AnnotationsCollectionChanging;
            this._annotations.CollectionChanged += this.AnnotationsCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("ConstructorDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("ConstructorDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<Modifier> Modifiers
        {
            get
            {
                return this._modifiers;
            }
        }
        
        /// <summary>
        /// The body property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement Body
        {
            get
            {
                return this._body;
            }
            set
            {
                if ((this._body != value))
                {
                    IBlockStatement old = this._body;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Body", e, _bodyReference);
                    this._body = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetBody;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetBody;
                    }
                    this.OnPropertyChanged("Body", e, _bodyReference);
                }
            }
        }
        
        /// <summary>
        /// The parameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("parameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IParameterSpecification> Parameters
        {
            get
            {
                return this._parameters;
            }
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IAnnotation> Annotations
        {
            get
            {
                return this._annotations;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ConstructorDeclarationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ConstructorDeclarationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ConstructorDeclaration")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConstructorDeclaration.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveModifiersAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConstructorDeclaration.ClassInstance)).Resolve("modifiers")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Modifiers", e, _modifiersAttribute);
        }
        
        private static ITypedElement RetrieveBodyReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConstructorDeclaration.ClassInstance)).Resolve("body")));
        }
        
        /// <summary>
        /// Handles the event that the Body property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetBody(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Body))
            {
                this.Body = null;
            }
        }
        
        private static ITypedElement RetrieveParametersReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConstructorDeclaration.ClassInstance)).Resolve("parameters")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Parameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ParametersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Parameters", e, _parametersReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Parameters property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ParametersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Parameters", e, _parametersReference);
        }
        
        private static ITypedElement RetrieveAnnotationsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConstructorDeclaration.ClassInstance)).Resolve("annotations")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Body))
            {
                return ModelHelper.CreatePath("body");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BODY"))
            {
                return this.Body;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "PARAMETERS"))
            {
                return this._parameters;
            }
            if ((feature == "ANNOTATIONS"))
            {
                return this._annotations;
            }
            if ((feature == "MODIFIERS"))
            {
                return this._modifiers;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BODY"))
            {
                this.Body = ((IBlockStatement)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "BODY"))
            {
                return new BodyProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._parameters))
            {
                return "parameters";
            }
            if ((container == this._annotations))
            {
                return "annotations";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ConstructorDeclaration")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ConstructorDeclaration class
        /// </summary>
        public class ConstructorDeclarationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ConstructorDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ConstructorDeclarationChildrenCollection(ConstructorDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Body != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Parameters.Count);
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Body == null))
                {
                    IBlockStatement bodyCasted = item.As<IBlockStatement>();
                    if ((bodyCasted != null))
                    {
                        this._parent.Body = bodyCasted;
                        return;
                    }
                }
                IParameterSpecification parametersCasted = item.As<IParameterSpecification>();
                if ((parametersCasted != null))
                {
                    this._parent.Parameters.Add(parametersCasted);
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Body = null;
                this._parent.Parameters.Clear();
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Body))
                {
                    return true;
                }
                if (this._parent.Parameters.Contains(item))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Body != null))
                {
                    array[arrayIndex] = this._parent.Body;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> parametersEnumerator = this._parent.Parameters.GetEnumerator();
                try
                {
                    for (
                    ; parametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = parametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    parametersEnumerator.Dispose();
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Body == item))
                {
                    this._parent.Body = null;
                    return true;
                }
                IParameterSpecification parameterSpecificationItem = item.As<IParameterSpecification>();
                if (((parameterSpecificationItem != null) 
                            && this._parent.Parameters.Remove(parameterSpecificationItem)))
                {
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Body).Concat(this._parent.Parameters).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ConstructorDeclaration class
        /// </summary>
        public class ConstructorDeclarationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ConstructorDeclaration _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ConstructorDeclarationReferencedElementsCollection(ConstructorDeclaration parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Body != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Parameters.Count);
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Parameters.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Body == null))
                {
                    IBlockStatement bodyCasted = item.As<IBlockStatement>();
                    if ((bodyCasted != null))
                    {
                        this._parent.Body = bodyCasted;
                        return;
                    }
                }
                IParameterSpecification parametersCasted = item.As<IParameterSpecification>();
                if ((parametersCasted != null))
                {
                    this._parent.Parameters.Add(parametersCasted);
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Body = null;
                this._parent.Parameters.Clear();
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Body))
                {
                    return true;
                }
                if (this._parent.Parameters.Contains(item))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Body != null))
                {
                    array[arrayIndex] = this._parent.Body;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> parametersEnumerator = this._parent.Parameters.GetEnumerator();
                try
                {
                    for (
                    ; parametersEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = parametersEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    parametersEnumerator.Dispose();
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Body == item))
                {
                    this._parent.Body = null;
                    return true;
                }
                IParameterSpecification parameterSpecificationItem = item.As<IParameterSpecification>();
                if (((parameterSpecificationItem != null) 
                            && this._parent.Parameters.Remove(parameterSpecificationItem)))
                {
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Body).Concat(this._parent.Parameters).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IConstructorDeclaration, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IConstructorDeclaration modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the body property
        /// </summary>
        private sealed class BodyProxy : ModelPropertyChange<IConstructorDeclaration, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BodyProxy(IConstructorDeclaration modelElement) : 
                    base(modelElement, "body")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.Body;
                }
                set
                {
                    this.ModelElement.Body = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ParameterSpecification class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ParameterSpecification")]
    [DebuggerDisplayAttribute("ParameterSpecification {Name}")]
    public partial class ParameterSpecification : ModelElement, IParameterSpecification, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the IsFinal property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private Nullable<bool> _isFinal;
        
        private static Lazy<ITypedElement> _isFinalAttribute = new Lazy<ITypedElement>(RetrieveIsFinalAttribute);
        
        private static Lazy<ITypedElement> _typeReference = new Lazy<ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _type;
        
        private static Lazy<ITypedElement> _annotationsReference = new Lazy<ITypedElement>(RetrieveAnnotationsReference);
        
        /// <summary>
        /// The backing field for the Annotations property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IAnnotation> _annotations;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public ParameterSpecification()
        {
            this._annotations = new ObservableCompositionList<IAnnotation>(this);
            this._annotations.CollectionChanging += this.AnnotationsCollectionChanging;
            this._annotations.CollectionChanged += this.AnnotationsCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("ParameterSpecification")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The isFinal property
        /// </summary>
        [DisplayNameAttribute("isFinal")]
        [CategoryAttribute("ParameterSpecification")]
        [XmlElementNameAttribute("isFinal")]
        [XmlAttributeAttribute(true)]
        public Nullable<bool> IsFinal
        {
            get
            {
                return this._isFinal;
            }
            set
            {
                if ((this._isFinal != value))
                {
                    Nullable<bool> old = this._isFinal;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("IsFinal", e, _isFinalAttribute);
                    this._isFinal = value;
                    this.OnPropertyChanged("IsFinal", e, _isFinalAttribute);
                }
            }
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    ITypeReference old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IAnnotation> Annotations
        {
            get
            {
                return this._annotations;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ParameterSpecificationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ParameterSpecificationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ParameterSpecification")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ParameterSpecification.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveIsFinalAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ParameterSpecification.ClassInstance)).Resolve("isFinal")));
        }
        
        private static ITypedElement RetrieveTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ParameterSpecification.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        private static ITypedElement RetrieveAnnotationsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ParameterSpecification.ClassInstance)).Resolve("annotations")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Annotations property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void AnnotationsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Annotations", e, _annotationsReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Type))
            {
                return ModelHelper.CreatePath("type");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            if ((attribute == "ISFINAL"))
            {
                return this.IsFinal;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ANNOTATIONS"))
            {
                return this._annotations;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TYPE"))
            {
                this.Type = ((ITypeReference)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            if ((feature == "ISFINAL"))
            {
                this.IsFinal = ((bool)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            if ((attribute == "ISFINAL"))
            {
                return Observable.Box(new IsFinalProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._annotations))
            {
                return "annotations";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ParameterSpecification")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ParameterSpecification class
        /// </summary>
        public class ParameterSpecificationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ParameterSpecification _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ParameterSpecificationChildrenCollection(ParameterSpecification parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Type = null;
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Type))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Type).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ParameterSpecification class
        /// </summary>
        public class ParameterSpecificationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ParameterSpecification _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ParameterSpecificationReferencedElementsCollection(ParameterSpecification parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Annotations.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Annotations.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
                IAnnotation annotationsCasted = item.As<IAnnotation>();
                if ((annotationsCasted != null))
                {
                    this._parent.Annotations.Add(annotationsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Type = null;
                this._parent.Annotations.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Type))
                {
                    return true;
                }
                if (this._parent.Annotations.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> annotationsEnumerator = this._parent.Annotations.GetEnumerator();
                try
                {
                    for (
                    ; annotationsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = annotationsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    annotationsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                IAnnotation annotationItem = item.As<IAnnotation>();
                if (((annotationItem != null) 
                            && this._parent.Annotations.Remove(annotationItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Type).Concat(this._parent.Annotations).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IParameterSpecification, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IParameterSpecification modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the isFinal property
        /// </summary>
        private sealed class IsFinalProxy : ModelPropertyChange<IParameterSpecification, Nullable<bool>>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IsFinalProxy(IParameterSpecification modelElement) : 
                    base(modelElement, "isFinal")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override Nullable<bool> Value
            {
                get
                {
                    return this.ModelElement.IsFinal;
                }
                set
                {
                    this.ModelElement.IsFinal = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IParameterSpecification, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IParameterSpecification modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the Annotation class
    /// </summary>
    [XmlIdentifierAttribute("Name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Annotation")]
    [DebuggerDisplayAttribute("Annotation {Name}")]
    public partial class Annotation : ModelElement, IAnnotation, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        private static Lazy<ITypedElement> _argumentsReference = new Lazy<ITypedElement>(RetrieveArgumentsReference);
        
        /// <summary>
        /// The backing field for the Arguments property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IExpression> _arguments;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public Annotation()
        {
            this._arguments = new ObservableCompositionList<IExpression>(this);
            this._arguments.CollectionChanging += this.ArgumentsCollectionChanging;
            this._arguments.CollectionChanged += this.ArgumentsCollectionChanged;
        }
        
        /// <summary>
        /// The Name property
        /// </summary>
        [CategoryAttribute("Annotation")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IExpression> Arguments
        {
            get
            {
                return this._arguments;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new AnnotationChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new AnnotationReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Annotation")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.Annotation.ClassInstance)).Resolve("Name")));
        }
        
        private static ITypedElement RetrieveArgumentsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.Annotation.ClassInstance)).Resolve("arguments")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Arguments", e, _argumentsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Arguments", e, _argumentsReference);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ARGUMENTS"))
            {
                return this._arguments;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._arguments))
            {
                return "arguments";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Annotation")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Annotation class
        /// </summary>
        public class AnnotationChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Annotation _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public AnnotationChildrenCollection(Annotation parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the Annotation class
        /// </summary>
        public class AnnotationReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private Annotation _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public AnnotationReferencedElementsCollection(Annotation parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the Name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IAnnotation, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IAnnotation modelElement) : 
                    base(modelElement, "Name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the Statement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Statement")]
    public partial class Statement : ModelElement, IStatement, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Statement")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Statement")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the VariableStatement class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//VariableStatement")]
    [DebuggerDisplayAttribute("VariableStatement {Name}")]
    public partial class VariableStatement : Statement, IVariableStatement, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        /// <summary>
        /// The backing field for the Modifiers property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<Modifier> _modifiers;
        
        private static Lazy<ITypedElement> _modifiersAttribute = new Lazy<ITypedElement>(RetrieveModifiersAttribute);
        
        private static Lazy<ITypedElement> _initExpressionReference = new Lazy<ITypedElement>(RetrieveInitExpressionReference);
        
        /// <summary>
        /// The backing field for the InitExpression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _initExpression;
        
        private static Lazy<ITypedElement> _typeReference = new Lazy<ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _type;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public VariableStatement()
        {
            this._modifiers = new ObservableList<Modifier>();
            this._modifiers.CollectionChanging += this.ModifiersCollectionChanging;
            this._modifiers.CollectionChanged += this.ModifiersCollectionChanged;
        }
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("VariableStatement")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("VariableStatement")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<Modifier> Modifiers
        {
            get
            {
                return this._modifiers;
            }
        }
        
        /// <summary>
        /// The initExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("initExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression InitExpression
        {
            get
            {
                return this._initExpression;
            }
            set
            {
                if ((this._initExpression != value))
                {
                    IExpression old = this._initExpression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("InitExpression", e, _initExpressionReference);
                    this._initExpression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetInitExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetInitExpression;
                    }
                    this.OnPropertyChanged("InitExpression", e, _initExpressionReference);
                }
            }
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    ITypeReference old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new VariableStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new VariableStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//VariableStatement")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableStatement.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveModifiersAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableStatement.ClassInstance)).Resolve("modifiers")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Modifiers", e, _modifiersAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Modifiers property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ModifiersCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Modifiers", e, _modifiersAttribute);
        }
        
        private static ITypedElement RetrieveInitExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableStatement.ClassInstance)).Resolve("initExpression")));
        }
        
        /// <summary>
        /// Handles the event that the InitExpression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetInitExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.InitExpression))
            {
                this.InitExpression = null;
            }
        }
        
        private static ITypedElement RetrieveTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableStatement.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.InitExpression))
            {
                return ModelHelper.CreatePath("initExpression");
            }
            if ((element == this.Type))
            {
                return ModelHelper.CreatePath("type");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "INITEXPRESSION"))
            {
                return this.InitExpression;
            }
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "MODIFIERS"))
            {
                return this._modifiers;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "INITEXPRESSION"))
            {
                this.InitExpression = ((IExpression)(value));
                return;
            }
            if ((feature == "TYPE"))
            {
                this.Type = ((ITypeReference)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "INITEXPRESSION"))
            {
                return new InitExpressionProxy(this);
            }
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//VariableStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the VariableStatement class
        /// </summary>
        public class VariableStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private VariableStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public VariableStatementChildrenCollection(VariableStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.InitExpression != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.InitExpression == null))
                {
                    IExpression initExpressionCasted = item.As<IExpression>();
                    if ((initExpressionCasted != null))
                    {
                        this._parent.InitExpression = initExpressionCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.InitExpression = null;
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.InitExpression))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.InitExpression != null))
                {
                    array[arrayIndex] = this._parent.InitExpression;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.InitExpression == item))
                {
                    this._parent.InitExpression = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.InitExpression).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the VariableStatement class
        /// </summary>
        public class VariableStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private VariableStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public VariableStatementReferencedElementsCollection(VariableStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.InitExpression != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.InitExpression == null))
                {
                    IExpression initExpressionCasted = item.As<IExpression>();
                    if ((initExpressionCasted != null))
                    {
                        this._parent.InitExpression = initExpressionCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.InitExpression = null;
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.InitExpression))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.InitExpression != null))
                {
                    array[arrayIndex] = this._parent.InitExpression;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.InitExpression == item))
                {
                    this._parent.InitExpression = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.InitExpression).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IVariableStatement, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IVariableStatement modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the initExpression property
        /// </summary>
        private sealed class InitExpressionProxy : ModelPropertyChange<IVariableStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public InitExpressionProxy(IVariableStatement modelElement) : 
                    base(modelElement, "initExpression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.InitExpression;
                }
                set
                {
                    this.ModelElement.InitExpression = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IVariableStatement, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IVariableStatement modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the WhileStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//WhileStatement")]
    public partial class WhileStatement : Statement, IWhileStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _statementReference = new Lazy<ITypedElement>(RetrieveStatementReference);
        
        /// <summary>
        /// The backing field for the Statement property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IStatement _statement;
        
        private static Lazy<ITypedElement> _testReference = new Lazy<ITypedElement>(RetrieveTestReference);
        
        /// <summary>
        /// The backing field for the Test property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _test;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The statement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IStatement Statement
        {
            get
            {
                return this._statement;
            }
            set
            {
                if ((this._statement != value))
                {
                    IStatement old = this._statement;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Statement", e, _statementReference);
                    this._statement = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetStatement;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetStatement;
                    }
                    this.OnPropertyChanged("Statement", e, _statementReference);
                }
            }
        }
        
        /// <summary>
        /// The test property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("test")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Test
        {
            get
            {
                return this._test;
            }
            set
            {
                if ((this._test != value))
                {
                    IExpression old = this._test;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Test", e, _testReference);
                    this._test = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTest;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTest;
                    }
                    this.OnPropertyChanged("Test", e, _testReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new WhileStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new WhileStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//WhileStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveStatementReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.WhileStatement.ClassInstance)).Resolve("statement")));
        }
        
        /// <summary>
        /// Handles the event that the Statement property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetStatement(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Statement))
            {
                this.Statement = null;
            }
        }
        
        private static ITypedElement RetrieveTestReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.WhileStatement.ClassInstance)).Resolve("test")));
        }
        
        /// <summary>
        /// Handles the event that the Test property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTest(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Test))
            {
                this.Test = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Statement))
            {
                return ModelHelper.CreatePath("statement");
            }
            if ((element == this.Test))
            {
                return ModelHelper.CreatePath("test");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "STATEMENT"))
            {
                return this.Statement;
            }
            if ((reference == "TEST"))
            {
                return this.Test;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "STATEMENT"))
            {
                this.Statement = ((IStatement)(value));
                return;
            }
            if ((feature == "TEST"))
            {
                this.Test = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "STATEMENT"))
            {
                return new StatementProxy(this);
            }
            if ((reference == "TEST"))
            {
                return new TestProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//WhileStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the WhileStatement class
        /// </summary>
        public class WhileStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private WhileStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public WhileStatementChildrenCollection(WhileStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Statement != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Test != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Statement == null))
                {
                    IStatement statementCasted = item.As<IStatement>();
                    if ((statementCasted != null))
                    {
                        this._parent.Statement = statementCasted;
                        return;
                    }
                }
                if ((this._parent.Test == null))
                {
                    IExpression testCasted = item.As<IExpression>();
                    if ((testCasted != null))
                    {
                        this._parent.Test = testCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statement = null;
                this._parent.Test = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Statement))
                {
                    return true;
                }
                if ((item == this._parent.Test))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Statement != null))
                {
                    array[arrayIndex] = this._parent.Statement;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Test != null))
                {
                    array[arrayIndex] = this._parent.Test;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Statement == item))
                {
                    this._parent.Statement = null;
                    return true;
                }
                if ((this._parent.Test == item))
                {
                    this._parent.Test = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statement).Concat(this._parent.Test).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the WhileStatement class
        /// </summary>
        public class WhileStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private WhileStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public WhileStatementReferencedElementsCollection(WhileStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Statement != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Test != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Statement == null))
                {
                    IStatement statementCasted = item.As<IStatement>();
                    if ((statementCasted != null))
                    {
                        this._parent.Statement = statementCasted;
                        return;
                    }
                }
                if ((this._parent.Test == null))
                {
                    IExpression testCasted = item.As<IExpression>();
                    if ((testCasted != null))
                    {
                        this._parent.Test = testCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statement = null;
                this._parent.Test = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Statement))
                {
                    return true;
                }
                if ((item == this._parent.Test))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Statement != null))
                {
                    array[arrayIndex] = this._parent.Statement;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Test != null))
                {
                    array[arrayIndex] = this._parent.Test;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Statement == item))
                {
                    this._parent.Statement = null;
                    return true;
                }
                if ((this._parent.Test == item))
                {
                    this._parent.Test = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statement).Concat(this._parent.Test).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the statement property
        /// </summary>
        private sealed class StatementProxy : ModelPropertyChange<IWhileStatement, IStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public StatementProxy(IWhileStatement modelElement) : 
                    base(modelElement, "statement")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IStatement Value
            {
                get
                {
                    return this.ModelElement.Statement;
                }
                set
                {
                    this.ModelElement.Statement = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the test property
        /// </summary>
        private sealed class TestProxy : ModelPropertyChange<IWhileStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TestProxy(IWhileStatement modelElement) : 
                    base(modelElement, "test")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Test;
                }
                set
                {
                    this.ModelElement.Test = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ConditionalStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ConditionalStatement")]
    public partial class ConditionalStatement : Statement, IConditionalStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _elseStatementReference = new Lazy<ITypedElement>(RetrieveElseStatementReference);
        
        /// <summary>
        /// The backing field for the ElseStatement property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IStatement _elseStatement;
        
        private static Lazy<ITypedElement> _trueStatementReference = new Lazy<ITypedElement>(RetrieveTrueStatementReference);
        
        /// <summary>
        /// The backing field for the TrueStatement property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IStatement _trueStatement;
        
        private static Lazy<ITypedElement> _testReference = new Lazy<ITypedElement>(RetrieveTestReference);
        
        /// <summary>
        /// The backing field for the Test property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _test;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The elseStatement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("elseStatement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IStatement ElseStatement
        {
            get
            {
                return this._elseStatement;
            }
            set
            {
                if ((this._elseStatement != value))
                {
                    IStatement old = this._elseStatement;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ElseStatement", e, _elseStatementReference);
                    this._elseStatement = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetElseStatement;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetElseStatement;
                    }
                    this.OnPropertyChanged("ElseStatement", e, _elseStatementReference);
                }
            }
        }
        
        /// <summary>
        /// The trueStatement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("trueStatement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IStatement TrueStatement
        {
            get
            {
                return this._trueStatement;
            }
            set
            {
                if ((this._trueStatement != value))
                {
                    IStatement old = this._trueStatement;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TrueStatement", e, _trueStatementReference);
                    this._trueStatement = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTrueStatement;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTrueStatement;
                    }
                    this.OnPropertyChanged("TrueStatement", e, _trueStatementReference);
                }
            }
        }
        
        /// <summary>
        /// The test property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("test")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Test
        {
            get
            {
                return this._test;
            }
            set
            {
                if ((this._test != value))
                {
                    IExpression old = this._test;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Test", e, _testReference);
                    this._test = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTest;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTest;
                    }
                    this.OnPropertyChanged("Test", e, _testReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ConditionalStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ConditionalStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ConditionalStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveElseStatementReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConditionalStatement.ClassInstance)).Resolve("elseStatement")));
        }
        
        /// <summary>
        /// Handles the event that the ElseStatement property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetElseStatement(object sender, EventArgs eventArgs)
        {
            if ((sender == this.ElseStatement))
            {
                this.ElseStatement = null;
            }
        }
        
        private static ITypedElement RetrieveTrueStatementReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConditionalStatement.ClassInstance)).Resolve("trueStatement")));
        }
        
        /// <summary>
        /// Handles the event that the TrueStatement property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTrueStatement(object sender, EventArgs eventArgs)
        {
            if ((sender == this.TrueStatement))
            {
                this.TrueStatement = null;
            }
        }
        
        private static ITypedElement RetrieveTestReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ConditionalStatement.ClassInstance)).Resolve("test")));
        }
        
        /// <summary>
        /// Handles the event that the Test property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTest(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Test))
            {
                this.Test = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.ElseStatement))
            {
                return ModelHelper.CreatePath("elseStatement");
            }
            if ((element == this.TrueStatement))
            {
                return ModelHelper.CreatePath("trueStatement");
            }
            if ((element == this.Test))
            {
                return ModelHelper.CreatePath("test");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "ELSESTATEMENT"))
            {
                return this.ElseStatement;
            }
            if ((reference == "TRUESTATEMENT"))
            {
                return this.TrueStatement;
            }
            if ((reference == "TEST"))
            {
                return this.Test;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "ELSESTATEMENT"))
            {
                this.ElseStatement = ((IStatement)(value));
                return;
            }
            if ((feature == "TRUESTATEMENT"))
            {
                this.TrueStatement = ((IStatement)(value));
                return;
            }
            if ((feature == "TEST"))
            {
                this.Test = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "ELSESTATEMENT"))
            {
                return new ElseStatementProxy(this);
            }
            if ((reference == "TRUESTATEMENT"))
            {
                return new TrueStatementProxy(this);
            }
            if ((reference == "TEST"))
            {
                return new TestProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ConditionalStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ConditionalStatement class
        /// </summary>
        public class ConditionalStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ConditionalStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ConditionalStatementChildrenCollection(ConditionalStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ElseStatement != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.TrueStatement != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Test != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ElseStatement == null))
                {
                    IStatement elseStatementCasted = item.As<IStatement>();
                    if ((elseStatementCasted != null))
                    {
                        this._parent.ElseStatement = elseStatementCasted;
                        return;
                    }
                }
                if ((this._parent.TrueStatement == null))
                {
                    IStatement trueStatementCasted = item.As<IStatement>();
                    if ((trueStatementCasted != null))
                    {
                        this._parent.TrueStatement = trueStatementCasted;
                        return;
                    }
                }
                if ((this._parent.Test == null))
                {
                    IExpression testCasted = item.As<IExpression>();
                    if ((testCasted != null))
                    {
                        this._parent.Test = testCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ElseStatement = null;
                this._parent.TrueStatement = null;
                this._parent.Test = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ElseStatement))
                {
                    return true;
                }
                if ((item == this._parent.TrueStatement))
                {
                    return true;
                }
                if ((item == this._parent.Test))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ElseStatement != null))
                {
                    array[arrayIndex] = this._parent.ElseStatement;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.TrueStatement != null))
                {
                    array[arrayIndex] = this._parent.TrueStatement;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Test != null))
                {
                    array[arrayIndex] = this._parent.Test;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ElseStatement == item))
                {
                    this._parent.ElseStatement = null;
                    return true;
                }
                if ((this._parent.TrueStatement == item))
                {
                    this._parent.TrueStatement = null;
                    return true;
                }
                if ((this._parent.Test == item))
                {
                    this._parent.Test = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ElseStatement).Concat(this._parent.TrueStatement).Concat(this._parent.Test).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ConditionalStatement class
        /// </summary>
        public class ConditionalStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ConditionalStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ConditionalStatementReferencedElementsCollection(ConditionalStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ElseStatement != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.TrueStatement != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Test != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ElseStatement == null))
                {
                    IStatement elseStatementCasted = item.As<IStatement>();
                    if ((elseStatementCasted != null))
                    {
                        this._parent.ElseStatement = elseStatementCasted;
                        return;
                    }
                }
                if ((this._parent.TrueStatement == null))
                {
                    IStatement trueStatementCasted = item.As<IStatement>();
                    if ((trueStatementCasted != null))
                    {
                        this._parent.TrueStatement = trueStatementCasted;
                        return;
                    }
                }
                if ((this._parent.Test == null))
                {
                    IExpression testCasted = item.As<IExpression>();
                    if ((testCasted != null))
                    {
                        this._parent.Test = testCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ElseStatement = null;
                this._parent.TrueStatement = null;
                this._parent.Test = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ElseStatement))
                {
                    return true;
                }
                if ((item == this._parent.TrueStatement))
                {
                    return true;
                }
                if ((item == this._parent.Test))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ElseStatement != null))
                {
                    array[arrayIndex] = this._parent.ElseStatement;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.TrueStatement != null))
                {
                    array[arrayIndex] = this._parent.TrueStatement;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Test != null))
                {
                    array[arrayIndex] = this._parent.Test;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ElseStatement == item))
                {
                    this._parent.ElseStatement = null;
                    return true;
                }
                if ((this._parent.TrueStatement == item))
                {
                    this._parent.TrueStatement = null;
                    return true;
                }
                if ((this._parent.Test == item))
                {
                    this._parent.Test = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ElseStatement).Concat(this._parent.TrueStatement).Concat(this._parent.Test).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the elseStatement property
        /// </summary>
        private sealed class ElseStatementProxy : ModelPropertyChange<IConditionalStatement, IStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ElseStatementProxy(IConditionalStatement modelElement) : 
                    base(modelElement, "elseStatement")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IStatement Value
            {
                get
                {
                    return this.ModelElement.ElseStatement;
                }
                set
                {
                    this.ModelElement.ElseStatement = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the trueStatement property
        /// </summary>
        private sealed class TrueStatementProxy : ModelPropertyChange<IConditionalStatement, IStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TrueStatementProxy(IConditionalStatement modelElement) : 
                    base(modelElement, "trueStatement")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IStatement Value
            {
                get
                {
                    return this.ModelElement.TrueStatement;
                }
                set
                {
                    this.ModelElement.TrueStatement = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the test property
        /// </summary>
        private sealed class TestProxy : ModelPropertyChange<IConditionalStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TestProxy(IConditionalStatement modelElement) : 
                    base(modelElement, "test")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Test;
                }
                set
                {
                    this.ModelElement.Test = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the DoStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//DoStatement")]
    public partial class DoStatement : Statement, IDoStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _testExpressionReference = new Lazy<ITypedElement>(RetrieveTestExpressionReference);
        
        /// <summary>
        /// The backing field for the TestExpression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _testExpression;
        
        private static Lazy<ITypedElement> _doStatementReference = new Lazy<ITypedElement>(RetrieveDoStatementReference);
        
        /// <summary>
        /// The backing field for the DoStatement_ property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _doStatement_;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The testExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("testExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression TestExpression
        {
            get
            {
                return this._testExpression;
            }
            set
            {
                if ((this._testExpression != value))
                {
                    IExpression old = this._testExpression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TestExpression", e, _testExpressionReference);
                    this._testExpression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTestExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTestExpression;
                    }
                    this.OnPropertyChanged("TestExpression", e, _testExpressionReference);
                }
            }
        }
        
        /// <summary>
        /// The doStatement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("doStatement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement DoStatement_
        {
            get
            {
                return this._doStatement_;
            }
            set
            {
                if ((this._doStatement_ != value))
                {
                    IBlockStatement old = this._doStatement_;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("DoStatement_", e, _doStatementReference);
                    this._doStatement_ = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetDoStatement_;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetDoStatement_;
                    }
                    this.OnPropertyChanged("DoStatement_", e, _doStatementReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new DoStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new DoStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//DoStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveTestExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.DoStatement.ClassInstance)).Resolve("testExpression")));
        }
        
        /// <summary>
        /// Handles the event that the TestExpression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTestExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.TestExpression))
            {
                this.TestExpression = null;
            }
        }
        
        private static ITypedElement RetrieveDoStatementReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.DoStatement.ClassInstance)).Resolve("doStatement")));
        }
        
        /// <summary>
        /// Handles the event that the DoStatement_ property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDoStatement_(object sender, EventArgs eventArgs)
        {
            if ((sender == this.DoStatement_))
            {
                this.DoStatement_ = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.TestExpression))
            {
                return ModelHelper.CreatePath("testExpression");
            }
            if ((element == this.DoStatement_))
            {
                return ModelHelper.CreatePath("doStatement");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "TESTEXPRESSION"))
            {
                return this.TestExpression;
            }
            if ((reference == "DOSTATEMENT"))
            {
                return this.DoStatement_;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TESTEXPRESSION"))
            {
                this.TestExpression = ((IExpression)(value));
                return;
            }
            if ((feature == "DOSTATEMENT"))
            {
                this.DoStatement_ = ((IBlockStatement)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TESTEXPRESSION"))
            {
                return new TestExpressionProxy(this);
            }
            if ((reference == "DOSTATEMENT_"))
            {
                return new DoStatementProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//DoStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the DoStatement class
        /// </summary>
        public class DoStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private DoStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public DoStatementChildrenCollection(DoStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.TestExpression != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.DoStatement_ != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.TestExpression == null))
                {
                    IExpression testExpressionCasted = item.As<IExpression>();
                    if ((testExpressionCasted != null))
                    {
                        this._parent.TestExpression = testExpressionCasted;
                        return;
                    }
                }
                if ((this._parent.DoStatement_ == null))
                {
                    IBlockStatement doStatementCasted = item.As<IBlockStatement>();
                    if ((doStatementCasted != null))
                    {
                        this._parent.DoStatement_ = doStatementCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TestExpression = null;
                this._parent.DoStatement_ = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.TestExpression))
                {
                    return true;
                }
                if ((item == this._parent.DoStatement_))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.TestExpression != null))
                {
                    array[arrayIndex] = this._parent.TestExpression;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.DoStatement_ != null))
                {
                    array[arrayIndex] = this._parent.DoStatement_;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.TestExpression == item))
                {
                    this._parent.TestExpression = null;
                    return true;
                }
                if ((this._parent.DoStatement_ == item))
                {
                    this._parent.DoStatement_ = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TestExpression).Concat(this._parent.DoStatement_).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the DoStatement class
        /// </summary>
        public class DoStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private DoStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public DoStatementReferencedElementsCollection(DoStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.TestExpression != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.DoStatement_ != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.TestExpression == null))
                {
                    IExpression testExpressionCasted = item.As<IExpression>();
                    if ((testExpressionCasted != null))
                    {
                        this._parent.TestExpression = testExpressionCasted;
                        return;
                    }
                }
                if ((this._parent.DoStatement_ == null))
                {
                    IBlockStatement doStatementCasted = item.As<IBlockStatement>();
                    if ((doStatementCasted != null))
                    {
                        this._parent.DoStatement_ = doStatementCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.TestExpression = null;
                this._parent.DoStatement_ = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.TestExpression))
                {
                    return true;
                }
                if ((item == this._parent.DoStatement_))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.TestExpression != null))
                {
                    array[arrayIndex] = this._parent.TestExpression;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.DoStatement_ != null))
                {
                    array[arrayIndex] = this._parent.DoStatement_;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.TestExpression == item))
                {
                    this._parent.TestExpression = null;
                    return true;
                }
                if ((this._parent.DoStatement_ == item))
                {
                    this._parent.DoStatement_ = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.TestExpression).Concat(this._parent.DoStatement_).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the testExpression property
        /// </summary>
        private sealed class TestExpressionProxy : ModelPropertyChange<IDoStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TestExpressionProxy(IDoStatement modelElement) : 
                    base(modelElement, "testExpression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.TestExpression;
                }
                set
                {
                    this.ModelElement.TestExpression = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the doStatement property
        /// </summary>
        private sealed class DoStatementProxy : ModelPropertyChange<IDoStatement, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DoStatementProxy(IDoStatement modelElement) : 
                    base(modelElement, "doStatement")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.DoStatement_;
                }
                set
                {
                    this.ModelElement.DoStatement_ = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the SwitchStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//SwitchStatement")]
    public partial class SwitchStatement : Statement, ISwitchStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _defaultReference = new Lazy<ITypedElement>(RetrieveDefaultReference);
        
        /// <summary>
        /// The backing field for the Default property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _default;
        
        private static Lazy<ITypedElement> _casesReference = new Lazy<ITypedElement>(RetrieveCasesReference);
        
        /// <summary>
        /// The backing field for the Cases property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ISwitchCase> _cases;
        
        private static Lazy<ITypedElement> _expressionReference = new Lazy<ITypedElement>(RetrieveExpressionReference);
        
        /// <summary>
        /// The backing field for the Expression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _expression;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public SwitchStatement()
        {
            this._cases = new ObservableCompositionList<ISwitchCase>(this);
            this._cases.CollectionChanging += this.CasesCollectionChanging;
            this._cases.CollectionChanged += this.CasesCollectionChanged;
        }
        
        /// <summary>
        /// The default property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("default")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement Default
        {
            get
            {
                return this._default;
            }
            set
            {
                if ((this._default != value))
                {
                    IBlockStatement old = this._default;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Default", e, _defaultReference);
                    this._default = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetDefault;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetDefault;
                    }
                    this.OnPropertyChanged("Default", e, _defaultReference);
                }
            }
        }
        
        /// <summary>
        /// The cases property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("cases")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ISwitchCase> Cases
        {
            get
            {
                return this._cases;
            }
        }
        
        /// <summary>
        /// The expression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("expression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Expression
        {
            get
            {
                return this._expression;
            }
            set
            {
                if ((this._expression != value))
                {
                    IExpression old = this._expression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Expression", e, _expressionReference);
                    this._expression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetExpression;
                    }
                    this.OnPropertyChanged("Expression", e, _expressionReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new SwitchStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new SwitchStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//SwitchStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveDefaultReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.SwitchStatement.ClassInstance)).Resolve("default")));
        }
        
        /// <summary>
        /// Handles the event that the Default property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetDefault(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Default))
            {
                this.Default = null;
            }
        }
        
        private static ITypedElement RetrieveCasesReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.SwitchStatement.ClassInstance)).Resolve("cases")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Cases property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void CasesCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Cases", e, _casesReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Cases property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void CasesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Cases", e, _casesReference);
        }
        
        private static ITypedElement RetrieveExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.SwitchStatement.ClassInstance)).Resolve("expression")));
        }
        
        /// <summary>
        /// Handles the event that the Expression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Expression))
            {
                this.Expression = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Default))
            {
                return ModelHelper.CreatePath("default");
            }
            if ((element == this.Expression))
            {
                return ModelHelper.CreatePath("expression");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "DEFAULT"))
            {
                return this.Default;
            }
            if ((reference == "EXPRESSION"))
            {
                return this.Expression;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "CASES"))
            {
                return this._cases;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "DEFAULT"))
            {
                this.Default = ((IBlockStatement)(value));
                return;
            }
            if ((feature == "EXPRESSION"))
            {
                this.Expression = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "DEFAULT"))
            {
                return new DefaultProxy(this);
            }
            if ((reference == "EXPRESSION"))
            {
                return new ExpressionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._cases))
            {
                return "cases";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//SwitchStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the SwitchStatement class
        /// </summary>
        public class SwitchStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private SwitchStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public SwitchStatementChildrenCollection(SwitchStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Default != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Cases.Count);
                    if ((this._parent.Expression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Cases.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Cases.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Default == null))
                {
                    IBlockStatement defaultCasted = item.As<IBlockStatement>();
                    if ((defaultCasted != null))
                    {
                        this._parent.Default = defaultCasted;
                        return;
                    }
                }
                ISwitchCase casesCasted = item.As<ISwitchCase>();
                if ((casesCasted != null))
                {
                    this._parent.Cases.Add(casesCasted);
                }
                if ((this._parent.Expression == null))
                {
                    IExpression expressionCasted = item.As<IExpression>();
                    if ((expressionCasted != null))
                    {
                        this._parent.Expression = expressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Default = null;
                this._parent.Cases.Clear();
                this._parent.Expression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Default))
                {
                    return true;
                }
                if (this._parent.Cases.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Expression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Default != null))
                {
                    array[arrayIndex] = this._parent.Default;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> casesEnumerator = this._parent.Cases.GetEnumerator();
                try
                {
                    for (
                    ; casesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = casesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    casesEnumerator.Dispose();
                }
                if ((this._parent.Expression != null))
                {
                    array[arrayIndex] = this._parent.Expression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Default == item))
                {
                    this._parent.Default = null;
                    return true;
                }
                ISwitchCase switchCaseItem = item.As<ISwitchCase>();
                if (((switchCaseItem != null) 
                            && this._parent.Cases.Remove(switchCaseItem)))
                {
                    return true;
                }
                if ((this._parent.Expression == item))
                {
                    this._parent.Expression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Default).Concat(this._parent.Cases).Concat(this._parent.Expression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the SwitchStatement class
        /// </summary>
        public class SwitchStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private SwitchStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public SwitchStatementReferencedElementsCollection(SwitchStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Default != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.Cases.Count);
                    if ((this._parent.Expression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.Cases.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.Cases.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Default == null))
                {
                    IBlockStatement defaultCasted = item.As<IBlockStatement>();
                    if ((defaultCasted != null))
                    {
                        this._parent.Default = defaultCasted;
                        return;
                    }
                }
                ISwitchCase casesCasted = item.As<ISwitchCase>();
                if ((casesCasted != null))
                {
                    this._parent.Cases.Add(casesCasted);
                }
                if ((this._parent.Expression == null))
                {
                    IExpression expressionCasted = item.As<IExpression>();
                    if ((expressionCasted != null))
                    {
                        this._parent.Expression = expressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Default = null;
                this._parent.Cases.Clear();
                this._parent.Expression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Default))
                {
                    return true;
                }
                if (this._parent.Cases.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Expression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Default != null))
                {
                    array[arrayIndex] = this._parent.Default;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> casesEnumerator = this._parent.Cases.GetEnumerator();
                try
                {
                    for (
                    ; casesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = casesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    casesEnumerator.Dispose();
                }
                if ((this._parent.Expression != null))
                {
                    array[arrayIndex] = this._parent.Expression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Default == item))
                {
                    this._parent.Default = null;
                    return true;
                }
                ISwitchCase switchCaseItem = item.As<ISwitchCase>();
                if (((switchCaseItem != null) 
                            && this._parent.Cases.Remove(switchCaseItem)))
                {
                    return true;
                }
                if ((this._parent.Expression == item))
                {
                    this._parent.Expression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Default).Concat(this._parent.Cases).Concat(this._parent.Expression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the default property
        /// </summary>
        private sealed class DefaultProxy : ModelPropertyChange<ISwitchStatement, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public DefaultProxy(ISwitchStatement modelElement) : 
                    base(modelElement, "default")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.Default;
                }
                set
                {
                    this.ModelElement.Default = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the expression property
        /// </summary>
        private sealed class ExpressionProxy : ModelPropertyChange<ISwitchStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExpressionProxy(ISwitchStatement modelElement) : 
                    base(modelElement, "expression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Expression;
                }
                set
                {
                    this.ModelElement.Expression = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the SwitchCase class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//SwitchCase")]
    public partial class SwitchCase : ModelElement, ISwitchCase, IModelElement
    {
        
        private static Lazy<ITypedElement> _statementsReference = new Lazy<ITypedElement>(RetrieveStatementsReference);
        
        /// <summary>
        /// The backing field for the Statements property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _statements;
        
        private static Lazy<ITypedElement> _expressionReference = new Lazy<ITypedElement>(RetrieveExpressionReference);
        
        /// <summary>
        /// The backing field for the Expression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _expression;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The statements property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement Statements
        {
            get
            {
                return this._statements;
            }
            set
            {
                if ((this._statements != value))
                {
                    IBlockStatement old = this._statements;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Statements", e, _statementsReference);
                    this._statements = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetStatements;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetStatements;
                    }
                    this.OnPropertyChanged("Statements", e, _statementsReference);
                }
            }
        }
        
        /// <summary>
        /// The expression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("expression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Expression
        {
            get
            {
                return this._expression;
            }
            set
            {
                if ((this._expression != value))
                {
                    IExpression old = this._expression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Expression", e, _expressionReference);
                    this._expression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetExpression;
                    }
                    this.OnPropertyChanged("Expression", e, _expressionReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new SwitchCaseChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new SwitchCaseReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//SwitchCase")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveStatementsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.SwitchCase.ClassInstance)).Resolve("statements")));
        }
        
        /// <summary>
        /// Handles the event that the Statements property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetStatements(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Statements))
            {
                this.Statements = null;
            }
        }
        
        private static ITypedElement RetrieveExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.SwitchCase.ClassInstance)).Resolve("expression")));
        }
        
        /// <summary>
        /// Handles the event that the Expression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Expression))
            {
                this.Expression = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Statements))
            {
                return ModelHelper.CreatePath("statements");
            }
            if ((element == this.Expression))
            {
                return ModelHelper.CreatePath("expression");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "STATEMENTS"))
            {
                return this.Statements;
            }
            if ((reference == "EXPRESSION"))
            {
                return this.Expression;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "STATEMENTS"))
            {
                this.Statements = ((IBlockStatement)(value));
                return;
            }
            if ((feature == "EXPRESSION"))
            {
                this.Expression = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "STATEMENTS"))
            {
                return new StatementsProxy(this);
            }
            if ((reference == "EXPRESSION"))
            {
                return new ExpressionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//SwitchCase")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the SwitchCase class
        /// </summary>
        public class SwitchCaseChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private SwitchCase _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public SwitchCaseChildrenCollection(SwitchCase parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Statements != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Expression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Statements == null))
                {
                    IBlockStatement statementsCasted = item.As<IBlockStatement>();
                    if ((statementsCasted != null))
                    {
                        this._parent.Statements = statementsCasted;
                        return;
                    }
                }
                if ((this._parent.Expression == null))
                {
                    IExpression expressionCasted = item.As<IExpression>();
                    if ((expressionCasted != null))
                    {
                        this._parent.Expression = expressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statements = null;
                this._parent.Expression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Statements))
                {
                    return true;
                }
                if ((item == this._parent.Expression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Statements != null))
                {
                    array[arrayIndex] = this._parent.Statements;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Expression != null))
                {
                    array[arrayIndex] = this._parent.Expression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Statements == item))
                {
                    this._parent.Statements = null;
                    return true;
                }
                if ((this._parent.Expression == item))
                {
                    this._parent.Expression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statements).Concat(this._parent.Expression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the SwitchCase class
        /// </summary>
        public class SwitchCaseReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private SwitchCase _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public SwitchCaseReferencedElementsCollection(SwitchCase parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Statements != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Expression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Statements == null))
                {
                    IBlockStatement statementsCasted = item.As<IBlockStatement>();
                    if ((statementsCasted != null))
                    {
                        this._parent.Statements = statementsCasted;
                        return;
                    }
                }
                if ((this._parent.Expression == null))
                {
                    IExpression expressionCasted = item.As<IExpression>();
                    if ((expressionCasted != null))
                    {
                        this._parent.Expression = expressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statements = null;
                this._parent.Expression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Statements))
                {
                    return true;
                }
                if ((item == this._parent.Expression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Statements != null))
                {
                    array[arrayIndex] = this._parent.Statements;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Expression != null))
                {
                    array[arrayIndex] = this._parent.Expression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Statements == item))
                {
                    this._parent.Statements = null;
                    return true;
                }
                if ((this._parent.Expression == item))
                {
                    this._parent.Expression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statements).Concat(this._parent.Expression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the statements property
        /// </summary>
        private sealed class StatementsProxy : ModelPropertyChange<ISwitchCase, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public StatementsProxy(ISwitchCase modelElement) : 
                    base(modelElement, "statements")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.Statements;
                }
                set
                {
                    this.ModelElement.Statements = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the expression property
        /// </summary>
        private sealed class ExpressionProxy : ModelPropertyChange<ISwitchCase, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExpressionProxy(ISwitchCase modelElement) : 
                    base(modelElement, "expression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Expression;
                }
                set
                {
                    this.ModelElement.Expression = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the BlockStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//BlockStatement")]
    public partial class BlockStatement : Statement, IBlockStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _statementsReference = new Lazy<ITypedElement>(RetrieveStatementsReference);
        
        /// <summary>
        /// The backing field for the Statements property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IStatement> _statements;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public BlockStatement()
        {
            this._statements = new ObservableCompositionList<IStatement>(this);
            this._statements.CollectionChanging += this.StatementsCollectionChanging;
            this._statements.CollectionChanged += this.StatementsCollectionChanged;
        }
        
        /// <summary>
        /// The statements property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IStatement> Statements
        {
            get
            {
                return this._statements;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new BlockStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new BlockStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//BlockStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveStatementsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.BlockStatement.ClassInstance)).Resolve("statements")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Statements property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void StatementsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Statements", e, _statementsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Statements property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void StatementsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Statements", e, _statementsReference);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "STATEMENTS"))
            {
                return this._statements;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._statements))
            {
                return "statements";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//BlockStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the BlockStatement class
        /// </summary>
        public class BlockStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private BlockStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public BlockStatementChildrenCollection(BlockStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Statements.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Statements.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Statements.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IStatement statementsCasted = item.As<IStatement>();
                if ((statementsCasted != null))
                {
                    this._parent.Statements.Add(statementsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statements.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Statements.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> statementsEnumerator = this._parent.Statements.GetEnumerator();
                try
                {
                    for (
                    ; statementsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = statementsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    statementsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IStatement statementItem = item.As<IStatement>();
                if (((statementItem != null) 
                            && this._parent.Statements.Remove(statementItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statements).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the BlockStatement class
        /// </summary>
        public class BlockStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private BlockStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public BlockStatementReferencedElementsCollection(BlockStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Statements.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Statements.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Statements.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IStatement statementsCasted = item.As<IStatement>();
                if ((statementsCasted != null))
                {
                    this._parent.Statements.Add(statementsCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statements.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Statements.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> statementsEnumerator = this._parent.Statements.GetEnumerator();
                try
                {
                    for (
                    ; statementsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = statementsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    statementsEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IStatement statementItem = item.As<IStatement>();
                if (((statementItem != null) 
                            && this._parent.Statements.Remove(statementItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statements).GetEnumerator();
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the TryStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TryStatement")]
    public partial class TryStatement : Statement, ITryStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _finallyBlockReference = new Lazy<ITypedElement>(RetrieveFinallyBlockReference);
        
        /// <summary>
        /// The backing field for the FinallyBlock property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _finallyBlock;
        
        private static Lazy<ITypedElement> _tryBlockReference = new Lazy<ITypedElement>(RetrieveTryBlockReference);
        
        /// <summary>
        /// The backing field for the TryBlock property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _tryBlock;
        
        private static Lazy<ITypedElement> _catchClausesReference = new Lazy<ITypedElement>(RetrieveCatchClausesReference);
        
        /// <summary>
        /// The backing field for the CatchClauses property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<ICatchClause> _catchClauses;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public TryStatement()
        {
            this._catchClauses = new ObservableCompositionList<ICatchClause>(this);
            this._catchClauses.CollectionChanging += this.CatchClausesCollectionChanging;
            this._catchClauses.CollectionChanged += this.CatchClausesCollectionChanged;
        }
        
        /// <summary>
        /// The finallyBlock property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("finallyBlock")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement FinallyBlock
        {
            get
            {
                return this._finallyBlock;
            }
            set
            {
                if ((this._finallyBlock != value))
                {
                    IBlockStatement old = this._finallyBlock;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("FinallyBlock", e, _finallyBlockReference);
                    this._finallyBlock = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetFinallyBlock;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetFinallyBlock;
                    }
                    this.OnPropertyChanged("FinallyBlock", e, _finallyBlockReference);
                }
            }
        }
        
        /// <summary>
        /// The tryBlock property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("tryBlock")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement TryBlock
        {
            get
            {
                return this._tryBlock;
            }
            set
            {
                if ((this._tryBlock != value))
                {
                    IBlockStatement old = this._tryBlock;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("TryBlock", e, _tryBlockReference);
                    this._tryBlock = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTryBlock;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTryBlock;
                    }
                    this.OnPropertyChanged("TryBlock", e, _tryBlockReference);
                }
            }
        }
        
        /// <summary>
        /// The catchClauses property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("catchClauses")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<ICatchClause> CatchClauses
        {
            get
            {
                return this._catchClauses;
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new TryStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new TryStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TryStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveFinallyBlockReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TryStatement.ClassInstance)).Resolve("finallyBlock")));
        }
        
        /// <summary>
        /// Handles the event that the FinallyBlock property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetFinallyBlock(object sender, EventArgs eventArgs)
        {
            if ((sender == this.FinallyBlock))
            {
                this.FinallyBlock = null;
            }
        }
        
        private static ITypedElement RetrieveTryBlockReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TryStatement.ClassInstance)).Resolve("tryBlock")));
        }
        
        /// <summary>
        /// Handles the event that the TryBlock property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTryBlock(object sender, EventArgs eventArgs)
        {
            if ((sender == this.TryBlock))
            {
                this.TryBlock = null;
            }
        }
        
        private static ITypedElement RetrieveCatchClausesReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.TryStatement.ClassInstance)).Resolve("catchClauses")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the CatchClauses property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void CatchClausesCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("CatchClauses", e, _catchClausesReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the CatchClauses property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void CatchClausesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("CatchClauses", e, _catchClausesReference);
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.FinallyBlock))
            {
                return ModelHelper.CreatePath("finallyBlock");
            }
            if ((element == this.TryBlock))
            {
                return ModelHelper.CreatePath("tryBlock");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "FINALLYBLOCK"))
            {
                return this.FinallyBlock;
            }
            if ((reference == "TRYBLOCK"))
            {
                return this.TryBlock;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "CATCHCLAUSES"))
            {
                return this._catchClauses;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "FINALLYBLOCK"))
            {
                this.FinallyBlock = ((IBlockStatement)(value));
                return;
            }
            if ((feature == "TRYBLOCK"))
            {
                this.TryBlock = ((IBlockStatement)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "FINALLYBLOCK"))
            {
                return new FinallyBlockProxy(this);
            }
            if ((reference == "TRYBLOCK"))
            {
                return new TryBlockProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._catchClauses))
            {
                return "catchClauses";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//TryStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TryStatement class
        /// </summary>
        public class TryStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TryStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TryStatementChildrenCollection(TryStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.FinallyBlock != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.TryBlock != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.CatchClauses.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.CatchClauses.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.CatchClauses.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.FinallyBlock == null))
                {
                    IBlockStatement finallyBlockCasted = item.As<IBlockStatement>();
                    if ((finallyBlockCasted != null))
                    {
                        this._parent.FinallyBlock = finallyBlockCasted;
                        return;
                    }
                }
                if ((this._parent.TryBlock == null))
                {
                    IBlockStatement tryBlockCasted = item.As<IBlockStatement>();
                    if ((tryBlockCasted != null))
                    {
                        this._parent.TryBlock = tryBlockCasted;
                        return;
                    }
                }
                ICatchClause catchClausesCasted = item.As<ICatchClause>();
                if ((catchClausesCasted != null))
                {
                    this._parent.CatchClauses.Add(catchClausesCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.FinallyBlock = null;
                this._parent.TryBlock = null;
                this._parent.CatchClauses.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.FinallyBlock))
                {
                    return true;
                }
                if ((item == this._parent.TryBlock))
                {
                    return true;
                }
                if (this._parent.CatchClauses.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.FinallyBlock != null))
                {
                    array[arrayIndex] = this._parent.FinallyBlock;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.TryBlock != null))
                {
                    array[arrayIndex] = this._parent.TryBlock;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> catchClausesEnumerator = this._parent.CatchClauses.GetEnumerator();
                try
                {
                    for (
                    ; catchClausesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = catchClausesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    catchClausesEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.FinallyBlock == item))
                {
                    this._parent.FinallyBlock = null;
                    return true;
                }
                if ((this._parent.TryBlock == item))
                {
                    this._parent.TryBlock = null;
                    return true;
                }
                ICatchClause catchClauseItem = item.As<ICatchClause>();
                if (((catchClauseItem != null) 
                            && this._parent.CatchClauses.Remove(catchClauseItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.FinallyBlock).Concat(this._parent.TryBlock).Concat(this._parent.CatchClauses).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the TryStatement class
        /// </summary>
        public class TryStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private TryStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public TryStatementReferencedElementsCollection(TryStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.FinallyBlock != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.TryBlock != null))
                    {
                        count = (count + 1);
                    }
                    count = (count + this._parent.CatchClauses.Count);
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.CatchClauses.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.CatchClauses.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.FinallyBlock == null))
                {
                    IBlockStatement finallyBlockCasted = item.As<IBlockStatement>();
                    if ((finallyBlockCasted != null))
                    {
                        this._parent.FinallyBlock = finallyBlockCasted;
                        return;
                    }
                }
                if ((this._parent.TryBlock == null))
                {
                    IBlockStatement tryBlockCasted = item.As<IBlockStatement>();
                    if ((tryBlockCasted != null))
                    {
                        this._parent.TryBlock = tryBlockCasted;
                        return;
                    }
                }
                ICatchClause catchClausesCasted = item.As<ICatchClause>();
                if ((catchClausesCasted != null))
                {
                    this._parent.CatchClauses.Add(catchClausesCasted);
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.FinallyBlock = null;
                this._parent.TryBlock = null;
                this._parent.CatchClauses.Clear();
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.FinallyBlock))
                {
                    return true;
                }
                if ((item == this._parent.TryBlock))
                {
                    return true;
                }
                if (this._parent.CatchClauses.Contains(item))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.FinallyBlock != null))
                {
                    array[arrayIndex] = this._parent.FinallyBlock;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.TryBlock != null))
                {
                    array[arrayIndex] = this._parent.TryBlock;
                    arrayIndex = (arrayIndex + 1);
                }
                IEnumerator<IModelElement> catchClausesEnumerator = this._parent.CatchClauses.GetEnumerator();
                try
                {
                    for (
                    ; catchClausesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = catchClausesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    catchClausesEnumerator.Dispose();
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.FinallyBlock == item))
                {
                    this._parent.FinallyBlock = null;
                    return true;
                }
                if ((this._parent.TryBlock == item))
                {
                    this._parent.TryBlock = null;
                    return true;
                }
                ICatchClause catchClauseItem = item.As<ICatchClause>();
                if (((catchClauseItem != null) 
                            && this._parent.CatchClauses.Remove(catchClauseItem)))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.FinallyBlock).Concat(this._parent.TryBlock).Concat(this._parent.CatchClauses).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the finallyBlock property
        /// </summary>
        private sealed class FinallyBlockProxy : ModelPropertyChange<ITryStatement, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public FinallyBlockProxy(ITryStatement modelElement) : 
                    base(modelElement, "finallyBlock")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.FinallyBlock;
                }
                set
                {
                    this.ModelElement.FinallyBlock = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the tryBlock property
        /// </summary>
        private sealed class TryBlockProxy : ModelPropertyChange<ITryStatement, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TryBlockProxy(ITryStatement modelElement) : 
                    base(modelElement, "tryBlock")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.TryBlock;
                }
                set
                {
                    this.ModelElement.TryBlock = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the CatchClause class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//CatchClause")]
    public partial class CatchClause : ModelElement, ICatchClause, IModelElement
    {
        
        /// <summary>
        /// The backing field for the VariableName property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _variableName;
        
        private static Lazy<ITypedElement> _variableNameAttribute = new Lazy<ITypedElement>(RetrieveVariableNameAttribute);
        
        private static Lazy<ITypedElement> _statementsReference = new Lazy<ITypedElement>(RetrieveStatementsReference);
        
        /// <summary>
        /// The backing field for the Statements property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _statements;
        
        private static Lazy<ITypedElement> _catchTypeReference = new Lazy<ITypedElement>(RetrieveCatchTypeReference);
        
        /// <summary>
        /// The backing field for the CatchType property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _catchType;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The variableName property
        /// </summary>
        [DisplayNameAttribute("variableName")]
        [CategoryAttribute("CatchClause")]
        [XmlElementNameAttribute("variableName")]
        [XmlAttributeAttribute(true)]
        public string VariableName
        {
            get
            {
                return this._variableName;
            }
            set
            {
                if ((this._variableName != value))
                {
                    string old = this._variableName;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("VariableName", e, _variableNameAttribute);
                    this._variableName = value;
                    this.OnPropertyChanged("VariableName", e, _variableNameAttribute);
                }
            }
        }
        
        /// <summary>
        /// The statements property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement Statements
        {
            get
            {
                return this._statements;
            }
            set
            {
                if ((this._statements != value))
                {
                    IBlockStatement old = this._statements;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Statements", e, _statementsReference);
                    this._statements = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetStatements;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetStatements;
                    }
                    this.OnPropertyChanged("Statements", e, _statementsReference);
                }
            }
        }
        
        /// <summary>
        /// The catchType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("catchType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference CatchType
        {
            get
            {
                return this._catchType;
            }
            set
            {
                if ((this._catchType != value))
                {
                    ITypeReference old = this._catchType;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("CatchType", e, _catchTypeReference);
                    this._catchType = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetCatchType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetCatchType;
                    }
                    this.OnPropertyChanged("CatchType", e, _catchTypeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new CatchClauseChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new CatchClauseReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//CatchClause")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveVariableNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.CatchClause.ClassInstance)).Resolve("variableName")));
        }
        
        private static ITypedElement RetrieveStatementsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.CatchClause.ClassInstance)).Resolve("statements")));
        }
        
        /// <summary>
        /// Handles the event that the Statements property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetStatements(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Statements))
            {
                this.Statements = null;
            }
        }
        
        private static ITypedElement RetrieveCatchTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.CatchClause.ClassInstance)).Resolve("catchType")));
        }
        
        /// <summary>
        /// Handles the event that the CatchType property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetCatchType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.CatchType))
            {
                this.CatchType = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Statements))
            {
                return ModelHelper.CreatePath("statements");
            }
            if ((element == this.CatchType))
            {
                return ModelHelper.CreatePath("catchType");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "STATEMENTS"))
            {
                return this.Statements;
            }
            if ((reference == "CATCHTYPE"))
            {
                return this.CatchType;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "VARIABLENAME"))
            {
                return this.VariableName;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "STATEMENTS"))
            {
                this.Statements = ((IBlockStatement)(value));
                return;
            }
            if ((feature == "CATCHTYPE"))
            {
                this.CatchType = ((ITypeReference)(value));
                return;
            }
            if ((feature == "VARIABLENAME"))
            {
                this.VariableName = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "VARIABLENAME"))
            {
                return new VariableNameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "STATEMENTS"))
            {
                return new StatementsProxy(this);
            }
            if ((reference == "CATCHTYPE"))
            {
                return new CatchTypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//CatchClause")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the CatchClause class
        /// </summary>
        public class CatchClauseChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private CatchClause _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public CatchClauseChildrenCollection(CatchClause parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Statements != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.CatchType != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Statements == null))
                {
                    IBlockStatement statementsCasted = item.As<IBlockStatement>();
                    if ((statementsCasted != null))
                    {
                        this._parent.Statements = statementsCasted;
                        return;
                    }
                }
                if ((this._parent.CatchType == null))
                {
                    ITypeReference catchTypeCasted = item.As<ITypeReference>();
                    if ((catchTypeCasted != null))
                    {
                        this._parent.CatchType = catchTypeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statements = null;
                this._parent.CatchType = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Statements))
                {
                    return true;
                }
                if ((item == this._parent.CatchType))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Statements != null))
                {
                    array[arrayIndex] = this._parent.Statements;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.CatchType != null))
                {
                    array[arrayIndex] = this._parent.CatchType;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Statements == item))
                {
                    this._parent.Statements = null;
                    return true;
                }
                if ((this._parent.CatchType == item))
                {
                    this._parent.CatchType = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statements).Concat(this._parent.CatchType).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the CatchClause class
        /// </summary>
        public class CatchClauseReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private CatchClause _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public CatchClauseReferencedElementsCollection(CatchClause parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Statements != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.CatchType != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Statements == null))
                {
                    IBlockStatement statementsCasted = item.As<IBlockStatement>();
                    if ((statementsCasted != null))
                    {
                        this._parent.Statements = statementsCasted;
                        return;
                    }
                }
                if ((this._parent.CatchType == null))
                {
                    ITypeReference catchTypeCasted = item.As<ITypeReference>();
                    if ((catchTypeCasted != null))
                    {
                        this._parent.CatchType = catchTypeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Statements = null;
                this._parent.CatchType = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Statements))
                {
                    return true;
                }
                if ((item == this._parent.CatchType))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Statements != null))
                {
                    array[arrayIndex] = this._parent.Statements;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.CatchType != null))
                {
                    array[arrayIndex] = this._parent.CatchType;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Statements == item))
                {
                    this._parent.Statements = null;
                    return true;
                }
                if ((this._parent.CatchType == item))
                {
                    this._parent.CatchType = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Statements).Concat(this._parent.CatchType).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the variableName property
        /// </summary>
        private sealed class VariableNameProxy : ModelPropertyChange<ICatchClause, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public VariableNameProxy(ICatchClause modelElement) : 
                    base(modelElement, "variableName")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.VariableName;
                }
                set
                {
                    this.ModelElement.VariableName = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the statements property
        /// </summary>
        private sealed class StatementsProxy : ModelPropertyChange<ICatchClause, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public StatementsProxy(ICatchClause modelElement) : 
                    base(modelElement, "statements")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.Statements;
                }
                set
                {
                    this.ModelElement.Statements = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the catchType property
        /// </summary>
        private sealed class CatchTypeProxy : ModelPropertyChange<ICatchClause, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public CatchTypeProxy(ICatchClause modelElement) : 
                    base(modelElement, "catchType")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.CatchType;
                }
                set
                {
                    this.ModelElement.CatchType = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ExpressionStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ExpressionStatement")]
    public partial class ExpressionStatement : Statement, IExpressionStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _expressionReference = new Lazy<ITypedElement>(RetrieveExpressionReference);
        
        /// <summary>
        /// The backing field for the Expression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _expression;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The expression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("expression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Expression
        {
            get
            {
                return this._expression;
            }
            set
            {
                if ((this._expression != value))
                {
                    IExpression old = this._expression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Expression", e, _expressionReference);
                    this._expression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetExpression;
                    }
                    this.OnPropertyChanged("Expression", e, _expressionReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ExpressionStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ExpressionStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ExpressionStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ExpressionStatement.ClassInstance)).Resolve("expression")));
        }
        
        /// <summary>
        /// Handles the event that the Expression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Expression))
            {
                this.Expression = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Expression))
            {
                return ModelHelper.CreatePath("expression");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "EXPRESSION"))
            {
                return this.Expression;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "EXPRESSION"))
            {
                this.Expression = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "EXPRESSION"))
            {
                return new ExpressionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ExpressionStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ExpressionStatement class
        /// </summary>
        public class ExpressionStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ExpressionStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ExpressionStatementChildrenCollection(ExpressionStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Expression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Expression == null))
                {
                    IExpression expressionCasted = item.As<IExpression>();
                    if ((expressionCasted != null))
                    {
                        this._parent.Expression = expressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Expression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Expression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Expression != null))
                {
                    array[arrayIndex] = this._parent.Expression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Expression == item))
                {
                    this._parent.Expression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Expression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ExpressionStatement class
        /// </summary>
        public class ExpressionStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ExpressionStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ExpressionStatementReferencedElementsCollection(ExpressionStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Expression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Expression == null))
                {
                    IExpression expressionCasted = item.As<IExpression>();
                    if ((expressionCasted != null))
                    {
                        this._parent.Expression = expressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Expression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Expression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Expression != null))
                {
                    array[arrayIndex] = this._parent.Expression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Expression == item))
                {
                    this._parent.Expression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Expression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the expression property
        /// </summary>
        private sealed class ExpressionProxy : ModelPropertyChange<IExpressionStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ExpressionProxy(IExpressionStatement modelElement) : 
                    base(modelElement, "expression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Expression;
                }
                set
                {
                    this.ModelElement.Expression = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the BreakStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//BreakStatement")]
    public partial class BreakStatement : Statement, IBreakStatement, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//BreakStatement")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//BreakStatement")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the ContinueStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ContinueStatement")]
    public partial class ContinueStatement : Statement, IContinueStatement, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ContinueStatement")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ContinueStatement")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the ReturnStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ReturnStatement")]
    public partial class ReturnStatement : Statement, IReturnStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _returnExpressionReference = new Lazy<ITypedElement>(RetrieveReturnExpressionReference);
        
        /// <summary>
        /// The backing field for the ReturnExpression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _returnExpression;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The returnExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("returnExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression ReturnExpression
        {
            get
            {
                return this._returnExpression;
            }
            set
            {
                if ((this._returnExpression != value))
                {
                    IExpression old = this._returnExpression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ReturnExpression", e, _returnExpressionReference);
                    this._returnExpression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetReturnExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetReturnExpression;
                    }
                    this.OnPropertyChanged("ReturnExpression", e, _returnExpressionReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ReturnStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ReturnStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ReturnStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveReturnExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ReturnStatement.ClassInstance)).Resolve("returnExpression")));
        }
        
        /// <summary>
        /// Handles the event that the ReturnExpression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetReturnExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.ReturnExpression))
            {
                this.ReturnExpression = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.ReturnExpression))
            {
                return ModelHelper.CreatePath("returnExpression");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "RETURNEXPRESSION"))
            {
                return this.ReturnExpression;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "RETURNEXPRESSION"))
            {
                this.ReturnExpression = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "RETURNEXPRESSION"))
            {
                return new ReturnExpressionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ReturnStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ReturnStatement class
        /// </summary>
        public class ReturnStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ReturnStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ReturnStatementChildrenCollection(ReturnStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ReturnExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ReturnExpression == null))
                {
                    IExpression returnExpressionCasted = item.As<IExpression>();
                    if ((returnExpressionCasted != null))
                    {
                        this._parent.ReturnExpression = returnExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ReturnExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ReturnExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ReturnExpression != null))
                {
                    array[arrayIndex] = this._parent.ReturnExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ReturnExpression == item))
                {
                    this._parent.ReturnExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ReturnExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ReturnStatement class
        /// </summary>
        public class ReturnStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ReturnStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ReturnStatementReferencedElementsCollection(ReturnStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ReturnExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ReturnExpression == null))
                {
                    IExpression returnExpressionCasted = item.As<IExpression>();
                    if ((returnExpressionCasted != null))
                    {
                        this._parent.ReturnExpression = returnExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ReturnExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ReturnExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ReturnExpression != null))
                {
                    array[arrayIndex] = this._parent.ReturnExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ReturnExpression == item))
                {
                    this._parent.ReturnExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ReturnExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the returnExpression property
        /// </summary>
        private sealed class ReturnExpressionProxy : ModelPropertyChange<IReturnStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ReturnExpressionProxy(IReturnStatement modelElement) : 
                    base(modelElement, "returnExpression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.ReturnExpression;
                }
                set
                {
                    this.ModelElement.ReturnExpression = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ThrowStatement class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ThrowStatement")]
    public partial class ThrowStatement : Statement, IThrowStatement, IModelElement
    {
        
        private static Lazy<ITypedElement> _throwExpressionReference = new Lazy<ITypedElement>(RetrieveThrowExpressionReference);
        
        /// <summary>
        /// The backing field for the ThrowExpression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _throwExpression;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The throwExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("throwExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression ThrowExpression
        {
            get
            {
                return this._throwExpression;
            }
            set
            {
                if ((this._throwExpression != value))
                {
                    IExpression old = this._throwExpression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ThrowExpression", e, _throwExpressionReference);
                    this._throwExpression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetThrowExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetThrowExpression;
                    }
                    this.OnPropertyChanged("ThrowExpression", e, _throwExpressionReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ThrowStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ThrowStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ThrowStatement")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveThrowExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ThrowStatement.ClassInstance)).Resolve("throwExpression")));
        }
        
        /// <summary>
        /// Handles the event that the ThrowExpression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetThrowExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.ThrowExpression))
            {
                this.ThrowExpression = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.ThrowExpression))
            {
                return ModelHelper.CreatePath("throwExpression");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "THROWEXPRESSION"))
            {
                return this.ThrowExpression;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "THROWEXPRESSION"))
            {
                this.ThrowExpression = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "THROWEXPRESSION"))
            {
                return new ThrowExpressionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ThrowStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ThrowStatement class
        /// </summary>
        public class ThrowStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ThrowStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ThrowStatementChildrenCollection(ThrowStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ThrowExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ThrowExpression == null))
                {
                    IExpression throwExpressionCasted = item.As<IExpression>();
                    if ((throwExpressionCasted != null))
                    {
                        this._parent.ThrowExpression = throwExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ThrowExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ThrowExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ThrowExpression != null))
                {
                    array[arrayIndex] = this._parent.ThrowExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ThrowExpression == item))
                {
                    this._parent.ThrowExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ThrowExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ThrowStatement class
        /// </summary>
        public class ThrowStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ThrowStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ThrowStatementReferencedElementsCollection(ThrowStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.ThrowExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.ThrowExpression == null))
                {
                    IExpression throwExpressionCasted = item.As<IExpression>();
                    if ((throwExpressionCasted != null))
                    {
                        this._parent.ThrowExpression = throwExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.ThrowExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.ThrowExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.ThrowExpression != null))
                {
                    array[arrayIndex] = this._parent.ThrowExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.ThrowExpression == item))
                {
                    this._parent.ThrowExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.ThrowExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the throwExpression property
        /// </summary>
        private sealed class ThrowExpressionProxy : ModelPropertyChange<IThrowStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ThrowExpressionProxy(IThrowStatement modelElement) : 
                    base(modelElement, "throwExpression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.ThrowExpression;
                }
                set
                {
                    this.ModelElement.ThrowExpression = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the VariableDeclarationStatement class
    /// </summary>
    [XmlIdentifierAttribute("name")]
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//VariableDeclarationStatement")]
    [DebuggerDisplayAttribute("VariableDeclarationStatement {Name}")]
    public partial class VariableDeclarationStatement : ModelElement, IVariableDeclarationStatement, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Name property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _name;
        
        private static Lazy<ITypedElement> _nameAttribute = new Lazy<ITypedElement>(RetrieveNameAttribute);
        
        private static Lazy<ITypedElement> _initExpressionReference = new Lazy<ITypedElement>(RetrieveInitExpressionReference);
        
        /// <summary>
        /// The backing field for the InitExpression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _initExpression;
        
        private static Lazy<ITypedElement> _typeReference = new Lazy<ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _type;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("VariableDeclarationStatement")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        public string Name
        {
            get
            {
                return this._name;
            }
            set
            {
                if ((this._name != value))
                {
                    string old = this._name;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Name", e, _nameAttribute);
                    this._name = value;
                    this.OnPropertyChanged("Name", e, _nameAttribute);
                    OnKeyChanged(e);
                }
            }
        }
        
        /// <summary>
        /// The initExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("initExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression InitExpression
        {
            get
            {
                return this._initExpression;
            }
            set
            {
                if ((this._initExpression != value))
                {
                    IExpression old = this._initExpression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("InitExpression", e, _initExpressionReference);
                    this._initExpression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetInitExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetInitExpression;
                    }
                    this.OnPropertyChanged("InitExpression", e, _initExpressionReference);
                }
            }
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    ITypeReference old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new VariableDeclarationStatementChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new VariableDeclarationStatementReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//VariableDeclarationStatement")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets a value indicating whether the current model element can be identified by an attribute value
        /// </summary>
        public override bool IsIdentified
        {
            get
            {
                return true;
            }
        }
        
        private static ITypedElement RetrieveNameAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableDeclarationStatement.ClassInstance)).Resolve("name")));
        }
        
        private static ITypedElement RetrieveInitExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableDeclarationStatement.ClassInstance)).Resolve("initExpression")));
        }
        
        /// <summary>
        /// Handles the event that the InitExpression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetInitExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.InitExpression))
            {
                this.InitExpression = null;
            }
        }
        
        private static ITypedElement RetrieveTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableDeclarationStatement.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.InitExpression))
            {
                return ModelHelper.CreatePath("initExpression");
            }
            if ((element == this.Type))
            {
                return ModelHelper.CreatePath("type");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "INITEXPRESSION"))
            {
                return this.InitExpression;
            }
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "NAME"))
            {
                return this.Name;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "INITEXPRESSION"))
            {
                this.InitExpression = ((IExpression)(value));
                return;
            }
            if ((feature == "TYPE"))
            {
                this.Type = ((ITypeReference)(value));
                return;
            }
            if ((feature == "NAME"))
            {
                this.Name = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "NAME"))
            {
                return new NameProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "INITEXPRESSION"))
            {
                return new InitExpressionProxy(this);
            }
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//VariableDeclarationStatement")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Gets the identifier string for this model element
        /// </summary>
        /// <returns>The identifier string</returns>
        public override string ToIdentifierString()
        {
            if ((this.Name == null))
            {
                return null;
            }
            return this.Name.ToString();
        }
        
        /// <summary>
        /// The collection class to to represent the children of the VariableDeclarationStatement class
        /// </summary>
        public class VariableDeclarationStatementChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private VariableDeclarationStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public VariableDeclarationStatementChildrenCollection(VariableDeclarationStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.InitExpression != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.InitExpression == null))
                {
                    IExpression initExpressionCasted = item.As<IExpression>();
                    if ((initExpressionCasted != null))
                    {
                        this._parent.InitExpression = initExpressionCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.InitExpression = null;
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.InitExpression))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.InitExpression != null))
                {
                    array[arrayIndex] = this._parent.InitExpression;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.InitExpression == item))
                {
                    this._parent.InitExpression = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.InitExpression).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the VariableDeclarationStatement class
        /// </summary>
        public class VariableDeclarationStatementReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private VariableDeclarationStatement _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public VariableDeclarationStatementReferencedElementsCollection(VariableDeclarationStatement parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.InitExpression != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.InitExpression == null))
                {
                    IExpression initExpressionCasted = item.As<IExpression>();
                    if ((initExpressionCasted != null))
                    {
                        this._parent.InitExpression = initExpressionCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.InitExpression = null;
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.InitExpression))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.InitExpression != null))
                {
                    array[arrayIndex] = this._parent.InitExpression;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.InitExpression == item))
                {
                    this._parent.InitExpression = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.InitExpression).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the name property
        /// </summary>
        private sealed class NameProxy : ModelPropertyChange<IVariableDeclarationStatement, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public NameProxy(IVariableDeclarationStatement modelElement) : 
                    base(modelElement, "name")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Name;
                }
                set
                {
                    this.ModelElement.Name = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the initExpression property
        /// </summary>
        private sealed class InitExpressionProxy : ModelPropertyChange<IVariableDeclarationStatement, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public InitExpressionProxy(IVariableDeclarationStatement modelElement) : 
                    base(modelElement, "initExpression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.InitExpression;
                }
                set
                {
                    this.ModelElement.InitExpression = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IVariableDeclarationStatement, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IVariableDeclarationStatement modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the Expression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Expression")]
    public partial class Expression : ModelElement, IExpression, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Expression")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//Expression")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the LambdaExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//LambdaExpression")]
    public partial class LambdaExpression : Expression, ILambdaExpression, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Parameter property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableList<string> _parameter;
        
        private static Lazy<ITypedElement> _parameterAttribute = new Lazy<ITypedElement>(RetrieveParameterAttribute);
        
        private static Lazy<ITypedElement> _bodyReference = new Lazy<ITypedElement>(RetrieveBodyReference);
        
        /// <summary>
        /// The backing field for the Body property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IBlockStatement _body;
        
        private static Lazy<ITypedElement> _returnExpressionReference = new Lazy<ITypedElement>(RetrieveReturnExpressionReference);
        
        /// <summary>
        /// The backing field for the ReturnExpression property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _returnExpression;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public LambdaExpression()
        {
            this._parameter = new ObservableList<string>();
            this._parameter.CollectionChanging += this.ParameterCollectionChanging;
            this._parameter.CollectionChanged += this.ParameterCollectionChanged;
        }
        
        /// <summary>
        /// The parameter property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("parameter")]
        [CategoryAttribute("LambdaExpression")]
        [XmlElementNameAttribute("parameter")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        public ICollectionExpression<string> Parameter
        {
            get
            {
                return this._parameter;
            }
        }
        
        /// <summary>
        /// The body property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IBlockStatement Body
        {
            get
            {
                return this._body;
            }
            set
            {
                if ((this._body != value))
                {
                    IBlockStatement old = this._body;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Body", e, _bodyReference);
                    this._body = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetBody;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetBody;
                    }
                    this.OnPropertyChanged("Body", e, _bodyReference);
                }
            }
        }
        
        /// <summary>
        /// The returnExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("returnExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression ReturnExpression
        {
            get
            {
                return this._returnExpression;
            }
            set
            {
                if ((this._returnExpression != value))
                {
                    IExpression old = this._returnExpression;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("ReturnExpression", e, _returnExpressionReference);
                    this._returnExpression = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetReturnExpression;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetReturnExpression;
                    }
                    this.OnPropertyChanged("ReturnExpression", e, _returnExpressionReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new LambdaExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new LambdaExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//LambdaExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveParameterAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.LambdaExpression.ClassInstance)).Resolve("parameter")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Parameter property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ParameterCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Parameter", e, _parameterAttribute);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Parameter property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ParameterCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Parameter", e, _parameterAttribute);
        }
        
        private static ITypedElement RetrieveBodyReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.LambdaExpression.ClassInstance)).Resolve("body")));
        }
        
        /// <summary>
        /// Handles the event that the Body property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetBody(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Body))
            {
                this.Body = null;
            }
        }
        
        private static ITypedElement RetrieveReturnExpressionReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.LambdaExpression.ClassInstance)).Resolve("returnExpression")));
        }
        
        /// <summary>
        /// Handles the event that the ReturnExpression property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetReturnExpression(object sender, EventArgs eventArgs)
        {
            if ((sender == this.ReturnExpression))
            {
                this.ReturnExpression = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Body))
            {
                return ModelHelper.CreatePath("body");
            }
            if ((element == this.ReturnExpression))
            {
                return ModelHelper.CreatePath("returnExpression");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "BODY"))
            {
                return this.Body;
            }
            if ((reference == "RETURNEXPRESSION"))
            {
                return this.ReturnExpression;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "PARAMETER"))
            {
                return this._parameter;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "BODY"))
            {
                this.Body = ((IBlockStatement)(value));
                return;
            }
            if ((feature == "RETURNEXPRESSION"))
            {
                this.ReturnExpression = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "BODY"))
            {
                return new BodyProxy(this);
            }
            if ((reference == "RETURNEXPRESSION"))
            {
                return new ReturnExpressionProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//LambdaExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the LambdaExpression class
        /// </summary>
        public class LambdaExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private LambdaExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public LambdaExpressionChildrenCollection(LambdaExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Body != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.ReturnExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Body == null))
                {
                    IBlockStatement bodyCasted = item.As<IBlockStatement>();
                    if ((bodyCasted != null))
                    {
                        this._parent.Body = bodyCasted;
                        return;
                    }
                }
                if ((this._parent.ReturnExpression == null))
                {
                    IExpression returnExpressionCasted = item.As<IExpression>();
                    if ((returnExpressionCasted != null))
                    {
                        this._parent.ReturnExpression = returnExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Body = null;
                this._parent.ReturnExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Body))
                {
                    return true;
                }
                if ((item == this._parent.ReturnExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Body != null))
                {
                    array[arrayIndex] = this._parent.Body;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.ReturnExpression != null))
                {
                    array[arrayIndex] = this._parent.ReturnExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Body == item))
                {
                    this._parent.Body = null;
                    return true;
                }
                if ((this._parent.ReturnExpression == item))
                {
                    this._parent.ReturnExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Body).Concat(this._parent.ReturnExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the LambdaExpression class
        /// </summary>
        public class LambdaExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private LambdaExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public LambdaExpressionReferencedElementsCollection(LambdaExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Body != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.ReturnExpression != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Body == null))
                {
                    IBlockStatement bodyCasted = item.As<IBlockStatement>();
                    if ((bodyCasted != null))
                    {
                        this._parent.Body = bodyCasted;
                        return;
                    }
                }
                if ((this._parent.ReturnExpression == null))
                {
                    IExpression returnExpressionCasted = item.As<IExpression>();
                    if ((returnExpressionCasted != null))
                    {
                        this._parent.ReturnExpression = returnExpressionCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Body = null;
                this._parent.ReturnExpression = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Body))
                {
                    return true;
                }
                if ((item == this._parent.ReturnExpression))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Body != null))
                {
                    array[arrayIndex] = this._parent.Body;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.ReturnExpression != null))
                {
                    array[arrayIndex] = this._parent.ReturnExpression;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Body == item))
                {
                    this._parent.Body = null;
                    return true;
                }
                if ((this._parent.ReturnExpression == item))
                {
                    this._parent.ReturnExpression = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Body).Concat(this._parent.ReturnExpression).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the body property
        /// </summary>
        private sealed class BodyProxy : ModelPropertyChange<ILambdaExpression, IBlockStatement>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public BodyProxy(ILambdaExpression modelElement) : 
                    base(modelElement, "body")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IBlockStatement Value
            {
                get
                {
                    return this.ModelElement.Body;
                }
                set
                {
                    this.ModelElement.Body = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the returnExpression property
        /// </summary>
        private sealed class ReturnExpressionProxy : ModelPropertyChange<ILambdaExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ReturnExpressionProxy(ILambdaExpression modelElement) : 
                    base(modelElement, "returnExpression")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.ReturnExpression;
                }
                set
                {
                    this.ModelElement.ReturnExpression = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the AssignmentExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//AssignmentExpression")]
    public partial class AssignmentExpression : Expression, IAssignmentExpression, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Assignment property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private AssignmentOperator _assignment;
        
        private static Lazy<ITypedElement> _assignmentAttribute = new Lazy<ITypedElement>(RetrieveAssignmentAttribute);
        
        private static Lazy<ITypedElement> _valueReference = new Lazy<ITypedElement>(RetrieveValueReference);
        
        /// <summary>
        /// The backing field for the Value property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _value;
        
        private static Lazy<ITypedElement> _leftReference = new Lazy<ITypedElement>(RetrieveLeftReference);
        
        /// <summary>
        /// The backing field for the Left property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _left;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The assignment property
        /// </summary>
        [DisplayNameAttribute("assignment")]
        [CategoryAttribute("AssignmentExpression")]
        [XmlElementNameAttribute("assignment")]
        [XmlAttributeAttribute(true)]
        public AssignmentOperator Assignment
        {
            get
            {
                return this._assignment;
            }
            set
            {
                if ((this._assignment != value))
                {
                    AssignmentOperator old = this._assignment;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Assignment", e, _assignmentAttribute);
                    this._assignment = value;
                    this.OnPropertyChanged("Assignment", e, _assignmentAttribute);
                }
            }
        }
        
        /// <summary>
        /// The value property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Value
        {
            get
            {
                return this._value;
            }
            set
            {
                if ((this._value != value))
                {
                    IExpression old = this._value;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Value", e, _valueReference);
                    this._value = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetValue;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetValue;
                    }
                    this.OnPropertyChanged("Value", e, _valueReference);
                }
            }
        }
        
        /// <summary>
        /// The left property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("left")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Left
        {
            get
            {
                return this._left;
            }
            set
            {
                if ((this._left != value))
                {
                    IExpression old = this._left;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Left", e, _leftReference);
                    this._left = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetLeft;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetLeft;
                    }
                    this.OnPropertyChanged("Left", e, _leftReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new AssignmentExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new AssignmentExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//AssignmentExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveAssignmentAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.AssignmentExpression.ClassInstance)).Resolve("assignment")));
        }
        
        private static ITypedElement RetrieveValueReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.AssignmentExpression.ClassInstance)).Resolve("value")));
        }
        
        /// <summary>
        /// Handles the event that the Value property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetValue(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Value))
            {
                this.Value = null;
            }
        }
        
        private static ITypedElement RetrieveLeftReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.AssignmentExpression.ClassInstance)).Resolve("left")));
        }
        
        /// <summary>
        /// Handles the event that the Left property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetLeft(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Left))
            {
                this.Left = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Value))
            {
                return ModelHelper.CreatePath("value");
            }
            if ((element == this.Left))
            {
                return ModelHelper.CreatePath("left");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "VALUE"))
            {
                return this.Value;
            }
            if ((reference == "LEFT"))
            {
                return this.Left;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "ASSIGNMENT"))
            {
                return this.Assignment;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "VALUE"))
            {
                this.Value = ((IExpression)(value));
                return;
            }
            if ((feature == "LEFT"))
            {
                this.Left = ((IExpression)(value));
                return;
            }
            if ((feature == "ASSIGNMENT"))
            {
                this.Assignment = ((AssignmentOperator)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "ASSIGNMENT"))
            {
                return Observable.Box(new AssignmentProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "VALUE"))
            {
                return new ValueProxy(this);
            }
            if ((reference == "LEFT"))
            {
                return new LeftProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//AssignmentExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the AssignmentExpression class
        /// </summary>
        public class AssignmentExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private AssignmentExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public AssignmentExpressionChildrenCollection(AssignmentExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Value != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Left != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Value == null))
                {
                    IExpression valueCasted = item.As<IExpression>();
                    if ((valueCasted != null))
                    {
                        this._parent.Value = valueCasted;
                        return;
                    }
                }
                if ((this._parent.Left == null))
                {
                    IExpression leftCasted = item.As<IExpression>();
                    if ((leftCasted != null))
                    {
                        this._parent.Left = leftCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Value = null;
                this._parent.Left = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Value))
                {
                    return true;
                }
                if ((item == this._parent.Left))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Value != null))
                {
                    array[arrayIndex] = this._parent.Value;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Left != null))
                {
                    array[arrayIndex] = this._parent.Left;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Value == item))
                {
                    this._parent.Value = null;
                    return true;
                }
                if ((this._parent.Left == item))
                {
                    this._parent.Left = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Value).Concat(this._parent.Left).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the AssignmentExpression class
        /// </summary>
        public class AssignmentExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private AssignmentExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public AssignmentExpressionReferencedElementsCollection(AssignmentExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Value != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Left != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Value == null))
                {
                    IExpression valueCasted = item.As<IExpression>();
                    if ((valueCasted != null))
                    {
                        this._parent.Value = valueCasted;
                        return;
                    }
                }
                if ((this._parent.Left == null))
                {
                    IExpression leftCasted = item.As<IExpression>();
                    if ((leftCasted != null))
                    {
                        this._parent.Left = leftCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Value = null;
                this._parent.Left = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Value))
                {
                    return true;
                }
                if ((item == this._parent.Left))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Value != null))
                {
                    array[arrayIndex] = this._parent.Value;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Left != null))
                {
                    array[arrayIndex] = this._parent.Left;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Value == item))
                {
                    this._parent.Value = null;
                    return true;
                }
                if ((this._parent.Left == item))
                {
                    this._parent.Left = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Value).Concat(this._parent.Left).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the assignment property
        /// </summary>
        private sealed class AssignmentProxy : ModelPropertyChange<IAssignmentExpression, AssignmentOperator>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public AssignmentProxy(IAssignmentExpression modelElement) : 
                    base(modelElement, "assignment")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override AssignmentOperator Value
            {
                get
                {
                    return this.ModelElement.Assignment;
                }
                set
                {
                    this.ModelElement.Assignment = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the value property
        /// </summary>
        private sealed class ValueProxy : ModelPropertyChange<IAssignmentExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ValueProxy(IAssignmentExpression modelElement) : 
                    base(modelElement, "value")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Value;
                }
                set
                {
                    this.ModelElement.Value = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the left property
        /// </summary>
        private sealed class LeftProxy : ModelPropertyChange<IAssignmentExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public LeftProxy(IAssignmentExpression modelElement) : 
                    base(modelElement, "left")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Left;
                }
                set
                {
                    this.ModelElement.Left = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the BinaryExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//BinaryExpression")]
    public partial class BinaryExpression : Expression, IBinaryExpression, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Operator property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private BinaryOperator _operator;
        
        private static Lazy<ITypedElement> _operatorAttribute = new Lazy<ITypedElement>(RetrieveOperatorAttribute);
        
        private static Lazy<ITypedElement> _rightReference = new Lazy<ITypedElement>(RetrieveRightReference);
        
        /// <summary>
        /// The backing field for the Right property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _right;
        
        private static Lazy<ITypedElement> _leftReference = new Lazy<ITypedElement>(RetrieveLeftReference);
        
        /// <summary>
        /// The backing field for the Left property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _left;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The operator property
        /// </summary>
        [DisplayNameAttribute("operator")]
        [CategoryAttribute("BinaryExpression")]
        [XmlElementNameAttribute("operator")]
        [XmlAttributeAttribute(true)]
        public BinaryOperator Operator
        {
            get
            {
                return this._operator;
            }
            set
            {
                if ((this._operator != value))
                {
                    BinaryOperator old = this._operator;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Operator", e, _operatorAttribute);
                    this._operator = value;
                    this.OnPropertyChanged("Operator", e, _operatorAttribute);
                }
            }
        }
        
        /// <summary>
        /// The right property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("right")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Right
        {
            get
            {
                return this._right;
            }
            set
            {
                if ((this._right != value))
                {
                    IExpression old = this._right;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Right", e, _rightReference);
                    this._right = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetRight;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetRight;
                    }
                    this.OnPropertyChanged("Right", e, _rightReference);
                }
            }
        }
        
        /// <summary>
        /// The left property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("left")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Left
        {
            get
            {
                return this._left;
            }
            set
            {
                if ((this._left != value))
                {
                    IExpression old = this._left;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Left", e, _leftReference);
                    this._left = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetLeft;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetLeft;
                    }
                    this.OnPropertyChanged("Left", e, _leftReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new BinaryExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new BinaryExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//BinaryExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveOperatorAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.BinaryExpression.ClassInstance)).Resolve("operator")));
        }
        
        private static ITypedElement RetrieveRightReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.BinaryExpression.ClassInstance)).Resolve("right")));
        }
        
        /// <summary>
        /// Handles the event that the Right property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetRight(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Right))
            {
                this.Right = null;
            }
        }
        
        private static ITypedElement RetrieveLeftReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.BinaryExpression.ClassInstance)).Resolve("left")));
        }
        
        /// <summary>
        /// Handles the event that the Left property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetLeft(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Left))
            {
                this.Left = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Right))
            {
                return ModelHelper.CreatePath("right");
            }
            if ((element == this.Left))
            {
                return ModelHelper.CreatePath("left");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "RIGHT"))
            {
                return this.Right;
            }
            if ((reference == "LEFT"))
            {
                return this.Left;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "OPERATOR"))
            {
                return this.Operator;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "RIGHT"))
            {
                this.Right = ((IExpression)(value));
                return;
            }
            if ((feature == "LEFT"))
            {
                this.Left = ((IExpression)(value));
                return;
            }
            if ((feature == "OPERATOR"))
            {
                this.Operator = ((BinaryOperator)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "OPERATOR"))
            {
                return Observable.Box(new OperatorProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "RIGHT"))
            {
                return new RightProxy(this);
            }
            if ((reference == "LEFT"))
            {
                return new LeftProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//BinaryExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the BinaryExpression class
        /// </summary>
        public class BinaryExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private BinaryExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public BinaryExpressionChildrenCollection(BinaryExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Right != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Left != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Right == null))
                {
                    IExpression rightCasted = item.As<IExpression>();
                    if ((rightCasted != null))
                    {
                        this._parent.Right = rightCasted;
                        return;
                    }
                }
                if ((this._parent.Left == null))
                {
                    IExpression leftCasted = item.As<IExpression>();
                    if ((leftCasted != null))
                    {
                        this._parent.Left = leftCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Right = null;
                this._parent.Left = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Right))
                {
                    return true;
                }
                if ((item == this._parent.Left))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Right != null))
                {
                    array[arrayIndex] = this._parent.Right;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Left != null))
                {
                    array[arrayIndex] = this._parent.Left;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Right == item))
                {
                    this._parent.Right = null;
                    return true;
                }
                if ((this._parent.Left == item))
                {
                    this._parent.Left = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Right).Concat(this._parent.Left).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the BinaryExpression class
        /// </summary>
        public class BinaryExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private BinaryExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public BinaryExpressionReferencedElementsCollection(BinaryExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Right != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Left != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Right == null))
                {
                    IExpression rightCasted = item.As<IExpression>();
                    if ((rightCasted != null))
                    {
                        this._parent.Right = rightCasted;
                        return;
                    }
                }
                if ((this._parent.Left == null))
                {
                    IExpression leftCasted = item.As<IExpression>();
                    if ((leftCasted != null))
                    {
                        this._parent.Left = leftCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Right = null;
                this._parent.Left = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Right))
                {
                    return true;
                }
                if ((item == this._parent.Left))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Right != null))
                {
                    array[arrayIndex] = this._parent.Right;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Left != null))
                {
                    array[arrayIndex] = this._parent.Left;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Right == item))
                {
                    this._parent.Right = null;
                    return true;
                }
                if ((this._parent.Left == item))
                {
                    this._parent.Left = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Right).Concat(this._parent.Left).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the operator property
        /// </summary>
        private sealed class OperatorProxy : ModelPropertyChange<IBinaryExpression, BinaryOperator>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public OperatorProxy(IBinaryExpression modelElement) : 
                    base(modelElement, "operator")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override BinaryOperator Value
            {
                get
                {
                    return this.ModelElement.Operator;
                }
                set
                {
                    this.ModelElement.Operator = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the right property
        /// </summary>
        private sealed class RightProxy : ModelPropertyChange<IBinaryExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public RightProxy(IBinaryExpression modelElement) : 
                    base(modelElement, "right")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Right;
                }
                set
                {
                    this.ModelElement.Right = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the left property
        /// </summary>
        private sealed class LeftProxy : ModelPropertyChange<IBinaryExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public LeftProxy(IBinaryExpression modelElement) : 
                    base(modelElement, "left")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Left;
                }
                set
                {
                    this.ModelElement.Left = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ThisExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ThisExpression")]
    public partial class ThisExpression : Expression, IThisExpression, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ThisExpression")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ThisExpression")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the SuperExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//SuperExpression")]
    public partial class SuperExpression : Expression, ISuperExpression, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//SuperExpression")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//SuperExpression")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the NullExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//NullExpression")]
    public partial class NullExpression : Expression, INullExpression, IModelElement
    {
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//NullExpression")));
                }
                return _classInstance;
            }
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//NullExpression")));
            }
            return _classInstance;
        }
    }
    
    /// <summary>
    /// The default implementation of the MemberAccessExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//MemberAccessExpression")]
    public partial class MemberAccessExpression : Expression, IMemberAccessExpression, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Member property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _member;
        
        private static Lazy<ITypedElement> _memberAttribute = new Lazy<ITypedElement>(RetrieveMemberAttribute);
        
        private static Lazy<ITypedElement> _targetReference = new Lazy<ITypedElement>(RetrieveTargetReference);
        
        /// <summary>
        /// The backing field for the Target property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _target;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The member property
        /// </summary>
        [DisplayNameAttribute("member")]
        [CategoryAttribute("MemberAccessExpression")]
        [XmlElementNameAttribute("member")]
        [XmlAttributeAttribute(true)]
        public string Member
        {
            get
            {
                return this._member;
            }
            set
            {
                if ((this._member != value))
                {
                    string old = this._member;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Member", e, _memberAttribute);
                    this._member = value;
                    this.OnPropertyChanged("Member", e, _memberAttribute);
                }
            }
        }
        
        /// <summary>
        /// The target property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Target
        {
            get
            {
                return this._target;
            }
            set
            {
                if ((this._target != value))
                {
                    IExpression old = this._target;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Target", e, _targetReference);
                    this._target = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTarget;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTarget;
                    }
                    this.OnPropertyChanged("Target", e, _targetReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new MemberAccessExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new MemberAccessExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//MemberAccessExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveMemberAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MemberAccessExpression.ClassInstance)).Resolve("member")));
        }
        
        private static ITypedElement RetrieveTargetReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.MemberAccessExpression.ClassInstance)).Resolve("target")));
        }
        
        /// <summary>
        /// Handles the event that the Target property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTarget(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Target))
            {
                this.Target = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Target))
            {
                return ModelHelper.CreatePath("target");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "TARGET"))
            {
                return this.Target;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "MEMBER"))
            {
                return this.Member;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TARGET"))
            {
                this.Target = ((IExpression)(value));
                return;
            }
            if ((feature == "MEMBER"))
            {
                this.Member = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "MEMBER"))
            {
                return new MemberProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TARGET"))
            {
                return new TargetProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//MemberAccessExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the MemberAccessExpression class
        /// </summary>
        public class MemberAccessExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private MemberAccessExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public MemberAccessExpressionChildrenCollection(MemberAccessExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Target != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Target == null))
                {
                    IExpression targetCasted = item.As<IExpression>();
                    if ((targetCasted != null))
                    {
                        this._parent.Target = targetCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Target = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Target))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Target != null))
                {
                    array[arrayIndex] = this._parent.Target;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Target == item))
                {
                    this._parent.Target = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Target).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the MemberAccessExpression class
        /// </summary>
        public class MemberAccessExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private MemberAccessExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public MemberAccessExpressionReferencedElementsCollection(MemberAccessExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Target != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Target == null))
                {
                    IExpression targetCasted = item.As<IExpression>();
                    if ((targetCasted != null))
                    {
                        this._parent.Target = targetCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Target = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Target))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Target != null))
                {
                    array[arrayIndex] = this._parent.Target;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Target == item))
                {
                    this._parent.Target = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Target).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the member property
        /// </summary>
        private sealed class MemberProxy : ModelPropertyChange<IMemberAccessExpression, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public MemberProxy(IMemberAccessExpression modelElement) : 
                    base(modelElement, "member")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Member;
                }
                set
                {
                    this.ModelElement.Member = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the target property
        /// </summary>
        private sealed class TargetProxy : ModelPropertyChange<IMemberAccessExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TargetProxy(IMemberAccessExpression modelElement) : 
                    base(modelElement, "target")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Target;
                }
                set
                {
                    this.ModelElement.Target = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ArrayCreateExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ArrayCreateExpression")]
    public partial class ArrayCreateExpression : Expression, IArrayCreateExpression, IModelElement
    {
        
        private static Lazy<ITypedElement> _sizeReference = new Lazy<ITypedElement>(RetrieveSizeReference);
        
        /// <summary>
        /// The backing field for the Size property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _size;
        
        private static Lazy<ITypedElement> _typeReference = new Lazy<ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _type;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The size property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("size")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Size
        {
            get
            {
                return this._size;
            }
            set
            {
                if ((this._size != value))
                {
                    IExpression old = this._size;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Size", e, _sizeReference);
                    this._size = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetSize;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetSize;
                    }
                    this.OnPropertyChanged("Size", e, _sizeReference);
                }
            }
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    ITypeReference old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ArrayCreateExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ArrayCreateExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ArrayCreateExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveSizeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ArrayCreateExpression.ClassInstance)).Resolve("size")));
        }
        
        /// <summary>
        /// Handles the event that the Size property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetSize(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Size))
            {
                this.Size = null;
            }
        }
        
        private static ITypedElement RetrieveTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ArrayCreateExpression.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Size))
            {
                return ModelHelper.CreatePath("size");
            }
            if ((element == this.Type))
            {
                return ModelHelper.CreatePath("type");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "SIZE"))
            {
                return this.Size;
            }
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "SIZE"))
            {
                this.Size = ((IExpression)(value));
                return;
            }
            if ((feature == "TYPE"))
            {
                this.Type = ((ITypeReference)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "SIZE"))
            {
                return new SizeProxy(this);
            }
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ArrayCreateExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ArrayCreateExpression class
        /// </summary>
        public class ArrayCreateExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ArrayCreateExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ArrayCreateExpressionChildrenCollection(ArrayCreateExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Size != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Size == null))
                {
                    IExpression sizeCasted = item.As<IExpression>();
                    if ((sizeCasted != null))
                    {
                        this._parent.Size = sizeCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Size = null;
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Size))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Size != null))
                {
                    array[arrayIndex] = this._parent.Size;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Size == item))
                {
                    this._parent.Size = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Size).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ArrayCreateExpression class
        /// </summary>
        public class ArrayCreateExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ArrayCreateExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ArrayCreateExpressionReferencedElementsCollection(ArrayCreateExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Size != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Size == null))
                {
                    IExpression sizeCasted = item.As<IExpression>();
                    if ((sizeCasted != null))
                    {
                        this._parent.Size = sizeCasted;
                        return;
                    }
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Size = null;
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Size))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Size != null))
                {
                    array[arrayIndex] = this._parent.Size;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Size == item))
                {
                    this._parent.Size = null;
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Size).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the size property
        /// </summary>
        private sealed class SizeProxy : ModelPropertyChange<IArrayCreateExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public SizeProxy(IArrayCreateExpression modelElement) : 
                    base(modelElement, "size")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Size;
                }
                set
                {
                    this.ModelElement.Size = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IArrayCreateExpression, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IArrayCreateExpression modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ArrayInitializeExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ArrayInitializeExpression")]
    public partial class ArrayInitializeExpression : Expression, IArrayInitializeExpression, IModelElement
    {
        
        private static Lazy<ITypedElement> _valuesReference = new Lazy<ITypedElement>(RetrieveValuesReference);
        
        /// <summary>
        /// The backing field for the Values property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IExpression> _values;
        
        private static Lazy<ITypedElement> _typeReference = new Lazy<ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _type;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public ArrayInitializeExpression()
        {
            this._values = new ObservableCompositionList<IExpression>(this);
            this._values.CollectionChanging += this.ValuesCollectionChanging;
            this._values.CollectionChanged += this.ValuesCollectionChanged;
        }
        
        /// <summary>
        /// The values property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("values")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IExpression> Values
        {
            get
            {
                return this._values;
            }
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    ITypeReference old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ArrayInitializeExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ArrayInitializeExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ArrayInitializeExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveValuesReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ArrayInitializeExpression.ClassInstance)).Resolve("values")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Values property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ValuesCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Values", e, _valuesReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Values property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ValuesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Values", e, _valuesReference);
        }
        
        private static ITypedElement RetrieveTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ArrayInitializeExpression.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Type))
            {
                return ModelHelper.CreatePath("type");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "VALUES"))
            {
                return this._values;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TYPE"))
            {
                this.Type = ((ITypeReference)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._values))
            {
                return "values";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ArrayInitializeExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ArrayInitializeExpression class
        /// </summary>
        public class ArrayInitializeExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ArrayInitializeExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ArrayInitializeExpressionChildrenCollection(ArrayInitializeExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Values.Count);
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Values.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Values.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression valuesCasted = item.As<IExpression>();
                if ((valuesCasted != null))
                {
                    this._parent.Values.Add(valuesCasted);
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Values.Clear();
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Values.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> valuesEnumerator = this._parent.Values.GetEnumerator();
                try
                {
                    for (
                    ; valuesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = valuesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    valuesEnumerator.Dispose();
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Values.Remove(expressionItem)))
                {
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Values).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ArrayInitializeExpression class
        /// </summary>
        public class ArrayInitializeExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ArrayInitializeExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ArrayInitializeExpressionReferencedElementsCollection(ArrayInitializeExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Values.Count);
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Values.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Values.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression valuesCasted = item.As<IExpression>();
                if ((valuesCasted != null))
                {
                    this._parent.Values.Add(valuesCasted);
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Values.Clear();
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Values.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> valuesEnumerator = this._parent.Values.GetEnumerator();
                try
                {
                    for (
                    ; valuesEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = valuesEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    valuesEnumerator.Dispose();
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Values.Remove(expressionItem)))
                {
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Values).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IArrayInitializeExpression, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IArrayInitializeExpression modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the ObjectCreateExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ObjectCreateExpression")]
    public partial class ObjectCreateExpression : Expression, IObjectCreateExpression, IModelElement
    {
        
        private static Lazy<ITypedElement> _argumentsReference = new Lazy<ITypedElement>(RetrieveArgumentsReference);
        
        /// <summary>
        /// The backing field for the Arguments property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IExpression> _arguments;
        
        private static Lazy<ITypedElement> _typeReference = new Lazy<ITypedElement>(RetrieveTypeReference);
        
        /// <summary>
        /// The backing field for the Type property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ITypeReference _type;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public ObjectCreateExpression()
        {
            this._arguments = new ObservableCompositionList<IExpression>(this);
            this._arguments.CollectionChanging += this.ArgumentsCollectionChanging;
            this._arguments.CollectionChanged += this.ArgumentsCollectionChanged;
        }
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IExpression> Arguments
        {
            get
            {
                return this._arguments;
            }
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public ITypeReference Type
        {
            get
            {
                return this._type;
            }
            set
            {
                if ((this._type != value))
                {
                    ITypeReference old = this._type;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Type", e, _typeReference);
                    this._type = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetType;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetType;
                    }
                    this.OnPropertyChanged("Type", e, _typeReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new ObjectCreateExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new ObjectCreateExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ObjectCreateExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveArgumentsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ObjectCreateExpression.ClassInstance)).Resolve("arguments")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Arguments", e, _argumentsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Arguments", e, _argumentsReference);
        }
        
        private static ITypedElement RetrieveTypeReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.ObjectCreateExpression.ClassInstance)).Resolve("type")));
        }
        
        /// <summary>
        /// Handles the event that the Type property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetType(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Type))
            {
                this.Type = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Type))
            {
                return ModelHelper.CreatePath("type");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "TYPE"))
            {
                return this.Type;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ARGUMENTS"))
            {
                return this._arguments;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TYPE"))
            {
                this.Type = ((ITypeReference)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TYPE"))
            {
                return new TypeProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._arguments))
            {
                return "arguments";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//ObjectCreateExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ObjectCreateExpression class
        /// </summary>
        public class ObjectCreateExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ObjectCreateExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ObjectCreateExpressionChildrenCollection(ObjectCreateExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the ObjectCreateExpression class
        /// </summary>
        public class ObjectCreateExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private ObjectCreateExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public ObjectCreateExpressionReferencedElementsCollection(ObjectCreateExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    if ((this._parent.Type != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
                if ((this._parent.Type == null))
                {
                    ITypeReference typeCasted = item.As<ITypeReference>();
                    if ((typeCasted != null))
                    {
                        this._parent.Type = typeCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
                this._parent.Type = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Type))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
                if ((this._parent.Type != null))
                {
                    array[arrayIndex] = this._parent.Type;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                if ((this._parent.Type == item))
                {
                    this._parent.Type = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).Concat(this._parent.Type).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the type property
        /// </summary>
        private sealed class TypeProxy : ModelPropertyChange<IObjectCreateExpression, ITypeReference>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TypeProxy(IObjectCreateExpression modelElement) : 
                    base(modelElement, "type")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override ITypeReference Value
            {
                get
                {
                    return this.ModelElement.Type;
                }
                set
                {
                    this.ModelElement.Type = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the InvokeExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//InvokeExpression")]
    public partial class InvokeExpression : Expression, IInvokeExpression, IModelElement
    {
        
        private static Lazy<ITypedElement> _argumentsReference = new Lazy<ITypedElement>(RetrieveArgumentsReference);
        
        /// <summary>
        /// The backing field for the Arguments property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private ObservableCompositionList<IExpression> _arguments;
        
        private static Lazy<ITypedElement> _targetReference = new Lazy<ITypedElement>(RetrieveTargetReference);
        
        /// <summary>
        /// The backing field for the Target property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _target;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// Creates a new instance
        /// </summary>
        public InvokeExpression()
        {
            this._arguments = new ObservableCompositionList<IExpression>(this);
            this._arguments.CollectionChanging += this.ArgumentsCollectionChanging;
            this._arguments.CollectionChanged += this.ArgumentsCollectionChanged;
        }
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        public ICollectionExpression<IExpression> Arguments
        {
            get
            {
                return this._arguments;
            }
        }
        
        /// <summary>
        /// The target property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Target
        {
            get
            {
                return this._target;
            }
            set
            {
                if ((this._target != value))
                {
                    IExpression old = this._target;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Target", e, _targetReference);
                    this._target = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTarget;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTarget;
                    }
                    this.OnPropertyChanged("Target", e, _targetReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new InvokeExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new InvokeExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//InvokeExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveArgumentsReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.InvokeExpression.ClassInstance)).Resolve("arguments")));
        }
        
        /// <summary>
        /// Forwards CollectionChanging notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanging(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanging("Arguments", e, _argumentsReference);
        }
        
        /// <summary>
        /// Forwards CollectionChanged notifications for the Arguments property to the parent model element
        /// </summary>
        /// <param name="sender">The collection that raised the change</param>
        /// <param name="e">The original event data</param>
        private void ArgumentsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.OnCollectionChanged("Arguments", e, _argumentsReference);
        }
        
        private static ITypedElement RetrieveTargetReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.InvokeExpression.ClassInstance)).Resolve("target")));
        }
        
        /// <summary>
        /// Handles the event that the Target property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTarget(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Target))
            {
                this.Target = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Target))
            {
                return ModelHelper.CreatePath("target");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "TARGET"))
            {
                return this.Target;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Gets the Model element collection for the given feature
        /// </summary>
        /// <returns>A non-generic list of elements</returns>
        /// <param name="feature">The requested feature</param>
        protected override System.Collections.IList GetCollectionForFeature(string feature)
        {
            if ((feature == "ARGUMENTS"))
            {
                return this._arguments;
            }
            return base.GetCollectionForFeature(feature);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "TARGET"))
            {
                this.Target = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "TARGET"))
            {
                return new TargetProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the property name for the given container
        /// </summary>
        /// <returns>The name of the respective container reference</returns>
        /// <param name="container">The container object</param>
        protected override string GetCompositionName(object container)
        {
            if ((container == this._arguments))
            {
                return "arguments";
            }
            return base.GetCompositionName(container);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//InvokeExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the InvokeExpression class
        /// </summary>
        public class InvokeExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private InvokeExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public InvokeExpressionChildrenCollection(InvokeExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    if ((this._parent.Target != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
                if ((this._parent.Target == null))
                {
                    IExpression targetCasted = item.As<IExpression>();
                    if ((targetCasted != null))
                    {
                        this._parent.Target = targetCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
                this._parent.Target = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Target))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
                if ((this._parent.Target != null))
                {
                    array[arrayIndex] = this._parent.Target;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                if ((this._parent.Target == item))
                {
                    this._parent.Target = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).Concat(this._parent.Target).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the InvokeExpression class
        /// </summary>
        public class InvokeExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private InvokeExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public InvokeExpressionReferencedElementsCollection(InvokeExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    count = (count + this._parent.Arguments.Count);
                    if ((this._parent.Target != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged += this.PropagateCollectionChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.Arguments.AsNotifiable().CollectionChanged -= this.PropagateCollectionChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                IExpression argumentsCasted = item.As<IExpression>();
                if ((argumentsCasted != null))
                {
                    this._parent.Arguments.Add(argumentsCasted);
                }
                if ((this._parent.Target == null))
                {
                    IExpression targetCasted = item.As<IExpression>();
                    if ((targetCasted != null))
                    {
                        this._parent.Target = targetCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Arguments.Clear();
                this._parent.Target = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if (this._parent.Arguments.Contains(item))
                {
                    return true;
                }
                if ((item == this._parent.Target))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                IEnumerator<IModelElement> argumentsEnumerator = this._parent.Arguments.GetEnumerator();
                try
                {
                    for (
                    ; argumentsEnumerator.MoveNext(); 
                    )
                    {
                        array[arrayIndex] = argumentsEnumerator.Current;
                        arrayIndex = (arrayIndex + 1);
                    }
                }
                finally
                {
                    argumentsEnumerator.Dispose();
                }
                if ((this._parent.Target != null))
                {
                    array[arrayIndex] = this._parent.Target;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                IExpression expressionItem = item.As<IExpression>();
                if (((expressionItem != null) 
                            && this._parent.Arguments.Remove(expressionItem)))
                {
                    return true;
                }
                if ((this._parent.Target == item))
                {
                    this._parent.Target = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Arguments).Concat(this._parent.Target).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the target property
        /// </summary>
        private sealed class TargetProxy : ModelPropertyChange<IInvokeExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TargetProxy(IInvokeExpression modelElement) : 
                    base(modelElement, "target")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Target;
                }
                set
                {
                    this.ModelElement.Target = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the IndexExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//IndexExpression")]
    public partial class IndexExpression : Expression, IIndexExpression, IModelElement
    {
        
        private static Lazy<ITypedElement> _indexReference = new Lazy<ITypedElement>(RetrieveIndexReference);
        
        /// <summary>
        /// The backing field for the Index property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _index;
        
        private static Lazy<ITypedElement> _targetReference = new Lazy<ITypedElement>(RetrieveTargetReference);
        
        /// <summary>
        /// The backing field for the Target property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private IExpression _target;
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The index property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("index")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Index
        {
            get
            {
                return this._index;
            }
            set
            {
                if ((this._index != value))
                {
                    IExpression old = this._index;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Index", e, _indexReference);
                    this._index = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetIndex;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetIndex;
                    }
                    this.OnPropertyChanged("Index", e, _indexReference);
                }
            }
        }
        
        /// <summary>
        /// The target property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        public IExpression Target
        {
            get
            {
                return this._target;
            }
            set
            {
                if ((this._target != value))
                {
                    IExpression old = this._target;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Target", e, _targetReference);
                    this._target = value;
                    if ((old != null))
                    {
                        if ((old.Parent == this))
                        {
                            old.Parent = null;
                        }
                        old.ParentChanged -= this.OnResetTarget;
                    }
                    if ((value != null))
                    {
                        value.Parent = this;
                        value.ParentChanged += this.OnResetTarget;
                    }
                    this.OnPropertyChanged("Target", e, _targetReference);
                }
            }
        }
        
        /// <summary>
        /// Gets the child model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> Children
        {
            get
            {
                return base.Children.Concat(new IndexExpressionChildrenCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the referenced model elements of this model element
        /// </summary>
        public override IEnumerableExpression<IModelElement> ReferencedElements
        {
            get
            {
                return base.ReferencedElements.Concat(new IndexExpressionReferencedElementsCollection(this));
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//IndexExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveIndexReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.IndexExpression.ClassInstance)).Resolve("index")));
        }
        
        /// <summary>
        /// Handles the event that the Index property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetIndex(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Index))
            {
                this.Index = null;
            }
        }
        
        private static ITypedElement RetrieveTargetReference()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.IndexExpression.ClassInstance)).Resolve("target")));
        }
        
        /// <summary>
        /// Handles the event that the Target property must reset
        /// </summary>
        /// <param name="sender">The object that sent this reset request</param>
        /// <param name="eventArgs">The event data for the reset event</param>
        private void OnResetTarget(object sender, EventArgs eventArgs)
        {
            if ((sender == this.Target))
            {
                this.Target = null;
            }
        }
        
        /// <summary>
        /// Gets the relative URI fragment for the given child model element
        /// </summary>
        /// <returns>A fragment of the relative URI</returns>
        /// <param name="element">The element that should be looked for</param>
        protected override string GetRelativePathForNonIdentifiedChild(IModelElement element)
        {
            if ((element == this.Index))
            {
                return ModelHelper.CreatePath("index");
            }
            if ((element == this.Target))
            {
                return ModelHelper.CreatePath("target");
            }
            return base.GetRelativePathForNonIdentifiedChild(element);
        }
        
        /// <summary>
        /// Resolves the given URI to a child model element
        /// </summary>
        /// <returns>The model element or null if it could not be found</returns>
        /// <param name="reference">The requested reference name</param>
        /// <param name="index">The index of this reference</param>
        protected override IModelElement GetModelElementForReference(string reference, int index)
        {
            if ((reference == "INDEX"))
            {
                return this.Index;
            }
            if ((reference == "TARGET"))
            {
                return this.Target;
            }
            return base.GetModelElementForReference(reference, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "INDEX"))
            {
                this.Index = ((IExpression)(value));
                return;
            }
            if ((feature == "TARGET"))
            {
                this.Target = ((IExpression)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given reference
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="reference">The requested reference in upper case</param>
        protected override NMF.Expressions.INotifyExpression<NMF.Models.IModelElement> GetExpressionForReference(string reference)
        {
            if ((reference == "INDEX"))
            {
                return new IndexProxy(this);
            }
            if ((reference == "TARGET"))
            {
                return new TargetProxy(this);
            }
            return base.GetExpressionForReference(reference);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//IndexExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// The collection class to to represent the children of the IndexExpression class
        /// </summary>
        public class IndexExpressionChildrenCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private IndexExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public IndexExpressionChildrenCollection(IndexExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Index != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Target != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Index == null))
                {
                    IExpression indexCasted = item.As<IExpression>();
                    if ((indexCasted != null))
                    {
                        this._parent.Index = indexCasted;
                        return;
                    }
                }
                if ((this._parent.Target == null))
                {
                    IExpression targetCasted = item.As<IExpression>();
                    if ((targetCasted != null))
                    {
                        this._parent.Target = targetCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Index = null;
                this._parent.Target = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Index))
                {
                    return true;
                }
                if ((item == this._parent.Target))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Index != null))
                {
                    array[arrayIndex] = this._parent.Index;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Target != null))
                {
                    array[arrayIndex] = this._parent.Target;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Index == item))
                {
                    this._parent.Index = null;
                    return true;
                }
                if ((this._parent.Target == item))
                {
                    this._parent.Target = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Index).Concat(this._parent.Target).GetEnumerator();
            }
        }
        
        /// <summary>
        /// The collection class to to represent the children of the IndexExpression class
        /// </summary>
        public class IndexExpressionReferencedElementsCollection : ReferenceCollection, ICollectionExpression<IModelElement>, ICollection<IModelElement>
        {
            
            private IndexExpression _parent;
            
            /// <summary>
            /// Creates a new instance
            /// </summary>
            public IndexExpressionReferencedElementsCollection(IndexExpression parent)
            {
                this._parent = parent;
            }
            
            /// <summary>
            /// Gets the amount of elements contained in this collection
            /// </summary>
            public override int Count
            {
                get
                {
                    int count = 0;
                    if ((this._parent.Index != null))
                    {
                        count = (count + 1);
                    }
                    if ((this._parent.Target != null))
                    {
                        count = (count + 1);
                    }
                    return count;
                }
            }
            
            /// <summary>
            /// Registers event hooks to keep the collection up to date
            /// </summary>
            protected override void AttachCore()
            {
                this._parent.BubbledChange += this.PropagateValueChanges;
                this._parent.BubbledChange += this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Unregisters all event hooks registered by AttachCore
            /// </summary>
            protected override void DetachCore()
            {
                this._parent.BubbledChange -= this.PropagateValueChanges;
                this._parent.BubbledChange -= this.PropagateValueChanges;
            }
            
            /// <summary>
            /// Adds the given element to the collection
            /// </summary>
            /// <param name="item">The item to add</param>
            public override void Add(IModelElement item)
            {
                if ((this._parent.Index == null))
                {
                    IExpression indexCasted = item.As<IExpression>();
                    if ((indexCasted != null))
                    {
                        this._parent.Index = indexCasted;
                        return;
                    }
                }
                if ((this._parent.Target == null))
                {
                    IExpression targetCasted = item.As<IExpression>();
                    if ((targetCasted != null))
                    {
                        this._parent.Target = targetCasted;
                        return;
                    }
                }
            }
            
            /// <summary>
            /// Clears the collection and resets all references that implement it.
            /// </summary>
            public override void Clear()
            {
                this._parent.Index = null;
                this._parent.Target = null;
            }
            
            /// <summary>
            /// Gets a value indicating whether the given element is contained in the collection
            /// </summary>
            /// <returns>True, if it is contained, otherwise False</returns>
            /// <param name="item">The item that should be looked out for</param>
            public override bool Contains(IModelElement item)
            {
                if ((item == this._parent.Index))
                {
                    return true;
                }
                if ((item == this._parent.Target))
                {
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Copies the contents of the collection to the given array starting from the given array index
            /// </summary>
            /// <param name="array">The array in which the elements should be copied</param>
            /// <param name="arrayIndex">The starting index</param>
            public override void CopyTo(IModelElement[] array, int arrayIndex)
            {
                if ((this._parent.Index != null))
                {
                    array[arrayIndex] = this._parent.Index;
                    arrayIndex = (arrayIndex + 1);
                }
                if ((this._parent.Target != null))
                {
                    array[arrayIndex] = this._parent.Target;
                    arrayIndex = (arrayIndex + 1);
                }
            }
            
            /// <summary>
            /// Removes the given item from the collection
            /// </summary>
            /// <returns>True, if the item was removed, otherwise False</returns>
            /// <param name="item">The item that should be removed</param>
            public override bool Remove(IModelElement item)
            {
                if ((this._parent.Index == item))
                {
                    this._parent.Index = null;
                    return true;
                }
                if ((this._parent.Target == item))
                {
                    this._parent.Target = null;
                    return true;
                }
                return false;
            }
            
            /// <summary>
            /// Gets an enumerator that enumerates the collection
            /// </summary>
            /// <returns>A generic enumerator</returns>
            public override IEnumerator<IModelElement> GetEnumerator()
            {
                return Enumerable.Empty<IModelElement>().Concat(this._parent.Index).Concat(this._parent.Target).GetEnumerator();
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the index property
        /// </summary>
        private sealed class IndexProxy : ModelPropertyChange<IIndexExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public IndexProxy(IIndexExpression modelElement) : 
                    base(modelElement, "index")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Index;
                }
                set
                {
                    this.ModelElement.Index = value;
                }
            }
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the target property
        /// </summary>
        private sealed class TargetProxy : ModelPropertyChange<IIndexExpression, IExpression>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public TargetProxy(IIndexExpression modelElement) : 
                    base(modelElement, "target")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override IExpression Value
            {
                get
                {
                    return this.ModelElement.Target;
                }
                set
                {
                    this.ModelElement.Target = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the StringLiteral class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//StringLiteral")]
    public partial class StringLiteral : Expression, IStringLiteral, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Value property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _value;
        
        private static Lazy<ITypedElement> _valueAttribute = new Lazy<ITypedElement>(RetrieveValueAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The value property
        /// </summary>
        [DisplayNameAttribute("value")]
        [CategoryAttribute("StringLiteral")]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(true)]
        public string Value
        {
            get
            {
                return this._value;
            }
            set
            {
                if ((this._value != value))
                {
                    string old = this._value;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Value", e, _valueAttribute);
                    this._value = value;
                    this.OnPropertyChanged("Value", e, _valueAttribute);
                }
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//StringLiteral")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveValueAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.StringLiteral.ClassInstance)).Resolve("value")));
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "VALUE"))
            {
                return this.Value;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "VALUE"))
            {
                this.Value = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "VALUE"))
            {
                return new ValueProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//StringLiteral")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the value property
        /// </summary>
        private sealed class ValueProxy : ModelPropertyChange<IStringLiteral, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ValueProxy(IStringLiteral modelElement) : 
                    base(modelElement, "value")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Value;
                }
                set
                {
                    this.ModelElement.Value = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the IntegerLiteral class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//IntegerLiteral")]
    public partial class IntegerLiteral : Expression, IIntegerLiteral, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Value property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private int _value;
        
        private static Lazy<ITypedElement> _valueAttribute = new Lazy<ITypedElement>(RetrieveValueAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The value property
        /// </summary>
        [DisplayNameAttribute("value")]
        [CategoryAttribute("IntegerLiteral")]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(true)]
        public int Value
        {
            get
            {
                return this._value;
            }
            set
            {
                if ((this._value != value))
                {
                    int old = this._value;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Value", e, _valueAttribute);
                    this._value = value;
                    this.OnPropertyChanged("Value", e, _valueAttribute);
                }
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//IntegerLiteral")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveValueAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.IntegerLiteral.ClassInstance)).Resolve("value")));
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "VALUE"))
            {
                return this.Value;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "VALUE"))
            {
                this.Value = ((int)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "VALUE"))
            {
                return Observable.Box(new ValueProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//IntegerLiteral")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the value property
        /// </summary>
        private sealed class ValueProxy : ModelPropertyChange<IIntegerLiteral, int>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ValueProxy(IIntegerLiteral modelElement) : 
                    base(modelElement, "value")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override int Value
            {
                get
                {
                    return this.ModelElement.Value;
                }
                set
                {
                    this.ModelElement.Value = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the DoubleLiteral class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//DoubleLiteral")]
    public partial class DoubleLiteral : Expression, IDoubleLiteral, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Value property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private double _value;
        
        private static Lazy<ITypedElement> _valueAttribute = new Lazy<ITypedElement>(RetrieveValueAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The value property
        /// </summary>
        [DisplayNameAttribute("value")]
        [CategoryAttribute("DoubleLiteral")]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(true)]
        public double Value
        {
            get
            {
                return this._value;
            }
            set
            {
                if ((this._value != value))
                {
                    double old = this._value;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Value", e, _valueAttribute);
                    this._value = value;
                    this.OnPropertyChanged("Value", e, _valueAttribute);
                }
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//DoubleLiteral")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveValueAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.DoubleLiteral.ClassInstance)).Resolve("value")));
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "VALUE"))
            {
                return this.Value;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "VALUE"))
            {
                this.Value = ((double)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "VALUE"))
            {
                return Observable.Box(new ValueProxy(this));
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//DoubleLiteral")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the value property
        /// </summary>
        private sealed class ValueProxy : ModelPropertyChange<IDoubleLiteral, double>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public ValueProxy(IDoubleLiteral modelElement) : 
                    base(modelElement, "value")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override double Value
            {
                get
                {
                    return this.ModelElement.Value;
                }
                set
                {
                    this.ModelElement.Value = value;
                }
            }
        }
    }
    
    /// <summary>
    /// The default implementation of the VariableExpression class
    /// </summary>
    [XmlNamespaceAttribute("anytext:simplejava")]
    [XmlNamespacePrefixAttribute("simplejava")]
    [ModelRepresentationClassAttribute("anytext:simplejava#//VariableExpression")]
    public partial class VariableExpression : Expression, IVariableExpression, IModelElement
    {
        
        /// <summary>
        /// The backing field for the Variable property
        /// </summary>
        [DebuggerBrowsableAttribute(DebuggerBrowsableState.Never)]
        private string _variable;
        
        private static Lazy<ITypedElement> _variableAttribute = new Lazy<ITypedElement>(RetrieveVariableAttribute);
        
        private static IClass _classInstance;
        
        /// <summary>
        /// The variable property
        /// </summary>
        [DisplayNameAttribute("variable")]
        [CategoryAttribute("VariableExpression")]
        [XmlElementNameAttribute("variable")]
        [XmlAttributeAttribute(true)]
        public string Variable
        {
            get
            {
                return this._variable;
            }
            set
            {
                if ((this._variable != value))
                {
                    string old = this._variable;
                    ValueChangedEventArgs e = new ValueChangedEventArgs(old, value);
                    this.OnPropertyChanging("Variable", e, _variableAttribute);
                    this._variable = value;
                    this.OnPropertyChanged("Variable", e, _variableAttribute);
                }
            }
        }
        
        /// <summary>
        /// Gets the Class model for this type
        /// </summary>
        public new static IClass ClassInstance
        {
            get
            {
                if ((_classInstance == null))
                {
                    _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//VariableExpression")));
                }
                return _classInstance;
            }
        }
        
        private static ITypedElement RetrieveVariableAttribute()
        {
            return ((ITypedElement)(((ModelElement)(AnyText.Tests.SimpleJava.VariableExpression.ClassInstance)).Resolve("variable")));
        }
        
        /// <summary>
        /// Resolves the given attribute name
        /// </summary>
        /// <returns>The attribute value or null if it could not be found</returns>
        /// <param name="attribute">The requested attribute name</param>
        /// <param name="index">The index of this attribute</param>
        protected override object GetAttributeValue(string attribute, int index)
        {
            if ((attribute == "VARIABLE"))
            {
                return this.Variable;
            }
            return base.GetAttributeValue(attribute, index);
        }
        
        /// <summary>
        /// Sets a value to the given feature
        /// </summary>
        /// <param name="feature">The requested feature</param>
        /// <param name="value">The value that should be set to that feature</param>
        protected override void SetFeature(string feature, object value)
        {
            if ((feature == "VARIABLE"))
            {
                this.Variable = ((string)(value));
                return;
            }
            base.SetFeature(feature, value);
        }
        
        /// <summary>
        /// Gets the property expression for the given attribute
        /// </summary>
        /// <returns>An incremental property expression</returns>
        /// <param name="attribute">The requested attribute in upper case</param>
        protected override NMF.Expressions.INotifyExpression<object> GetExpressionForAttribute(string attribute)
        {
            if ((attribute == "VARIABLE"))
            {
                return new VariableProxy(this);
            }
            return base.GetExpressionForAttribute(attribute);
        }
        
        /// <summary>
        /// Gets the Class for this model element
        /// </summary>
        public override IClass GetClass()
        {
            if ((_classInstance == null))
            {
                _classInstance = ((IClass)(MetaRepository.Instance.Resolve("anytext:simplejava#//VariableExpression")));
            }
            return _classInstance;
        }
        
        /// <summary>
        /// Represents a proxy to represent an incremental access to the variable property
        /// </summary>
        private sealed class VariableProxy : ModelPropertyChange<IVariableExpression, string>
        {
            
            /// <summary>
            /// Creates a new observable property access proxy
            /// </summary>
            /// <param name="modelElement">The model instance element for which to create the property access proxy</param>
            public VariableProxy(IVariableExpression modelElement) : 
                    base(modelElement, "variable")
            {
            }
            
            /// <summary>
            /// Gets or sets the value of this expression
            /// </summary>
            public override string Value
            {
                get
                {
                    return this.ModelElement.Variable;
                }
                set
                {
                    this.ModelElement.Variable = value;
                }
            }
        }
    }
    
    [ModelRepresentationClassAttribute("anytext:simplejava#//PrimitiveType")]
    public enum PrimitiveType
    {
        
        Byte = 0,
        
        Short = 1,
        
        Integer = 2,
        
        Long = 3,
        
        Float = 4,
        
        Double = 5,
        
        Boolean = 6,
    }
    
    [ModelRepresentationClassAttribute("anytext:simplejava#//Modifier")]
    public enum Modifier
    {
        
        Public = 0,
        
        Protected = 1,
        
        Private = 2,
        
        Static = 3,
        
        Abstract = 4,
        
        Final = 5,
        
        Native = 6,
        
        Synchronized = 7,
        
        Transient = 8,
        
        Volatile = 9,
        
        StrictFp = 10,
    }
    
    [ModelRepresentationClassAttribute("anytext:simplejava#//AssignmentOperator")]
    public enum AssignmentOperator
    {
        
        Assign = 0,
        
        AddAssign = 1,
        
        SubtractAssign = 2,
        
        DivideAssign = 3,
        
        AndAssign = 4,
        
        OrAssign = 5,
        
        XorAssign = 6,
        
        ModAssign = 7,
        
        LeftShiftAssign = 8,
        
        RightShiftAssign = 9,
        
        RightShiftOverflowAssign = 10,
    }
    
    [ModelRepresentationClassAttribute("anytext:simplejava#//BinaryOperator")]
    public enum BinaryOperator
    {
        
        Add = 0,
        
        Subtract = 1,
        
        OrElse = 2,
        
        AndAlso = 3,
        
        Or = 4,
        
        And = 5,
        
        Xor = 6,
        
        LeftShift = 7,
        
        RightShift = 8,
        
        RightShiftCirc = 9,
        
        Modulo = 10,
        
        Equals = 11,
        
        NotEquals = 12,
        
        LessOrEqual = 13,
        
        GreaterOrEqual = 14,
        
        LessThan = 15,
        
        GreaterThan = 16,
        
        Multiply = 17,
        
        Divide = 18,
    }
    
    /// <summary>
    /// The public interface for VariableExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(VariableExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(VariableExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//VariableExpression")]
    public partial interface IVariableExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The variable property
        /// </summary>
        [DisplayNameAttribute("variable")]
        [CategoryAttribute("VariableExpression")]
        [XmlElementNameAttribute("variable")]
        [XmlAttributeAttribute(true)]
        string Variable
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for DoubleLiteral
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(DoubleLiteral))]
    [XmlDefaultImplementationTypeAttribute(typeof(DoubleLiteral))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//DoubleLiteral")]
    public partial interface IDoubleLiteral : IModelElement, IExpression
    {
        
        /// <summary>
        /// The value property
        /// </summary>
        [DisplayNameAttribute("value")]
        [CategoryAttribute("DoubleLiteral")]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(true)]
        double Value
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for IntegerLiteral
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(IntegerLiteral))]
    [XmlDefaultImplementationTypeAttribute(typeof(IntegerLiteral))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//IntegerLiteral")]
    public partial interface IIntegerLiteral : IModelElement, IExpression
    {
        
        /// <summary>
        /// The value property
        /// </summary>
        [DisplayNameAttribute("value")]
        [CategoryAttribute("IntegerLiteral")]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(true)]
        int Value
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for StringLiteral
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(StringLiteral))]
    [XmlDefaultImplementationTypeAttribute(typeof(StringLiteral))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//StringLiteral")]
    public partial interface IStringLiteral : IModelElement, IExpression
    {
        
        /// <summary>
        /// The value property
        /// </summary>
        [DisplayNameAttribute("value")]
        [CategoryAttribute("StringLiteral")]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(true)]
        string Value
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for IndexExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(IndexExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(IndexExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//IndexExpression")]
    public partial interface IIndexExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The index property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("index")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Index
        {
            get;
            set;
        }
        
        /// <summary>
        /// The target property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Target
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for InvokeExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(InvokeExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(InvokeExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//InvokeExpression")]
    public partial interface IInvokeExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IExpression> Arguments
        {
            get;
        }
        
        /// <summary>
        /// The target property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Target
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ObjectCreateExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ObjectCreateExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(ObjectCreateExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ObjectCreateExpression")]
    public partial interface IObjectCreateExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IExpression> Arguments
        {
            get;
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Type
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ArrayInitializeExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ArrayInitializeExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(ArrayInitializeExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ArrayInitializeExpression")]
    public partial interface IArrayInitializeExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The values property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("values")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IExpression> Values
        {
            get;
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Type
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ArrayCreateExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ArrayCreateExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(ArrayCreateExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ArrayCreateExpression")]
    public partial interface IArrayCreateExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The size property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("size")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Size
        {
            get;
            set;
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Type
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for MemberAccessExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(MemberAccessExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(MemberAccessExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//MemberAccessExpression")]
    public partial interface IMemberAccessExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The member property
        /// </summary>
        [DisplayNameAttribute("member")]
        [CategoryAttribute("MemberAccessExpression")]
        [XmlElementNameAttribute("member")]
        [XmlAttributeAttribute(true)]
        string Member
        {
            get;
            set;
        }
        
        /// <summary>
        /// The target property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("target")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Target
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for NullExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(NullExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(NullExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//NullExpression")]
    public partial interface INullExpression : IModelElement, IExpression
    {
    }
    
    /// <summary>
    /// The public interface for SuperExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(SuperExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(SuperExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//SuperExpression")]
    public partial interface ISuperExpression : IModelElement, IExpression
    {
    }
    
    /// <summary>
    /// The public interface for ThisExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ThisExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(ThisExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ThisExpression")]
    public partial interface IThisExpression : IModelElement, IExpression
    {
    }
    
    /// <summary>
    /// The public interface for BinaryExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(BinaryExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(BinaryExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//BinaryExpression")]
    public partial interface IBinaryExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The operator property
        /// </summary>
        [DisplayNameAttribute("operator")]
        [CategoryAttribute("BinaryExpression")]
        [XmlElementNameAttribute("operator")]
        [XmlAttributeAttribute(true)]
        BinaryOperator Operator
        {
            get;
            set;
        }
        
        /// <summary>
        /// The right property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("right")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Right
        {
            get;
            set;
        }
        
        /// <summary>
        /// The left property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("left")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Left
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for AssignmentExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(AssignmentExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(AssignmentExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//AssignmentExpression")]
    public partial interface IAssignmentExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The assignment property
        /// </summary>
        [DisplayNameAttribute("assignment")]
        [CategoryAttribute("AssignmentExpression")]
        [XmlElementNameAttribute("assignment")]
        [XmlAttributeAttribute(true)]
        AssignmentOperator Assignment
        {
            get;
            set;
        }
        
        /// <summary>
        /// The value property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("value")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Value
        {
            get;
            set;
        }
        
        /// <summary>
        /// The left property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("left")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Left
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for LambdaExpression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(LambdaExpression))]
    [XmlDefaultImplementationTypeAttribute(typeof(LambdaExpression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//LambdaExpression")]
    public partial interface ILambdaExpression : IModelElement, IExpression
    {
        
        /// <summary>
        /// The parameter property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("parameter")]
        [CategoryAttribute("LambdaExpression")]
        [XmlElementNameAttribute("parameter")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<string> Parameter
        {
            get;
        }
        
        /// <summary>
        /// The body property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement Body
        {
            get;
            set;
        }
        
        /// <summary>
        /// The returnExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("returnExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression ReturnExpression
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for Expression
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Expression))]
    [XmlDefaultImplementationTypeAttribute(typeof(Expression))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Expression")]
    public partial interface IExpression : IModelElement
    {
    }
    
    /// <summary>
    /// The public interface for VariableDeclarationStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(VariableDeclarationStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(VariableDeclarationStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//VariableDeclarationStatement")]
    public partial interface IVariableDeclarationStatement : IModelElement
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("VariableDeclarationStatement")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The initExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("initExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression InitExpression
        {
            get;
            set;
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Type
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ThrowStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ThrowStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(ThrowStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ThrowStatement")]
    public partial interface IThrowStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The throwExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("throwExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression ThrowExpression
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ReturnStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ReturnStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(ReturnStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ReturnStatement")]
    public partial interface IReturnStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The returnExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("returnExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression ReturnExpression
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ContinueStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ContinueStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(ContinueStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ContinueStatement")]
    public partial interface IContinueStatement : IModelElement, IStatement
    {
    }
    
    /// <summary>
    /// The public interface for BreakStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(BreakStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(BreakStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//BreakStatement")]
    public partial interface IBreakStatement : IModelElement, IStatement
    {
    }
    
    /// <summary>
    /// The public interface for ExpressionStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ExpressionStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(ExpressionStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ExpressionStatement")]
    public partial interface IExpressionStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The expression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("expression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Expression
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for CatchClause
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(CatchClause))]
    [XmlDefaultImplementationTypeAttribute(typeof(CatchClause))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//CatchClause")]
    public partial interface ICatchClause : IModelElement
    {
        
        /// <summary>
        /// The variableName property
        /// </summary>
        [DisplayNameAttribute("variableName")]
        [CategoryAttribute("CatchClause")]
        [XmlElementNameAttribute("variableName")]
        [XmlAttributeAttribute(true)]
        string VariableName
        {
            get;
            set;
        }
        
        /// <summary>
        /// The statements property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement Statements
        {
            get;
            set;
        }
        
        /// <summary>
        /// The catchType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("catchType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference CatchType
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for TryStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(TryStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(TryStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TryStatement")]
    public partial interface ITryStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The finallyBlock property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("finallyBlock")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement FinallyBlock
        {
            get;
            set;
        }
        
        /// <summary>
        /// The tryBlock property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("tryBlock")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement TryBlock
        {
            get;
            set;
        }
        
        /// <summary>
        /// The catchClauses property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("catchClauses")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ICatchClause> CatchClauses
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for BlockStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(BlockStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(BlockStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//BlockStatement")]
    public partial interface IBlockStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The statements property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IStatement> Statements
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for SwitchCase
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(SwitchCase))]
    [XmlDefaultImplementationTypeAttribute(typeof(SwitchCase))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//SwitchCase")]
    public partial interface ISwitchCase : IModelElement
    {
        
        /// <summary>
        /// The statements property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement Statements
        {
            get;
            set;
        }
        
        /// <summary>
        /// The expression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("expression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Expression
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for SwitchStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(SwitchStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(SwitchStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//SwitchStatement")]
    public partial interface ISwitchStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The default property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("default")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement Default
        {
            get;
            set;
        }
        
        /// <summary>
        /// The cases property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("cases")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ISwitchCase> Cases
        {
            get;
        }
        
        /// <summary>
        /// The expression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("expression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Expression
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for DoStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(DoStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(DoStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//DoStatement")]
    public partial interface IDoStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The testExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("testExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression TestExpression
        {
            get;
            set;
        }
        
        /// <summary>
        /// The doStatement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("doStatement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement DoStatement_
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ConditionalStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ConditionalStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(ConditionalStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ConditionalStatement")]
    public partial interface IConditionalStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The elseStatement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("elseStatement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IStatement ElseStatement
        {
            get;
            set;
        }
        
        /// <summary>
        /// The trueStatement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("trueStatement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IStatement TrueStatement
        {
            get;
            set;
        }
        
        /// <summary>
        /// The test property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("test")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Test
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for WhileStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(WhileStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(WhileStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//WhileStatement")]
    public partial interface IWhileStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The statement property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("statement")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IStatement Statement
        {
            get;
            set;
        }
        
        /// <summary>
        /// The test property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("test")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Test
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for VariableStatement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(VariableStatement))]
    [XmlDefaultImplementationTypeAttribute(typeof(VariableStatement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//VariableStatement")]
    public partial interface IVariableStatement : IModelElement, IStatement
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("VariableStatement")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("VariableStatement")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<Modifier> Modifiers
        {
            get;
        }
        
        /// <summary>
        /// The initExpression property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("initExpression")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression InitExpression
        {
            get;
            set;
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Type
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for Statement
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Statement))]
    [XmlDefaultImplementationTypeAttribute(typeof(Statement))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Statement")]
    public partial interface IStatement : IModelElement
    {
    }
    
    /// <summary>
    /// The public interface for Annotation
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Annotation))]
    [XmlDefaultImplementationTypeAttribute(typeof(Annotation))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Annotation")]
    public partial interface IAnnotation : IModelElement
    {
        
        /// <summary>
        /// The Name property
        /// </summary>
        [CategoryAttribute("Annotation")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IExpression> Arguments
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for ParameterSpecification
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ParameterSpecification))]
    [XmlDefaultImplementationTypeAttribute(typeof(ParameterSpecification))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ParameterSpecification")]
    public partial interface IParameterSpecification : IModelElement
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("ParameterSpecification")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The isFinal property
        /// </summary>
        [DisplayNameAttribute("isFinal")]
        [CategoryAttribute("ParameterSpecification")]
        [XmlElementNameAttribute("isFinal")]
        [XmlAttributeAttribute(true)]
        Nullable<bool> IsFinal
        {
            get;
            set;
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Type
        {
            get;
            set;
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IAnnotation> Annotations
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for ConstructorDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ConstructorDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(ConstructorDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ConstructorDeclaration")]
    public partial interface IConstructorDeclaration : IModelElement, ITypeMember
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("ConstructorDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("ConstructorDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<Modifier> Modifiers
        {
            get;
        }
        
        /// <summary>
        /// The body property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement Body
        {
            get;
            set;
        }
        
        /// <summary>
        /// The parameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("parameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IParameterSpecification> Parameters
        {
            get;
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IAnnotation> Annotations
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for MethodDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(MethodDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(MethodDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//MethodDeclaration")]
    public partial interface IMethodDeclaration : IModelElement, ITypeMember
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("MethodDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("MethodDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<Modifier> Modifiers
        {
            get;
        }
        
        /// <summary>
        /// The body property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("body")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IBlockStatement Body
        {
            get;
            set;
        }
        
        /// <summary>
        /// The parameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("parameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IParameterSpecification> Parameters
        {
            get;
        }
        
        /// <summary>
        /// The returnType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("returnType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference ReturnType
        {
            get;
            set;
        }
        
        /// <summary>
        /// The typeParameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("typeParameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeParameter> TypeParameters
        {
            get;
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IAnnotation> Annotations
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for FieldDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(FieldDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(FieldDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//FieldDeclaration")]
    public partial interface IFieldDeclaration : IModelElement, ITypeMember
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("FieldDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("FieldDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<Modifier> Modifiers
        {
            get;
        }
        
        /// <summary>
        /// The default property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("default")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        IExpression Default
        {
            get;
            set;
        }
        
        /// <summary>
        /// The type property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("type")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Type
        {
            get;
            set;
        }
        
        /// <summary>
        /// The annotations property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("annotations")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IAnnotation> Annotations
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for EnumConstant
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(EnumConstant))]
    [XmlDefaultImplementationTypeAttribute(typeof(EnumConstant))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//EnumConstant")]
    public partial interface IEnumConstant : IModelElement
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("EnumConstant")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The arguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("arguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IExpression> Arguments
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for TypeMember
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(TypeMember))]
    [XmlDefaultImplementationTypeAttribute(typeof(TypeMember))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeMember")]
    public partial interface ITypeMember : IModelElement
    {
    }
    
    /// <summary>
    /// The public interface for ReferenceTypeReference
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ReferenceTypeReference))]
    [XmlDefaultImplementationTypeAttribute(typeof(ReferenceTypeReference))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ReferenceTypeReference")]
    public partial interface IReferenceTypeReference : IModelElement, ITypeReference
    {
        
        /// <summary>
        /// The targetType property
        /// </summary>
        [DisplayNameAttribute("targetType")]
        [CategoryAttribute("ReferenceTypeReference")]
        [XmlElementNameAttribute("targetType")]
        [XmlAttributeAttribute(true)]
        IClassDeclaration TargetType
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for TypeArgument
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(TypeArgument))]
    [XmlDefaultImplementationTypeAttribute(typeof(TypeArgument))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeArgument")]
    public partial interface ITypeArgument : IModelElement
    {
        
        /// <summary>
        /// The isSuper property
        /// </summary>
        [DisplayNameAttribute("isSuper")]
        [CategoryAttribute("TypeArgument")]
        [XmlElementNameAttribute("isSuper")]
        [XmlAttributeAttribute(true)]
        Nullable<bool> IsSuper
        {
            get;
            set;
        }
        
        /// <summary>
        /// The isExtends property
        /// </summary>
        [DisplayNameAttribute("isExtends")]
        [CategoryAttribute("TypeArgument")]
        [XmlElementNameAttribute("isExtends")]
        [XmlAttributeAttribute(true)]
        Nullable<bool> IsExtends
        {
            get;
            set;
        }
        
        /// <summary>
        /// The referencedType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("referencedType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference ReferencedType
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for GenericTypeReference
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(GenericTypeReference))]
    [XmlDefaultImplementationTypeAttribute(typeof(GenericTypeReference))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//GenericTypeReference")]
    public partial interface IGenericTypeReference : IModelElement, ITypeReference
    {
        
        /// <summary>
        /// The baseType property
        /// </summary>
        [DisplayNameAttribute("baseType")]
        [CategoryAttribute("GenericTypeReference")]
        [XmlElementNameAttribute("baseType")]
        [XmlAttributeAttribute(true)]
        string BaseType
        {
            get;
            set;
        }
        
        /// <summary>
        /// The typeArguments property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("typeArguments")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeArgument> TypeArguments
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for PrimitiveTypeReference
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(PrimitiveTypeReference))]
    [XmlDefaultImplementationTypeAttribute(typeof(PrimitiveTypeReference))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//PrimitiveTypeReference")]
    public partial interface IPrimitiveTypeReference : IModelElement, ITypeReference
    {
        
        /// <summary>
        /// The primitiveType property
        /// </summary>
        [DisplayNameAttribute("primitiveType")]
        [CategoryAttribute("PrimitiveTypeReference")]
        [XmlElementNameAttribute("primitiveType")]
        [XmlAttributeAttribute(true)]
        PrimitiveType PrimitiveType
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ArrayTypeReference
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ArrayTypeReference))]
    [XmlDefaultImplementationTypeAttribute(typeof(ArrayTypeReference))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ArrayTypeReference")]
    public partial interface IArrayTypeReference : IModelElement, ITypeReference
    {
        
        /// <summary>
        /// The baseType property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("baseType")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference BaseType
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for TypeReference
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(TypeReference))]
    [XmlDefaultImplementationTypeAttribute(typeof(TypeReference))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeReference")]
    public partial interface ITypeReference : IModelElement
    {
    }
    
    /// <summary>
    /// The public interface for AnnotationDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(AnnotationDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(AnnotationDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//AnnotationDeclaration")]
    public partial interface IAnnotationDeclaration : IModelElement, ITypeDeclaration
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("AnnotationDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for EnumDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(EnumDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(EnumDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//EnumDeclaration")]
    public partial interface IEnumDeclaration : IModelElement, ITypeDeclaration
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("EnumDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("EnumDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<Modifier> Modifiers
        {
            get;
        }
        
        /// <summary>
        /// The implements property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("implements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeReference> Implements
        {
            get;
        }
        
        /// <summary>
        /// The members property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("members")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeMember> Members
        {
            get;
        }
        
        /// <summary>
        /// The constants property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("constants")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IEnumConstant> Constants
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for InterfaceDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(InterfaceDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(InterfaceDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//InterfaceDeclaration")]
    public partial interface IInterfaceDeclaration : IModelElement, ITypeDeclaration
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("InterfaceDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("InterfaceDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<Modifier> Modifiers
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for TypeParameter
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(TypeParameter))]
    [XmlDefaultImplementationTypeAttribute(typeof(TypeParameter))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeParameter")]
    public partial interface ITypeParameter : IModelElement
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("TypeParameter")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The extends property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("extends")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference Extends
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for ClassDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(ClassDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(ClassDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//ClassDeclaration")]
    public partial interface IClassDeclaration : IModelElement, ITypeDeclaration
    {
        
        /// <summary>
        /// The name property
        /// </summary>
        [DisplayNameAttribute("name")]
        [CategoryAttribute("ClassDeclaration")]
        [XmlElementNameAttribute("name")]
        [IdAttribute()]
        [XmlAttributeAttribute(true)]
        string Name
        {
            get;
            set;
        }
        
        /// <summary>
        /// The modifiers property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [DisplayNameAttribute("modifiers")]
        [CategoryAttribute("ClassDeclaration")]
        [XmlElementNameAttribute("modifiers")]
        [XmlAttributeAttribute(true)]
        [ConstantAttribute()]
        ICollectionExpression<Modifier> Modifiers
        {
            get;
        }
        
        /// <summary>
        /// The implements property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("implements")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeReference> Implements
        {
            get;
        }
        
        /// <summary>
        /// The superClass property
        /// </summary>
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("superClass")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        ITypeReference SuperClass
        {
            get;
            set;
        }
        
        /// <summary>
        /// The members property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("members")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeMember> Members
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for TypeDeclaration
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(TypeDeclaration))]
    [XmlDefaultImplementationTypeAttribute(typeof(TypeDeclaration))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//TypeDeclaration")]
    public partial interface ITypeDeclaration : IModelElement, ITypeMember
    {
        
        /// <summary>
        /// The typeParameters property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("typeParameters")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeParameter> TypeParameters
        {
            get;
        }
    }
    
    /// <summary>
    /// The public interface for Import
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(Import))]
    [XmlDefaultImplementationTypeAttribute(typeof(Import))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//Import")]
    public partial interface IImport : IModelElement
    {
        
        /// <summary>
        /// The importedPackage property
        /// </summary>
        [DisplayNameAttribute("importedPackage")]
        [CategoryAttribute("Import")]
        [XmlElementNameAttribute("importedPackage")]
        [XmlAttributeAttribute(true)]
        string ImportedPackage
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// The public interface for CodeUnit
    /// </summary>
    [DefaultImplementationTypeAttribute(typeof(CodeUnit))]
    [XmlDefaultImplementationTypeAttribute(typeof(CodeUnit))]
    [ModelRepresentationClassAttribute("anytext:simplejava#//CodeUnit")]
    public partial interface ICodeUnit : IModelElement
    {
        
        /// <summary>
        /// The package property
        /// </summary>
        [DisplayNameAttribute("package")]
        [CategoryAttribute("CodeUnit")]
        [XmlElementNameAttribute("package")]
        [XmlAttributeAttribute(true)]
        string Package
        {
            get;
            set;
        }
        
        /// <summary>
        /// The types property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("types")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<ITypeDeclaration> Types
        {
            get;
        }
        
        /// <summary>
        /// The imports property
        /// </summary>
        [DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content)]
        [BrowsableAttribute(false)]
        [XmlElementNameAttribute("imports")]
        [XmlAttributeAttribute(false)]
        [ContainmentAttribute()]
        [ConstantAttribute()]
        ICollectionExpression<IImport> Imports
        {
            get;
        }
    }
}
