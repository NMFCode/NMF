//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:8.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using NMF.AnyText;
using NMF.AnyText.Metamodel;
using NMF.AnyText.Model;
using NMF.AnyText.PrettyPrinting;
using NMF.AnyText.Rules;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;


namespace NMF.AnyText.Grammars
{


    /// <summary>
    /// Denotes a class capable to parse the language anytext
    /// </summary>
    public partial class AnyTextGrammar : ReflectiveGrammar
    {

        /// <summary>
        /// Gets the language id for this grammar
        /// </summary>
        public override string LanguageId
        {
            get
            {
                return "anytext";
            }
        }

        /// <summary>
        /// Gets the root rule
        /// </summary>
        /// <returns>the root rule for this grammar</returns>
        /// <param name="context">a context to resolve the root rule</param>
        protected override NMF.AnyText.Rules.Rule GetRootRule(GrammarContext context)
        {
            return context.ResolveRule<GrammarRule>();
        }

        /// <summary>
        /// A rule class representing the rule &apos;Grammar&apos;
        /// </summary>
        public partial class GrammarRule : ModelElementRule<NMF.AnyText.Metamodel.Grammar>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("grammar"),
                        context.ResolveFormattedRule<GrammarNameIDRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("("), context.ResolveFormattedRule<GrammarLanguageIdIDRule>(), context.ResolveKeyword(")")), NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline),
                        context.ResolveKeyword("root"),
                        context.ResolveFormattedRule<GrammarStartRuleClassRuleRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline),
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<GrammarImportsMetamodelImportRule>(), NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline),
                        RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<GrammarCommentsCommentRuleRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline), NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline),
                        RuleFormatter.OneOrMore(context.ResolveFormattedRule<GrammarRulesRuleRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline))};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;CommentRule&apos;
        /// </summary>
        public partial class CommentRuleRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<MultilineCommentRuleRule>(),
                        context.ResolveRule<SinglelineCommentRuleRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;SinglelineCommentRule&apos;
        /// </summary>
        public partial class SinglelineCommentRuleRule : ModelElementRule<SinglelineCommentRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("comment"),
                        context.ResolveFormattedRule<SinglelineCommentRuleStartKeywordRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MultilineCommentRule&apos;
        /// </summary>
        public partial class MultilineCommentRuleRule : ModelElementRule<NMF.AnyText.Metamodel.MultilineCommentRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("comment"),
                        context.ResolveFormattedRule<MultilineCommentRuleStartKeywordRule>(),
                        context.ResolveKeyword("to"),
                        context.ResolveFormattedRule<MultilineCommentRuleEndKeywordRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MetamodelImport&apos;
        /// </summary>
        public partial class MetamodelImportRule : ModelElementRule<MetamodelImport>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("imports"),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<MetamodelImportPrefixIDRule>(), context.ResolveKeyword("from"))),
                        context.ResolveFormattedRule<MetamodelImportFileUriRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Rule&apos;
        /// </summary>
        public partial class RuleRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<ClassRuleRule>(),
                        context.ResolveRule<DataRuleRule>(),
                        context.ResolveRule<FragmentRuleRule>(),
                        context.ResolveRule<ParanthesisRuleRule>(),
                        context.ResolveRule<EnumRuleRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ClassRule&apos;
        /// </summary>
        public partial class ClassRuleRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<InheritanceRuleRule>(),
                        context.ResolveRule<ModelRuleRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;InheritanceRule&apos;
        /// </summary>
        public partial class InheritanceRuleRule : ModelElementRule<InheritanceRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<RuleNameIDRule>(),
                        context.ResolveFormattedRule<RuleTypeFragmentRule>(),
                        context.ResolveKeyword(":", NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline, NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent),
                        context.ResolveFormattedRule<InheritanceRuleSubtypesClassRuleRule>(),
                        RuleFormatter.OneOrMore(new SequenceRule(context.ResolveKeyword("|"), context.ResolveFormattedRule<InheritanceRuleSubtypesClassRuleRule>()), NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(";", NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent, NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ModelRule&apos;
        /// </summary>
        public partial class ModelRuleRule : ModelElementRule<ModelRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<RuleNameIDRule>(),
                        context.ResolveFormattedRule<RuleTypeFragmentRule>(),
                        context.ResolveKeyword(":", NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline, NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent),
                        context.ResolveFormattedRule<ModelRuleExpressionParserExpressionRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(";", NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent, NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;DataRule&apos;
        /// </summary>
        public partial class DataRuleRule : ModelElementRule<DataRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("terminal"),
                        context.ResolveFormattedRule<RuleNameIDRule>(),
                        context.ResolveFormattedRule<RuleTypeFragmentRule>(),
                        context.ResolveKeyword(":", NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline, NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent),
                        context.ResolveFormattedRule<DataRuleRegexRegexRule>(),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("surround"), context.ResolveKeyword("with"), context.ResolveFormattedRule<DataRuleSurroundCharacterCharRule>())),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("escape"), context.ResolveFormattedRule<DataRuleEscapeRulesEscapeRuleRule>(), RuleFormatter.ZeroOrMore(new SequenceRule(context.ResolveKeyword(","), context.ResolveFormattedRule<DataRuleEscapeRulesEscapeRuleRule>()))), NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(";", NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent, NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;EscapeRule&apos;
        /// </summary>
        public partial class EscapeRuleRule : ModelElementRule<EscapeRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<EscapeRuleCharacterCharRule>(),
                        context.ResolveKeyword("as"),
                        context.ResolveFormattedRule<EscapeRuleEscapeKeywordRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;FragmentRule&apos;
        /// </summary>
        public partial class FragmentRuleRule : ModelElementRule<FragmentRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("fragment"),
                        context.ResolveFormattedRule<RuleNameIDRule>(),
                        context.ResolveKeyword("processes"),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<RulePrefixIDRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace), context.ResolveKeyword(".", NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace))),
                        context.ResolveFormattedRule<RuleTypeNameIDRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(":", NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline, NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent),
                        context.ResolveFormattedRule<FragmentRuleExpressionParserExpressionRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(";", NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent, NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ParanthesisRule&apos;
        /// </summary>
        public partial class ParanthesisRuleRule : ModelElementRule<ParanthesisRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("parantheses"),
                        context.ResolveFormattedRule<RuleNameIDRule>(),
                        context.ResolveKeyword(":", NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline, NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent),
                        context.ResolveFormattedRule<ParanthesisRuleOpeningParanthesisKeywordExpressionRule>(),
                        context.ResolveFormattedRule<ParanthesisRuleInnerRuleClassRuleRule>(),
                        context.ResolveFormattedRule<ParanthesisRuleClosingParanthesisKeywordExpressionRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(";", NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent, NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;EnumRule&apos;
        /// </summary>
        public partial class EnumRuleRule : ModelElementRule<EnumRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("enum"),
                        context.ResolveFormattedRule<RuleNameIDRule>(),
                        context.ResolveFormattedRule<RuleTypeFragmentRule>(),
                        context.ResolveKeyword(":", NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline, NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent),
                        RuleFormatter.OneOrMore(context.ResolveFormattedRule<EnumRuleLiteralsLiteralRuleRule>(), NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword(";", NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent, NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;LiteralRule&apos;
        /// </summary>
        public partial class LiteralRuleRule : ModelElementRule<NMF.AnyText.Metamodel.LiteralRule>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<LiteralRuleLiteralIDRule>(),
                        context.ResolveKeyword("=>"),
                        context.ResolveFormattedRule<LiteralRuleKeywordParserExpressionRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline)};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;RuleTypeFragment&apos;
        /// </summary>
        public partial class RuleTypeFragmentRule : QuoteRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword("returns"), RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveFormattedRule<RulePrefixIDRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace), context.ResolveKeyword(".", NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace))), context.ResolveFormattedRule<RuleTypeNameIDRule>()), NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;FormattingInstructionFragment&apos;
        /// </summary>
        public partial class FormattingInstructionFragmentRule : QuoteRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = RuleFormatter.ZeroOrMore(context.ResolveFormattedRule<ParserExpressionFormattingInstructionsFormattingInstructionRule>());
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;FormattingInstruction&apos;
        /// </summary>
        public partial class FormattingInstructionRule : EnumRule<NMF.AnyText.Metamodel.FormattingInstruction>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveKeyword("<nl>", NMF.AnyText.PrettyPrinting.FormattingInstruction.Newline),
                        context.ResolveKeyword("<ind>", NMF.AnyText.PrettyPrinting.FormattingInstruction.Indent),
                        context.ResolveKeyword("<unind>", NMF.AnyText.PrettyPrinting.FormattingInstruction.Unindent),
                        context.ResolveKeyword("<nsp>"),
                        context.ResolveKeyword("<!nsp>")};
                Values = new NMF.AnyText.Metamodel.FormattingInstruction[] {
                        NMF.AnyText.Metamodel.FormattingInstruction.Newline,
                        NMF.AnyText.Metamodel.FormattingInstruction.Indent,
                        NMF.AnyText.Metamodel.FormattingInstruction.Unindent,
                        NMF.AnyText.Metamodel.FormattingInstruction.AvoidSpace,
                        NMF.AnyText.Metamodel.FormattingInstruction.ForbidSpace};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ParserExpression&apos;
        /// </summary>
        public partial class ParserExpressionRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<SequenceExpressionRule>(),
                        context.ResolveRule<ChoiceExpressionRule>(),
                        context.ResolveRule<ConjunctiveParserExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ConjunctiveParserExpression&apos;
        /// </summary>
        public partial class ConjunctiveParserExpressionRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<PlusExpressionRule>(),
                        context.ResolveRule<StarExpressionRule>(),
                        context.ResolveRule<MaybeExpressionRule>(),
                        context.ResolveRule<BasicParserExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;BasicParserExpression&apos;
        /// </summary>
        public partial class BasicParserExpressionRule : ChoiceRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Alternatives = new FormattedRule[] {
                        context.ResolveRule<NegativeLookaheadExpressionRule>(),
                        context.ResolveRule<KeywordExpressionRule>(),
                        context.ResolveRule<ReferenceExpressionRule>(),
                        context.ResolveRule<AssignExpressionRule>(),
                        context.ResolveRule<AddAssignExpressionRule>(),
                        context.ResolveRule<ExistsAssignExpressionRule>(),
                        context.ResolveRule<RuleExpressionRule>(),
                        context.ResolveRule<ParanthesisExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ParanthesisExpression&apos;
        /// </summary>
        public partial class ParanthesisExpressionRule : ParanthesesRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("("),
                        context.ResolveRule<ParserExpressionRule>(),
                        context.ResolveKeyword(")")};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;SequenceExpression&apos;
        /// </summary>
        public partial class SequenceExpressionRule : ModelElementRule<SequenceExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<SequenceExpressionInnerExpressionsConjunctiveParserExpressionRule>(),
                        RuleFormatter.OneOrMore(context.ResolveFormattedRule<SequenceExpressionInnerExpressionsConjunctiveParserExpressionRule>())};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;PlusExpression&apos;
        /// </summary>
        public partial class PlusExpressionRule : ModelElementRule<PlusExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<UnaryParserExpressionInnerBasicParserExpressionRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("+"),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;StarExpression&apos;
        /// </summary>
        public partial class StarExpressionRule : ModelElementRule<StarExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<UnaryParserExpressionInnerBasicParserExpressionRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("*"),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;MaybeExpression&apos;
        /// </summary>
        public partial class MaybeExpressionRule : ModelElementRule<MaybeExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<UnaryParserExpressionInnerBasicParserExpressionRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("?"),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;KeywordExpression&apos;
        /// </summary>
        public partial class KeywordExpressionRule : ModelElementRule<KeywordExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<KeywordExpressionKeywordKeywordRule>(),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ChoiceExpression&apos;
        /// </summary>
        public partial class ChoiceExpressionRule : ModelElementRule<ChoiceExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        RuleFormatter.OneOrMore(new SequenceRule(context.ResolveFormattedRule<ChoiceExpressionAlternativesConjunctiveParserExpressionRule>(), context.ResolveKeyword("|"))),
                        context.ResolveFormattedRule<ChoiceExpressionAlternativesConjunctiveParserExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AssignExpression&apos;
        /// </summary>
        public partial class AssignExpressionRule : ModelElementRule<AssignExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<FeatureExpressionFeatureIdOrContextRefRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("=", NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<FeatureExpressionAssignedBasicParserExpressionRule>(),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;AddAssignExpression&apos;
        /// </summary>
        public partial class AddAssignExpressionRule : ModelElementRule<AddAssignExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<FeatureExpressionFeatureIdOrContextRefRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("+=", NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<FeatureExpressionAssignedBasicParserExpressionRule>(),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ExistsAssignExpression&apos;
        /// </summary>
        public partial class ExistsAssignExpressionRule : ModelElementRule<ExistsAssignExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<FeatureExpressionFeatureIdOrContextRefRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveKeyword("?=", NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<FeatureExpressionAssignedBasicParserExpressionRule>(),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;NegativeLookaheadExpression&apos;
        /// </summary>
        public partial class NegativeLookaheadExpressionRule : ModelElementRule<NegativeLookaheadExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("!", NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<UnaryParserExpressionInnerBasicParserExpressionRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;RuleExpression&apos;
        /// </summary>
        public partial class RuleExpressionRule : ModelElementRule<RuleExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveFormattedRule<RuleExpressionRuleRuleRule>(),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>(),
                        new NegativeLookaheadRule(context.ResolveKeyword("=")),
                        new NegativeLookaheadRule(context.ResolveKeyword("+=")),
                        new NegativeLookaheadRule(context.ResolveKeyword("?="))};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ReferenceExpression&apos;
        /// </summary>
        public partial class ReferenceExpressionRule : ModelElementRule<ReferenceExpression>
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Rules = new FormattedRule[] {
                        context.ResolveKeyword("[", NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        context.ResolveFormattedRule<ReferenceExpressionReferencedRuleRuleRule>(NMF.AnyText.PrettyPrinting.FormattingInstruction.SupressSpace),
                        RuleFormatter.ZeroOrOne(new SequenceRule(context.ResolveKeyword(":"), context.ResolveFormattedRule<ReferenceExpressionFormatDataRuleRule>())),
                        context.ResolveKeyword("]"),
                        context.ResolveFormattedRule<FormattingInstructionFragmentRule>()};
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;IdOrContextRef&apos;
        /// </summary>
        public partial class IdOrContextRefRule : NMF.AnyText.Rules.RegexRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^(context\\.)?[a-zA-Z]\\w*", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;ID&apos;
        /// </summary>
        public partial class IDRule : NMF.AnyText.Rules.RegexRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^[a-zA-Z]\\w*", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Keyword&apos;
        /// </summary>
        public partial class KeywordRule : EscapedRegexRule
        {

            /// <summary>
            /// Escapes the given string
            /// </summary>
            /// <returns>the escaped string</returns>
            /// <param name="value">the unescaped string</param>
            public override string Escape(string value)
            {
                return (("\'" + value.Replace("\\", "\\\\").Replace("\'", "\\\'"))
                            + "\'");
            }

            /// <summary>
            /// Unescapes the given string
            /// </summary>
            /// <returns>the unescaped string</returns>
            /// <param name="value">the escaped string</param>
            public override string Unescape(string value)
            {
                return value.Substring(1, (value.Length - 2)).Replace("\\\\", "\\").Replace("\\\'", "\'");
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\'(\\\\\\\\|\\\\\'|[^\'\\\\])+\'", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Regex&apos;
        /// </summary>
        public partial class RegexRule : EscapedRegexRule
        {

            /// <summary>
            /// Escapes the given string
            /// </summary>
            /// <returns>the escaped string</returns>
            /// <param name="value">the unescaped string</param>
            public override string Escape(string value)
            {
                return (("/" + value.Replace("/", "\\/"))
                            + "/");
            }

            /// <summary>
            /// Unescapes the given string
            /// </summary>
            /// <returns>the unescaped string</returns>
            /// <param name="value">the escaped string</param>
            public override string Unescape(string value)
            {
                return value.Substring(1, (value.Length - 2)).Replace("\\/", "/");
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^/(\\\\/|[^/])*/", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Uri&apos;
        /// </summary>
        public partial class UriRule : NMF.AnyText.Rules.RegexRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^.+", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// A rule class representing the rule &apos;Char&apos;
        /// </summary>
        public partial class CharRule : NMF.AnyText.Rules.RegexRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Regex = new Regex("^\\S+", RegexOptions.Compiled);
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Rules
        /// </summary>
        public partial class GrammarRulesRuleRule : AddAssignRule<IGrammar, IRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Rules";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<RuleRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IRule> GetCollection(IGrammar semanticElement, ParseContext context)
            {
                return semanticElement.Rules;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Comments
        /// </summary>
        public partial class GrammarCommentsCommentRuleRule : AddAssignRule<IGrammar, ICommentRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Comments";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<CommentRuleRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ICommentRule> GetCollection(IGrammar semanticElement, ParseContext context)
            {
                return semanticElement.Comments;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Imports
        /// </summary>
        public partial class GrammarImportsMetamodelImportRule : AddAssignRule<IGrammar, IMetamodelImport>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Imports";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<MetamodelImportRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IMetamodelImport> GetCollection(IGrammar semanticElement, ParseContext context)
            {
                return semanticElement.Imports;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to StartRule
        /// </summary>
        public partial class GrammarStartRuleClassRuleRule : AssignModelReferenceRule<IGrammar, IClassRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "StartRule";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IClassRule GetValue(IGrammar semanticElement, ParseContext context)
            {
                return semanticElement.StartRule;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IGrammar semanticElement, IClassRule propertyValue, ParseContext context)
            {
                semanticElement.StartRule = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to LanguageId
        /// </summary>
        public partial class GrammarLanguageIdIDRule : AssignRule<IGrammar, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "LanguageId";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IGrammar semanticElement, ParseContext context)
            {
                return semanticElement.LanguageId;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IGrammar semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.LanguageId = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Name
        /// </summary>
        public partial class GrammarNameIDRule : AssignRule<IGrammar, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Name";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IGrammar semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IGrammar semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Start
        /// </summary>
        public partial class SinglelineCommentRuleStartKeywordRule : AssignRule<ISinglelineCommentRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Start";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<KeywordRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(ISinglelineCommentRule semanticElement, ParseContext context)
            {
                return semanticElement.Start;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ISinglelineCommentRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Start = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to End
        /// </summary>
        public partial class MultilineCommentRuleEndKeywordRule : AssignRule<IMultilineCommentRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "End";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<KeywordRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IMultilineCommentRule semanticElement, ParseContext context)
            {
                return semanticElement.End;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMultilineCommentRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.End = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Start
        /// </summary>
        public partial class MultilineCommentRuleStartKeywordRule : AssignRule<IMultilineCommentRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Start";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<KeywordRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IMultilineCommentRule semanticElement, ParseContext context)
            {
                return semanticElement.Start;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMultilineCommentRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Start = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to File
        /// </summary>
        public partial class MetamodelImportFileUriRule : AssignRule<IMetamodelImport, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "File";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<UriRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IMetamodelImport semanticElement, ParseContext context)
            {
                return semanticElement.File;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMetamodelImport semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.File = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Prefix
        /// </summary>
        public partial class MetamodelImportPrefixIDRule : AssignRule<IMetamodelImport, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Prefix";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IMetamodelImport semanticElement, ParseContext context)
            {
                return semanticElement.Prefix;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IMetamodelImport semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Prefix = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Subtypes
        /// </summary>
        public partial class InheritanceRuleSubtypesClassRuleRule : AddAssignModelReferenceRule<IInheritanceRule, IClassRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Subtypes";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IClassRule> GetCollection(IInheritanceRule semanticElement, ParseContext context)
            {
                return semanticElement.Subtypes;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Name
        /// </summary>
        public partial class RuleNameIDRule : AssignRule<IRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Name";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IRule semanticElement, ParseContext context)
            {
                return semanticElement.Name;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Name = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Expression
        /// </summary>
        public partial class ModelRuleExpressionParserExpressionRule : AssignRule<IModelRule, IParserExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Expression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<ParserExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IParserExpression GetValue(IModelRule semanticElement, ParseContext context)
            {
                return semanticElement.Expression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IModelRule semanticElement, IParserExpression propertyValue, ParseContext context)
            {
                semanticElement.Expression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to EscapeRules
        /// </summary>
        public partial class DataRuleEscapeRulesEscapeRuleRule : AddAssignRule<IDataRule, IEscapeRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "EscapeRules";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<EscapeRuleRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IEscapeRule> GetCollection(IDataRule semanticElement, ParseContext context)
            {
                return semanticElement.EscapeRules;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to SurroundCharacter
        /// </summary>
        public partial class DataRuleSurroundCharacterCharRule : AssignRule<IDataRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "SurroundCharacter";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<CharRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IDataRule semanticElement, ParseContext context)
            {
                return semanticElement.SurroundCharacter;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IDataRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.SurroundCharacter = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Regex
        /// </summary>
        public partial class DataRuleRegexRegexRule : AssignRule<IDataRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Regex";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<RegexRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IDataRule semanticElement, ParseContext context)
            {
                return semanticElement.Regex;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IDataRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Regex = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Escape
        /// </summary>
        public partial class EscapeRuleEscapeKeywordRule : AssignRule<IEscapeRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Escape";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<KeywordRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IEscapeRule semanticElement, ParseContext context)
            {
                return semanticElement.Escape;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IEscapeRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Escape = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Character
        /// </summary>
        public partial class EscapeRuleCharacterCharRule : AssignRule<IEscapeRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Character";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<CharRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IEscapeRule semanticElement, ParseContext context)
            {
                return semanticElement.Character;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IEscapeRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Character = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Expression
        /// </summary>
        public partial class FragmentRuleExpressionParserExpressionRule : AssignRule<IFragmentRule, IParserExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Expression";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<ParserExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IParserExpression GetValue(IFragmentRule semanticElement, ParseContext context)
            {
                return semanticElement.Expression;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IFragmentRule semanticElement, IParserExpression propertyValue, ParseContext context)
            {
                semanticElement.Expression = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to TypeName
        /// </summary>
        public partial class RuleTypeNameIDRule : AssignRule<IRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "TypeName";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IRule semanticElement, ParseContext context)
            {
                return semanticElement.TypeName;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.TypeName = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Prefix
        /// </summary>
        public partial class RulePrefixIDRule : AssignRule<IRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Prefix";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IRule semanticElement, ParseContext context)
            {
                return semanticElement.Prefix;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Prefix = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to ClosingParanthesis
        /// </summary>
        public partial class ParanthesisRuleClosingParanthesisKeywordExpressionRule : AssignRule<IParanthesisRule, IKeywordExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "ClosingParanthesis";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<KeywordExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IKeywordExpression GetValue(IParanthesisRule semanticElement, ParseContext context)
            {
                return semanticElement.ClosingParanthesis;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IParanthesisRule semanticElement, IKeywordExpression propertyValue, ParseContext context)
            {
                semanticElement.ClosingParanthesis = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to InnerRule
        /// </summary>
        public partial class ParanthesisRuleInnerRuleClassRuleRule : AssignModelReferenceRule<IParanthesisRule, IClassRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "InnerRule";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IClassRule GetValue(IParanthesisRule semanticElement, ParseContext context)
            {
                return semanticElement.InnerRule;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IParanthesisRule semanticElement, IClassRule propertyValue, ParseContext context)
            {
                semanticElement.InnerRule = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to OpeningParanthesis
        /// </summary>
        public partial class ParanthesisRuleOpeningParanthesisKeywordExpressionRule : AssignRule<IParanthesisRule, IKeywordExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "OpeningParanthesis";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<KeywordExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IKeywordExpression GetValue(IParanthesisRule semanticElement, ParseContext context)
            {
                return semanticElement.OpeningParanthesis;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IParanthesisRule semanticElement, IKeywordExpression propertyValue, ParseContext context)
            {
                semanticElement.OpeningParanthesis = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Literals
        /// </summary>
        public partial class EnumRuleLiteralsLiteralRuleRule : AddAssignRule<IEnumRule, ILiteralRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Literals";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<LiteralRuleRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<ILiteralRule> GetCollection(IEnumRule semanticElement, ParseContext context)
            {
                return semanticElement.Literals;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Keyword
        /// </summary>
        public partial class LiteralRuleKeywordParserExpressionRule : AssignRule<ILiteralRule, IParserExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Keyword";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<ParserExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IParserExpression GetValue(ILiteralRule semanticElement, ParseContext context)
            {
                return semanticElement.Keyword;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ILiteralRule semanticElement, IParserExpression propertyValue, ParseContext context)
            {
                semanticElement.Keyword = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Literal
        /// </summary>
        public partial class LiteralRuleLiteralIDRule : AssignRule<ILiteralRule, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Literal";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(ILiteralRule semanticElement, ParseContext context)
            {
                return semanticElement.Literal;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(ILiteralRule semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Literal = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to InnerExpressions
        /// </summary>
        public partial class SequenceExpressionInnerExpressionsConjunctiveParserExpressionRule : AddAssignRule<ISequenceExpression, IParserExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "InnerExpressions";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<ConjunctiveParserExpressionRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IParserExpression> GetCollection(ISequenceExpression semanticElement, ParseContext context)
            {
                return semanticElement.InnerExpressions;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Inner
        /// </summary>
        public partial class UnaryParserExpressionInnerBasicParserExpressionRule : AssignRule<IUnaryParserExpression, IParserExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Inner";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<BasicParserExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IParserExpression GetValue(IUnaryParserExpression semanticElement, ParseContext context)
            {
                return semanticElement.Inner;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IUnaryParserExpression semanticElement, IParserExpression propertyValue, ParseContext context)
            {
                semanticElement.Inner = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Keyword
        /// </summary>
        public partial class KeywordExpressionKeywordKeywordRule : AssignRule<IKeywordExpression, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Keyword";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<KeywordRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IKeywordExpression semanticElement, ParseContext context)
            {
                return semanticElement.Keyword;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IKeywordExpression semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Keyword = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Alternatives
        /// </summary>
        public partial class ChoiceExpressionAlternativesConjunctiveParserExpressionRule : AddAssignRule<IChoiceExpression, IParserExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Alternatives";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<ConjunctiveParserExpressionRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<IParserExpression> GetCollection(IChoiceExpression semanticElement, ParseContext context)
            {
                return semanticElement.Alternatives;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Assigned
        /// </summary>
        public partial class FeatureExpressionAssignedBasicParserExpressionRule : AssignRule<IFeatureExpression, IParserExpression>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Assigned";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<BasicParserExpressionRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IParserExpression GetValue(IFeatureExpression semanticElement, ParseContext context)
            {
                return semanticElement.Assigned;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IFeatureExpression semanticElement, IParserExpression propertyValue, ParseContext context)
            {
                semanticElement.Assigned = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Feature
        /// </summary>
        public partial class FeatureExpressionFeatureIdOrContextRefRule : AssignRule<IFeatureExpression, string>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Feature";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IdOrContextRefRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override string GetValue(IFeatureExpression semanticElement, ParseContext context)
            {
                return semanticElement.Feature;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IFeatureExpression semanticElement, string propertyValue, ParseContext context)
            {
                semanticElement.Feature = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Rule
        /// </summary>
        public partial class RuleExpressionRuleRuleRule : AssignModelReferenceRule<IRuleExpression, IRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Rule";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IRule GetValue(IRuleExpression semanticElement, ParseContext context)
            {
                return semanticElement.Rule;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IRuleExpression semanticElement, IRule propertyValue, ParseContext context)
            {
                semanticElement.Rule = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to Format
        /// </summary>
        public partial class ReferenceExpressionFormatDataRuleRule : AssignModelReferenceRule<IReferenceExpression, IDataRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "Format";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IDataRule GetValue(IReferenceExpression semanticElement, ParseContext context)
            {
                return semanticElement.Format;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IReferenceExpression semanticElement, IDataRule propertyValue, ParseContext context)
            {
                semanticElement.Format = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to ReferencedRule
        /// </summary>
        public partial class ReferenceExpressionReferencedRuleRuleRule : AssignModelReferenceRule<IReferenceExpression, IClassRule>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "ReferencedRule";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<IDRule>();
            }

            /// <summary>
            /// Gets the value of the given property
            /// </summary>
            /// <returns>the property value</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parsing context</param>
            protected override IClassRule GetValue(IReferenceExpression semanticElement, ParseContext context)
            {
                return semanticElement.ReferencedRule;
            }

            /// <summary>
            /// Assigns the value to the given semantic element
            /// </summary>
            /// <param name="semanticElement">the context element</param>
            /// <param name="propertyValue">the value to assign</param>
            /// <param name="context">the parsing context</param>
            protected override void SetValue(IReferenceExpression semanticElement, IClassRule propertyValue, ParseContext context)
            {
                semanticElement.ReferencedRule = propertyValue;
            }
        }

        /// <summary>
        /// Rule to assign the contents of the inner rule to FormattingInstructions
        /// </summary>
        public partial class ParserExpressionFormattingInstructionsFormattingInstructionRule : AddAssignRule<IParserExpression, NMF.AnyText.Metamodel.FormattingInstruction>
        {

            /// <summary>
            /// Gets the name of the feature that is assigned
            /// </summary>
            protected override string Feature
            {
                get
                {
                    return "FormattingInstructions";
                }
            }

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                Inner = context.ResolveRule<FormattingInstructionRule>();
            }

            /// <summary>
            /// Obtains the child collection
            /// </summary>
            /// <returns>a collection of values</returns>
            /// <param name="semanticElement">the context element</param>
            /// <param name="context">the parse context in which the collection is obtained</param>
            public override ICollection<NMF.AnyText.Metamodel.FormattingInstruction> GetCollection(IParserExpression semanticElement, ParseContext context)
            {
                return semanticElement.FormattingInstructions;
            }
        }

        /// <summary>
        /// Denotes a rule to parse single-line comments starting with &apos;//&apos;
        /// </summary>
        public partial class SinglelineComment1Rule : NMF.AnyText.Rules.CommentRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                CommentStart = "//";
            }
        }

        /// <summary>
        /// Denotes a rule to parse multi-line comments starting with &apos;/*&apos; and ending with &apos;*/&apos;
        /// </summary>
        public partial class MultilineComment1Rule : NMF.AnyText.Rules.MultilineCommentRule
        {

            /// <summary>
            /// Initializes the current grammar rule
            /// </summary>
            /// <param name="context">the grammar context in which the rule is initialized</param>
            /// <remarks>Do not modify the contents of this method as it will be overridden as the contents of the AnyText file change.</remarks>
            public override void Initialize(GrammarContext context)
            {
                CommentStart = "/*";
                CommentEnd = "*/";
            }
        }
    }
}
